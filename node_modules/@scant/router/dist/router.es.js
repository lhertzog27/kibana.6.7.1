/*!
 * @scant/router v0.1.0
 * (c) 2018-present Joe Fleming (https://github.com/w33ble)
 * Released under the MIT License.
 */
import UrlPattern from 'url-pattern';

/* istanbul ignore file */
var isType = function (type, val) {
  if (type === 'object') { return typeof val === 'object' && val != null && !Array.isArray(val); }
  if (type === 'array') { return Array.isArray(val); }
  if (type === 'null') { return val === null; }
  if (type === 'unset') { return val == null; }
  var valType = typeof val;
  return valType === type;
};

var hasKey = function (obj, key) { return Object.prototype.hasOwnProperty.call(obj, key); };

var startsWithSlash = function (path) { return /^\//.test(path); };

var noop = function () {};

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) { continue; } if (!Object.prototype.hasOwnProperty.call(obj, i)) { continue; } target[i] = obj[i]; } return target; }

// path format helpers
var isValidRouteConfig = function (conf) {
  if (!isType('object', conf)) { return false; }
  var validAction = isType('unset', conf.action) || isType('function', conf.action);
  var validChildren = isType('unset', conf.children) || isType('array', conf.children);
  var validMeta = isType('unset', conf.meta) || isType('object', conf.meta);
  return hasKey(conf, 'path') && validAction && validChildren && validMeta;
};

// takes a path (leading /), appends to another path, and returns it without the trailing /
var getPath = function (path, appendTo) {
  if ( appendTo === void 0 ) appendTo = '';

  if (!startsWithSlash(path)) { return false; }
  var newPath = "" + (appendTo.replace(/\/$/, '')) + path;
  return newPath.length > 1 ? newPath.replace(/\/$/, '') : newPath;
};

var parseUrl = function (path) {
  var parts = path.match(/^(\/[^?#\s]*)(\?[^#\s]*)?(#[^\s]*)?$/);
  if (!parts) { throw new Error(("Failed to extract pathname: " + path)); }
  return {
    url: parts[0],
    pathname: parts[1],
    search: parts[2],
    hash: parts[3]
  };
};

var getMatchedObject = function (matched) { return ({
  path: matched.path,
  name: matched.name,
  meta: matched.meta
}); };

// given a route object and optional parent path, create an array of route configs
function parseRoute(route, path) {
  if ( path === void 0 ) path = '';

  if (!isValidRouteConfig(route)) {
    throw new Error(("Route definition is invalid: " + (JSON.stringify(route))));
  }

  var fullPath = getPath(route.path, path);
  if (fullPath === false) { throw new Error(("Route's path is invalid: " + (route.path))); }

  // if children is defined, recurse into child definitions, appending parent paths
  if (isType('array', route.children)) {
    return route.children.reduce(function (routesAcc, childRoute) { return routesAcc.concat(parseRoute(childRoute, fullPath)); }, []);
  }

  return [{
    name: route.name,
    path: fullPath,
    meta: route.meta || {},
    action: route.action || noop,
    parser: new UrlPattern(fullPath, {
      segmentNameCharset: 'a-zA-Z0-9_-',
      segmentValueCharset: 'a-zA-Z0-9-_~ %.'
    })
  }];
}

function createRouter(routes, opts) {
  if ( opts === void 0 ) opts = {};

  if (!isType('array', routes)) { throw new Error('An array of route objects is required'); }

  // internal options
  var options = {
    hashChar: opts.useHash ? '#' : opts.useHashBang ? '#!' : '', // eslint-disable-line no-nested-ternary
    basepath: startsWithSlash(opts.basepath) ? getPath(opts.basepath) : ''
  };

  // used to track all route definitions
  var routeConfigs = { configs: [], parsers: [], names: [] };

  // used to build the routeConfigs object
  function addRoute(route) {
    // parse route definition into flattened collection of routes (children included)
    var parsedRoutes = parseRoute(route);

    // add all of the parsed routes to the main routeConfig
    parsedRoutes.forEach(function (_ref) {
      var parser = _ref.parser;
      var routeConfig = _objectWithoutProperties(_ref, ['parser']);

      if (routeConfig.name != null && routeConfigs.names.includes(routeConfig.name)) {
        throw new Error(("Route with name '" + (routeConfig.name) + "' already defined, names must be unique"));
      }

      routeConfigs.parsers.push(parser);
      routeConfigs.configs.push(routeConfig);
      routeConfigs.names.push(routeConfig.name);
    });
  }

  // given a url, return params, matching index, and config, or false of no match
  function getRoute(url) {
    return routeConfigs.parsers.reduce(function (acc, parser, index) {
      // short-circuit if there's already a match
      if (acc !== false) { return acc; }

      var params = parser.match(url);
      if (params) { return Object.assign({}, routeConfigs.configs[index], { params: params, index: index }); }
      return acc;
    }, false);
  }

  // load any initial routes
  routes.forEach(addRoute);

  return {
    // given a URL, check the route collection for a match
    match: function match(url) {
      var location = parseUrl(url);
      var matched = getRoute(location.pathname);

      // no match, nothing left to do
      if (matched === false) { return false; }

      // return the matched definition object
      return getMatchedObject(matched);
    },

    // given a URL, check routes collection, parse params & execute the action of match
    parse: function parse(url) {
      return new Promise(function ($return, $error) {
        var location, matched, payload;
        location = parseUrl(url);
        matched = getRoute(location.pathname);


        // no match, nothing left to do
        if (matched === false) { return $error(new Error(("No matching route found: " + url))); }

        // cast any number values to numbers, mutation is ok, this is our own object
        Object.keys(matched.params).forEach(function (key) {
          var numberVal = parseFloat(matched.params[key]);
          if (!Number.isNaN(numberVal)) { matched.params[key] = numberVal; }
        });

        payload = {
          location: location,
          params: matched.params,
          match: getMatchedObject(matched),
          router: this
        };
        return Promise.resolve(matched.action(payload)).then(function ($await_2) {
          try {
            return $return(payload);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this), $error);
      }.bind(this));
    },

    // given a name and optional params, generate a URL from the routes collection
    create: function create(name, params) {
      if ( params === void 0 ) params = {};

      // only create routes from existing named routes
      if (name == null) { return false; }

      // given a name with a slash, it's a url, use it directly
      if (startsWithSlash(name)) { return ("" + (options.hashChar) + (options.basepath) + name); }

      // check that the passed name exists
      if (!routeConfigs.names.includes(name)) { return false; }

      // build and return the route given using provided params
      var routeIndex = routeConfigs.configs.findIndex(function (config) { return config.name === name; });

      try {
        // throws when a route can not be built
        var route = routeConfigs.parsers[routeIndex].stringify(params);
        return ("" + (options.hashChar) + (options.basepath) + route);
      } catch (e) {
        // add a little more context to the thrown errors
        e.message = "Route can not be created, " + (e.message);
        throw e;
      }
    }
  };
}

export default createRouter;
