{"version":3,"file":"router.min.js","sources":["../src/utils.js","../src/index.js"],"sourcesContent":["/* istanbul ignore file */\nexport const isType = (type, val) => {\n  if (type === 'object') return typeof val === 'object' && val != null && !Array.isArray(val);\n  if (type === 'array') return Array.isArray(val);\n  if (type === 'null') return val === null;\n  if (type === 'unset') return val == null;\n  const valType = typeof val;\n  return valType === type;\n};\n\nexport const hasKey = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n\nexport const startsWithSlash = path => /^\\//.test(path);\n\nexport const noop = () => {};\n","import UrlPattern from 'url-pattern';\nimport { isType, hasKey, startsWithSlash, noop } from './utils';\n\n// path format helpers\nconst isValidRouteConfig = conf => {\n  if (!isType('object', conf)) return false;\n  const validAction = isType('unset', conf.action) || isType('function', conf.action);\n  const validChildren = isType('unset', conf.children) || isType('array', conf.children);\n  const validMeta = isType('unset', conf.meta) || isType('object', conf.meta);\n  return hasKey(conf, 'path') && validAction && validChildren && validMeta;\n};\n\n// takes a path (leading /), appends to another path, and returns it without the trailing /\nconst getPath = (path, appendTo = '') => {\n  if (!startsWithSlash(path)) return false;\n  const newPath = `${appendTo.replace(/\\/$/, '')}${path}`;\n  return newPath.length > 1 ? newPath.replace(/\\/$/, '') : newPath;\n};\n\nconst parseUrl = path => {\n  const parts = path.match(/^(\\/[^?#\\s]*)(\\?[^#\\s]*)?(#[^\\s]*)?$/);\n  if (!parts) throw new Error(`Failed to extract pathname: ${path}`);\n  return {\n    url: parts[0],\n    pathname: parts[1],\n    search: parts[2],\n    hash: parts[3],\n  };\n};\n\nconst getMatchedObject = matched => ({\n  path: matched.path,\n  name: matched.name,\n  meta: matched.meta,\n});\n\n// given a route object and optional parent path, create an array of route configs\nfunction parseRoute(route, path = '') {\n  if (!isValidRouteConfig(route)) {\n    throw new Error(`Route definition is invalid: ${JSON.stringify(route)}`);\n  }\n\n  const fullPath = getPath(route.path, path);\n  if (fullPath === false) throw new Error(`Route's path is invalid: ${route.path}`);\n\n  // if children is defined, recurse into child definitions, appending parent paths\n  if (isType('array', route.children)) {\n    return route.children.reduce(\n      (routesAcc, childRoute) => routesAcc.concat(parseRoute(childRoute, fullPath)),\n      []\n    );\n  }\n\n  return [\n    {\n      name: route.name,\n      path: fullPath,\n      meta: route.meta || {},\n      action: route.action || noop,\n      parser: new UrlPattern(fullPath, {\n        segmentNameCharset: 'a-zA-Z0-9_-',\n        segmentValueCharset: 'a-zA-Z0-9-_~ %.',\n      }),\n    },\n  ];\n}\n\nexport default function createRouter(routes, opts = {}) {\n  if (!isType('array', routes)) throw new Error('An array of route objects is required');\n\n  // internal options\n  const options = {\n    hashChar: opts.useHash ? '#' : opts.useHashBang ? '#!' : '', // eslint-disable-line no-nested-ternary\n    basepath: startsWithSlash(opts.basepath) ? getPath(opts.basepath) : '',\n  };\n\n  // used to track all route definitions\n  const routeConfigs = { configs: [], parsers: [], names: [] };\n\n  // used to build the routeConfigs object\n  function addRoute(route) {\n    // parse route definition into flattened collection of routes (children included)\n    const parsedRoutes = parseRoute(route);\n\n    // add all of the parsed routes to the main routeConfig\n    parsedRoutes.forEach(({ parser, ...routeConfig }) => {\n      if (routeConfig.name != null && routeConfigs.names.includes(routeConfig.name)) {\n        throw new Error(\n          `Route with name '${routeConfig.name}' already defined, names must be unique`\n        );\n      }\n\n      routeConfigs.parsers.push(parser);\n      routeConfigs.configs.push(routeConfig);\n      routeConfigs.names.push(routeConfig.name);\n    });\n  }\n\n  // given a url, return params, matching index, and config, or false of no match\n  function getRoute(url) {\n    return routeConfigs.parsers.reduce((acc, parser, index) => {\n      // short-circuit if there's already a match\n      if (acc !== false) return acc;\n\n      const params = parser.match(url);\n      if (params) return { ...routeConfigs.configs[index], params, index };\n      return acc;\n    }, false);\n  }\n\n  // load any initial routes\n  routes.forEach(addRoute);\n\n  return {\n    // given a URL, check the route collection for a match\n    match(url) {\n      const location = parseUrl(url);\n      const matched = getRoute(location.pathname);\n\n      // no match, nothing left to do\n      if (matched === false) return false;\n\n      // return the matched definition object\n      return getMatchedObject(matched);\n    },\n\n    // given a URL, check routes collection, parse params & execute the action of match\n    async parse(url) {\n      const location = parseUrl(url);\n      const matched = getRoute(location.pathname);\n\n      // no match, nothing left to do\n      if (matched === false) throw new Error(`No matching route found: ${url}`);\n\n      // cast any number values to numbers, mutation is ok, this is our own object\n      Object.keys(matched.params).forEach(key => {\n        const numberVal = parseFloat(matched.params[key]);\n        if (!Number.isNaN(numberVal)) matched.params[key] = numberVal;\n      });\n\n      const payload = {\n        location,\n        params: matched.params,\n        match: getMatchedObject(matched),\n        router: this,\n      };\n\n      await matched.action(payload);\n      return payload;\n    },\n\n    // given a name and optional params, generate a URL from the routes collection\n    create(name, params = {}) {\n      // only create routes from existing named routes\n      if (name == null) return false;\n\n      // given a name with a slash, it's a url, use it directly\n      if (startsWithSlash(name)) return `${options.hashChar}${options.basepath}${name}`;\n\n      // check that the passed name exists\n      if (!routeConfigs.names.includes(name)) return false;\n\n      // build and return the route given using provided params\n      const routeIndex = routeConfigs.configs.findIndex(config => config.name === name);\n\n      try {\n        // throws when a route can not be built\n        const route = routeConfigs.parsers[routeIndex].stringify(params);\n        return `${options.hashChar}${options.basepath}${route}`;\n      } catch (e) {\n        // add a little more context to the thrown errors\n        e.message = `Route can not be created, ${e.message}`;\n        throw e;\n      }\n    },\n  };\n}\n"],"names":["isType","type","val","Array","isArray","startsWithSlash","path","test","noop","const","isValidRouteConfig","conf","obj","key","validAction","action","validChildren","children","validMeta","meta","Object","prototype","hasOwnProperty","call","getPath","appendTo","newPath","replace","length","parseUrl","parts","match","Error","getMatchedObject","matched","name","routes","opts","options","useHash","useHashBang","basepath","routeConfigs","configs","parsers","names","getRoute","url","reduce","acc","parser","index","params","forEach","route","parseRoute","JSON","stringify","fullPath","routesAcc","childRoute","concat","UrlPattern","routeConfig","includes","push","pathname","location","keys","numberVal","parseFloat","Number","isNaN","this","payload","routeIndex","findIndex","config","e","message"],"mappings":"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"}