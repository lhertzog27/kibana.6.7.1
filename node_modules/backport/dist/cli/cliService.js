"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const lodash_isempty_1 = __importDefault(require("lodash.isempty"));
const ora_1 = __importDefault(require("ora"));
const prompts_1 = require("../lib/prompts");
const github_1 = require("../lib/github");
const errors_1 = require("../lib/errors");
const env_1 = require("../lib/env");
const logger = __importStar(require("../lib/logger"));
const git_1 = require("../lib/git");
function doBackportVersions(owner, repoName, commits, branches, username, labels) {
    return sequentially(branches, async (branch) => {
        try {
            const pullRequest = await doBackportVersion(owner, repoName, commits, branch, username, labels);
            logger.log(`View pull request: ${pullRequest.html_url}\n`);
        }
        catch (e) {
            handleErrors(e);
        }
    });
}
exports.doBackportVersions = doBackportVersions;
function handleErrors(e) {
    switch (e.name) {
        // Handled exceptions
        case 'HandledError':
            console.error(e.message);
            break;
        // Unhandled exceptions
        default:
            console.error(e);
            throw e;
    }
}
exports.handleErrors = handleErrors;
async function doBackportVersion(owner, repoName, commits, branch, username, labels = []) {
    const backportBranchName = getBackportBranchName(branch, commits);
    const refValues = commits.map(commit => getReferenceLong(commit)).join(', ');
    logger.log(`Backporting ${refValues} to ${branch}`);
    await withSpinner({ text: 'Pulling latest changes' }, async () => {
        await git_1.resetAndPullMaster(owner, repoName);
        await git_1.createAndCheckoutBranch(owner, repoName, branch, backportBranchName);
    });
    await sequentially(commits, commit => cherrypickAndConfirm(owner, repoName, commit.sha));
    await withSpinner({ text: `Pushing branch ${username}:${backportBranchName}` }, () => git_1.push(owner, repoName, username, backportBranchName));
    return withSpinner({ text: 'Creating pull request' }, async () => {
        const payload = getPullRequestPayload(branch, commits, username);
        const pullRequest = await github_1.createPullRequest(owner, repoName, payload);
        if (labels.length > 0) {
            await github_1.addLabels(owner, repoName, pullRequest.number, labels);
        }
        return pullRequest;
    });
}
exports.doBackportVersion = doBackportVersion;
async function maybeSetupRepo(owner, repoName, username) {
    await git_1.verifyGithubSshAuth();
    if (await git_1.repoExists(owner, repoName)) {
        return;
    }
    const text = 'Cloning repository (only first time)';
    const spinner = ora_1.default(`0% ${text}`).start();
    try {
        await git_1.setupRepo(owner, repoName, username, (progress) => {
            spinner.text = `${progress}% ${text}`;
        });
        spinner.succeed();
    }
    catch (e) {
        spinner.stop();
        await git_1.deleteRepo(owner, repoName);
        throw e;
    }
}
exports.maybeSetupRepo = maybeSetupRepo;
async function getCommitBySha(owner, repoName, sha) {
    const spinner = ora_1.default().start();
    try {
        const commit = await github_1.getCommit(owner, repoName, sha);
        spinner.stopAndPersist({
            symbol: chalk_1.default.green('?'),
            text: `${chalk_1.default.bold('Select commit')} ${chalk_1.default.cyan(commit.message)}`
        });
        return commit;
    }
    catch (e) {
        spinner.stop();
        throw e;
    }
}
exports.getCommitBySha = getCommitBySha;
async function getCommitsByPrompt(owner, repoName, author, multipleCommits) {
    const spinner = ora_1.default('Loading commits...').start();
    try {
        const commits = await github_1.getCommits(owner, repoName, author);
        if (lodash_isempty_1.default(commits)) {
            spinner.stopAndPersist({
                symbol: chalk_1.default.green('?'),
                text: `${chalk_1.default.bold('Select commit')} `
            });
            throw new errors_1.HandledError(chalk_1.default.red(author
                ? 'There are no commits by you in this repository'
                : 'There are no commits in this repository'));
        }
        spinner.stop();
        return prompts_1.listCommits(commits, multipleCommits);
    }
    catch (e) {
        spinner.fail();
        throw e;
    }
}
exports.getCommitsByPrompt = getCommitsByPrompt;
function getBranchesByPrompt(branches, isMultipleChoice = false) {
    return prompts_1.listBranches(branches, isMultipleChoice);
}
exports.getBranchesByPrompt = getBranchesByPrompt;
function sequentially(items, handler) {
    return items.reduce(async (p, item) => {
        await p;
        return handler(item);
    }, Promise.resolve());
}
function getBackportBranchName(branch, commits) {
    const refValues = commits
        .map(commit => getReferenceShort(commit))
        .join('_')
        .slice(0, 200);
    return `backport/${branch}/${refValues}`;
}
function getShortSha(commit) {
    return commit.sha.slice(0, 7);
}
function getReferenceLong(commit) {
    return commit.pullRequest ? `#${commit.pullRequest}` : getShortSha(commit);
}
exports.getReferenceLong = getReferenceLong;
function getReferenceShort(commit) {
    return commit.pullRequest
        ? `pr-${commit.pullRequest}`
        : `commit-${getShortSha(commit)}`;
}
async function cherrypickAndConfirm(owner, repoName, sha) {
    try {
        await withSpinner({
            text: 'Cherry-picking commit',
            errorText: `Cherry-picking failed. Please resolve conflicts in: ${env_1.getRepoPath(owner, repoName)}`
        }, () => git_1.cherrypick(owner, repoName, sha));
    }
    catch (e) {
        const hasConflict = e.cmd.includes('git cherry-pick');
        if (!hasConflict) {
            throw e;
        }
        await confirmResolvedRecursive(owner, repoName);
    }
}
async function confirmResolvedRecursive(owner, repoName) {
    const res = await prompts_1.confirmConflictResolved();
    if (!res) {
        throw new errors_1.HandledError('Application was aborted.');
    }
    const isDirty = await git_1.isIndexDirty(owner, repoName);
    if (isDirty) {
        await confirmResolvedRecursive(owner, repoName);
    }
}
function getPullRequestTitle(branch, commits) {
    const commitMessages = commits
        .map(commit => commit.message)
        .join(' | ')
        .slice(0, 200);
    return `[${branch}] ${commitMessages}`;
}
function getPullRequestPayload(branch, commits, username) {
    const backportBranchName = getBackportBranchName(branch, commits);
    const commitRefs = commits
        .map(commit => {
        const ref = getReferenceLong(commit);
        return ` - ${commit.message.replace(`(${ref})`, '')} (${ref})`;
    })
        .join('\n');
    return {
        title: getPullRequestTitle(branch, commits),
        body: `Backports the following commits to ${branch}:\n${commitRefs}`,
        head: `${username}:${backportBranchName}`,
        base: `${branch}`
    };
}
async function withSpinner({ text, errorText }, fn) {
    const spinner = ora_1.default(text).start();
    try {
        const res = await fn();
        if (text) {
            spinner.succeed();
        }
        else {
            spinner.stop();
        }
        return res;
    }
    catch (e) {
        if (errorText) {
            spinner.text = errorText;
        }
        spinner.fail();
        throw e;
    }
}
