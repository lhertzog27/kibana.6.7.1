"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lodash_isempty_1 = __importDefault(require("lodash.isempty"));
const lodash_isstring_1 = __importDefault(require("lodash.isstring"));
const find_up_1 = __importDefault(require("find-up"));
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
const errors_1 = require("./errors");
const env = __importStar(require("./env"));
const rpc = __importStar(require("./rpc"));
const schemas_1 = require("./schemas");
async function maybeCreateGlobalConfigAndFolder() {
    const reposPath = env.getReposPath();
    const globalConfigPath = env.getGlobalConfigPath();
    const configTemplate = await getConfigTemplate();
    await rpc.mkdirp(reposPath);
    await maybeCreateGlobalConfig(globalConfigPath, configTemplate);
    await ensureCorrectPermissions(globalConfigPath);
}
exports.maybeCreateGlobalConfigAndFolder = maybeCreateGlobalConfigAndFolder;
function ensureCorrectPermissions(globalConfigPath) {
    return rpc.chmod(globalConfigPath, '600');
}
async function maybeCreateGlobalConfig(globalConfigPath, configTemplate) {
    try {
        await rpc.writeFile(globalConfigPath, configTemplate, {
            flag: 'wx',
            mode: 0o600 // give the owner read-write privleges, no access for others
        });
    }
    catch (e) {
        const FILE_ALREADY_EXISTS = 'EEXIST';
        if (e.code !== FILE_ALREADY_EXISTS) {
            throw e;
        }
    }
}
exports.maybeCreateGlobalConfig = maybeCreateGlobalConfig;
function getConfigTemplate() {
    const p = path_1.default.join(__dirname, '../../templates/configTemplate.json');
    return rpc.readFile(p, 'utf8');
}
exports.getConfigTemplate = getConfigTemplate;
async function readConfigFile(filepath) {
    const fileContents = await rpc.readFile(filepath, 'utf8');
    const configWithoutComments = strip_json_comments_1.default(fileContents);
    try {
        return JSON.parse(configWithoutComments);
    }
    catch (e) {
        throw new errors_1.HandledError(`"${filepath}" contains invalid JSON:\n\n${fileContents}\n\nTry validating the file on https://jsonlint.com/`);
    }
}
async function getGlobalConfig() {
    await maybeCreateGlobalConfigAndFolder();
    const globalConfigPath = env.getGlobalConfigPath();
    const config = await readConfigFile(globalConfigPath);
    return schemas_1.validateGlobalConfig(config, globalConfigPath);
}
exports.getGlobalConfig = getGlobalConfig;
async function getProjectConfig() {
    const filepath = await find_up_1.default('.backportrc.json');
    if (!filepath) {
        return null;
    }
    const config = schemas_1.validateProjectConfig(await readConfigFile(filepath), filepath);
    const { branches } = config, configRest = __rest(config, ["branches"]);
    return Object.assign({}, configRest, { branchChoices: config.branches.map((choice) => {
            return lodash_isstring_1.default(choice)
                ? {
                    name: choice,
                    checked: false
                }
                : choice;
        }) });
}
exports.getProjectConfig = getProjectConfig;
async function getCombinedConfig() {
    const [projectConfig, globalConfig] = await Promise.all([
        getProjectConfig(),
        getGlobalConfig()
    ]);
    return Object.assign({ 
        // defaults
        multiple: false, multipleCommits: false, multipleBranches: true, all: false, labels: [] }, globalConfig, projectConfig);
}
exports.getCombinedConfig = getCombinedConfig;
function validateOptions(options) {
    if (lodash_isempty_1.default(options.branches) && lodash_isempty_1.default(options.branchChoices)) {
        throw new Error(`Missing branch\n\nYou must either:\n - Add a .backportrc.json. Read more: https://github.com/sqren/backport/blob/master/docs/configuration.md#project-specific-configuration\n - Add branch as CLI argument: "--branch 6.1" `);
    }
    if (!options.upstream) {
        throw new Error(`Missing upstream\n\nYou must either:\n - Add a .backportrc.json. Read more: https://github.com/sqren/backport/blob/master/docs/configuration.md#project-specific-configuration\n - Add upstream as CLI argument: "--upstream elastic/kibana" `);
    }
    return options;
}
exports.validateOptions = validateOptions;
