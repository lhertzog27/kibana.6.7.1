"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = __importDefault(require("child_process"));
const rimraf_1 = __importDefault(require("rimraf"));
const env = __importStar(require("./env"));
const rpc_1 = require("./rpc");
const errors_1 = require("./errors");
async function folderExists(path) {
    try {
        return (await rpc_1.stat(path)).isDirectory();
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            return false;
        }
        throw e;
    }
}
function repoExists(owner, repoName) {
    return folderExists(env.getRepoPath(owner, repoName));
}
exports.repoExists = repoExists;
// Clone repo and add remotes
async function setupRepo(owner, repoName, username, callback) {
    await rpc_1.mkdirp(env.getRepoOwnerPath(owner));
    await cloneRepo(owner, repoName, callback);
    return addRemote(owner, repoName, username);
}
exports.setupRepo = setupRepo;
function deleteRepo(owner, repoName) {
    return new Promise(resolve => {
        const repoPath = env.getRepoPath(owner, repoName);
        rimraf_1.default(repoPath, resolve);
    });
}
exports.deleteRepo = deleteRepo;
function getRemoteUrl(owner, repoName) {
    return `git@github.com:${owner}/${repoName}`;
}
function cloneRepo(owner, repoName, callback) {
    return new Promise((resolve, reject) => {
        const execProcess = child_process_1.default.exec(`git clone ${getRemoteUrl(owner, repoName)} --progress`, { cwd: env.getRepoOwnerPath(owner), maxBuffer: 100 * 1024 * 1024 }, error => {
            if (error) {
                reject(error);
            }
            resolve();
        });
        execProcess.stderr.on('data', data => {
            const regex = /^Receiving objects:\s+(\d+)%/;
            const [, progress] = data.toString().match(regex) || [];
            if (progress) {
                callback(progress);
            }
        });
    });
}
function addRemote(owner, repoName, username) {
    return rpc_1.exec(`git remote add ${username} ${getRemoteUrl(username, repoName)}`, {
        cwd: env.getRepoPath(owner, repoName)
    });
}
function cherrypick(owner, repoName, sha) {
    return rpc_1.exec(`git cherry-pick ${sha}`, {
        cwd: env.getRepoPath(owner, repoName)
    });
}
exports.cherrypick = cherrypick;
async function isIndexDirty(owner, repoName) {
    try {
        await rpc_1.exec(`git diff-index --quiet HEAD --`, {
            cwd: env.getRepoPath(owner, repoName)
        });
        return false;
    }
    catch (e) {
        return true;
    }
}
exports.isIndexDirty = isIndexDirty;
async function createAndCheckoutBranch(owner, repoName, baseBranch, featureBranch) {
    try {
        return await rpc_1.exec(`git fetch origin ${baseBranch} && git branch ${featureBranch} origin/${baseBranch} --force && git checkout ${featureBranch} `, {
            cwd: env.getRepoPath(owner, repoName)
        });
    }
    catch (e) {
        if (e.stderr.includes(`Couldn't find remote ref`) ||
            e.stderr.includes(`Invalid refspec`)) {
            throw new errors_1.HandledError(`The branch "${baseBranch}"  is invalid or doesn't exist`);
        }
        throw e;
    }
}
exports.createAndCheckoutBranch = createAndCheckoutBranch;
function push(owner, repoName, username, branchName) {
    return rpc_1.exec(`git push ${username} ${branchName}:${branchName} --force`, {
        cwd: env.getRepoPath(owner, repoName)
    });
}
exports.push = push;
async function resetAndPullMaster(owner, repoName) {
    return rpc_1.exec(`git reset --hard && git clean -d --force && git checkout master && git pull origin master`, {
        cwd: env.getRepoPath(owner, repoName)
    });
}
exports.resetAndPullMaster = resetAndPullMaster;
async function verifyGithubSshAuth() {
    try {
        await rpc_1.exec(`ssh -oBatchMode=yes -T git@github.com`);
        return true;
    }
    catch (e) {
        switch (e.code) {
            case 1:
                return true;
            case 255:
                if (e.stderr.includes('Host key verification failed.')) {
                    throw new errors_1.HandledError('Host verification of github.com failed. To automatically add it to .ssh/known_hosts run:\nssh -T git@github.com');
                }
                else if (e.stderr.includes('Permission denied')) {
                    throw new errors_1.HandledError('Permission denied. Please add your ssh private key to the keychain by following these steps:\nhttps://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#adding-your-ssh-key-to-the-ssh-agent');
                }
                else {
                    throw e;
                }
            default:
                throw e;
        }
    }
}
exports.verifyGithubSshAuth = verifyGithubSshAuth;
