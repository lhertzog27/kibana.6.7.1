"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const querystring_1 = __importDefault(require("querystring"));
const lodash_get_1 = __importDefault(require("lodash.get"));
const errors_1 = require("./errors");
let accessToken;
function getCommitMessage(message) {
    return message.split('\n')[0].trim();
}
async function getCommits(owner, repoName, author) {
    const query = {
        access_token: accessToken,
        per_page: 20
    };
    if (author) {
        query.author = author;
        query.per_page = 5;
    }
    try {
        const res = await axios_1.default(`https://api.github.com/repos/${owner}/${repoName}/commits?${querystring_1.default.stringify(query)}`);
        const promises = res.data.map(async (commit) => {
            const sha = commit.sha;
            return {
                message: getCommitMessage(commit.commit.message),
                sha,
                pullRequest: await getPullRequestBySha(owner, repoName, sha)
            };
        });
        return Promise.all(promises);
    }
    catch (e) {
        throw getError(e);
    }
}
exports.getCommits = getCommits;
async function getCommit(owner, repoName, sha) {
    try {
        const res = await axios_1.default(`https://api.github.com/repos/${owner}/${repoName}/commits/${sha}?access_token=${accessToken}`);
        const fullSha = res.data.sha;
        const pullRequest = await getPullRequestBySha(owner, repoName, fullSha);
        return {
            message: getCommitMessage(res.data.commit.message),
            sha: fullSha,
            pullRequest
        };
    }
    catch (e) {
        throw getError(e);
    }
}
exports.getCommit = getCommit;
async function createPullRequest(owner, repoName, payload) {
    try {
        const res = await axios_1.default.post(`https://api.github.com/repos/${owner}/${repoName}/pulls?access_token=${accessToken}`, payload);
        return {
            html_url: res.data.html_url,
            number: res.data.number
        };
    }
    catch (e) {
        throw getError(e);
    }
}
exports.createPullRequest = createPullRequest;
async function addLabels(owner, repoName, pullNumber, labels) {
    try {
        return await axios_1.default.post(`https://api.github.com/repos/${owner}/${repoName}/issues/${pullNumber}/labels?access_token=${accessToken}`, labels);
    }
    catch (e) {
        throw getError(e);
    }
}
exports.addLabels = addLabels;
async function getPullRequestBySha(owner, repoName, commitSha) {
    try {
        const res = await axios_1.default(`https://api.github.com/search/issues?q=repo:${owner}/${repoName}+${commitSha}+base:master&access_token=${accessToken}`);
        return lodash_get_1.default(res.data.items[0], 'number');
    }
    catch (e) {
        throw getError(e);
    }
}
function setAccessToken(token) {
    accessToken = token;
}
exports.setAccessToken = setAccessToken;
function getError(e) {
    if (e.response && e.response.data) {
        return new errors_1.HandledError(JSON.stringify(Object.assign({}, e.response.data, { axiosUrl: e.config.url }), null, 4));
    }
    return e;
}
