/*
* history-extra version 4.0.2
*
* The MIT License (MIT)
* 
* Copyright (c) 2018 Joe Fleming (https://github.com/w33ble)
* 
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
* 
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

import locationUtils from 'history/LocationUtils';
import PathUtils from 'history/PathUtils';
import _createTransitionManager from 'history/createTransitionManager';
import DOMUtils from 'history/DOMUtils';

/* eslint no-use-before-define: 0 */
var createLocation = locationUtils.createLocation,
    locationsAreEqual = locationUtils.locationsAreEqual;
var addLeadingSlash = PathUtils.addLeadingSlash,
    stripLeadingSlash = PathUtils.stripLeadingSlash,
    stripTrailingSlash = PathUtils.stripTrailingSlash,
    hasBasename = PathUtils.hasBasename,
    stripBasename = PathUtils.stripBasename,
    createPath = PathUtils.createPath;
var canUseDOM = DOMUtils.canUseDOM,
    addEventListener = DOMUtils.addEventListener,
    removeEventListener = DOMUtils.removeEventListener,
    getConfirmation = DOMUtils.getConfirmation,
    supportsGoWithoutReloadUsingHash = DOMUtils.supportsGoWithoutReloadUsingHash,
    supportsHistory = DOMUtils.supportsHistory; // goofy hack to handle cjs and esm differences in build

var createTransitionManager = Object.hasOwnProperty.call(_createTransitionManager, 'default') ? _createTransitionManager.default : _createTransitionManager;

function warning(condition, message) {
  if (condition) return; // eslint-disable-next-line no-console

  console.warn(message);
}

function invariant(condition, message) {
  if (condition) return;
  throw new Error("Invariant failed: ".concat(message || ''));
}

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : "!/".concat(stripLeadingSlash(path));
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');
  window.location.replace("".concat(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0), "#").concat(path));
};

var createHashStateHistory = function createHashStateHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  invariant(canUseDOM, 'Hash history needs a DOM');
  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
  var canUseHistory = supportsHistory();
  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  var getDOMLocation = function getDOMLocation() {
    var _getHistoryState = getHistoryState(),
        key = _getHistoryState.key,
        state = _getHistoryState.state;

    var path = decodePath(getHashPath());
    warning(!basename || hasBasename(path, basename), "".concat('You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "').concat(path, "\" to begin with \"").concat(basename, "\"."));
    if (basename) path = stripBasename(path, basename);
    return createLocation(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = createTransitionManager();

  var setState = function setState(nextState) {
    Object.assign(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;
      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }; // Ensure the hash is encoded properly before doing anything else.


  var path = getHashPath();
  var encodedPath = encodePath(path);
  if (path !== encodedPath) replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)]; // Public interface

  var createHref = function createHref(location) {
    return "#".concat(encodePath(basename + createPath(location)));
  }; // eslint-disable-next-line no-shadow


  var push = function push(path, state) {
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return; // eslint-disable-next-line no-shadow

      var path = createPath(location); // eslint-disable-next-line no-shadow

      var encodedPath = encodePath(basename + path);

      if (canUseHistory) {
        // eslint-disable-next-line no-shadow
        var key = location.key,
            _state = location.state;
        var href = createHref(location);
        globalHistory.pushState({
          key: key,
          state: _state
        }, null, href);
      } else {
        // legacy fallback
        ignorePath = path;
        var hashChanged = getHashPath() !== encodedPath;

        if (hashChanged) {
          // We cannot tell if a hashchange was caused by a PUSH, so we'd
          // rather setState here and ignore the hashchange. The caveat here
          // is that other hash histories in the page will consider it a POP.
          warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');
          setState();
        } else {
          warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history, state is ignored');
        }

        pushHashPath(encodedPath);
      }

      var prevIndex = allPaths.lastIndexOf(createPath(history.location));
      var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
      nextPaths.push(path);
      allPaths = nextPaths;
      setState({
        action: action,
        location: location
      });
    });
  }; // eslint-disable-next-line no-shadow


  var replace = function replace(path, state) {
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return; // eslint-disable-next-line no-shadow

      var path = createPath(location); // eslint-disable-next-line no-shadow

      var encodedPath = encodePath(basename + path);

      if (canUseHistory) {
        // eslint-disable-next-line no-shadow
        var key = location.key,
            _state2 = location.state;
        var href = createHref(location);
        globalHistory.replaceState({
          key: key,
          state: _state2
        }, null, href);
      } else {
        // legacy fallback
        warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history, state is ignored');
        var hashChanged = getHashPath() !== encodedPath;

        if (hashChanged) {
          // We cannot tell if a hashchange was caused by a REPLACE, so we'd
          // rather setState here and ignore the hashchange. The caveat here
          // is that other hash histories in the page will consider it a POP.
          ignorePath = path;
          replaceHashPath(encodedPath);
        }
      }

      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1) allPaths[prevIndex] = path;
      setState({
        action: action,
        location: location
      });
    });
  };

  var go = function go(n) {
    warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;
    var eventType = canUseHistory ? PopStateEvent : HashChangeEvent;

    if (listenerCount === 1) {
      addEventListener(window, eventType, handleHashChange);
    } else if (listenerCount === 0) {
      removeEventListener(window, eventType, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
};

export default createHashStateHistory;
//# sourceMappingURL=createHashStateHistory.mjs.map
