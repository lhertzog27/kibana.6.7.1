{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/agg_types/buckets/histogram.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/agg_types/buckets/histogram.js","mtime":1567631711697},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.histogramBucketAgg = undefined;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _notify = require('ui/notify');\n\nrequire('../../validate_date_interval');\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _bucket_agg_type = require('./_bucket_agg_type');\n\nvar _histogram = require('./create_filter/histogram');\n\nvar _number_interval = require('../controls/number_interval.html');\n\nvar _number_interval2 = _interopRequireDefault(_number_interval);\n\nvar _min_doc_count = require('../controls/min_doc_count.html');\n\nvar _min_doc_count2 = _interopRequireDefault(_min_doc_count);\n\nvar _extended_bounds = require('../controls/extended_bounds.html');\n\nvar _extended_bounds2 = _interopRequireDefault(_extended_bounds);\n\nvar _i18n = require('@kbn/i18n');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar config = _chrome2.default.getUiSettingsClient();\nvar histogramBucketAgg = exports.histogramBucketAgg = new _bucket_agg_type.BucketAggType({\n  name: 'histogram',\n  title: _i18n.i18n.translate('common.ui.aggTypes.buckets.histogramTitle', {\n    defaultMessage: 'Histogram'\n  }),\n  ordered: {},\n  makeLabel: function makeLabel(aggConfig) {\n    return aggConfig.getFieldDisplayName();\n  },\n  createFilter: _histogram.createFilterHistogram,\n  decorateAggConfig: function decorateAggConfig() {\n    var autoBounds = void 0;\n\n    return {\n      setAutoBounds: {\n        configurable: true,\n        value: function value(newValue) {\n          autoBounds = newValue;\n        }\n      },\n      getAutoBounds: {\n        configurable: true,\n        value: function value() {\n          return autoBounds;\n        }\n      }\n    };\n  },\n  params: [{\n    name: 'field',\n    type: 'field',\n    filterFieldTypes: 'number'\n  }, {\n    /*\n     * This parameter can be set if you want the auto scaled interval to always\n     * be a multiple of a specific base.\n     */\n    name: 'intervalBase',\n    default: null,\n    write: function write() {}\n  }, {\n    name: 'interval',\n    editor: _number_interval2.default,\n    modifyAggConfigOnSearchRequestStart: function modifyAggConfigOnSearchRequestStart(aggConfig, searchSource) {\n      var field = aggConfig.getField();\n      var aggBody = field.scripted ? { script: { inline: field.script, lang: field.lang } } : { field: field.name };\n\n      return searchSource.createChild().setField('size', 0).setField('aggs', {\n        maxAgg: {\n          max: aggBody\n        },\n        minAgg: {\n          min: aggBody\n        }\n      }).fetch().then(function (resp) {\n        aggConfig.setAutoBounds({\n          min: _lodash2.default.get(resp, 'aggregations.minAgg.value'),\n          max: _lodash2.default.get(resp, 'aggregations.maxAgg.value')\n        });\n      }).catch(function () {\n        _notify.toastNotifications.addWarning(_i18n.i18n.translate('common.ui.aggTypes.histogram.missingMaxMinValuesWarning', {\n          // eslint-disable-next-line max-len\n          defaultMessage: 'Unable to retrieve max and min values to auto-scale histogram buckets. This may lead to poor visualization performance.'\n        }));\n      });\n    },\n\n    write: function write(aggConfig, output) {\n      var interval = parseFloat(aggConfig.params.interval);\n      if (interval <= 0) {\n        interval = 1;\n      }\n\n      // ensure interval does not create too many buckets and crash browser\n      if (aggConfig.getAutoBounds()) {\n        var range = aggConfig.getAutoBounds().max - aggConfig.getAutoBounds().min;\n        var bars = range / interval;\n        if (bars > config.get('histogram:maxBars')) {\n          var minInterval = range / config.get('histogram:maxBars');\n          // Round interval by order of magnitude to provide clean intervals\n          // Always round interval up so there will always be less buckets than histogram:maxBars\n          var orderOfMagnitude = Math.pow(10, Math.floor(Math.log10(minInterval)));\n          var roundInterval = orderOfMagnitude;\n          while (roundInterval < minInterval) {\n            roundInterval += orderOfMagnitude;\n          }\n          interval = roundInterval;\n        }\n      }\n\n      var base = aggConfig.params.intervalBase;\n      if (base) {\n        if (interval < base) {\n          // In case the specified interval is below the base, just increase it to it's base\n          interval = base;\n        } else if (interval % base !== 0) {\n          // In case the interval is not a multiple of the base round it to the next base\n          interval = Math.round(interval / base) * base;\n        }\n      }\n\n      output.params.interval = interval;\n    }\n  }, {\n    name: 'min_doc_count',\n    default: null,\n    editor: _min_doc_count2.default,\n    write: function write(aggConfig, output) {\n      if (aggConfig.params.min_doc_count) {\n        output.params.min_doc_count = 0;\n      } else {\n        output.params.min_doc_count = 1;\n      }\n    }\n  }, {\n    name: 'extended_bounds',\n    default: {},\n    editor: _extended_bounds2.default,\n    write: function write(aggConfig, output) {\n      var val = aggConfig.params.extended_bounds;\n\n      if (aggConfig.params.min_doc_count && (val.min != null || val.max != null)) {\n        output.params.extended_bounds = {\n          min: val.min,\n          max: val.max\n        };\n      }\n    },\n\n    // called from the editor\n    shouldShow: function shouldShow(aggConfig) {\n      var field = aggConfig.params.field;\n      if (field && (field.type === 'number' || field.type === 'date')) {\n        return aggConfig.params.min_doc_count;\n      }\n    }\n  }]\n});",null]}