{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/kibana/public/dashboard/dashboard_state_manager.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/kibana/public/dashboard/dashboard_state_manager.js","mtime":1567631711557},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DashboardStateManager = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed to Elasticsearch B.V. under one or more contributor\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * license agreements. See the NOTICE file distributed with\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * this work for additional information regarding copyright\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ownership. Elasticsearch B.V. licenses this file to you under\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the Apache License, Version 2.0 (the \"License\"); you may\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * software distributed under the License is distributed on an\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * KIND, either express or implied.  See the License for the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * specific language governing permissions and limitations\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * under the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _i18n = require('@kbn/i18n');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _dashboard_view_mode = require('./dashboard_view_mode');\n\nvar _filter_utils = require('./lib/filter_utils');\n\nvar _panel_utils = require('./panel/panel_utils');\n\nvar _store = require('../store');\n\nvar _actions = require('./actions');\n\nvar _state_monitor_factory = require('ui/state_management/state_monitor_factory');\n\nvar _panel = require('./panel');\n\nvar _lib = require('./lib');\n\nvar _selectors = require('../selectors');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dashboard state manager handles connecting angular and redux state between the angular and react portions of the\n * app. There are two \"sources of truth\" that need to stay in sync - AppState (aka the `_a` portion of the url) and\n * the Store. They aren't complete duplicates of each other as AppState has state that the Store doesn't, and vice\n * versa. They should be as decoupled as possible so updating the store won't affect bwc of urls.\n */\nvar DashboardStateManager = exports.DashboardStateManager = function () {\n  /**\n   *\n   * @param {SavedDashboard} savedDashboard\n   * @param {AppState} AppState The AppState class to use when instantiating a new AppState instance.\n   * @param {boolean} hideWriteControls true if write controls should be hidden.\n   * @param {function} addFilter a function that can be used to add a filter bar filter\n   */\n  function DashboardStateManager(_ref) {\n    var _this = this;\n\n    var savedDashboard = _ref.savedDashboard,\n        AppState = _ref.AppState,\n        hideWriteControls = _ref.hideWriteControls,\n        addFilter = _ref.addFilter;\n\n    _classCallCheck(this, DashboardStateManager);\n\n    this.addNewPanel = function (id, type) {\n      var maxPanelIndex = _panel_utils.PanelUtils.getMaxPanelIndex(_this.getPanels());\n      var newPanel = (0, _panel.createPanelState)(id, type, maxPanelIndex, _this.getPanels());\n      _this.getPanels().push(newPanel);\n      _this.saveState();\n    };\n\n    this.savedDashboard = savedDashboard;\n    this.hideWriteControls = hideWriteControls;\n    this.addFilter = addFilter;\n\n    this.stateDefaults = (0, _lib.getAppStateDefaults)(this.savedDashboard, this.hideWriteControls);\n\n    this.appState = new AppState(this.stateDefaults);\n\n    // Initializing appState does two things - first it translates the defaults into AppState, second it updates\n    // appState based on the URL (the url trumps the defaults). This means if we update the state format at all and\n    // want to handle BWC, we must not only migrate the data stored with saved Dashboard, but also any old state in the\n    // url.\n    (0, _lib.migrateAppState)(this.appState);\n\n    this.isDirty = false;\n\n    // We can't compare the filters stored on this.appState to this.savedDashboard because in order to apply\n    // the filters to the visualizations, we need to save it on the dashboard. We keep track of the original\n    // filter state in order to let the user know if their filters changed and provide this specific information\n    // in the 'lose changes' warning message.\n    this.lastSavedDashboardFilters = this.getFilterState();\n\n    // A mapping of panel index to the index pattern it uses.\n    this.panelIndexPatternMapping = {};\n\n    _panel_utils.PanelUtils.initPanelIndexes(this.getPanels());\n\n    this.createStateMonitor();\n\n    _store.store.dispatch((0, _actions.closeContextMenu)());\n\n    // Always start out with all panels minimized when a dashboard is first loaded.\n    _store.store.dispatch((0, _actions.minimizePanel)());\n    this._pushAppStateChangesToStore();\n\n    this.changeListeners = [];\n\n    this.unsubscribe = _store.store.subscribe(function () {\n      return _this._handleStoreChanges();\n    });\n    this.stateMonitor.onChange(function (status) {\n      _this.changeListeners.forEach(function (listener) {\n        return listener(status);\n      });\n      _this._pushAppStateChangesToStore();\n    });\n  }\n\n  _createClass(DashboardStateManager, [{\n    key: 'registerChangeListener',\n    value: function registerChangeListener(callback) {\n      this.changeListeners.push(callback);\n    }\n  }, {\n    key: '_areStoreAndAppStatePanelsEqual',\n    value: function _areStoreAndAppStatePanelsEqual() {\n      var state = _store.store.getState();\n      var storePanels = (0, _selectors.getPanels)(_store.store.getState());\n      var appStatePanels = this.getPanels();\n\n      if (Object.values(storePanels).length !== appStatePanels.length) {\n        return false;\n      }\n\n      return appStatePanels.every(function (appStatePanel) {\n        var storePanel = (0, _selectors.getPanel)(state, appStatePanel.panelIndex);\n        return _lodash2.default.isEqual(appStatePanel, storePanel);\n      });\n    }\n\n    /**\n     * Time is part of global state so we need to deal with it outside of _pushAppStateChangesToStore.\n     * @param {String|Object} newTimeFilter.to -- either a string representing an absolute time in utc format,\n     * or a relative time (now-15m), or a moment object\n     * @param {String|Object} newTimeFilter.from - either a string representing an absolute or a relative time, or a\n     * moment object\n     * @param {String} newTimeFilter.mode\n     */\n\n  }, {\n    key: 'handleTimeChange',\n    value: function handleTimeChange(newTimeFilter) {\n      _store.store.dispatch((0, _actions.updateTimeRange)({\n        from: _filter_utils.FilterUtils.convertTimeToUTCString(newTimeFilter.from),\n        to: _filter_utils.FilterUtils.convertTimeToUTCString(newTimeFilter.to),\n        mode: newTimeFilter.mode\n      }));\n    }\n\n    /**\n     * Changes made to app state outside of direct calls to this class will need to be propagated to the store.\n     * @private\n     */\n\n  }, {\n    key: '_pushAppStateChangesToStore',\n    value: function _pushAppStateChangesToStore() {\n      // We need these checks, or you can get into a loop where a change is triggered by the store, which updates\n      // AppState, which then dispatches the change here, which will end up triggering setState warnings.\n      if (!this._areStoreAndAppStatePanelsEqual()) {\n        // Translate appState panels data into the data expected by redux, copying the panel objects as we do so\n        // because the panels inside appState can be mutated, while redux state should never be mutated directly.\n        var panelsMap = this.getPanels().reduce(function (acc, panel) {\n          acc[panel.panelIndex] = _lodash2.default.cloneDeep(panel);\n          return acc;\n        }, {});\n        _store.store.dispatch((0, _actions.setPanels)(panelsMap));\n      }\n\n      var state = _store.store.getState();\n\n      if ((0, _selectors.getTitle)(state) !== this.getTitle()) {\n        _store.store.dispatch((0, _actions.updateTitle)(this.getTitle()));\n      }\n\n      if ((0, _selectors.getDescription)(state) !== this.getDescription()) {\n        _store.store.dispatch((0, _actions.updateDescription)(this.getDescription()));\n      }\n\n      if ((0, _selectors.getViewMode)(state) !== this.getViewMode()) {\n        _store.store.dispatch((0, _actions.updateViewMode)(this.getViewMode()));\n      }\n\n      if ((0, _selectors.getUseMargins)(state) !== this.getUseMargins()) {\n        _store.store.dispatch((0, _actions.updateUseMargins)(this.getUseMargins()));\n      }\n\n      if ((0, _selectors.getHidePanelTitles)(state) !== this.getHidePanelTitles()) {\n        _store.store.dispatch((0, _actions.updateHidePanelTitles)(this.getHidePanelTitles()));\n      }\n\n      if ((0, _selectors.getFullScreenMode)(state) !== this.getFullScreenMode()) {\n        _store.store.dispatch((0, _actions.updateIsFullScreenMode)(this.getFullScreenMode()));\n      }\n\n      if ((0, _selectors.getTitle)(state) !== this.getTitle()) {\n        _store.store.dispatch((0, _actions.updateTitle)(this.getTitle()));\n      }\n\n      if ((0, _selectors.getDescription)(state) !== this.getDescription()) {\n        _store.store.dispatch((0, _actions.updateDescription)(this.getDescription()));\n      }\n\n      if ((0, _selectors.getQuery)(state) !== this.getQuery()) {\n        _store.store.dispatch((0, _actions.updateQuery)(this.getQuery()));\n      }\n\n      this._pushFiltersToStore();\n    }\n  }, {\n    key: '_pushFiltersToStore',\n    value: function _pushFiltersToStore() {\n      var state = _store.store.getState();\n      var dashboardFilters = this.getDashboardFilterBars();\n      if (!_lodash2.default.isEqual(_filter_utils.FilterUtils.cleanFiltersForComparison(dashboardFilters), _filter_utils.FilterUtils.cleanFiltersForComparison((0, _selectors.getFilters)(state)))) {\n        _store.store.dispatch((0, _actions.updateFilters)(dashboardFilters));\n      }\n    }\n  }, {\n    key: 'requestReload',\n    value: function requestReload() {\n      _store.store.dispatch((0, _actions.requestReload)());\n    }\n  }, {\n    key: '_handleStoreChanges',\n    value: function _handleStoreChanges() {\n      var _this2 = this;\n\n      var dirty = false;\n      if (!this._areStoreAndAppStatePanelsEqual()) {\n        var panels = (0, _selectors.getPanels)(_store.store.getState());\n        this.appState.panels = [];\n        this.panelIndexPatternMapping = {};\n        Object.values(panels).map(function (panel) {\n          _this2.appState.panels.push(_lodash2.default.cloneDeep(panel));\n        });\n        dirty = true;\n      }\n\n      _lodash2.default.forEach((0, _selectors.getEmbeddables)(_store.store.getState()), function (embeddable, panelId) {\n        if (embeddable.initialized && !_this2.panelIndexPatternMapping.hasOwnProperty(panelId)) {\n          var indexPattern = (0, _selectors.getEmbeddableMetadata)(_store.store.getState(), panelId).indexPattern;\n          if (indexPattern) {\n            _this2.panelIndexPatternMapping[panelId] = indexPattern;\n            _this2.dirty = true;\n          }\n        }\n      });\n\n      var stagedFilters = (0, _selectors.getStagedFilters)(_store.store.getState());\n      stagedFilters.forEach(function (filter) {\n        _this2.addFilter(filter);\n      });\n      if (stagedFilters.length > 0) {\n        this.saveState();\n        _store.store.dispatch((0, _actions.clearStagedFilters)());\n      }\n\n      var fullScreen = (0, _selectors.getFullScreenMode)(_store.store.getState());\n      if (fullScreen !== this.getFullScreenMode()) {\n        this.setFullScreenMode(fullScreen);\n      }\n\n      this.changeListeners.forEach(function (listener) {\n        return listener({ dirty: dirty });\n      });\n      this.saveState();\n    }\n  }, {\n    key: 'getFullScreenMode',\n    value: function getFullScreenMode() {\n      return this.appState.fullScreenMode;\n    }\n  }, {\n    key: 'setFullScreenMode',\n    value: function setFullScreenMode(fullScreenMode) {\n      this.appState.fullScreenMode = fullScreenMode;\n      this.saveState();\n    }\n  }, {\n    key: 'getPanelIndexPatterns',\n    value: function getPanelIndexPatterns() {\n      return _lodash2.default.uniq(Object.values(this.panelIndexPatternMapping));\n    }\n\n    /**\n     * Resets the state back to the last saved version of the dashboard.\n     */\n\n  }, {\n    key: 'resetState',\n    value: function resetState() {\n      // In order to show the correct warning for the saved-object-save-as-check-box we have to store the unsaved\n      // title on the dashboard object. We should fix this at some point, but this is how all the other object\n      // save panels work at the moment.\n      this.savedDashboard.title = this.savedDashboard.lastSavedTitle;\n\n      // appState.reset uses the internal defaults to reset the state, but some of the default settings (e.g. the panels\n      // array) point to the same object that is stored on appState and is getting modified.\n      // The right way to fix this might be to ensure the defaults object stored on state is a deep\n      // clone, but given how much code uses the state object, I determined that to be too risky of a change for\n      // now.  TODO: revisit this!\n      this.stateDefaults = (0, _lib.getAppStateDefaults)(this.savedDashboard, this.hideWriteControls);\n      // The original query won't be restored by the above because the query on this.savedDashboard is applied\n      // in place in order for it to affect the visualizations.\n      this.stateDefaults.query = this.lastSavedDashboardFilters.query;\n      // Need to make a copy to ensure they are not overwritten.\n      this.stateDefaults.filters = [].concat(_toConsumableArray(this.getLastSavedFilterBars()));\n\n      this.isDirty = false;\n      this.appState.setDefaults(this.stateDefaults);\n      this.appState.reset();\n      this.stateMonitor.setInitialState(this.appState.toJSON());\n    }\n\n    /**\n     * Returns an object which contains the current filter state of this.savedDashboard.\n     * @returns {{timeTo: String, timeFrom: String, filterBars: Array, query: Object}}\n     */\n\n  }, {\n    key: 'getFilterState',\n    value: function getFilterState() {\n      return {\n        timeTo: this.savedDashboard.timeTo,\n        timeFrom: this.savedDashboard.timeFrom,\n        filterBars: this.getDashboardFilterBars(),\n        query: this.getDashboardQuery()\n      };\n    }\n  }, {\n    key: 'getTitle',\n    value: function getTitle() {\n      return this.appState.title;\n    }\n  }, {\n    key: 'getDescription',\n    value: function getDescription() {\n      return this.appState.description;\n    }\n  }, {\n    key: 'setDescription',\n    value: function setDescription(description) {\n      this.appState.description = description;\n      this.saveState();\n    }\n  }, {\n    key: 'setTitle',\n    value: function setTitle(title) {\n      this.appState.title = title;\n      // The saved-object-save-as-check-box shows a warning if the current object title is different then\n      // the existing object title. It calculates this difference by comparing this.dashboard.title to\n      // this.dashboard.lastSavedTitle, so we need to push the temporary, unsaved title, onto the dashboard.\n      this.savedDashboard.title = title;\n      this.saveState();\n    }\n  }, {\n    key: 'getAppState',\n    value: function getAppState() {\n      return this.appState;\n    }\n  }, {\n    key: 'getQuery',\n    value: function getQuery() {\n      return this.appState.query;\n    }\n  }, {\n    key: 'getUseMargins',\n    value: function getUseMargins() {\n      // Existing dashboards that don't define this should default to false.\n      return this.appState.options.useMargins === undefined ? false : this.appState.options.useMargins;\n    }\n  }, {\n    key: 'setUseMargins',\n    value: function setUseMargins(useMargins) {\n      this.appState.options.useMargins = useMargins;\n      this.saveState();\n    }\n  }, {\n    key: 'getHidePanelTitles',\n    value: function getHidePanelTitles() {\n      return this.appState.options.hidePanelTitles;\n    }\n  }, {\n    key: 'setHidePanelTitles',\n    value: function setHidePanelTitles(hidePanelTitles) {\n      this.appState.options.hidePanelTitles = hidePanelTitles;\n      this.saveState();\n    }\n  }, {\n    key: 'getDarkTheme',\n    value: function getDarkTheme() {\n      return this.appState.options.darkTheme;\n    }\n  }, {\n    key: 'setDarkTheme',\n    value: function setDarkTheme(darkTheme) {\n      this.appState.options.darkTheme = darkTheme;\n      this.saveState();\n    }\n  }, {\n    key: 'getTimeRestore',\n    value: function getTimeRestore() {\n      return this.appState.timeRestore;\n    }\n  }, {\n    key: 'setTimeRestore',\n    value: function setTimeRestore(timeRestore) {\n      this.appState.timeRestore = timeRestore;\n      this.saveState();\n    }\n\n    /**\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'getIsTimeSavedWithDashboard',\n    value: function getIsTimeSavedWithDashboard() {\n      return this.savedDashboard.timeRestore;\n    }\n  }, {\n    key: 'getDashboardFilterBars',\n    value: function getDashboardFilterBars() {\n      return _filter_utils.FilterUtils.getFilterBarsForDashboard(this.savedDashboard);\n    }\n  }, {\n    key: 'getDashboardQuery',\n    value: function getDashboardQuery() {\n      return _filter_utils.FilterUtils.getQueryFilterForDashboard(this.savedDashboard);\n    }\n  }, {\n    key: 'getLastSavedFilterBars',\n    value: function getLastSavedFilterBars() {\n      return this.lastSavedDashboardFilters.filterBars;\n    }\n  }, {\n    key: 'getLastSavedQuery',\n    value: function getLastSavedQuery() {\n      return this.lastSavedDashboardFilters.query;\n    }\n\n    /**\n     * @returns {boolean} True if the query changed since the last time the dashboard was saved, or if it's a\n     * new dashboard, if the query differs from the default.\n     */\n\n  }, {\n    key: 'getQueryChanged',\n    value: function getQueryChanged() {\n      var currentQuery = this.appState.query;\n      var lastSavedQuery = this.getLastSavedQuery();\n\n      var isLegacyStringQuery = _lodash2.default.isString(lastSavedQuery) && _lodash2.default.isPlainObject(currentQuery) && _lodash2.default.has(currentQuery, 'query');\n      if (isLegacyStringQuery) {\n        return lastSavedQuery !== currentQuery.query;\n      }\n\n      return !_lodash2.default.isEqual(currentQuery, lastSavedQuery);\n    }\n\n    /**\n     * @returns {boolean} True if the filter bar state has changed since the last time the dashboard was saved,\n     * or if it's a new dashboard, if the query differs from the default.\n     */\n\n  }, {\n    key: 'getFilterBarChanged',\n    value: function getFilterBarChanged() {\n      return !_lodash2.default.isEqual(_filter_utils.FilterUtils.cleanFiltersForComparison(this.appState.filters), _filter_utils.FilterUtils.cleanFiltersForComparison(this.getLastSavedFilterBars()));\n    }\n\n    /**\n     * @param timeFilter\n     * @returns {boolean} True if the time state has changed since the time saved with the dashboard.\n     */\n\n  }, {\n    key: 'getTimeChanged',\n    value: function getTimeChanged(timeFilter) {\n      return !_filter_utils.FilterUtils.areTimesEqual(this.lastSavedDashboardFilters.timeFrom, timeFilter.getTime().from) || !_filter_utils.FilterUtils.areTimesEqual(this.lastSavedDashboardFilters.timeTo, timeFilter.getTime().to);\n    }\n\n    /**\n     *\n     * @returns {DashboardViewMode}\n     */\n\n  }, {\n    key: 'getViewMode',\n    value: function getViewMode() {\n      return this.hideWriteControls ? _dashboard_view_mode.DashboardViewMode.VIEW : this.appState.viewMode;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'getIsViewMode',\n    value: function getIsViewMode() {\n      return this.getViewMode() === _dashboard_view_mode.DashboardViewMode.VIEW;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'getIsEditMode',\n    value: function getIsEditMode() {\n      return this.getViewMode() === _dashboard_view_mode.DashboardViewMode.EDIT;\n    }\n\n    /**\n     *\n     * @returns {boolean} True if the dashboard has changed since the last save (or, is new).\n     */\n\n  }, {\n    key: 'getIsDirty',\n    value: function getIsDirty(timeFilter) {\n      // Filter bar comparison is done manually (see cleanFiltersForComparison for the reason) and time picker\n      // changes are not tracked by the state monitor.\n      var hasTimeFilterChanged = timeFilter ? this.getFiltersChanged(timeFilter) : false;\n      return this.getIsEditMode() && (this.isDirty || hasTimeFilterChanged);\n    }\n  }, {\n    key: 'getPanels',\n    value: function getPanels() {\n      return this.appState.panels;\n    }\n  }, {\n    key: 'updatePanel',\n    value: function updatePanel(panelIndex, panelAttributes) {\n      var panel = this.getPanels().find(function (panel) {\n        return panel.panelIndex === panelIndex;\n      });\n      Object.assign(panel, panelAttributes);\n      this.saveState();\n      return panel;\n    }\n\n    /**\n     * Creates and initializes a basic panel, adding it to the state.\n     * @param {number} id\n     * @param {string} type\n     */\n\n  }, {\n    key: 'removePanel',\n    value: function removePanel(panelIndex) {\n      var _this3 = this;\n\n      _lodash2.default.remove(this.getPanels(), function (panel) {\n        if (panel.panelIndex === panelIndex) {\n          delete _this3.panelIndexPatternMapping[panelIndex];\n          return true;\n        } else {\n          return false;\n        }\n      });\n      this.saveState();\n    }\n\n    /**\n     * @param timeFilter\n     * @returns {Array.<string>} An array of user friendly strings indicating the filter types that have changed.\n     */\n\n  }, {\n    key: 'getChangedFilterTypes',\n    value: function getChangedFilterTypes(timeFilter) {\n      var changedFilters = [];\n      if (this.getFilterBarChanged()) {\n        changedFilters.push('filter');\n      }\n      if (this.getQueryChanged()) {\n        changedFilters.push('query');\n      }\n      if (this.savedDashboard.timeRestore && this.getTimeChanged(timeFilter)) {\n        changedFilters.push('time range');\n      }\n      return changedFilters;\n    }\n\n    /**\n     * @return {boolean} True if filters (query, filter bar filters, and time picker if time is stored\n     * with the dashboard) have changed since the last saved state (or if the dashboard hasn't been saved,\n     * the default state).\n     */\n\n  }, {\n    key: 'getFiltersChanged',\n    value: function getFiltersChanged(timeFilter) {\n      return this.getChangedFilterTypes(timeFilter).length > 0;\n    }\n\n    /**\n     * Updates timeFilter to match the time saved with the dashboard.\n     * @param {Object} timeFilter\n     * @param {func} timeFilter.setTime\n     * @param {func} timeFilter.setRefreshInterval\n     * @param quickTimeRanges\n     */\n\n  }, {\n    key: 'syncTimefilterWithDashboard',\n    value: function syncTimefilterWithDashboard(timeFilter, quickTimeRanges) {\n      var _this4 = this;\n\n      if (!this.getIsTimeSavedWithDashboard()) {\n        throw new Error(_i18n.i18n.translate('kbn.dashboard.stateManager.timeNotSavedWithDashboardErrorMessage', {\n          defaultMessage: 'The time is not saved with this dashboard so should not be synced.'\n        }));\n      }\n\n      var mode = void 0;\n      var isMoment = (0, _moment2.default)(this.savedDashboard.timeTo).isValid();\n      if (isMoment) {\n        mode = 'absolute';\n      } else {\n        var quickTime = _lodash2.default.find(quickTimeRanges, function (timeRange) {\n          return timeRange.from === _this4.savedDashboard.timeFrom && timeRange.to === _this4.savedDashboard.timeTo;\n        });\n\n        mode = quickTime ? 'quick' : 'relative';\n      }\n      timeFilter.setTime({\n        from: this.savedDashboard.timeFrom,\n        to: this.savedDashboard.timeTo,\n        mode: mode\n      });\n\n      if (this.savedDashboard.refreshInterval) {\n        timeFilter.setRefreshInterval(this.savedDashboard.refreshInterval);\n      }\n    }\n\n    /**\n     * Saves the current application state to the URL.\n     */\n\n  }, {\n    key: 'saveState',\n    value: function saveState() {\n      this.appState.save();\n    }\n\n    /**\n     * Applies the current filter state to the dashboard.\n     * @param filter {Array.<Object>} An array of filter bar filters.\n     */\n\n  }, {\n    key: 'applyFilters',\n    value: function applyFilters(query, filters) {\n      this.appState.query = query;\n      this.savedDashboard.searchSource.setField('query', query);\n      this.savedDashboard.searchSource.setField('filter', filters);\n      this.saveState();\n      // pinned filters go on global state, therefore are not propagated to store via app state and have to be pushed manually.\n      this._pushFiltersToStore();\n    }\n\n    /**\n     * Creates a state monitor and saves it to this.stateMonitor. Used to track unsaved changes made to appState.\n     */\n\n  }, {\n    key: 'createStateMonitor',\n    value: function createStateMonitor() {\n      var _this5 = this;\n\n      this.stateMonitor = _state_monitor_factory.stateMonitorFactory.create(this.appState, this.stateDefaults);\n\n      this.stateMonitor.ignoreProps('viewMode');\n      // Filters need to be compared manually because they sometimes have a $$hashkey stored on the object.\n      this.stateMonitor.ignoreProps('filters');\n      // Query needs to be compared manually because saved legacy queries get migrated in app state automatically\n      this.stateMonitor.ignoreProps('query');\n\n      this.stateMonitor.onChange(function (status) {\n        _this5.isDirty = status.dirty;\n      });\n    }\n\n    /**\n     * @param newMode {DashboardViewMode}\n     */\n\n  }, {\n    key: 'switchViewMode',\n    value: function switchViewMode(newMode) {\n      this.appState.viewMode = newMode;\n      this.saveState();\n    }\n\n    /**\n     * Destroys and cleans up this object when it's no longer used.\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this.stateMonitor) {\n        this.stateMonitor.destroy();\n      }\n      this.savedDashboard.destroy();\n      this.unsubscribe();\n    }\n  }]);\n\n  return DashboardStateManager;\n}();",null]}