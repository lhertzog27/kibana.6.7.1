{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/console/public/src/autocomplete/engine.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/console/public/src/autocomplete/engine.js","mtime":1567631691125},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapComponentWithDefaults = wrapComponentWithDefaults;\nexports.WalkingState = WalkingState;\nexports.walkTokenPath = walkTokenPath;\nexports.populateContext = populateContext;\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar _ = require('lodash');\n\nfunction wrapComponentWithDefaults(component, defaults) {\n  var originalGetTerms = component.getTerms;\n  component.getTerms = function (context, editor) {\n    var result = originalGetTerms.call(component, context, editor);\n    if (!result) {\n      return result;\n    }\n    result = _.map(result, function (term) {\n      if (!_.isObject(term)) {\n        term = { name: term };\n      }\n      return _.defaults(term, defaults);\n    }, this);\n    return result;\n  };\n  return component;\n}\n\nvar tracer = function tracer() {\n  if (window.engine_trace) {\n    console.log.call(console, arguments);\n  }\n};\n\nfunction passThroughContext(context, extensionList) {\n  function PTC() {}\n\n  PTC.prototype = context;\n  var result = new PTC();\n  if (extensionList) {\n    extensionList.unshift(result);\n    _.assign.apply(_, extensionList);\n    extensionList.shift();\n  }\n  return result;\n}\n\nfunction WalkingState(parentName, components, contextExtensionList, depth, priority) {\n  this.parentName = parentName;\n  this.components = components;\n  this.contextExtensionList = contextExtensionList;\n  this.depth = depth || 0;\n  this.priority = priority;\n}\n\nfunction walkTokenPath(tokenPath, walkingStates, context, editor) {\n  if (!tokenPath || tokenPath.length === 0) {\n    return walkingStates;\n  }\n  var token = tokenPath[0];\n  var nextWalkingStates = [];\n\n  tracer('starting token evaluation [' + token + ']');\n\n  _.each(walkingStates, function (ws) {\n    var contextForState = passThroughContext(context, ws.contextExtensionList);\n    _.each(ws.components, function (component) {\n      tracer('evaluating [' + token + '] with [' + component.name + ']', component);\n      var result = component.match(token, contextForState, editor);\n      if (result && !_.isEmpty(result)) {\n        tracer('matched [' + token + '] with:', result);\n        var next = void 0;\n        var extensionList = void 0;\n        if (result.next && !Array.isArray(result.next)) {\n          next = [result.next];\n        } else {\n          next = result.next;\n        }\n        if (result.context_values) {\n          extensionList = [];\n          [].push.apply(extensionList, ws.contextExtensionList);\n          extensionList.push(result.context_values);\n        } else {\n          extensionList = ws.contextExtensionList;\n        }\n\n        var priority = ws.priority;\n        if (_.isNumber(result.priority)) {\n          if (_.isNumber(priority)) {\n            priority = Math.min(priority, result.priority);\n          } else {\n            priority = result.priority;\n          }\n        }\n\n        nextWalkingStates.push(new WalkingState(component.name, next, extensionList, ws.depth + 1, priority));\n      }\n    });\n  });\n\n  if (nextWalkingStates.length === 0) {\n    // no where to go, still return context variables returned so far..\n    return _.map(walkingStates, function (ws) {\n      return new WalkingState(ws.name, [], ws.contextExtensionList);\n    });\n  }\n\n  return walkTokenPath(tokenPath.slice(1), nextWalkingStates, context, editor);\n}\n\nfunction populateContext(tokenPath, context, editor, includeAutoComplete, components) {\n\n  var walkStates = walkTokenPath(tokenPath, [new WalkingState('ROOT', components, [])], context, editor);\n  if (includeAutoComplete) {\n    var autoCompleteSet = [];\n    _.each(walkStates, function (ws) {\n      var contextForState = passThroughContext(context, ws.contextExtensionList);\n      _.each(ws.components, function (component) {\n        _.each(component.getTerms(contextForState, editor), function (term) {\n          if (!_.isObject(term)) {\n            term = { name: term };\n          }\n          autoCompleteSet.push(term);\n        });\n      });\n    });\n    autoCompleteSet = _.uniq(autoCompleteSet, false);\n    context.autoCompleteSet = autoCompleteSet;\n  }\n\n  // apply what values were set so far to context, selecting the deepest on which sets the context\n  if (walkStates.length !== 0) {\n    var wsToUse = void 0;\n    walkStates = _.sortBy(walkStates, function (ws) {\n      return _.isNumber(ws.priority) ? ws.priority : Number.MAX_VALUE;\n    });\n    wsToUse = _.find(walkStates, function (ws) {\n      return _.isEmpty(ws.components);\n    });\n\n    if (!wsToUse && walkStates.length > 1 && !includeAutoComplete) {\n      console.info('more then one context active for current path, but autocomplete isn\\'t requested', walkStates);\n    }\n\n    if (!wsToUse) {\n      wsToUse = walkStates[0];\n    }\n\n    _.each(wsToUse.contextExtensionList, function (extension) {\n      _.assign(context, extension);\n    });\n  }\n}",null]}