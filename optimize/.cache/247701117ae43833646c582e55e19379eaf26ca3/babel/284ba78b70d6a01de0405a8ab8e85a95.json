{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/console/public/src/sense_editor/editor.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/console/public/src/sense_editor/editor.js","mtime":1567631711527},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = SenseEditor;\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar _ = require('lodash');\nvar ace = require('brace');\nvar $ = require('jquery');\nvar curl = require('../curl');\nvar RowParser = require('./row_parser');\nvar InputMode = require('./mode/input');\nvar utils = require('../utils');\nvar es = require('../es');\nvar chrome = require('ui/chrome');\n\nvar smartResize = require('../smart_resize');\n\nfunction createInstance($el) {\n  var aceEditor = ace.edit($el[0]);\n\n  // we must create a custom class for each instance, so that the prototype\n  // can be the unique aceEditor it extends\n  var CustomSenseEditor = function CustomSenseEditor() {};\n  CustomSenseEditor.prototype = {};\n\n  function bindProp(key) {\n    Object.defineProperty(CustomSenseEditor.prototype, key, {\n      get: function get() {\n        return aceEditor[key];\n      },\n      set: function set(val) {\n        aceEditor[key] = val;\n      }\n    });\n  }\n\n  // iterate all of the accessible properties/method, on the prototype and beyond\n  // eslint-disable-next-line guard-for-in\n  for (var key in aceEditor) {\n    switch (_typeof(aceEditor[key])) {\n      case 'function':\n        CustomSenseEditor.prototype[key] = _.bindKey(aceEditor, key);\n        break;\n      default:\n        bindProp(key);\n        break;\n    }\n  }\n\n  var editor = new CustomSenseEditor();\n  editor.__ace = aceEditor;\n  return editor;\n}\n\nfunction SenseEditor($el) {\n  var editor = createInstance($el);\n  var CURRENT_REQ_RANGE = null;\n\n  editor.$el = $el;\n  // place holder for an action bar, needs to be set externally.\n  editor.$actions = null;\n\n  // mixin the RowParser\n  editor.parser = new RowParser(editor);\n  editor.resize = smartResize(editor);\n\n  // dirty check for tokenizer state, uses a lot less cycles\n  // than listening for tokenizerUpdate\n  var onceDoneTokenizing = function onceDoneTokenizing(func, cancelAlreadyScheduledCalls) {\n    var session = editor.getSession();\n    var timer = false;\n    var checkInterval = 25;\n\n    return function () {\n      var self = this;\n      var args = [].slice.call(arguments, 0);\n\n      if (cancelAlreadyScheduledCalls) {\n        timer = clearTimeout(timer);\n      }\n\n      setTimeout(function check() {\n        if (session.bgTokenizer.running) {\n          timer = setTimeout(check, checkInterval);\n        } else {\n          func.apply(self, args);\n        }\n      });\n    };\n  };\n\n  editor.setShowPrintMargin(false);\n  (function (session) {\n    session.setMode(new InputMode.Mode());\n    session.setFoldStyle('markbeginend');\n    session.setTabSize(2);\n    session.setUseWrapMode(true);\n  })(editor.getSession());\n\n  editor.prevRequestStart = function (rowOrPos) {\n    rowOrPos = _.isUndefined(rowOrPos) || rowOrPos === null ? editor.getCursorPosition() : rowOrPos;\n\n    var curRow = _.isObject(rowOrPos) ? rowOrPos.row : rowOrPos;\n    while (curRow > 0 && !editor.parser.isStartRequestRow(curRow, editor)) {\n      curRow--;\n    }return {\n      row: curRow,\n      column: 0\n    };\n  };\n\n  editor.nextRequestStart = function (rowOrPos) {\n    rowOrPos = _.isUndefined(rowOrPos) || rowOrPos === null ? editor.getCursorPosition() : rowOrPos;\n    var session = editor.getSession();\n    var curRow = _.isObject(rowOrPos) ? rowOrPos.row : rowOrPos;\n    var maxLines = session.getLength();\n    for (; curRow < maxLines - 1; curRow++) {\n      if (editor.parser.isStartRequestRow(curRow, editor)) {\n        break;\n      }\n    }\n    return {\n      row: curRow,\n      column: 0\n    };\n  };\n\n  editor.autoIndent = onceDoneTokenizing(function () {\n    editor.getRequestRange(function (reqRange) {\n      if (!reqRange) {\n        return;\n      }\n      editor.getRequest(function (parsedReq) {\n        if (parsedReq.data && parsedReq.data.length > 0) {\n          var indent = parsedReq.data.length === 1; // unindent multi docs by default\n          var formattedData = utils.reformatData(parsedReq.data, indent);\n          if (!formattedData.changed) {\n            // toggle.\n            indent = !indent;\n            formattedData = utils.reformatData(parsedReq.data, indent);\n          }\n          parsedReq.data = formattedData.data;\n\n          editor.replaceRequestRange(parsedReq, reqRange);\n        }\n      });\n    });\n  }, true);\n\n  editor.update = function (data, callback) {\n    callback = typeof callback === 'function' ? callback : null;\n    var session = editor.getSession();\n\n    session.setValue(data);\n    if (callback) {\n      // force update of tokens, but not on this thread to allow for ace rendering.\n      setTimeout(function () {\n        var i = void 0;\n        for (i = 0; i < session.getLength(); i++) {\n          session.getTokens(i);\n        }\n        callback();\n      });\n    }\n  };\n\n  editor.replaceRequestRange = function (newRequest, requestRange) {\n    var text = utils.textFromRequest(newRequest);\n    if (requestRange) {\n      var pos = editor.getCursorPosition();\n      editor.getSession().replace(requestRange, text);\n      var maxRow = Math.max(requestRange.start.row + text.split('\\n').length - 1, 0);\n      pos.row = Math.min(pos.row, maxRow);\n      editor.moveCursorToPosition(pos);\n      // ACE UPGRADE - check if needed - at the moment the above may trigger a selection.\n      editor.clearSelection();\n    } else {\n      // just insert where we are\n      editor.insert(text);\n    }\n  };\n\n  editor.iterForCurrentLoc = function () {\n    var pos = editor.getCursorPosition();\n    return editor.iterForPosition(pos.row, pos.column, editor);\n  };\n\n  editor.iterForPosition = function (row, column) {\n    return new (ace.acequire('ace/token_iterator').TokenIterator)(editor.getSession(), row, column);\n  };\n\n  editor.getRequestRange = onceDoneTokenizing(function (row, cb) {\n    if (_.isUndefined(cb)) {\n      cb = row;\n      row = null;\n    }\n    if (typeof cb !== 'function') {\n      return;\n    }\n\n    if (editor.parser.isInBetweenRequestsRow(row)) {\n      cb(null);\n      return;\n    }\n\n    var reqStart = editor.prevRequestStart(row, editor);\n    var reqEnd = editor.nextRequestEnd(reqStart, editor);\n    cb(new (ace.acequire('ace/range').Range)(reqStart.row, reqStart.column, reqEnd.row, reqEnd.column));\n  });\n\n  editor.getEngulfingRequestsRange = onceDoneTokenizing(function (range, cb) {\n    if (_.isUndefined(cb)) {\n      cb = range;\n      range = null;\n    }\n\n    range = range || editor.getSelectionRange();\n\n    var session = editor.getSession();\n    var startRow = range.start.row;\n    var endRow = range.end.row;\n    var maxLine = Math.max(0, session.getLength() - 1);\n\n    // move start row to the previous request start if in body, o.w. forward\n    if (editor.parser.isInBetweenRequestsRow(startRow)) {\n      //for (; startRow <= endRow; startRow++) {\n      //  if (editor.parser.isStartRequestRow(startRow)) {\n      //    break;\n      //  }\n      //}\n    } else {\n      for (; startRow >= 0; startRow--) {\n        if (editor.parser.isStartRequestRow(startRow)) {\n          break;\n        }\n      }\n    }\n\n    if (startRow < 0 || startRow > endRow) {\n      cb(null);\n      return;\n    }\n    // move end row to the previous request end if between requests, o.w. walk forward\n    if (editor.parser.isInBetweenRequestsRow(endRow)) {\n      for (; endRow >= startRow; endRow--) {\n        if (editor.parser.isEndRequestRow(endRow)) {\n          break;\n        }\n      }\n    } else {\n\n      for (; endRow <= maxLine; endRow++) {\n        if (editor.parser.isEndRequestRow(endRow)) {\n          break;\n        }\n      }\n    }\n\n    if (endRow < startRow || endRow > maxLine) {\n      cb(null);\n      return;\n    }\n\n    var endColumn = (session.getLine(endRow) || '').replace(/\\s+$/, '').length;\n    cb(new (ace.acequire('ace/range').Range)(startRow, 0, endRow, endColumn));\n  });\n\n  editor.getRequestInRange = onceDoneTokenizing(function (range, cb) {\n    if (!range) {\n      return;\n    }\n    var request = {\n      method: '',\n      data: [],\n      url: null,\n      range: range\n    };\n\n    var pos = range.start;\n    var tokenIter = editor.iterForPosition(pos.row, pos.column, editor);\n    var t = tokenIter.getCurrentToken();\n    if (editor.parser.isEmptyToken(t)) {\n      // if the row starts with some spaces, skip them.\n      t = editor.parser.nextNonEmptyToken(tokenIter);\n    }\n    request.method = t.value;\n    t = editor.parser.nextNonEmptyToken(tokenIter);\n    if (!t || t.type === 'method') {\n      return null;\n    }\n    request.url = '';\n    while (t && t.type && t.type.indexOf('url') === 0) {\n      request.url += t.value;\n      t = tokenIter.stepForward();\n    }\n    if (editor.parser.isEmptyToken(t)) {\n      // if the url row ends with some spaces, skip them.\n      t = editor.parser.nextNonEmptyToken(tokenIter);\n    }\n\n    var bodyStartRow = (t ? 0 : 1) + tokenIter.getCurrentTokenRow(); // artificially increase end of docs.\n    var dataEndPos = void 0;\n    while (bodyStartRow < range.end.row || bodyStartRow === range.end.row && 0 < range.end.column) {\n      dataEndPos = editor.nextDataDocEnd({\n        row: bodyStartRow,\n        column: 0\n      });\n      var bodyRange = new (ace.acequire('ace/range').Range)(bodyStartRow, 0, dataEndPos.row, dataEndPos.column);\n      var data = editor.getSession().getTextRange(bodyRange);\n      request.data.push(data.trim());\n      bodyStartRow = dataEndPos.row + 1;\n    }\n\n    cb(request);\n  });\n\n  editor.getRequestsInRange = function (range, includeNonRequestBlocks, cb) {\n    if (_.isUndefined(includeNonRequestBlocks)) {\n      includeNonRequestBlocks = false;\n      cb = range;\n      range = null;\n    } else if (_.isUndefined(cb)) {\n      cb = includeNonRequestBlocks;\n      includeNonRequestBlocks = false;\n    }\n\n    function explicitRangeToRequests(requestsRange, tempCb) {\n      if (!requestsRange) {\n        tempCb([]);\n        return;\n      }\n\n      var startRow = requestsRange.start.row;\n      var endRow = requestsRange.end.row;\n\n      // move to the next request start (during the second iterations this may not be exactly on a request\n      var currentRow = startRow;\n      for (; currentRow <= endRow; currentRow++) {\n        if (editor.parser.isStartRequestRow(currentRow)) {\n          break;\n        }\n      }\n\n      var nonRequestPrefixBlock = null;\n      if (includeNonRequestBlocks && currentRow !== startRow) {\n        nonRequestPrefixBlock = editor.getSession().getLines(startRow, currentRow - 1).join('\\n');\n      }\n\n      if (currentRow > endRow) {\n        tempCb(nonRequestPrefixBlock ? [nonRequestPrefixBlock] : []);\n        return;\n      }\n\n      editor.getRequest(currentRow, function (request) {\n        if (!request) {\n          return;\n        }\n        explicitRangeToRequests({\n          start: {\n            row: request.range.end.row + 1\n          },\n          end: {\n            row: requestsRange.end.row\n          }\n        }, function (restOfRequests) {\n          restOfRequests.unshift(request);\n          if (nonRequestPrefixBlock !== null) {\n            restOfRequests.unshift(nonRequestPrefixBlock);\n          }\n          tempCb(restOfRequests);\n        });\n      });\n    }\n\n    editor.getEngulfingRequestsRange(range, function (requestRange) {\n      explicitRangeToRequests(requestRange, cb);\n    });\n  };\n\n  editor.getRequest = onceDoneTokenizing(function (row, cb) {\n    if (_.isUndefined(cb)) {\n      cb = row;\n      row = null;\n    }\n    if (typeof cb !== 'function') {\n      return;\n    }\n    if (editor.parser.isInBetweenRequestsRow(row)) {\n      cb(null);\n      return;\n    }\n    editor.getRequestRange(row, function (range) {\n      editor.getRequestInRange(range, cb);\n    });\n  });\n\n  editor.moveToPreviousRequestEdge = onceDoneTokenizing(function () {\n    var pos = editor.getCursorPosition();\n    for (pos.row--; pos.row > 0 && !editor.parser.isRequestEdge(pos.row); pos.row--) {\n      // loop for side effects\n    }\n    editor.moveCursorTo(pos.row, 0);\n  });\n\n  editor.moveToNextRequestEdge = onceDoneTokenizing(function (moveOnlyIfNotOnEdge) {\n    var pos = editor.getCursorPosition();\n    var maxRow = editor.getSession().getLength();\n    if (!moveOnlyIfNotOnEdge) {\n      pos.row++;\n    }\n    for (; pos.row < maxRow && !editor.parser.isRequestEdge(pos.row); pos.row++) {\n      // loop for side effects\n    }\n    editor.moveCursorTo(pos.row, 0);\n  });\n\n  editor.nextRequestEnd = function (pos) {\n    pos = pos || editor.getCursorPosition();\n    var session = editor.getSession();\n    var curRow = pos.row;\n    var maxLines = session.getLength();\n    for (; curRow < maxLines - 1; curRow++) {\n      var curRowMode = editor.parser.getRowParseMode(curRow, editor);\n      if ((curRowMode & editor.parser.MODE.REQUEST_END) > 0) {\n        break;\n      }\n      if (curRow !== pos.row && (curRowMode & editor.parser.MODE.REQUEST_START) > 0) {\n        break;\n      }\n    }\n\n    var column = (session.getLine(curRow) || '').replace(/\\s+$/, '').length;\n\n    return {\n      row: curRow,\n      column: column\n    };\n  };\n\n  editor.nextDataDocEnd = function (pos) {\n    pos = pos || editor.getCursorPosition();\n    var session = editor.getSession();\n    var curRow = pos.row;\n    var maxLines = session.getLength();\n    for (; curRow < maxLines - 1; curRow++) {\n      var curRowMode = editor.parser.getRowParseMode(curRow, editor);\n      if ((curRowMode & RowParser.REQUEST_END) > 0) {\n        break;\n      }\n      if ((curRowMode & editor.parser.MODE.MULTI_DOC_CUR_DOC_END) > 0) {\n        break;\n      }\n      if (curRow !== pos.row && (curRowMode & editor.parser.MODE.REQUEST_START) > 0) {\n        break;\n      }\n    }\n\n    var column = (session.getLine(curRow) || '').length;\n\n    return {\n      row: curRow,\n      column: column\n    };\n  };\n\n  // overwrite the actual aceEditor's onPaste method\n  var origOnPaste = editor.__ace.onPaste;\n  editor.__ace.onPaste = function (text) {\n    if (text && curl.detectCURL(text)) {\n      editor.handleCURLPaste(text);\n      return;\n    }\n    origOnPaste.call(this, text);\n  };\n\n  editor.handleCURLPaste = function (text) {\n    var curlInput = curl.parseCURL(text);\n\n    editor.insert(curlInput);\n  };\n\n  editor.highlightCurrentRequestsAndUpdateActionBar = onceDoneTokenizing(function () {\n    var session = editor.getSession();\n    editor.getEngulfingRequestsRange(function (newCurrentReqRange) {\n      if (newCurrentReqRange === null && CURRENT_REQ_RANGE === null) {\n        return;\n      }\n      if (newCurrentReqRange !== null && CURRENT_REQ_RANGE !== null && newCurrentReqRange.start.row === CURRENT_REQ_RANGE.start.row && newCurrentReqRange.end.row === CURRENT_REQ_RANGE.end.row) {\n        // same request, now see if we are on the first line and update the action bar\n        var cursorRow = editor.getCursorPosition().row;\n        if (cursorRow === CURRENT_REQ_RANGE.start.row) {\n          editor.updateActionsBar();\n        }\n        return; // nothing to do..\n      }\n\n      if (CURRENT_REQ_RANGE) {\n        session.removeMarker(CURRENT_REQ_RANGE.marker_id);\n      }\n\n      CURRENT_REQ_RANGE = newCurrentReqRange;\n      if (CURRENT_REQ_RANGE) {\n        CURRENT_REQ_RANGE.marker_id = session.addMarker(CURRENT_REQ_RANGE, 'ace_snippet-marker', 'fullLine');\n      }\n      editor.updateActionsBar();\n    });\n  }, true);\n\n  editor.getRequestsAsCURL = function (range, cb) {\n    if (_.isUndefined(cb)) {\n      cb = range;\n      range = null;\n    }\n\n    if (_.isUndefined(cb)) {\n      cb = $.noop;\n    }\n\n    editor.getRequestsInRange(range, true, function (requests) {\n\n      var result = _.map(requests, function requestToCurl(req) {\n\n        if (typeof req === 'string') {\n          // no request block\n          return req;\n        }\n\n        var esPath = req.url;\n        var esMethod = req.method;\n        var esData = req.data;\n\n        // this is the first url defined in elasticsearch.hosts\n        var elasticsearchBaseUrl = chrome.getInjected('elasticsearchUrl');\n        var url = es.constructESUrl(elasticsearchBaseUrl, esPath);\n\n        var ret = 'curl -X' + esMethod + ' \"' + url + '\"';\n        if (esData && esData.length) {\n          ret += ' -H \\'Content-Type: application/json\\' -d\\'\\n';\n          var dataAsString = utils.collapseLiteralStrings(esData.join('\\n'));\n          // since Sense doesn't allow single quote json string any single qoute is within a string.\n          ret += dataAsString.replace(/'/g, '\\\\\"');\n          if (esData.length > 1) {\n            ret += '\\n';\n          } // end with a new line\n          ret += '\\'';\n        }\n        return ret;\n      });\n\n      cb(result.join('\\n'));\n    });\n  };\n\n  editor.getSession().on('tokenizerUpdate', function () {\n    editor.highlightCurrentRequestsAndUpdateActionBar();\n  });\n\n  editor.getSession().selection.on('changeCursor', function () {\n    editor.highlightCurrentRequestsAndUpdateActionBar();\n  });\n\n  editor.updateActionsBar = function () {\n    var set = function set(top) {\n      if (top === null) {\n        editor.$actions.css('visibility', 'hidden');\n      } else {\n        editor.$actions.css({\n          top: top,\n          visibility: 'visible'\n        });\n      }\n    };\n\n    var hide = function hide() {\n      set();\n    };\n\n    return function () {\n      if (!editor.$actions) {\n        return;\n      }\n      if (CURRENT_REQ_RANGE) {\n        // elements are positioned relative to the editor's container\n        // pageY is relative to page, so subtract the offset\n        // from pageY to get the new top value\n        var offsetFromPage = editor.$el.offset().top;\n        var startRow = CURRENT_REQ_RANGE.start.row;\n        var startColumn = CURRENT_REQ_RANGE.start.column;\n        var session = editor.session;\n        var firstLine = session.getLine(startRow);\n\n        if (firstLine.length > session.getWrapLimit() - 5) {\n          // overlap first row\n          if (startRow > 0) {\n            startRow--;\n          } else {\n            startRow++;\n          }\n        }\n\n        var topOfReq = editor.renderer.textToScreenCoordinates(startRow, startColumn).pageY - offsetFromPage;\n\n        if (topOfReq >= 0) {\n          return set(topOfReq);\n        }\n\n        var bottomOfReq = editor.renderer.textToScreenCoordinates(CURRENT_REQ_RANGE.end.row, CURRENT_REQ_RANGE.end.column).pageY - offsetFromPage;\n\n        if (bottomOfReq >= 0) {\n          return set(0);\n        }\n      }\n\n      hide();\n    };\n  }();\n\n  editor.getSession().on('changeScrollTop', editor.updateActionsBar);\n\n  return editor;\n}\nmodule.exports = exports['default'];",null]}