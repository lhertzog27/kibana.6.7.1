{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/doc_table/doc_table.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/doc_table/doc_table.js","mtime":1567631711720},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _doc_table = require('./doc_table.html');\n\nvar _doc_table2 = _interopRequireDefault(_doc_table);\n\nvar _get_sort = require('./lib/get_sort');\n\nrequire('../directives/truncated');\n\nrequire('../directives/infinite_scroll');\n\nrequire('./components/table_header');\n\nrequire('./components/table_row');\n\nvar _render_complete = require('../render_complete');\n\nvar _modules = require('../modules');\n\nvar _courier_inspector_utils = require('../courier/utils/courier_inspector_utils');\n\nvar _doc_table_strings = require('./doc_table_strings');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_modules.uiModules.get('kibana').directive('docTable', function (config, Notifier, getAppState, pagerFactory, $filter, courier, i18n) {\n  return {\n    restrict: 'E',\n    template: _doc_table2.default,\n    scope: {\n      sorting: '=',\n      columns: '=',\n      hits: '=?', // You really want either hits & indexPattern, OR searchSource\n      indexPattern: '=?',\n      searchSource: '=?',\n      infiniteScroll: '=?',\n      filter: '=?',\n      filters: '=?',\n      minimumVisibleRows: '=?',\n      onAddColumn: '=?',\n      onChangeSortOrder: '=?',\n      onMoveColumn: '=?',\n      onRemoveColumn: '=?',\n      inspectorAdapters: '=?'\n    },\n    link: function link($scope, $el) {\n      var notify = new Notifier();\n\n      $scope.$watch('minimumVisibleRows', function (minimumVisibleRows) {\n        $scope.limit = Math.max(minimumVisibleRows || 50, $scope.limit || 50);\n      });\n\n      $scope.persist = {\n        sorting: $scope.sorting,\n        columns: $scope.columns\n      };\n\n      var limitTo = $filter('limitTo');\n      var calculateItemsOnPage = function calculateItemsOnPage() {\n        $scope.pager.setTotalItems($scope.hits.length);\n        $scope.pageOfItems = limitTo($scope.hits, $scope.pager.pageSize, $scope.pager.startIndex);\n      };\n\n      $scope.limitedResultsWarning = (0, _doc_table_strings.getLimitedSearchResultsMessage)(config.get('discover:sampleSize'));\n\n      $scope.addRows = function () {\n        $scope.limit += 50;\n      };\n\n      // This exists to fix the problem of an empty initial column list not playing nice with watchCollection.\n      $scope.$watch('columns', function (columns) {\n        if (columns.length !== 0) return;\n\n        var $state = getAppState();\n        $scope.columns.push('_source');\n        if ($state) $state.replace();\n      });\n\n      $scope.$watchCollection('columns', function (columns, oldColumns) {\n        if (oldColumns.length === 1 && oldColumns[0] === '_source' && $scope.columns.length > 1) {\n          _lodash2.default.pull($scope.columns, '_source');\n        }\n\n        if ($scope.columns.length === 0) $scope.columns.push('_source');\n      });\n\n      $scope.$watch('searchSource', function () {\n        if (!$scope.searchSource) return;\n\n        $scope.indexPattern = $scope.searchSource.getField('index');\n\n        $scope.searchSource.setField('size', config.get('discover:sampleSize'));\n        $scope.searchSource.setField('sort', (0, _get_sort.getSort)($scope.sorting, $scope.indexPattern));\n\n        // Set the watcher after initialization\n        $scope.$watchCollection('sorting', function (newSort, oldSort) {\n          // Don't react if sort values didn't really change\n          if (newSort === oldSort) return;\n          $scope.searchSource.setField('sort', (0, _get_sort.getSort)(newSort, $scope.indexPattern));\n          $scope.searchSource.fetchQueued();\n        });\n\n        $scope.$on('$destroy', function () {\n          if ($scope.searchSource) $scope.searchSource.destroy();\n        });\n\n        function onResults(resp) {\n          // Reset infinite scroll limit\n          $scope.limit = 50;\n\n          // Abort if something changed\n          if ($scope.searchSource !== $scope.searchSource) return;\n\n          $scope.hits = resp.hits.hits;\n          if ($scope.hits.length === 0) {\n            (0, _render_complete.dispatchRenderComplete)($el[0]);\n          }\n          // We limit the number of returned results, but we want to show the actual number of hits, not\n          // just how many we retrieved.\n          $scope.totalHitCount = resp.hits.total;\n          $scope.pager = pagerFactory.create($scope.hits.length, 50, 1);\n          calculateItemsOnPage();\n\n          return $scope.searchSource.onResults().then(onResults);\n        }\n\n        function startSearching() {\n          var inspectorRequest = undefined;\n          if (_lodash2.default.has($scope, 'inspectorAdapters.requests')) {\n            $scope.inspectorAdapters.requests.reset();\n            var title = i18n('common.ui.docTable.inspectorRequestDataTitle', {\n              defaultMessage: 'Data'\n            });\n            var description = i18n('common.ui.docTable.inspectorRequestDescription', {\n              defaultMessage: 'This request queries Elasticsearch to fetch the data for the search.'\n            });\n            inspectorRequest = $scope.inspectorAdapters.requests.start(title, { description: description });\n            inspectorRequest.stats((0, _courier_inspector_utils.getRequestInspectorStats)($scope.searchSource));\n            $scope.searchSource.getSearchRequestBody().then(function (body) {\n              inspectorRequest.json(body);\n            });\n          }\n          $scope.searchSource.onResults().then(function (resp) {\n            if (inspectorRequest) {\n              inspectorRequest.stats((0, _courier_inspector_utils.getResponseInspectorStats)($scope.searchSource, resp)).ok({ json: resp });\n            }\n            return resp;\n          }).then(onResults).catch(function (error) {\n            notify.error(error);\n            startSearching();\n          });\n        }\n        startSearching();\n        courier.fetch();\n      });\n\n      $scope.pageOfItems = [];\n      $scope.onPageNext = function () {\n        $scope.pager.nextPage();\n        calculateItemsOnPage();\n      };\n\n      $scope.onPagePrevious = function () {\n        $scope.pager.previousPage();\n        calculateItemsOnPage();\n      };\n\n      $scope.shouldShowLimitedResultsWarning = function () {\n        return !$scope.pager.hasNextPage && $scope.pager.totalItems < $scope.totalHitCount;\n      };\n    }\n  };\n}); /*\n     * Licensed to Elasticsearch B.V. under one or more contributor\n     * license agreements. See the NOTICE file distributed with\n     * this work for additional information regarding copyright\n     * ownership. Elasticsearch B.V. licenses this file to you under\n     * the Apache License, Version 2.0 (the \"License\"); you may\n     * not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *    http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing,\n     * software distributed under the License is distributed on an\n     * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     * KIND, either express or implied.  See the License for the\n     * specific language governing permissions and limitations\n     * under the License.\n     */",null]}