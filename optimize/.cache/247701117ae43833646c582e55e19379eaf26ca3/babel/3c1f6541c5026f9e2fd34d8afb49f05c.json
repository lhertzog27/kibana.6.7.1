{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/packages/kbn-i18n/target/web/react/provider.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/packages/kbn-i18n/target/web/react/provider.js","mtime":1567666390220},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["\"use strict\";\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.I18nProvider = void 0;\n\nvar PropTypes = _interopRequireWildcard(require(\"prop-types\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _reactIntl = require(\"react-intl\");\n\nvar i18n = _interopRequireWildcard(require(\"../core\"));\n\nvar _pseudo_locale = require(\"../core/pseudo_locale\");\n\nvar _inject = require(\"./inject\");\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }newObj.default = obj;return newObj;\n  }\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n    };\n  }return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;return o;\n  };return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n  } else {\n    obj[key] = value;\n  }return obj;\n}\n\n/**\n * To translate label that includes nested `FormattedMessage` instances React Intl\n * replaces them with special placeholders (@__uid__@ELEMENT-uid-counter@__uid__@)\n * and maps them back with nested translations after `formatMessage` processes\n * original string, so we shouldn't modify these special placeholders with pseudo\n * translations otherwise React Intl won't be able to properly replace placeholders.\n * It's implementation detail of the React Intl, but since pseudo localization is dev\n * only feature we should be fine here.\n * @param message\n */\nfunction translateFormattedMessageUsingPseudoLocale(message) {\n  var formattedMessageDelimiter = message.match(/@__.{10}__@/);\n\n  if (formattedMessageDelimiter !== null) {\n    return message.split(formattedMessageDelimiter[0]).map(function (part) {\n      return part.startsWith('ELEMENT-') ? part : (0, _pseudo_locale.translateUsingPseudoLocale)(part);\n    }).join(formattedMessageDelimiter[0]);\n  }\n\n  return (0, _pseudo_locale.translateUsingPseudoLocale)(message);\n}\n/**\n * If pseudo locale is detected, default intl.formatMessage should be decorated\n * with the pseudo localization function.\n * @param child I18nProvider child component.\n */\n\nfunction wrapIntlFormatMessage(child) {\n  return React.createElement((0, _inject.injectI18n)(function (_ref) {\n    var intl = _ref.intl;\n    var formatMessage = intl.formatMessage;\n\n    intl.formatMessage = function () {\n      return translateFormattedMessageUsingPseudoLocale(formatMessage.apply(void 0, arguments));\n    };\n\n    return React.Children.only(child);\n  }));\n}\n/**\n * The library uses the provider pattern to scope an i18n context to a tree\n * of components. This component is used to setup the i18n context for a tree.\n * IntlProvider should wrap react app's root component (inside each react render method).\n */\n\nvar I18nProvider =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(I18nProvider, _React$PureComponent);\n\n  function I18nProvider() {\n    _classCallCheck(this, I18nProvider);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(I18nProvider).apply(this, arguments));\n  }\n\n  _createClass(I18nProvider, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(_reactIntl.IntlProvider, {\n        locale: i18n.getLocale(),\n        messages: i18n.getTranslation().messages,\n        defaultLocale: i18n.getDefaultLocale(),\n        formats: i18n.getFormats(),\n        textComponent: React.Fragment\n      }, (0, _pseudo_locale.isPseudoLocale)(i18n.getLocale()) ? wrapIntlFormatMessage(this.props.children) : this.props.children);\n    }\n  }]);\n\n  return I18nProvider;\n}(React.PureComponent);\n\nexports.I18nProvider = I18nProvider;\n\n_defineProperty(I18nProvider, \"propTypes\", {\n  children: PropTypes.element.isRequired\n});",null]}