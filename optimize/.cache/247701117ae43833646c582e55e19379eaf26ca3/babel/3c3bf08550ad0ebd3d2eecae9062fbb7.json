{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/kibana/public/management/sections/index_patterns/create_index_pattern_wizard/lib/ensure_minimum_time.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/kibana/public/management/sections/index_patterns/create_index_pattern_wizard/lib/ensure_minimum_time.js","mtime":1567631691242},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ensureMinimumTime = exports.ensureMinimumTime = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(promiseOrPromises) {\n    var minimumTimeMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_MINIMUM_TIME_MS;\n    var returnValue, bufferedMinimumTimeMs, asyncActionStartTime, asyncActionCompletionTime, asyncActionDuration, additionalWaitingTime;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            returnValue = void 0;\n\n            // https://kibana-ci.elastic.co/job/elastic+kibana+6.x+multijob-intake/128/console\n            // We're having periodic failures around the timing here. I'm not exactly sure\n            // why it's not consistent but I'm going to add some buffer space here to\n            // prevent these random failures\n\n            bufferedMinimumTimeMs = minimumTimeMs + 5;\n\n            // Block on the async action and start the clock.\n\n            asyncActionStartTime = new Date().getTime();\n\n            if (!Array.isArray(promiseOrPromises)) {\n              _context.next = 9;\n              break;\n            }\n\n            _context.next = 6;\n            return Promise.all(promiseOrPromises);\n\n          case 6:\n            returnValue = _context.sent;\n            _context.next = 12;\n            break;\n\n          case 9:\n            _context.next = 11;\n            return promiseOrPromises;\n\n          case 11:\n            returnValue = _context.sent;\n\n          case 12:\n\n            // Measure how long the async action took to complete.\n            asyncActionCompletionTime = new Date().getTime();\n            asyncActionDuration = asyncActionCompletionTime - asyncActionStartTime;\n\n            // Wait longer if the async action completed too quickly.\n\n            if (!(asyncActionDuration < bufferedMinimumTimeMs)) {\n              _context.next = 18;\n              break;\n            }\n\n            additionalWaitingTime = bufferedMinimumTimeMs - (asyncActionCompletionTime - asyncActionStartTime);\n            _context.next = 18;\n            return new Promise(function (resolve) {\n              return setTimeout(resolve, additionalWaitingTime);\n            });\n\n          case 18:\n            return _context.abrupt(\"return\", returnValue);\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function ensureMinimumTime(_x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * When you make an async request, typically you want to show the user a spinner while they wait.\n * However, if the request takes less than 300 ms, the spinner will flicker in the UI and the user\n * won't have time to register it as a spinner. This function ensures the spinner (or whatever\n * you're showing the user) displays for at least 300 ms, even if the request completes before then.\n */\n\nvar DEFAULT_MINIMUM_TIME_MS = exports.DEFAULT_MINIMUM_TIME_MS = 300;",null]}