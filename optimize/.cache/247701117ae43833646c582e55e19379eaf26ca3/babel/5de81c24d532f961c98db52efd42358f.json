{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/state_management/app_state.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/state_management/app_state.js","mtime":1567631711754},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AppStateProvider = AppStateProvider;\n\nvar _modules = require('../modules');\n\nvar _state = require('./state');\n\nrequire('../persisted_state');\n\nvar _legacy_class = require('../utils/legacy_class');\n\nvar _function = require('../utils/function');\n\nvar urlParam = '_a'; /*\n                      * Licensed to Elasticsearch B.V. under one or more contributor\n                      * license agreements. See the NOTICE file distributed with\n                      * this work for additional information regarding copyright\n                      * ownership. Elasticsearch B.V. licenses this file to you under\n                      * the Apache License, Version 2.0 (the \"License\"); you may\n                      * not use this file except in compliance with the License.\n                      * You may obtain a copy of the License at\n                      *\n                      *    http://www.apache.org/licenses/LICENSE-2.0\n                      *\n                      * Unless required by applicable law or agreed to in writing,\n                      * software distributed under the License is distributed on an\n                      * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                      * KIND, either express or implied.  See the License for the\n                      * specific language governing permissions and limitations\n                      * under the License.\n                      */\n\n/**\n * @name AppState\n *\n * @extends State\n *\n * @description Inherits State, which inherits Events. This class seems to be\n * concerned with mapping \"props\" to PersistedState instances, and surfacing the\n * ability to destroy those mappings.\n */\n\nfunction AppStateProvider(Private, $rootScope, $location, $injector) {\n  var State = Private(_state.StateProvider);\n  var PersistedState = $injector.get('PersistedState');\n  var persistedStates = void 0;\n  var eventUnsubscribers = void 0;\n\n  (0, _legacy_class.createLegacyClass)(AppState).inherits(State);\n  function AppState(defaults) {\n    // Initialize persistedStates. This object maps \"prop\" names to\n    // PersistedState instances. These are used to make properties \"stateful\".\n    persistedStates = {};\n\n    // Initialize eventUnsubscribers. These will be called in `destroy`, to\n    // remove handlers for the 'change' and 'fetch_with_changes' events which\n    // are dispatched via the rootScope.\n    eventUnsubscribers = [];\n\n    AppState.Super.call(this, urlParam, defaults);\n    AppState.getAppState._set(this);\n  }\n\n  // if the url param is missing, write it back\n  AppState.prototype._persistAcrossApps = false;\n\n  AppState.prototype.destroy = function () {\n    AppState.Super.prototype.destroy.call(this);\n    AppState.getAppState._set(null);\n    (0, _function.callEach)(eventUnsubscribers);\n  };\n\n  /**\n   * @returns PersistedState instance.\n   */\n  AppState.prototype.makeStateful = function (prop) {\n    var _this = this;\n\n    if (persistedStates[prop]) return persistedStates[prop];\n    var self = this;\n\n    // set up the ui state\n    persistedStates[prop] = new PersistedState();\n\n    // update the app state when the stateful instance changes\n    var updateOnChange = function updateOnChange() {\n      var replaceState = false; // TODO: debouncing logic\n      self[prop] = persistedStates[prop].getChanges();\n      // Save state to the URL.\n      self.save(replaceState);\n    };\n    var handlerOnChange = function handlerOnChange(method) {\n      return persistedStates[prop][method]('change', updateOnChange);\n    };\n    handlerOnChange('on');\n    eventUnsubscribers.push(function () {\n      return handlerOnChange('off');\n    });\n\n    // update the stateful object when the app state changes\n    var persistOnChange = function persistOnChange(changes) {\n      if (!changes) return;\n\n      if (changes.indexOf(prop) !== -1) {\n        persistedStates[prop].set(self[prop]);\n      }\n    };\n    var handlePersist = function handlePersist(method) {\n      return _this[method]('fetch_with_changes', persistOnChange);\n    };\n    handlePersist('on');\n    eventUnsubscribers.push(function () {\n      return handlePersist('off');\n    });\n\n    // if the thing we're making stateful has an appState value, write to persisted state\n    if (self[prop]) persistedStates[prop].setSilent(self[prop]);\n\n    return persistedStates[prop];\n  };\n\n  AppState.getAppState = function () {\n    var currentAppState = void 0;\n\n    function get() {\n      return currentAppState;\n    }\n\n    // Checks to see if the appState might already exist, even if it hasn't been newed up\n    get.previouslyStored = function () {\n      var search = $location.search();\n      return search[urlParam] ? true : false;\n    };\n\n    get._set = function (current) {\n      currentAppState = current;\n    };\n\n    return get;\n  }();\n\n  return AppState;\n}\n\n_modules.uiModules.get('kibana/global_state').factory('AppState', function (Private) {\n  return Private(AppStateProvider);\n}).service('getAppState', function (Private) {\n  return Private(AppStateProvider).getAppState;\n});",null]}