{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/time_buckets/time_buckets.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/time_buckets/time_buckets.js","mtime":1567631711760},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TimeBuckets = undefined;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _parse_interval = require('../utils/parse_interval');\n\nvar _calc_auto_interval = require('./calc_auto_interval');\n\nvar _calc_es_interval = require('./calc_es_interval');\n\nvar _field_formats = require('../registry/field_formats');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar config = _chrome2.default.getUiSettingsClient(); /*\n                                                      * Licensed to Elasticsearch B.V. under one or more contributor\n                                                      * license agreements. See the NOTICE file distributed with\n                                                      * this work for additional information regarding copyright\n                                                      * ownership. Elasticsearch B.V. licenses this file to you under\n                                                      * the Apache License, Version 2.0 (the \"License\"); you may\n                                                      * not use this file except in compliance with the License.\n                                                      * You may obtain a copy of the License at\n                                                      *\n                                                      *    http://www.apache.org/licenses/LICENSE-2.0\n                                                      *\n                                                      * Unless required by applicable law or agreed to in writing,\n                                                      * software distributed under the License is distributed on an\n                                                      * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                                                      * KIND, either express or implied.  See the License for the\n                                                      * specific language governing permissions and limitations\n                                                      * under the License.\n                                                      */\n\nvar getConfig = function getConfig() {\n  return config.get.apply(config, arguments);\n};\n\nfunction isValidMoment(m) {\n  return m && 'isValid' in m && m.isValid();\n}\n\n/**\n * Helper class for wrapping the concept of an \"Interval\",\n * which describes a timespan that will separate moments.\n *\n * @param {state} object - one of \"\"\n * @param {[type]} display [description]\n */\nfunction TimeBuckets() {\n  return TimeBuckets.__cached__(this);\n}\n\n/****\n *  PUBLIC API\n ****/\n\n/**\n * Set the bounds that these buckets are expected to cover.\n * This is required to support interval \"auto\" as well\n * as interval scaling.\n *\n * @param {object} input - an object with properties min and max,\n *                       representing the edges for the time span\n *                       we should cover\n *\n * @returns {undefined}\n */\nTimeBuckets.prototype.setBounds = function (input) {\n  if (!input) return this.clearBounds();\n\n  var bounds = void 0;\n  if (_lodash2.default.isPlainObject(input)) {\n    // accept the response from timefilter.getActiveBounds()\n    bounds = [input.min, input.max];\n  } else {\n    bounds = Array.isArray(input) ? input : [];\n  }\n\n  var moments = (0, _lodash2.default)(bounds).map(_lodash2.default.ary(_moment2.default, 1)).sortBy(Number);\n\n  var valid = moments.size() === 2 && moments.every(isValidMoment);\n  if (!valid) {\n    this.clearBounds();\n    throw new Error('invalid bounds set: ' + input);\n  }\n\n  this._lb = moments.shift();\n  this._ub = moments.pop();\n  if (this.getDuration().asSeconds() < 0) {\n    throw new TypeError('Intervals must be positive');\n  }\n};\n\n/**\n * Clear the stored bounds\n *\n * @return {undefined}\n */\nTimeBuckets.prototype.clearBounds = function () {\n  this._lb = this._ub = null;\n};\n\n/**\n * Check to see if we have received bounds yet\n *\n * @return {Boolean}\n */\nTimeBuckets.prototype.hasBounds = function () {\n  return isValidMoment(this._ub) && isValidMoment(this._lb);\n};\n\n/**\n * Return the current bounds, if we have any.\n *\n * THIS DOES NOT CLONE THE BOUNDS, so editing them\n * may have unexpected side-effects. Always\n * call bounds.min.clone() before editing\n *\n * @return {object|undefined} - If bounds are not defined, this\n *                      returns undefined, else it returns the bounds\n *                      for these buckets. This object has two props,\n *                      min and max. Each property will be a moment()\n *                      object\n *\n */\nTimeBuckets.prototype.getBounds = function () {\n  if (!this.hasBounds()) return;\n  return {\n    min: this._lb,\n    max: this._ub\n  };\n};\n\n/**\n * Get a moment duration object representing\n * the distance between the bounds, if the bounds\n * are set.\n *\n * @return {moment.duration|undefined}\n */\nTimeBuckets.prototype.getDuration = function () {\n  if (!this.hasBounds()) return;\n  return _moment2.default.duration(this._ub - this._lb, 'ms');\n};\n\n/**\n * Update the interval at which buckets should be\n * generated.\n *\n * Input can be one of the following:\n *  - Any object from src/ui/agg_types/buckets/_interval_options.js\n *  - \"auto\"\n *  - Pass a valid moment unit\n *  - a moment.duration object.\n *\n * @param {object|string|moment.duration} input - see desc\n */\nTimeBuckets.prototype.setInterval = function (input) {\n  // Preserve the original units because they're lost when the interval is converted to a\n  // moment duration object.\n  this.originalInterval = input;\n\n  var interval = input;\n\n  // selection object -> val\n  if (_lodash2.default.isObject(input)) {\n    interval = input.val;\n  }\n\n  if (!interval || interval === 'auto') {\n    this._i = 'auto';\n    return;\n  }\n\n  if (_lodash2.default.isString(interval)) {\n    input = interval;\n    interval = (0, _parse_interval.parseInterval)(interval);\n    if (+interval === 0) {\n      interval = null;\n    }\n  }\n\n  // if the value wasn't converted to a duration, and isn't\n  // already a duration, we have a problem\n  if (!_moment2.default.isDuration(interval)) {\n    throw new TypeError('\"' + input + '\" is not a valid interval.');\n  }\n\n  this._i = interval;\n};\n\n/**\n * Get the interval for the buckets. If the\n * number of buckets created by the interval set\n * is larger than config:histogram:maxBars then the\n * interval will be scaled up. If the number of buckets\n * created is less than one, the interval is scaled back.\n *\n * The interval object returned is a moment.duration\n * object that has been decorated with the following\n * properties.\n *\n * interval.description: a text description of the interval.\n *   designed to be used list \"field per {{ desc }}\".\n *     - \"minute\"\n *     - \"10 days\"\n *     - \"3 years\"\n *\n * interval.expr: the elasticsearch expression that creates this\n *   interval. If the interval does not properly form an elasticsearch\n *   expression it will be forced into one.\n *\n * interval.scaled: the interval was adjusted to\n *   accommodate the maxBars setting.\n *\n * interval.scale: the number that y-values should be\n *   multiplied by\n *\n * interval.scaleDescription: a description that reflects\n *   the values which will be produced by using the\n *   interval.scale.\n *\n *\n * @return {[type]} [description]\n */\nTimeBuckets.prototype.getInterval = function () {\n  var useNormalizedEsInterval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  var self = this;\n  var duration = self.getDuration();\n  var parsedInterval = readInterval();\n\n  if (useNormalizedEsInterval) {\n    return decorateInterval(maybeScaleInterval(parsedInterval));\n  } else {\n    return decorateInterval(parsedInterval);\n  }\n\n  // either pull the interval from state or calculate the auto-interval\n  function readInterval() {\n    var interval = self._i;\n    if (_moment2.default.isDuration(interval)) return interval;\n    return (0, _calc_auto_interval.calcAutoIntervalNear)(config.get('histogram:barTarget'), Number(duration));\n  }\n\n  // check to see if the interval should be scaled, and scale it if so\n  function maybeScaleInterval(interval) {\n    if (!self.hasBounds()) return interval;\n\n    var maxLength = config.get('histogram:maxBars');\n    var approxLen = duration / interval;\n    var scaled = void 0;\n\n    if (approxLen > maxLength) {\n      scaled = (0, _calc_auto_interval.calcAutoIntervalLessThan)(maxLength, Number(duration));\n    } else {\n      return interval;\n    }\n\n    if (+scaled === +interval) return interval;\n\n    decorateInterval(interval);\n    return _lodash2.default.assign(scaled, {\n      preScaled: interval,\n      scale: interval / scaled,\n      scaled: true\n    });\n  }\n\n  // append some TimeBuckets specific props to the interval\n  function decorateInterval(interval) {\n    var esInterval = useNormalizedEsInterval ? (0, _calc_es_interval.convertDurationToNormalizedEsInterval)(interval) : (0, _calc_es_interval.convertIntervalToEsInterval)(self.originalInterval);\n    interval.esValue = esInterval.value;\n    interval.esUnit = esInterval.unit;\n    interval.expression = esInterval.expression;\n    interval.overflow = duration > interval ? _moment2.default.duration(interval - duration) : false;\n\n    var prettyUnits = _moment2.default.normalizeUnits(esInterval.unit);\n    if (esInterval.value === 1) {\n      interval.description = prettyUnits;\n    } else {\n      interval.description = esInterval.value + ' ' + prettyUnits + 's';\n    }\n\n    return interval;\n  }\n};\n\n/**\n * Get a date format string that will represent dates that\n * progress at our interval.\n *\n * Since our interval can be as small as 1ms, the default\n * date format is usually way too much. with `dateFormat:scaled`\n * users can modify how dates are formatted within series\n * produced by TimeBuckets\n *\n * @return {string}\n */\nTimeBuckets.prototype.getScaledDateFormat = function () {\n  var interval = this.getInterval();\n  var rules = config.get('dateFormat:scaled');\n\n  for (var i = rules.length - 1; i >= 0; i--) {\n    var rule = rules[i];\n    if (!rule[0] || interval >= _moment2.default.duration(rule[0])) {\n      return rule[1];\n    }\n  }\n\n  return config.get('dateFormat');\n};\n\nTimeBuckets.prototype.getScaledDateFormatter = function () {\n  var DateFieldFormat = _field_formats.fieldFormats.getType('date');\n  return new DateFieldFormat({\n    pattern: this.getScaledDateFormat()\n  }, getConfig);\n};\n\nTimeBuckets.__cached__ = function (self) {\n  var cache = {};\n  var sameMoment = same(_moment2.default.isMoment);\n  var sameDuration = same(_moment2.default.isDuration);\n\n  var desc = {\n    __cached__: {\n      value: self\n    }\n  };\n\n  var breakers = {\n    setBounds: 'bounds',\n    clearBounds: 'bounds',\n    setInterval: 'interval'\n  };\n\n  var resources = {\n    bounds: {\n      setup: function setup() {\n        return [self._lb, self._ub];\n      },\n      changes: function changes(prev) {\n        return !sameMoment(prev[0], self._lb) || !sameMoment(prev[1], self._ub);\n      }\n    },\n    interval: {\n      setup: function setup() {\n        return self._i;\n      },\n      changes: function changes(prev) {\n        return !sameDuration(prev, this._i);\n      }\n    }\n  };\n\n  function cachedGetter(prop) {\n    return {\n      value: function cachedGetter() {\n        if (cache.hasOwnProperty(prop)) {\n          return cache[prop];\n        }\n\n        return cache[prop] = self[prop].apply(self, arguments);\n      }\n    };\n  }\n\n  function cacheBreaker(prop) {\n    var resource = resources[breakers[prop]];\n    var setup = resource.setup;\n    var changes = resource.changes;\n    var fn = self[prop];\n\n    return {\n      value: function cacheBreaker() {\n        var prev = setup.call(self);\n        var ret = fn.apply(self, arguments);\n\n        if (changes.call(self, prev)) {\n          cache = {};\n        }\n\n        return ret;\n      }\n    };\n  }\n\n  function same(checkType) {\n    return function (a, b) {\n      if (a === b) return true;\n      if (checkType(a) === checkType(b)) return +a === +b;\n      return false;\n    };\n  }\n\n  _lodash2.default.forOwn(TimeBuckets.prototype, function (fn, prop) {\n    if (prop[0] === '_') return;\n\n    if (breakers.hasOwnProperty(prop)) {\n      desc[prop] = cacheBreaker(prop);\n    } else {\n      desc[prop] = cachedGetter(prop);\n    }\n  });\n\n  return Object.create(self, desc);\n};\n\nexports.TimeBuckets = TimeBuckets;",null]}