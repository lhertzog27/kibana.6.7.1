{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/courier/search_source/search_source.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/courier/search_source/search_source.js","mtime":1567631711715},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed to Elasticsearch B.V. under one or more contributor\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * license agreements. See the NOTICE file distributed with\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * this work for additional information regarding copyright\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ownership. Elasticsearch B.V. licenses this file to you under\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the Apache License, Version 2.0 (the \"License\"); you may\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * software distributed under the License is distributed on an\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * KIND, either express or implied.  See the License for the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * specific language governing permissions and limitations\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * under the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n/**\n * @name SearchSource\n *\n * @description A promise-based stream of search results that can inherit from other search sources.\n *\n * Because filters/queries in Kibana have different levels of persistence and come from different\n * places, it is important to keep track of where filters come from for when they are saved back to\n * the savedObject store in the Kibana index. To do this, we create trees of searchSource objects\n * that can have associated query parameters (index, query, filter, etc) which can also inherit from\n * other searchSource objects.\n *\n * At query time, all of the searchSource objects that have subscribers are \"flattened\", at which\n * point the query params from the searchSource are collected while traversing up the inheritance\n * chain. At each link in the chain a decision about how to merge the query params is made until a\n * single set of query parameters is created for each active searchSource (a searchSource with\n * subscribers).\n *\n * That set of query parameters is then sent to elasticsearch. This is how the filter hierarchy\n * works in Kibana.\n *\n * Visualize, starting from a new search:\n *\n *  - the `savedVis.searchSource` is set as the `appSearchSource`.\n *  - The `savedVis.searchSource` would normally inherit from the `appSearchSource`, but now it is\n *    upgraded to inherit from the `rootSearchSource`.\n *  - Any interaction with the visualization will still apply filters to the `appSearchSource`, so\n *    they will be stored directly on the `savedVis.searchSource`.\n *  - Any interaction with the time filter will be written to the `rootSearchSource`, so those\n *    filters will not be saved by the `savedVis`.\n *  - When the `savedVis` is saved to elasticsearch, it takes with it all the filters that are\n *    defined on it directly, but none of the ones that it inherits from other places.\n *\n * Visualize, starting from an existing search:\n *\n *  - The `savedVis` loads the `savedSearch` on which it is built.\n *  - The `savedVis.searchSource` is set to inherit from the `saveSearch.searchSource` and set as\n *    the `appSearchSource`.\n *  - The `savedSearch.searchSource`, is set to inherit from the `rootSearchSource`.\n *  - Then the `savedVis` is written to elasticsearch it will be flattened and only include the\n *    filters created in the visualize application and will reconnect the filters from the\n *    `savedSearch` at runtime to prevent losing the relationship\n *\n * Dashboard search sources:\n *\n *  - Each panel in a dashboard has a search source.\n *  - The `savedDashboard` also has a searchsource, and it is set as the `appSearchSource`.\n *  - Each panel's search source inherits from the `appSearchSource`, meaning that they inherit from\n *    the dashboard search source.\n *  - When a filter is added to the search box, or via a visualization, it is written to the\n *    `appSearchSource`.\n */\n\nexports.SearchSourceProvider = SearchSourceProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _esQuery = require('@kbn/es-query');\n\nrequire('../../promises');\n\nvar _normalize_sort_request = require('./_normalize_sort_request');\n\nvar _request = require('../fetch/request');\n\nvar _segmented_search_request = require('../fetch/request/segmented_search_request');\n\nvar _search_request_queue = require('../search_request_queue');\n\nvar _fetch = require('../fetch');\n\nvar _field_wildcard = require('../../field_wildcard');\n\nvar _highlight = require('../../../../legacy/core_plugins/kibana/common/highlight');\n\nvar _errors = require('../../errors');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FIELDS = ['type', 'query', 'filter', 'sort', 'highlight', 'highlightAll', 'aggs', 'from', 'searchAfter', 'size', 'source', 'version', 'fields', 'index'];\n\nfunction parseInitialFields(initialFields) {\n  if (!initialFields) {\n    return {};\n  }\n\n  return typeof initialFields === 'string' ? JSON.parse(initialFields) : _lodash2.default.cloneDeep(initialFields);\n}\n\nfunction isIndexPattern(val) {\n  return Boolean(val && typeof val.toIndexList === 'function');\n}\n\nfunction SearchSourceProvider(Promise, Private, config) {\n  var SearchRequest = Private(_request.SearchRequestProvider);\n  var SegmentedSearchRequest = Private(_segmented_search_request.SegmentedSearchRequestProvider);\n  var normalizeSortRequest = Private(_normalize_sort_request.NormalizeSortRequestProvider);\n  var fetchSoon = Private(_fetch.FetchSoonProvider);\n\n  var _Private = Private(_field_wildcard.FieldWildcardProvider),\n      fieldWildcardFilter = _Private.fieldWildcardFilter;\n\n  var getConfig = function getConfig() {\n    return config.get.apply(config, arguments);\n  };\n\n  var forIp = Symbol('for which index pattern?');\n\n  var SearchSource = function () {\n    function SearchSource(initialFields) {\n      var _this = this;\n\n      _classCallCheck(this, SearchSource);\n\n      this.setField = function (field, value) {\n        if (!FIELDS.includes(field)) {\n          throw new Error('Can\\'t set field \\'' + field + '\\' on SearchSource. Acceptable fields are: ' + FIELDS.join(', ') + '.');\n        }\n\n        if (field === 'index') {\n          var fields = _this._fields;\n\n          var hasSource = fields.source;\n          var sourceCameFromIp = hasSource && fields.source.hasOwnProperty(forIp);\n          var sourceIsForOurIp = sourceCameFromIp && fields.source[forIp] === fields.index;\n          if (sourceIsForOurIp) {\n            delete fields.source;\n          }\n\n          if (value === null || value === undefined) {\n            delete fields.index;\n            return _this;\n          }\n\n          if (!isIndexPattern(value)) {\n            throw new TypeError('expected indexPattern to be an IndexPattern duck.');\n          }\n\n          fields[field] = value;\n          if (!fields.source) {\n            // imply source filtering based on the index pattern, but allow overriding\n            // it by simply setting another field for \"source\". When index is changed\n            fields.source = function () {\n              return value.getSourceFiltering();\n            };\n            fields.source[forIp] = value;\n          }\n\n          return _this;\n        }\n\n        if (value == null) {\n          delete _this._fields[field];\n          return _this;\n        }\n\n        _this._fields[field] = value;\n        return _this;\n      };\n\n      this.getField = function (field) {\n        if (!FIELDS.includes(field)) {\n          throw new Error('Can\\'t get field \\'' + field + '\\' from SearchSource. Acceptable fields are: ' + FIELDS.join(', ') + '.');\n        }\n\n        var searchSource = _this;\n\n        while (searchSource) {\n          var value = searchSource._fields[field];\n          if (value !== void 0) {\n            return value;\n          }\n\n          searchSource = searchSource.getParent();\n        }\n      };\n\n      this._id = _lodash2.default.uniqueId('data_source');\n\n      this._searchStrategyId = undefined;\n      this._fields = parseInitialFields(initialFields);\n      this._parent = undefined;\n\n      this.history = [];\n      this._requestStartHandlers = [];\n      this._inheritOptions = {};\n\n      this._filterPredicates = [function (filter) {\n        // remove null/undefined filters\n        return filter;\n      }, function (filter) {\n        var disabled = _lodash2.default.get(filter, 'meta.disabled');\n        return disabled === undefined || disabled === false;\n      }, function (filter, data) {\n        var index = data.index || _this.getField('index');\n        return !config.get('courier:ignoreFilterIfFieldNotInIndex') || (0, _esQuery.filterMatchesIndex)(filter, index);\n      }];\n    }\n\n    /*****\n     * PUBLIC API\n     *****/\n\n    _createClass(SearchSource, [{\n      key: 'setPreferredSearchStrategyId',\n      value: function setPreferredSearchStrategyId(searchStrategyId) {\n        this._searchStrategyId = searchStrategyId;\n      }\n    }, {\n      key: 'getPreferredSearchStrategyId',\n      value: function getPreferredSearchStrategyId() {\n        return this._searchStrategyId;\n      }\n    }, {\n      key: 'setFields',\n      value: function setFields(newFields) {\n        this._fields = newFields;\n        return this;\n      }\n    }, {\n      key: 'getId',\n      value: function getId() {\n        return this._id;\n      }\n    }, {\n      key: 'getFields',\n      value: function getFields() {\n        return _lodash2.default.clone(this._fields);\n      }\n\n      /**\n       * Get fields from the fields\n       */\n\n    }, {\n      key: 'getOwnField',\n\n\n      /**\n       * Get the field from our own fields, don't traverse up the chain\n       */\n      value: function getOwnField(field) {\n        if (!FIELDS.includes(field)) {\n          throw new Error('Can\\'t get field \\'' + field + '\\' from SearchSource. Acceptable fields are: ' + FIELDS.join(', ') + '.');\n        }\n\n        var value = this._fields[field];\n        if (value !== void 0) {\n          return value;\n        }\n      }\n    }, {\n      key: 'create',\n      value: function create() {\n        return new SearchSource();\n      }\n    }, {\n      key: 'createCopy',\n      value: function createCopy() {\n        var json = _angular2.default.toJson(this._fields);\n        var newSearchSource = new SearchSource(json);\n        // when serializing the internal fields we lose the internal classes used in the index\n        // pattern, so we have to set it again to workaround this behavior\n        newSearchSource.setField('index', this.getField('index'));\n        newSearchSource.setParent(this.getParent());\n        return newSearchSource;\n      }\n    }, {\n      key: 'createChild',\n      value: function createChild() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        var childSearchSource = new SearchSource();\n        childSearchSource.setParent(this, options);\n        return childSearchSource;\n      }\n\n      /**\n       * Set a searchSource that this source should inherit from\n       * @param  {SearchSource} searchSource - the parent searchSource\n       * @return {this} - chainable\n       */\n\n    }, {\n      key: 'setParent',\n      value: function setParent(parent) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        this._parent = parent;\n        this._inheritOptions = options;\n        return this;\n      }\n\n      /**\n       * Get the parent of this SearchSource\n       * @return {undefined|searchSource}\n       */\n\n    }, {\n      key: 'getParent',\n      value: function getParent() {\n        return this._parent || undefined;\n      }\n\n      /**\n       * Fetch this source and reject the returned Promise on error\n       *\n       * @async\n       */\n\n    }, {\n      key: 'fetch',\n      value: function fetch() {\n        var self = this;\n        var req = _lodash2.default.first(self._myStartableQueued());\n\n        if (!req) {\n          var errorHandler = function errorHandler(request, error) {\n            request.defer.reject(error);\n            request.abort();\n          };\n          req = self._createRequest({ errorHandler: errorHandler });\n        }\n\n        fetchSoon.fetchSearchRequests([req]);\n        return req.getCompletePromise();\n      }\n\n      /**\n       * Fetch all pending requests for this source ASAP\n       * @async\n       */\n\n    }, {\n      key: 'fetchQueued',\n      value: function fetchQueued() {\n        return fetchSoon.fetchSearchRequests(this._myStartableQueued());\n      }\n\n      /**\n       * Cancel all pending requests for this searchSource\n       * @return {undefined}\n       */\n\n    }, {\n      key: 'cancelQueued',\n      value: function cancelQueued() {\n        var _this2 = this;\n\n        _search_request_queue.searchRequestQueue.getAll().filter(function (req) {\n          return req.source === _this2;\n        }).forEach(function (req) {\n          return req.abort();\n        });\n      }\n\n      /**\n       *  Add a handler that will be notified whenever requests start\n       *  @param  {Function} handler\n       *  @return {undefined}\n       */\n\n    }, {\n      key: 'onRequestStart',\n      value: function onRequestStart(handler) {\n        this._requestStartHandlers.push(handler);\n      }\n\n      /**\n       *  Called by requests of this search source when they are started\n       *  @param  {Courier.Request} request\n       *  @return {Promise<undefined>}\n       */\n\n    }, {\n      key: 'requestIsStarting',\n      value: function requestIsStarting(request) {\n        var _this3 = this;\n\n        this.activeFetchCount = (this.activeFetchCount || 0) + 1;\n        this.history = [request];\n\n        var handlers = [].concat(_toConsumableArray(this._requestStartHandlers));\n        // If callparentStartHandlers has been set to true, we also call all\n        // handlers of parent search sources.\n        if (this._inheritOptions.callParentStartHandlers) {\n          var searchSource = this.getParent();\n          while (searchSource) {\n            handlers.push.apply(handlers, _toConsumableArray(searchSource._requestStartHandlers));\n            searchSource = searchSource.getParent();\n          }\n        }\n\n        return Promise.map(handlers, function (fn) {\n          return fn(_this3, request);\n        }).then(_lodash2.default.noop);\n      }\n\n      /**\n       * Put a request in to the courier that this Source should\n       * be fetched on the next run of the courier\n       * @return {Promise}\n       */\n\n    }, {\n      key: 'onResults',\n      value: function onResults() {\n        var self = this;\n\n        return new Promise(function (resolve, reject) {\n          var defer = Promise.defer();\n          defer.promise.then(resolve, reject);\n\n          var errorHandler = function errorHandler(request, error) {\n            reject(error);\n            request.abort();\n          };\n          self._createRequest({ defer: defer, errorHandler: errorHandler });\n        });\n      }\n    }, {\n      key: 'onBeginSegmentedFetch',\n      value: function onBeginSegmentedFetch(initFunction) {\n        var self = this;\n        return new Promise(function (resolve, reject) {\n          function addRequest() {\n            var defer = Promise.defer();\n            var errorHandler = function errorHandler(request, error) {\n              reject(error);\n              request.abort();\n            };\n            var req = new SegmentedSearchRequest({ source: self, defer: defer, errorHandler: errorHandler, initFn: initFunction });\n\n            // Return promises created by the completion handler so that\n            // errors will bubble properly\n            return req.getCompletePromise().then(addRequest);\n          }\n\n          addRequest();\n        });\n      }\n    }, {\n      key: 'getSearchRequestBody',\n      value: function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n          var searchRequest;\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this._flatten();\n\n                case 2:\n                  searchRequest = _context.sent;\n                  return _context.abrupt('return', searchRequest.body);\n\n                case 4:\n                case 'end':\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function getSearchRequestBody() {\n          return _ref.apply(this, arguments);\n        }\n\n        return getSearchRequestBody;\n      }()\n\n      /**\n       *  Called by requests of this search source when they are done\n       *  @param  {Courier.Request} request\n       *  @return {undefined}\n       */\n\n    }, {\n      key: 'requestIsStopped',\n      value: function requestIsStopped() {\n        this.activeFetchCount -= 1;\n      }\n\n      /**\n       * Completely destroy the SearchSource.\n       * @return {undefined}\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.cancelQueued();\n        this._requestStartHandlers.length = 0;\n      }\n\n      /******\n       * PRIVATE APIS\n       ******/\n\n    }, {\n      key: '_myStartableQueued',\n      value: function _myStartableQueued() {\n        var _this4 = this;\n\n        return _search_request_queue.searchRequestQueue.getStartable().filter(function (req) {\n          return req.source === _this4;\n        });\n      }\n\n      /**\n       * Create a common search request object, which should\n       * be put into the pending request queue, for this search\n       * source\n       *\n       * @param {Deferred} defer - the deferred object that should be resolved\n       *                         when the request is complete\n       * @return {SearchRequest}\n       */\n\n    }, {\n      key: '_createRequest',\n      value: function _createRequest(_ref2) {\n        var defer = _ref2.defer,\n            errorHandler = _ref2.errorHandler;\n\n        return new SearchRequest({ source: this, defer: defer, errorHandler: errorHandler });\n      }\n\n      /**\n       * Used to merge properties into the data within ._flatten().\n       * The data is passed in and modified by the function\n       *\n       * @param  {object} data - the current merged data\n       * @param  {*} val - the value at `key`\n       * @param  {*} key - The key of `val`\n       * @return {undefined}\n       */\n\n    }, {\n      key: '_mergeProp',\n      value: function _mergeProp(data, val, key) {\n        var _this5 = this;\n\n        if (typeof val === 'function') {\n          var source = this;\n          return Promise.cast(val(this)).then(function (newVal) {\n            return source._mergeProp(data, newVal, key);\n          });\n        }\n\n        if (val == null || !key || !_lodash2.default.isString(key)) return;\n\n        switch (key) {\n          case 'filter':\n            var filters = Array.isArray(val) ? val : [val];\n\n            filters = filters.filter(function (filter) {\n              return _this5._filterPredicates.every(function (predicate) {\n                return predicate(filter, data);\n              });\n            });\n\n            data.filters = [].concat(_toConsumableArray(data.filters || []), _toConsumableArray(filters));\n            return;\n          case 'index':\n          case 'type':\n          case 'id':\n          case 'highlightAll':\n            if (key && data[key] == null) {\n              data[key] = val;\n            }\n            return;\n          case 'searchAfter':\n            key = 'search_after';\n            addToBody();\n            break;\n          case 'source':\n            key = '_source';\n            addToBody();\n            break;\n          case 'sort':\n            val = normalizeSortRequest(val, this.getField('index'));\n            addToBody();\n            break;\n          case 'query':\n            data.query = (data.query || []).concat(val);\n            break;\n          case 'fields':\n            data[key] = _lodash2.default.uniq([].concat(_toConsumableArray(data[key] || []), _toConsumableArray(val)));\n            break;\n          default:\n            addToBody();\n        }\n\n        /**\n         * Add the key and val to the body of the request\n         */\n        function addToBody() {\n          data.body = data.body || {};\n          // ignore if we already have a value\n          if (data.body[key] == null) {\n            data.body[key] = val;\n          }\n        }\n      }\n\n      /**\n       * Walk the inheritance chain of a source and return it's\n       * flat representation (taking into account merging rules)\n       * @returns {Promise}\n       * @resolved {Object|null} - the flat data of the SearchSource\n       */\n\n    }, {\n      key: '_flatten',\n      value: function _flatten() {\n        // the merged data of this dataSource and it's ancestors\n        var flatData = {};\n\n        // function used to write each property from each data object in the chain to flat data\n        var root = this;\n\n        // start the chain at this source\n        var current = this;\n\n        // call the ittr and return it's promise\n        return function ittr() {\n          // iterate the _fields object (not array) and\n          // pass each key:value pair to source._mergeProp. if _mergeProp\n          // returns a promise, then wait for it to complete and call _mergeProp again\n          return Promise.all(_lodash2.default.map(current._fields, function ittr(value, key) {\n            if (Promise.is(value)) {\n              return value.then(function (value) {\n                return ittr(value, key);\n              });\n            }\n\n            var prom = root._mergeProp(flatData, value, key);\n            return Promise.is(prom) ? prom : null;\n          })).then(function () {\n            // move to this sources parent\n            var parent = current.getParent();\n            // keep calling until we reach the top parent\n            if (parent) {\n              current = parent;\n              return ittr();\n            }\n          });\n        }().then(function () {\n          // This is down here to prevent the circular dependency\n          flatData.body = flatData.body || {};\n\n          var computedFields = flatData.index.getComputedFields();\n          flatData.body.stored_fields = computedFields.storedFields;\n          flatData.body.script_fields = flatData.body.script_fields || {};\n          flatData.body.docvalue_fields = flatData.body.docvalue_fields || [];\n\n          _lodash2.default.extend(flatData.body.script_fields, computedFields.scriptFields);\n          flatData.body.docvalue_fields = _lodash2.default.union(flatData.body.docvalue_fields, computedFields.docvalueFields);\n\n          if (flatData.body._source) {\n            // exclude source fields for this index pattern specified by the user\n            var filter = fieldWildcardFilter(flatData.body._source.excludes);\n            flatData.body.docvalue_fields = flatData.body.docvalue_fields.filter(function (docvalueField) {\n              return filter(docvalueField.field);\n            });\n          }\n\n          // if we only want to search for certain fields\n          var fields = flatData.fields;\n          if (fields) {\n            // filter out the docvalue_fields, and script_fields to only include those that we are concerned with\n            flatData.body.docvalue_fields = _lodash2.default.intersection(flatData.body.docvalue_fields, fields);\n            flatData.body.script_fields = _lodash2.default.pick(flatData.body.script_fields, fields);\n\n            // request the remaining fields from both stored_fields and _source\n            var remainingFields = _lodash2.default.difference(fields, _lodash2.default.keys(flatData.body.script_fields));\n            flatData.body.stored_fields = remainingFields;\n            _lodash2.default.set(flatData.body, '_source.includes', remainingFields);\n          }\n\n          try {\n            var esQueryConfigs = (0, _esQuery.getEsQueryConfig)(config);\n            flatData.body.query = (0, _esQuery.buildEsQuery)(flatData.index, flatData.query, flatData.filters, esQueryConfigs);\n          } catch (e) {\n            if (e.message === 'OutdatedKuerySyntaxError') {\n              throw new _errors.OutdatedKuerySyntaxError();\n            }\n            throw new _errors.KbnError(e.message, _errors.KbnError);\n          }\n\n          if (flatData.highlightAll != null) {\n            if (flatData.highlightAll && flatData.body.query) {\n              flatData.body.highlight = (0, _highlight.getHighlightRequest)(flatData.body.query, getConfig);\n            }\n            delete flatData.highlightAll;\n          }\n\n          /**\n           * Translate a filter into a query to support es 3+\n           * @param  {Object} filter - The filter to translate\n           * @return {Object} the query version of that filter\n           */\n          var translateToQuery = function translateToQuery(filter) {\n            if (!filter) return;\n\n            if (filter.query) {\n              return filter.query;\n            }\n\n            return filter;\n          };\n\n          // re-write filters within filter aggregations\n          (function recurse(aggBranch) {\n            if (!aggBranch) return;\n            Object.keys(aggBranch).forEach(function (id) {\n              var agg = aggBranch[id];\n\n              if (agg.filters) {\n                // translate filters aggregations\n                var filters = agg.filters.filters;\n\n                Object.keys(filters).forEach(function (filterId) {\n                  filters[filterId] = translateToQuery(filters[filterId]);\n                });\n              }\n\n              recurse(agg.aggs || agg.aggregations);\n            });\n          })(flatData.body.aggs || flatData.body.aggregations);\n\n          return flatData;\n        });\n      }\n    }]);\n\n    return SearchSource;\n  }();\n\n  return SearchSource;\n}",null]}