{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/courier/saved_object/saved_object.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/courier/saved_object/saved_object.js","mtime":1567631711714},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /*\n                                                                                                                                                                                                                                                                               * Licensed to Elasticsearch B.V. under one or more contributor\n                                                                                                                                                                                                                                                                               * license agreements. See the NOTICE file distributed with\n                                                                                                                                                                                                                                                                               * this work for additional information regarding copyright\n                                                                                                                                                                                                                                                                               * ownership. Elasticsearch B.V. licenses this file to you under\n                                                                                                                                                                                                                                                                               * the Apache License, Version 2.0 (the \"License\"); you may\n                                                                                                                                                                                                                                                                               * not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                               * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               *    http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * Unless required by applicable law or agreed to in writing,\n                                                                                                                                                                                                                                                                               * software distributed under the License is distributed on an\n                                                                                                                                                                                                                                                                               * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                                                                                                                                                                                                                                                                               * KIND, either express or implied.  See the License for the\n                                                                                                                                                                                                                                                                               * specific language governing permissions and limitations\n                                                                                                                                                                                                                                                                               * under the License.\n                                                                                                                                                                                                                                                                               */\n\n/**\n * @name SavedObject\n *\n * NOTE: SavedObject seems to track a reference to an object in ES,\n * and surface methods for CRUD functionality (save and delete). This seems\n * similar to how Backbone Models work.\n *\n * This class seems to interface with ES primarily through the es Angular\n * service and the saved object api.\n */\n\nexports.SavedObjectProvider = SavedObjectProvider;\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _errors = require('../../errors');\n\nvar _mapping_setup = require('../../utils/mapping_setup');\n\nvar _mapping_setup2 = _interopRequireDefault(_mapping_setup);\n\nvar _search_source = require('../search_source');\n\nvar _saved_objects = require('../../saved_objects');\n\nvar _migrate_legacy_query = require('../../utils/migrate_legacy_query');\n\nvar _persisted_log = require('../../persisted_log');\n\nvar _i18n = require('@kbn/i18n');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * An error message to be used when the user rejects a confirm overwrite.\n * @type {string}\n */\nvar OVERWRITE_REJECTED = _i18n.i18n.translate('common.ui.courier.savedObject.overwriteRejectedDescription', {\n  defaultMessage: 'Overwrite confirmation was rejected'\n});\n\n/**\n * An error message to be used when the user rejects a confirm save with duplicate title.\n * @type {string}\n */\nvar SAVE_DUPLICATE_REJECTED = _i18n.i18n.translate('common.ui.courier.savedObject.saveDuplicateRejectedDescription', {\n  defaultMessage: 'Save with duplicate title confirmation was rejected'\n});\n\n/**\n * @param error {Error} the error\n * @return {boolean}\n */\nfunction isErrorNonFatal(error) {\n  if (!error) return false;\n  return error.message === OVERWRITE_REJECTED || error.message === SAVE_DUPLICATE_REJECTED;\n}\n\nfunction SavedObjectProvider(Promise, Private, Notifier, confirmModalPromise, indexPatterns) {\n  var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);\n  var SearchSource = Private(_search_source.SearchSourceProvider);\n  var mappingSetup = Private(_mapping_setup2.default);\n\n  function SavedObject(config) {\n    var _this = this;\n\n    if (!_lodash2.default.isObject(config)) config = {};\n\n    /************\n     * Initialize config vars\n     ************/\n\n    // type name for this object, used as the ES-type\n    var esType = config.type;\n\n    this.getDisplayName = function () {\n      return esType;\n    };\n\n    // NOTE: this.type (not set in this file, but somewhere else) is the sub type, e.g. 'area' or\n    // 'data table', while esType is the more generic type - e.g. 'visualization' or 'saved search'.\n    this.getEsType = function () {\n      return esType;\n    };\n\n    /**\n     * Flips to true during a save operation, and back to false once the save operation\n     * completes.\n     * @type {boolean}\n     */\n    this.isSaving = false;\n    this.defaults = config.defaults || {};\n\n    // mapping definition for the fields that this object will expose\n    var mapping = mappingSetup.expandShorthand(config.mapping);\n\n    var afterESResp = config.afterESResp || _lodash2.default.noop;\n    var customInit = config.init || _lodash2.default.noop;\n\n    // optional search source which this object configures\n    this.searchSource = config.searchSource ? new SearchSource() : undefined;\n\n    // the id of the document\n    this.id = config.id || void 0;\n\n    // the migration version of the document, should only be set on imports\n    this.migrationVersion = config.migrationVersion;\n\n    // Whether to create a copy when the object is saved. This should eventually go away\n    // in favor of a better rename/save flow.\n    this.copyOnSave = false;\n\n    var parseSearchSource = function parseSearchSource(searchSourceJson) {\n      if (!_this.searchSource) return;\n\n      // if we have a searchSource, set its values based on the searchSourceJson field\n      var searchSourceValues = void 0;\n      try {\n        searchSourceValues = JSON.parse(searchSourceJson);\n      } catch (e) {\n        throw new _errors.InvalidJSONProperty('Invalid JSON in ' + esType + ' \"' + _this.id + '\". ' + e.message + ' JSON: ' + searchSourceJson);\n      }\n\n      // This detects a scenario where documents with invalid JSON properties have been imported into the saved object index.\n      // (This happened in issue #20308)\n      if (!searchSourceValues || (typeof searchSourceValues === 'undefined' ? 'undefined' : _typeof(searchSourceValues)) !== 'object') {\n        throw new _errors.InvalidJSONProperty('Invalid searchSourceJSON in ' + esType + ' \"' + _this.id + '\".');\n      }\n\n      var searchSourceFields = _this.searchSource.getFields();\n      var fnProps = _lodash2.default.transform(searchSourceFields, function (dynamic, val, name) {\n        if (_lodash2.default.isFunction(val)) dynamic[name] = val;\n      }, {});\n\n      _this.searchSource.setFields(_lodash2.default.defaults(searchSourceValues, fnProps));\n\n      if (!_lodash2.default.isUndefined(_this.searchSource.getOwnField('query'))) {\n        _this.searchSource.setField('query', (0, _migrate_legacy_query.migrateLegacyQuery)(_this.searchSource.getOwnField('query')));\n      }\n    };\n\n    /**\n     * After creation or fetching from ES, ensure that the searchSources index indexPattern\n     * is an bonafide IndexPattern object.\n     *\n     * @return {Promise<IndexPattern | null>}\n     */\n    this.hydrateIndexPattern = function (id) {\n      if (!_this.searchSource) {\n        return Promise.resolve(null);\n      }\n\n      if (config.clearSavedIndexPattern) {\n        _this.searchSource.setField('index', null);\n        return Promise.resolve(null);\n      }\n\n      var index = id || config.indexPattern || _this.searchSource.getOwnField('index');\n\n      if (!index) {\n        return Promise.resolve(null);\n      }\n\n      // If index is not an IndexPattern object at this point, then it's a string id of an index.\n      if (!(index instanceof indexPatterns.IndexPattern)) {\n        index = indexPatterns.get(index);\n      }\n\n      // At this point index will either be an IndexPattern, if cached, or a promise that\n      // will return an IndexPattern, if not cached.\n      return Promise.resolve(index).then(function (indexPattern) {\n        _this.searchSource.setField('index', indexPattern);\n      });\n    };\n\n    /**\n     * Asynchronously initialize this object - will only run\n     * once even if called multiple times.\n     *\n     * @return {Promise}\n     * @resolved {SavedObject}\n     */\n    this.init = _lodash2.default.once(function () {\n      // ensure that the esType is defined\n      if (!esType) throw new Error('You must define a type name to use SavedObject objects.');\n\n      return Promise.resolve().then(function () {\n        // If there is not id, then there is no document to fetch from elasticsearch\n        if (!_this.id) {\n          // just assign the defaults and be done\n          _lodash2.default.assign(_this, _this.defaults);\n          return _this.hydrateIndexPattern().then(function () {\n            return afterESResp.call(_this);\n          });\n        }\n\n        // fetch the object from ES\n        return savedObjectsClient.get(esType, _this.id).then(function (resp) {\n          // temporary compatability for savedObjectsClient\n          return {\n            _id: resp.id,\n            _type: resp.type,\n            _source: _lodash2.default.cloneDeep(resp.attributes),\n            found: resp._version ? true : false\n          };\n        }).then(_this.applyESResp).catch(_this.applyEsResp);\n      }).then(function () {\n        return customInit.call(_this);\n      }).then(function () {\n        return _this;\n      });\n    });\n\n    this.applyESResp = function (resp) {\n      _this._source = _lodash2.default.cloneDeep(resp._source);\n\n      if (resp.found != null && !resp.found) {\n        throw new _errors.SavedObjectNotFound(esType, _this.id);\n      }\n\n      var meta = resp._source.kibanaSavedObjectMeta || {};\n      delete resp._source.kibanaSavedObjectMeta;\n\n      if (!config.indexPattern && _this._source.indexPattern) {\n        config.indexPattern = _this._source.indexPattern;\n        delete _this._source.indexPattern;\n      }\n\n      // assign the defaults to the response\n      _lodash2.default.defaults(_this._source, _this.defaults);\n\n      // transform the source using _deserializers\n      _lodash2.default.forOwn(mapping, function (fieldMapping, fieldName) {\n        if (fieldMapping._deserialize) {\n          _this._source[fieldName] = fieldMapping._deserialize(_this._source[fieldName], resp, fieldName, fieldMapping);\n        }\n      });\n\n      // Give obj all of the values in _source.fields\n      _lodash2.default.assign(_this, _this._source);\n      _this.lastSavedTitle = _this.title;\n\n      return Promise.try(function () {\n        parseSearchSource(meta.searchSourceJSON);\n        return _this.hydrateIndexPattern();\n      }).then(function () {\n        return Promise.cast(afterESResp.call(_this, resp));\n      });\n    };\n\n    /**\n     * Serialize this object\n     *\n     * @return {Object}\n     */\n    this.serialize = function () {\n      var body = {};\n\n      _lodash2.default.forOwn(mapping, function (fieldMapping, fieldName) {\n        if (_this[fieldName] != null) {\n          body[fieldName] = fieldMapping._serialize ? fieldMapping._serialize(_this[fieldName]) : _this[fieldName];\n        }\n      });\n\n      if (_this.searchSource) {\n        var searchSourceFields = _lodash2.default.omit(_this.searchSource.getFields(), ['sort', 'size']);\n        body.kibanaSavedObjectMeta = {\n          searchSourceJSON: _angular2.default.toJson(searchSourceFields)\n        };\n      }\n\n      return body;\n    };\n\n    /**\n     * Returns true if the object's original title has been changed. New objects return false.\n     * @return {boolean}\n     */\n    this.isTitleChanged = function () {\n      return _this._source && _this._source.title !== _this.title;\n    };\n\n    this.creationOpts = function () {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return _extends({\n        id: _this.id,\n        migrationVersion: _this.migrationVersion\n      }, opts);\n    };\n\n    /**\n     * Attempts to create the current object using the serialized source. If an object already\n     * exists, a warning message requests an overwrite confirmation.\n     * @param source - serialized version of this object (return value from this.serialize())\n     * What will be indexed into elasticsearch.\n     * @returns {Promise} - A promise that is resolved with the objects id if the object is\n     * successfully indexed. If the overwrite confirmation was rejected, an error is thrown with\n     * a confirmRejected = true parameter so that case can be handled differently than\n     * a create or index error.\n     * @resolved {SavedObject}\n     */\n    var createSource = function createSource(source) {\n      return savedObjectsClient.create(esType, source, _this.creationOpts()).catch(function (err) {\n        // record exists, confirm overwriting\n        if (_lodash2.default.get(err, 'res.status') === 409) {\n          var confirmMessage = _i18n.i18n.translate('common.ui.courier.savedObject.confirmModal.overwriteConfirmationMessage', {\n            defaultMessage: 'Are you sure you want to overwrite {title}?',\n            values: { title: _this.title }\n          });\n\n          return confirmModalPromise(confirmMessage, {\n            confirmButtonText: _i18n.i18n.translate('common.ui.courier.savedObject.confirmModal.overwriteButtonLabel', {\n              defaultMessage: 'Overwrite'\n            }),\n            title: _i18n.i18n.translate('common.ui.courier.savedObject.confirmModal.overwriteTitle', {\n              defaultMessage: 'Overwrite {name}?',\n              values: { name: _this.getDisplayName() }\n            })\n          }).then(function () {\n            return savedObjectsClient.create(esType, source, _this.creationOpts({ overwrite: true }));\n          }).catch(function () {\n            return Promise.reject(new Error(OVERWRITE_REJECTED));\n          });\n        }\n        return Promise.reject(err);\n      });\n    };\n\n    var displayDuplicateTitleConfirmModal = function displayDuplicateTitleConfirmModal() {\n      var confirmMessage = _i18n.i18n.translate('common.ui.courier.savedObject.confirmModal.saveDuplicateConfirmationMessage', {\n        defaultMessage: 'A {name} with the title \\'{title}\\' already exists. Would you like to save anyway?',\n        values: { title: _this.title, name: _this.getDisplayName() }\n      });\n\n      return confirmModalPromise(confirmMessage, {\n        confirmButtonText: _i18n.i18n.translate('common.ui.courier.savedObject.confirmModal.saveDuplicateButtonLabel', {\n          defaultMessage: 'Save {name}',\n          values: { name: _this.getDisplayName() }\n        })\n      }).catch(function () {\n        return Promise.reject(new Error(SAVE_DUPLICATE_REJECTED));\n      });\n    };\n\n    var checkForDuplicateTitle = function checkForDuplicateTitle(isTitleDuplicateConfirmed, onTitleDuplicate) {\n      // Don't check for duplicates if user has already confirmed save with duplicate title\n      if (isTitleDuplicateConfirmed) {\n        return Promise.resolve();\n      }\n\n      // Don't check if the user isn't updating the title, otherwise that would become very annoying to have\n      // to confirm the save every time, except when copyOnSave is true, then we do want to check.\n      if (_this.title === _this.lastSavedTitle && !_this.copyOnSave) {\n        return Promise.resolve();\n      }\n\n      return (0, _saved_objects.findObjectByTitle)(savedObjectsClient, _this.getEsType(), _this.title).then(function (duplicate) {\n        if (!duplicate) return true;\n        if (duplicate.id === _this.id) return true;\n\n        if (onTitleDuplicate) {\n          onTitleDuplicate();\n          return Promise.reject(new Error(SAVE_DUPLICATE_REJECTED));\n        }\n\n        // TODO: make onTitleDuplicate a required prop and remove UI components from this class\n        // Need to leave here until all users pass onTitleDuplicate.\n        return displayDuplicateTitleConfirmModal();\n      });\n    };\n\n    /**\n     * Saves this object.\n     *\n     * @param {object} [options={}]\n     * @property {boolean} [options.confirmOverwrite=false] - If true, attempts to create the source so it\n     * can confirm an overwrite if a document with the id already exists.\n     * @property {boolean} [options.isTitleDuplicateConfirmed=false] - If true, save allowed with duplicate title\n     * @property {func} [options.onTitleDuplicate] - function called if duplicate title exists.\n     * When not provided, confirm modal will be displayed asking user to confirm or cancel save.\n     * @return {Promise}\n     * @resolved {String} - The id of the doc\n     */\n    this.save = function () {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$confirmOverwrite = _ref.confirmOverwrite,\n          confirmOverwrite = _ref$confirmOverwrite === undefined ? false : _ref$confirmOverwrite,\n          _ref$isTitleDuplicate = _ref.isTitleDuplicateConfirmed,\n          isTitleDuplicateConfirmed = _ref$isTitleDuplicate === undefined ? false : _ref$isTitleDuplicate,\n          onTitleDuplicate = _ref.onTitleDuplicate;\n\n      // Save the original id in case the save fails.\n      var originalId = _this.id;\n      // Read https://github.com/elastic/kibana/issues/9056 and\n      // https://github.com/elastic/kibana/issues/9012 for some background into why this copyOnSave variable\n      // exists.\n      // The goal is to move towards a better rename flow, but since our users have been conditioned\n      // to expect a 'save as' flow during a rename, we are keeping the logic the same until a better\n      // UI/UX can be worked out.\n      if (_this.copyOnSave) {\n        _this.id = null;\n      }\n\n      var source = _this.serialize();\n\n      _this.isSaving = true;\n\n      return checkForDuplicateTitle(isTitleDuplicateConfirmed, onTitleDuplicate).then(function () {\n        if (confirmOverwrite) {\n          return createSource(source);\n        } else {\n          return savedObjectsClient.create(esType, source, _this.creationOpts({ overwrite: true }));\n        }\n      }).then(function (resp) {\n        _this.id = resp.id;\n      }).then(function () {\n        if (_this.showInRecentlyAccessed && _this.getFullPath) {\n          _persisted_log.recentlyAccessed.add(_this.getFullPath(), _this.title, _this.id);\n        }\n        _this.isSaving = false;\n        _this.lastSavedTitle = _this.title;\n        return _this.id;\n      }).catch(function (err) {\n        _this.isSaving = false;\n        _this.id = originalId;\n        if (isErrorNonFatal(err)) {\n          return;\n        }\n        return Promise.reject(err);\n      });\n    };\n\n    this.destroy = function () {\n      if (_this.searchSource) {\n        _this.searchSource.cancelQueued();\n      }\n    };\n\n    /**\n     * Delete this object from Elasticsearch\n     * @return {promise}\n     */\n    this.delete = function () {\n      return savedObjectsClient.delete(esType, _this.id);\n    };\n  }\n\n  return SavedObject;\n}",null]}