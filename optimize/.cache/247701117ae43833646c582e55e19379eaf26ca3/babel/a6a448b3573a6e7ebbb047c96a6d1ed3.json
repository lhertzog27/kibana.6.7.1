{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/kibana/public/management/sections/objects/lib/resolve_saved_objects.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/kibana/public/management/sections/objects/lib/resolve_saved_objects.js","mtime":1567631711590},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSavedObjects = exports.resolveSavedSearches = exports.saveObject = exports.saveObjects = exports.resolveIndexPatternConflicts = undefined;\n\nvar getSavedObject = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(doc, services) {\n    var service, obj;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            service = services.find(function (service) {\n              return service.type === doc._type;\n            });\n\n            if (service) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt('return');\n\n          case 3:\n            _context.next = 5;\n            return service.get();\n\n          case 5:\n            obj = _context.sent;\n\n            obj.id = doc._id;\n            obj.migrationVersion = doc._migrationVersion;\n            return _context.abrupt('return', obj);\n\n          case 9:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function getSavedObject(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar importIndexPattern = function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(doc, indexPatterns, overwriteAll) {\n    var emptyPattern, _doc$_source, title, timeFieldName, fields, fieldFormatMap, sourceFilters, type, typeMeta, importedIndexPattern, newId;\n\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return indexPatterns.get();\n\n          case 2:\n            emptyPattern = _context2.sent;\n            _doc$_source = doc._source, title = _doc$_source.title, timeFieldName = _doc$_source.timeFieldName, fields = _doc$_source.fields, fieldFormatMap = _doc$_source.fieldFormatMap, sourceFilters = _doc$_source.sourceFilters, type = _doc$_source.type, typeMeta = _doc$_source.typeMeta;\n            importedIndexPattern = {\n              id: doc._id,\n              title: title,\n              timeFieldName: timeFieldName\n            };\n\n            if (type) {\n              importedIndexPattern.type = type;\n            }\n            addJsonFieldToIndexPattern(importedIndexPattern, fields, 'fields', title);\n            addJsonFieldToIndexPattern(importedIndexPattern, fieldFormatMap, 'fieldFormatMap', title);\n            addJsonFieldToIndexPattern(importedIndexPattern, sourceFilters, 'sourceFilters', title);\n            addJsonFieldToIndexPattern(importedIndexPattern, typeMeta, 'typeMeta', title);\n            Object.assign(emptyPattern, importedIndexPattern);\n\n            _context2.next = 13;\n            return emptyPattern.create(true, !overwriteAll);\n\n          case 13:\n            newId = _context2.sent;\n\n            indexPatterns.cache.clear(newId);\n            return _context2.abrupt('return', newId);\n\n          case 16:\n          case 'end':\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n\n  return function importIndexPattern(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar importDocument = function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(obj, doc, overwriteAll) {\n    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return obj.applyESResp(doc);\n\n          case 2:\n            _context3.next = 4;\n            return obj.save({ confirmOverwrite: !overwriteAll });\n\n          case 4:\n            return _context3.abrupt('return', _context3.sent);\n\n          case 5:\n          case 'end':\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this);\n  }));\n\n  return function importDocument(_x6, _x7, _x8) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar awaitEachItemInParallel = function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(list, op) {\n    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return Promise.all(list.map(function (item) {\n              return op(item);\n            }));\n\n          case 2:\n            return _context4.abrupt('return', _context4.sent);\n\n          case 3:\n          case 'end':\n            return _context4.stop();\n        }\n      }\n    }, _callee4, this);\n  }));\n\n  return function awaitEachItemInParallel(_x9, _x10) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar resolveIndexPatternConflicts = exports.resolveIndexPatternConflicts = function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(resolutions, conflictedIndexPatterns, overwriteAll) {\n    var _this = this;\n\n    var importCount;\n    return regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            importCount = 0;\n            _context6.next = 3;\n            return awaitEachItemInParallel(conflictedIndexPatterns, function () {\n              var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref6) {\n                var obj = _ref6.obj;\n                var oldIndexId, resolution, newIndexId;\n                return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                  while (1) {\n                    switch (_context5.prev = _context5.next) {\n                      case 0:\n                        oldIndexId = obj.searchSource.getOwnField('index');\n                        // Depending on the object, this can either be the raw id or the actual index pattern object\n\n                        if (typeof oldIndexId !== 'string') {\n                          oldIndexId = oldIndexId.id;\n                        }\n                        resolution = resolutions.find(function (_ref8) {\n                          var oldId = _ref8.oldId;\n                          return oldId === oldIndexId;\n                        });\n\n                        if (resolution) {\n                          _context5.next = 5;\n                          break;\n                        }\n\n                        return _context5.abrupt('return');\n\n                      case 5:\n                        newIndexId = resolution.newId;\n                        _context5.next = 8;\n                        return obj.hydrateIndexPattern(newIndexId);\n\n                      case 8:\n                        _context5.next = 10;\n                        return saveObject(obj, overwriteAll);\n\n                      case 10:\n                        if (!_context5.sent) {\n                          _context5.next = 12;\n                          break;\n                        }\n\n                        importCount++;\n\n                      case 12:\n                      case 'end':\n                        return _context5.stop();\n                    }\n                  }\n                }, _callee5, _this);\n              }));\n\n              return function (_x14) {\n                return _ref7.apply(this, arguments);\n              };\n            }());\n\n          case 3:\n            return _context6.abrupt('return', importCount);\n\n          case 4:\n          case 'end':\n            return _context6.stop();\n        }\n      }\n    }, _callee6, this);\n  }));\n\n  return function resolveIndexPatternConflicts(_x11, _x12, _x13) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar saveObjects = exports.saveObjects = function () {\n  var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(objs, overwriteAll) {\n    var _this2 = this;\n\n    var importCount;\n    return regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            importCount = 0;\n            _context8.next = 3;\n            return awaitEachItemInParallel(objs, function () {\n              var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(obj) {\n                return regeneratorRuntime.wrap(function _callee7$(_context7) {\n                  while (1) {\n                    switch (_context7.prev = _context7.next) {\n                      case 0:\n                        _context7.next = 2;\n                        return saveObject(obj, overwriteAll);\n\n                      case 2:\n                        if (!_context7.sent) {\n                          _context7.next = 4;\n                          break;\n                        }\n\n                        importCount++;\n\n                      case 4:\n                      case 'end':\n                        return _context7.stop();\n                    }\n                  }\n                }, _callee7, _this2);\n              }));\n\n              return function (_x17) {\n                return _ref10.apply(this, arguments);\n              };\n            }());\n\n          case 3:\n            return _context8.abrupt('return', importCount);\n\n          case 4:\n          case 'end':\n            return _context8.stop();\n        }\n      }\n    }, _callee8, this);\n  }));\n\n  return function saveObjects(_x15, _x16) {\n    return _ref9.apply(this, arguments);\n  };\n}();\n\nvar saveObject = exports.saveObject = function () {\n  var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(obj, overwriteAll) {\n    return regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.next = 2;\n            return obj.save({ confirmOverwrite: !overwriteAll });\n\n          case 2:\n            return _context9.abrupt('return', _context9.sent);\n\n          case 3:\n          case 'end':\n            return _context9.stop();\n        }\n      }\n    }, _callee9, this);\n  }));\n\n  return function saveObject(_x18, _x19) {\n    return _ref11.apply(this, arguments);\n  };\n}();\n\nvar resolveSavedSearches = exports.resolveSavedSearches = function () {\n  var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(savedSearches, services, indexPatterns, overwriteAll) {\n    var _this3 = this;\n\n    var importCount;\n    return regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            importCount = 0;\n            _context11.next = 3;\n            return awaitEachItemInParallel(savedSearches, function () {\n              var _ref13 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(searchDoc) {\n                var obj;\n                return regeneratorRuntime.wrap(function _callee10$(_context10) {\n                  while (1) {\n                    switch (_context10.prev = _context10.next) {\n                      case 0:\n                        _context10.next = 2;\n                        return getSavedObject(searchDoc, services);\n\n                      case 2:\n                        obj = _context10.sent;\n\n                        if (obj) {\n                          _context10.next = 5;\n                          break;\n                        }\n\n                        return _context10.abrupt('return');\n\n                      case 5:\n                        _context10.next = 7;\n                        return importDocument(obj, searchDoc, overwriteAll);\n\n                      case 7:\n                        if (!_context10.sent) {\n                          _context10.next = 9;\n                          break;\n                        }\n\n                        importCount++;\n\n                      case 9:\n                      case 'end':\n                        return _context10.stop();\n                    }\n                  }\n                }, _callee10, _this3);\n              }));\n\n              return function (_x24) {\n                return _ref13.apply(this, arguments);\n              };\n            }());\n\n          case 3:\n            return _context11.abrupt('return', importCount);\n\n          case 4:\n          case 'end':\n            return _context11.stop();\n        }\n      }\n    }, _callee11, this);\n  }));\n\n  return function resolveSavedSearches(_x20, _x21, _x22, _x23) {\n    return _ref12.apply(this, arguments);\n  };\n}();\n\nvar resolveSavedObjects = exports.resolveSavedObjects = function () {\n  var _ref14 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(savedObjects, overwriteAll, services, indexPatterns) {\n    var _this4 = this;\n\n    var docTypes, importedObjectCount, failedImports, conflictedSearchDocs, conflictedIndexPatterns, conflictedSavedObjectsLinkedToSavedSearches;\n    return regeneratorRuntime.wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            docTypes = groupByType(savedObjects);\n\n            // Keep track of how many we actually import because the user\n            // can cancel an override\n\n            importedObjectCount = 0;\n            // Keep a record of any objects which fail to import for unknown reasons.\n\n            failedImports = [];\n            // Start with the index patterns since everything is dependent on them\n\n            _context15.next = 5;\n            return awaitEachItemInParallel(docTypes.indexPatterns, function () {\n              var _ref15 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(indexPatternDoc) {\n                var importedIndexPatternId;\n                return regeneratorRuntime.wrap(function _callee12$(_context12) {\n                  while (1) {\n                    switch (_context12.prev = _context12.next) {\n                      case 0:\n                        _context12.prev = 0;\n                        _context12.next = 3;\n                        return importIndexPattern(indexPatternDoc, indexPatterns, overwriteAll);\n\n                      case 3:\n                        importedIndexPatternId = _context12.sent;\n\n                        if (importedIndexPatternId) {\n                          importedObjectCount++;\n                        }\n                        _context12.next = 10;\n                        break;\n\n                      case 7:\n                        _context12.prev = 7;\n                        _context12.t0 = _context12['catch'](0);\n\n                        failedImports.push({ indexPatternDoc: indexPatternDoc, error: _context12.t0 });\n\n                      case 10:\n                      case 'end':\n                        return _context12.stop();\n                    }\n                  }\n                }, _callee12, _this4, [[0, 7]]);\n              }));\n\n              return function (_x29) {\n                return _ref15.apply(this, arguments);\n              };\n            }());\n\n          case 5:\n\n            // We want to do the same for saved searches, but we want to keep them separate because they need\n            // to be applied _first_ because other saved objects can be dependent on those saved searches existing\n            conflictedSearchDocs = [];\n            // Keep a record of the index patterns assigned to our imported saved objects that do not\n            // exist. We will provide a way for the user to manually select a new index pattern for those\n            // saved objects.\n\n            conflictedIndexPatterns = [];\n            // It's possible to have saved objects that link to saved searches which then link to index patterns\n            // and those could error out, but the error comes as an index pattern not found error. We can't resolve\n            // those the same as way as normal index pattern not found errors, but when those are fixed, it's very\n            // likely that these saved objects will work once resaved so keep them around to resave them.\n\n            conflictedSavedObjectsLinkedToSavedSearches = [];\n            _context15.next = 10;\n            return awaitEachItemInParallel(docTypes.searches, function () {\n              var _ref16 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(searchDoc) {\n                var obj;\n                return regeneratorRuntime.wrap(function _callee13$(_context13) {\n                  while (1) {\n                    switch (_context13.prev = _context13.next) {\n                      case 0:\n                        _context13.next = 2;\n                        return getSavedObject(searchDoc, services);\n\n                      case 2:\n                        obj = _context13.sent;\n                        _context13.prev = 3;\n                        _context13.next = 6;\n                        return importDocument(obj, searchDoc, overwriteAll);\n\n                      case 6:\n                        if (!_context13.sent) {\n                          _context13.next = 8;\n                          break;\n                        }\n\n                        importedObjectCount++;\n\n                      case 8:\n                        _context13.next = 13;\n                        break;\n\n                      case 10:\n                        _context13.prev = 10;\n                        _context13.t0 = _context13['catch'](3);\n\n                        if (_context13.t0 instanceof _errors.SavedObjectNotFound) {\n                          if (_context13.t0.savedObjectType === 'index-pattern') {\n                            conflictedIndexPatterns.push({ obj: obj, doc: searchDoc });\n                          } else {\n                            conflictedSearchDocs.push(searchDoc);\n                          }\n                        } else {\n                          failedImports.push({ obj: obj, error: _context13.t0 });\n                        }\n\n                      case 13:\n                      case 'end':\n                        return _context13.stop();\n                    }\n                  }\n                }, _callee13, _this4, [[3, 10]]);\n              }));\n\n              return function (_x30) {\n                return _ref16.apply(this, arguments);\n              };\n            }());\n\n          case 10:\n            _context15.next = 12;\n            return awaitEachItemInParallel(docTypes.other, function () {\n              var _ref17 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(otherDoc) {\n                var obj;\n                return regeneratorRuntime.wrap(function _callee14$(_context14) {\n                  while (1) {\n                    switch (_context14.prev = _context14.next) {\n                      case 0:\n                        _context14.next = 2;\n                        return getSavedObject(otherDoc, services);\n\n                      case 2:\n                        obj = _context14.sent;\n                        _context14.prev = 3;\n                        _context14.next = 6;\n                        return importDocument(obj, otherDoc, overwriteAll);\n\n                      case 6:\n                        if (!_context14.sent) {\n                          _context14.next = 8;\n                          break;\n                        }\n\n                        importedObjectCount++;\n\n                      case 8:\n                        _context14.next = 13;\n                        break;\n\n                      case 10:\n                        _context14.prev = 10;\n                        _context14.t0 = _context14['catch'](3);\n\n                        if (_context14.t0 instanceof _errors.SavedObjectNotFound) {\n                          if (_context14.t0.savedObjectType === 'search') {\n                            failedImports.push({ obj: obj, error: _context14.t0 });\n                          }\n\n                          if (_context14.t0.savedObjectType === 'index-pattern') {\n                            if (obj.savedSearchId) {\n                              conflictedSavedObjectsLinkedToSavedSearches.push(obj);\n                            } else {\n                              conflictedIndexPatterns.push({ obj: obj, doc: otherDoc });\n                            }\n                          }\n                        } else {\n                          failedImports.push({ obj: obj, error: _context14.t0 });\n                        }\n\n                      case 13:\n                      case 'end':\n                        return _context14.stop();\n                    }\n                  }\n                }, _callee14, _this4, [[3, 10]]);\n              }));\n\n              return function (_x31) {\n                return _ref17.apply(this, arguments);\n              };\n            }());\n\n          case 12:\n            return _context15.abrupt('return', {\n              conflictedIndexPatterns: conflictedIndexPatterns,\n              conflictedSavedObjectsLinkedToSavedSearches: conflictedSavedObjectsLinkedToSavedSearches,\n              conflictedSearchDocs: conflictedSearchDocs,\n              importedObjectCount: importedObjectCount,\n              failedImports: failedImports\n            });\n\n          case 13:\n          case 'end':\n            return _context15.stop();\n        }\n      }\n    }, _callee15, this);\n  }));\n\n  return function resolveSavedObjects(_x25, _x26, _x27, _x28) {\n    return _ref14.apply(this, arguments);\n  };\n}();\n\nvar _errors = require('ui/errors');\n\nvar _i18n = require('@kbn/i18n');\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Licensed to Elasticsearch B.V. under one or more contributor\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * license agreements. See the NOTICE file distributed with\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * this work for additional information regarding copyright\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * ownership. Elasticsearch B.V. licenses this file to you under\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * the Apache License, Version 2.0 (the \"License\"); you may\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *    http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Unless required by applicable law or agreed to in writing,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * software distributed under the License is distributed on an\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * KIND, either express or implied.  See the License for the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * specific language governing permissions and limitations\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * under the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */\n\nfunction addJsonFieldToIndexPattern(target, sourceString, fieldName, indexName) {\n  if (sourceString) {\n    try {\n      target[fieldName] = JSON.parse(sourceString);\n    } catch (error) {\n      throw new Error(_i18n.i18n.translate('kbn.management.objects.parsingFieldErrorMessage', {\n        defaultMessage: 'Error encountered parsing {fieldName} for index pattern {indexName}: {errorMessage}',\n        values: {\n          fieldName: fieldName,\n          indexName: indexName,\n          errorMessage: error.message\n        }\n      }));\n    }\n  }\n}\n\n\nfunction groupByType(docs) {\n  var defaultDocTypes = {\n    searches: [],\n    indexPatterns: [],\n    other: []\n  };\n\n  return docs.reduce(function (types, doc) {\n    switch (doc._type) {\n      case 'search':\n        types.searches.push(doc);\n        break;\n      case 'index-pattern':\n        types.indexPatterns.push(doc);\n        break;\n      default:\n        types.other.push(doc);\n    }\n    return types;\n  }, defaultDocTypes);\n}",null]}