{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/vis/map/convert_to_geojson.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/vis/map/convert_to_geojson.js","mtime":1567631711772},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertToGeoJson = convertToGeoJson;\n\nvar _decode_geo_hash = require('ui/utils/decode_geo_hash');\n\nvar _grid_dimensions = require('./grid_dimensions');\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nfunction convertToGeoJson(tabifiedResponse) {\n\n  var features = void 0;\n  var min = Infinity;\n  var max = -Infinity;\n  var geoAgg = void 0;\n\n  if (tabifiedResponse && tabifiedResponse.rows) {\n\n    var table = tabifiedResponse;\n    var geohashColumn = table.columns.find(function (column) {\n      return column.aggConfig.type.dslName === 'geohash_grid';\n    });\n\n    if (!geohashColumn) {\n      features = [];\n    } else {\n\n      geoAgg = geohashColumn.aggConfig;\n\n      var metricColumn = table.columns.find(function (column) {\n        return column.aggConfig.type.type === 'metrics';\n      });\n      var geocentroidColumn = table.columns.find(function (column) {\n        return column.aggConfig.type.dslName === 'geo_centroid';\n      });\n\n      features = table.rows.map(function (row) {\n\n        var geohash = row[geohashColumn.id];\n        if (!geohash) return false;\n        var geohashLocation = (0, _decode_geo_hash.decodeGeoHash)(geohash);\n\n        var pointCoordinates = void 0;\n        if (geocentroidColumn) {\n          var location = row[geocentroidColumn.id];\n          pointCoordinates = [location.lon, location.lat];\n        } else {\n          pointCoordinates = [geohashLocation.longitude[2], geohashLocation.latitude[2]];\n        }\n\n        var rectangle = [[geohashLocation.latitude[0], geohashLocation.longitude[0]], [geohashLocation.latitude[0], geohashLocation.longitude[1]], [geohashLocation.latitude[1], geohashLocation.longitude[1]], [geohashLocation.latitude[1], geohashLocation.longitude[0]]];\n\n        var centerLatLng = [geohashLocation.latitude[2], geohashLocation.longitude[2]];\n\n        if (geoAgg.params.useGeocentroid) {\n          // see https://github.com/elastic/elasticsearch/issues/24694 for why clampGrid is used\n          pointCoordinates[0] = clampGrid(pointCoordinates[0], geohashLocation.longitude[0], geohashLocation.longitude[1]);\n          pointCoordinates[1] = clampGrid(pointCoordinates[1], geohashLocation.latitude[0], geohashLocation.latitude[1]);\n        }\n\n        var value = row[metricColumn.id];\n        min = Math.min(min, value);\n        max = Math.max(max, value);\n\n        return {\n          type: 'Feature',\n          geometry: {\n            type: 'Point',\n            coordinates: pointCoordinates\n          },\n          properties: {\n            geohash: geohash,\n            geohash_meta: {\n              center: centerLatLng,\n              rectangle: rectangle\n            },\n            value: value\n          }\n        };\n      }).filter(function (row) {\n        return row;\n      });\n    }\n  } else {\n    features = [];\n  }\n\n  var featureCollection = {\n    type: 'FeatureCollection',\n    features: features\n  };\n\n  return {\n    featureCollection: featureCollection,\n    meta: {\n      min: min,\n      max: max,\n      geohashPrecision: geoAgg && geoAgg.params.precision,\n      geohashGridDimensionsAtEquator: geoAgg && (0, _grid_dimensions.gridDimensions)(geoAgg.params.precision)\n    }\n  };\n}\n\nfunction clampGrid(val, min, max) {\n  if (val > max) val = max;else if (val < min) val = min;\n  return val;\n}",null]}