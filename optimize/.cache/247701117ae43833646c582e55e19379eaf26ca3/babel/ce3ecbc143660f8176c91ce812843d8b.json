{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/kibana/public/dashboard/dashboard_app.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/kibana/public/dashboard/dashboard_app.js","mtime":1567631711542},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _modules = require('ui/modules');\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _i18n = require('ui/i18n');\n\nvar _theme = require('ui/theme');\n\nvar _notify = require('ui/notify');\n\nrequire('ui/query_bar');\n\nvar _panel_actions_store = require('./store/panel_actions_store');\n\nvar _dashboard_strings = require('./dashboard_strings');\n\nvar _dashboard_view_mode = require('./dashboard_view_mode');\n\nvar _top_nav_ids = require('./top_nav/top_nav_ids');\n\nvar _confirm_modal = require('ui/modals/confirm_modal');\n\nvar _query_filter = require('ui/filter_bar/query_filter');\n\nvar _doc_title = require('ui/doc_title');\n\nvar _get_top_nav_config = require('./top_nav/get_top_nav_config');\n\nvar _dashboard_constants = require('./dashboard_constants');\n\nvar _dashboard_state_manager = require('./dashboard_state_manager');\n\nvar _lib = require('./lib');\n\nvar _show_clone_modal = require('./top_nav/show_clone_modal');\n\nvar _show_saved_object_save_modal = require('ui/saved_objects/show_saved_object_save_modal');\n\nvar _save_modal = require('./top_nav/save_modal');\n\nvar _show_add_panel = require('./top_nav/show_add_panel');\n\nvar _show_options_popover = require('./top_nav/show_options_popover');\n\nvar _wizard = require('../visualize/wizard');\n\nvar _share = require('ui/share');\n\nvar _migrate_legacy_query = require('ui/utils/migrate_legacy_query');\n\nvar _filter = require('ui/doc_table/actions/filter');\n\nvar filterActions = _interopRequireWildcard(_filter);\n\nvar _filter_manager = require('ui/filter_manager');\n\nvar _embeddable_factories_registry = require('ui/embeddable/embeddable_factories_registry');\n\nvar _embeddable = require('ui/embeddable');\n\nvar _vis_types = require('ui/registry/vis_types');\n\nvar _timefilter = require('ui/timefilter');\n\nvar _state_hashing = require('ui/state_management/state_hashing');\n\nvar _documentation_links = require('ui/documentation_links');\n\nvar _dashboard_viewport_provider = require('./viewport/dashboard_viewport_provider');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar app = _modules.uiModules.get('app/dashboard', ['elasticsearch', 'ngRoute', 'react', 'kibana/courier', 'kibana/config']); /*\n                                                                                                                              * Licensed to Elasticsearch B.V. under one or more contributor\n                                                                                                                              * license agreements. See the NOTICE file distributed with\n                                                                                                                              * this work for additional information regarding copyright\n                                                                                                                              * ownership. Elasticsearch B.V. licenses this file to you under\n                                                                                                                              * the Apache License, Version 2.0 (the \"License\"); you may\n                                                                                                                              * not use this file except in compliance with the License.\n                                                                                                                              * You may obtain a copy of the License at\n                                                                                                                              *\n                                                                                                                              *    http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                              *\n                                                                                                                              * Unless required by applicable law or agreed to in writing,\n                                                                                                                              * software distributed under the License is distributed on an\n                                                                                                                              * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                                                                                                                              * KIND, either express or implied.  See the License for the\n                                                                                                                              * specific language governing permissions and limitations\n                                                                                                                              * under the License.\n                                                                                                                              */\n\napp.directive('dashboardViewportProvider', function (reactDirective) {\n  return reactDirective((0, _i18n.wrapInI18nContext)(_dashboard_viewport_provider.DashboardViewportProvider));\n});\n\napp.directive('dashboardApp', function ($injector) {\n  var courier = $injector.get('courier');\n  var AppState = $injector.get('AppState');\n  var kbnUrl = $injector.get('kbnUrl');\n  var confirmModal = $injector.get('confirmModal');\n  var config = $injector.get('config');\n  var Private = $injector.get('Private');\n\n  return {\n    restrict: 'E',\n    controllerAs: 'dashboardApp',\n    controller: function controller($scope, $rootScope, $route, $routeParams, $window, getAppState, dashboardConfig, localStorage, i18n) {\n      var _this = this;\n\n      var filterManager = Private(_filter_manager.FilterManagerProvider);\n      var filterBar = Private(_query_filter.FilterBarQueryFilterProvider);\n      var docTitle = Private(_doc_title.DocTitleProvider);\n      var embeddableFactories = Private(_embeddable_factories_registry.EmbeddableFactoriesRegistryProvider);\n      var panelActionsRegistry = Private(_embeddable.ContextMenuActionsRegistryProvider);\n      var getUnhashableStates = Private(_state_hashing.getUnhashableStatesProvider);\n      var shareContextMenuExtensions = Private(_share.ShareContextMenuExtensionsRegistryProvider);\n\n      _panel_actions_store.panelActionsStore.initializeFromRegistry(panelActionsRegistry);\n\n      var visTypes = Private(_vis_types.VisTypesRegistryProvider);\n      $scope.getEmbeddableFactory = function (panelType) {\n        return embeddableFactories.byName[panelType];\n      };\n\n      var dash = $scope.dash = $route.current.locals.dash;\n      if (dash.id) {\n        docTitle.change(dash.title);\n      }\n\n      var dashboardStateManager = new _dashboard_state_manager.DashboardStateManager({\n        savedDashboard: dash,\n        AppState: AppState,\n        hideWriteControls: dashboardConfig.getHideWriteControls(),\n        addFilter: function addFilter(_ref) {\n          var field = _ref.field,\n              value = _ref.value,\n              operator = _ref.operator,\n              index = _ref.index;\n\n          filterActions.addFilter(field, value, operator, index, dashboardStateManager.getAppState(), filterManager);\n        }\n      });\n\n      $scope.getDashboardState = function () {\n        return dashboardStateManager;\n      };\n      $scope.appState = dashboardStateManager.getAppState();\n\n      // The 'previouslyStored' check is so we only update the time filter on dashboard open, not during\n      // normal cross app navigation.\n      if (dashboardStateManager.getIsTimeSavedWithDashboard() && !getAppState.previouslyStored()) {\n        dashboardStateManager.syncTimefilterWithDashboard(_timefilter.timefilter, config.get('timepicker:quickRanges'));\n      }\n\n      var updateState = function updateState() {\n        // Following the \"best practice\" of always have a '.' in your ng-models â€“\n        // https://github.com/angular/angular.js/wiki/Understanding-Scopes\n        $scope.model = {\n          query: dashboardStateManager.getQuery(),\n          timeRestore: dashboardStateManager.getTimeRestore(),\n          title: dashboardStateManager.getTitle(),\n          description: dashboardStateManager.getDescription()\n        };\n        $scope.panels = dashboardStateManager.getPanels();\n        $scope.indexPatterns = dashboardStateManager.getPanelIndexPatterns();\n      };\n\n      // Part of the exposed plugin API - do not remove without careful consideration.\n      this.appStatus = {\n        dirty: !dash.id\n      };\n\n      dashboardStateManager.registerChangeListener(function (status) {\n        _this.appStatus.dirty = status.dirty || !dash.id;\n        updateState();\n      });\n\n      dashboardStateManager.applyFilters(dashboardStateManager.getQuery() || {\n        query: '',\n        language: localStorage.get('kibana.userQueryLanguage') || config.get('search:queryLanguage')\n      }, filterBar.getFilters());\n\n      _timefilter.timefilter.enableAutoRefreshSelector();\n      _timefilter.timefilter.enableTimeRangeSelector();\n\n      updateState();\n\n      $scope.refresh = function () {\n        $rootScope.$broadcast('fetch');\n        courier.fetch();\n      };\n      dashboardStateManager.handleTimeChange(_timefilter.timefilter.getTime());\n\n      $scope.expandedPanel = null;\n      $scope.dashboardViewMode = dashboardStateManager.getViewMode();\n\n      $scope.landingPageUrl = function () {\n        return '#' + _dashboard_constants.DashboardConstants.LANDING_PAGE_PATH;\n      };\n      $scope.hasExpandedPanel = function () {\n        return $scope.expandedPanel !== null;\n      };\n      $scope.getDashTitle = function () {\n        return (0, _dashboard_strings.getDashboardTitle)(dashboardStateManager.getTitle(), dashboardStateManager.getViewMode(), dashboardStateManager.getIsDirty(_timefilter.timefilter));\n      };\n\n      // Push breadcrumbs to new header navigation\n      var updateBreadcrumbs = function updateBreadcrumbs() {\n        _chrome2.default.breadcrumbs.set([{\n          text: i18n('kbn.dashboard.dashboardAppBreadcrumbsTitle', {\n            defaultMessage: 'Dashboard'\n          }),\n          href: $scope.landingPageUrl()\n        }, { text: $scope.getDashTitle() }]);\n      };\n      updateBreadcrumbs();\n      dashboardStateManager.registerChangeListener(updateBreadcrumbs);\n      config.watch('k7design', function (val) {\n        return $scope.showPluginBreadcrumbs = !val;\n      });\n\n      $scope.newDashboard = function () {\n        kbnUrl.change(_dashboard_constants.DashboardConstants.CREATE_NEW_DASHBOARD_URL, {});\n      };\n      $scope.saveState = function () {\n        return dashboardStateManager.saveState();\n      };\n      $scope.getShouldShowEditHelp = function () {\n        return !dashboardStateManager.getPanels().length && dashboardStateManager.getIsEditMode() && !dashboardConfig.getHideWriteControls();\n      };\n      $scope.getShouldShowViewHelp = function () {\n        return !dashboardStateManager.getPanels().length && dashboardStateManager.getIsViewMode() && !dashboardConfig.getHideWriteControls();\n      };\n\n      $scope.minimizeExpandedPanel = function () {\n        $scope.expandedPanel = null;\n      };\n\n      $scope.expandPanel = function (panelIndex) {\n        $scope.expandedPanel = dashboardStateManager.getPanels().find(function (panel) {\n          return panel.panelIndex === panelIndex;\n        });\n      };\n\n      $scope.updateQueryAndFetch = function (_ref2) {\n        var query = _ref2.query;\n\n        var oldQuery = $scope.model.query;\n        if (_lodash2.default.isEqual(oldQuery, query)) {\n          // The user can still request a reload in the query bar, even if the\n          // query is the same, and in that case, we have to explicitly ask for\n          // a reload, since no state changes will cause it.\n          dashboardStateManager.requestReload();\n        } else {\n          $scope.model.query = query;\n          dashboardStateManager.applyFilters($scope.model.query, filterBar.getFilters());\n        }\n        $scope.refresh();\n      };\n\n      updateTheme();\n\n      $scope.indexPatterns = [];\n\n      $scope.onPanelRemoved = function (panelIndex) {\n        dashboardStateManager.removePanel(panelIndex);\n        $scope.indexPatterns = dashboardStateManager.getPanelIndexPatterns();\n      };\n\n      $scope.$watch('model.query', function (newQuery) {\n        var query = (0, _migrate_legacy_query.migrateLegacyQuery)(newQuery);\n        $scope.updateQueryAndFetch({ query: query });\n      });\n\n      $scope.$listenAndDigestAsync(_timefilter.timefilter, 'fetch', function () {\n        dashboardStateManager.handleTimeChange(_timefilter.timefilter.getTime());\n        // Currently discover relies on this logic to re-fetch. We need to refactor it to rely instead on the\n        // directly passed down time filter. Then we can get rid of this reliance on scope broadcasts.\n        $scope.refresh();\n      });\n\n      function updateViewMode(newMode) {\n        $scope.topNavMenu = (0, _get_top_nav_config.getTopNavConfig)(newMode, navActions, dashboardConfig.getHideWriteControls()); // eslint-disable-line no-use-before-define\n        dashboardStateManager.switchViewMode(newMode);\n        $scope.dashboardViewMode = newMode;\n      }\n\n      var onChangeViewMode = function onChangeViewMode(newMode) {\n        var isPageRefresh = newMode === dashboardStateManager.getViewMode();\n        var isLeavingEditMode = !isPageRefresh && newMode === _dashboard_view_mode.DashboardViewMode.VIEW;\n        var willLoseChanges = isLeavingEditMode && dashboardStateManager.getIsDirty(_timefilter.timefilter);\n\n        if (!willLoseChanges) {\n          updateViewMode(newMode);\n          return;\n        }\n\n        function revertChangesAndExitEditMode() {\n          dashboardStateManager.resetState();\n          kbnUrl.change(dash.id ? (0, _dashboard_constants.createDashboardEditUrl)(dash.id) : _dashboard_constants.DashboardConstants.CREATE_NEW_DASHBOARD_URL);\n          // This is only necessary for new dashboards, which will default to Edit mode.\n          updateViewMode(_dashboard_view_mode.DashboardViewMode.VIEW);\n\n          // We need to do a hard reset of the timepicker. appState will not reload like\n          // it does on 'open' because it's been saved to the url and the getAppState.previouslyStored() check on\n          // reload will cause it not to sync.\n          if (dashboardStateManager.getIsTimeSavedWithDashboard()) {\n            dashboardStateManager.syncTimefilterWithDashboard(_timefilter.timefilter, config.get('timepicker:quickRanges'));\n          }\n        }\n\n        confirmModal(i18n('kbn.dashboard.changeViewModeConfirmModal.discardChangesDescription', { defaultMessage: 'Once you discard your changes, there\\'s no getting them back.' }), {\n          onConfirm: revertChangesAndExitEditMode,\n          onCancel: _lodash2.default.noop,\n          confirmButtonText: i18n('kbn.dashboard.changeViewModeConfirmModal.confirmButtonLabel', { defaultMessage: 'Discard changes' }),\n          cancelButtonText: i18n('kbn.dashboard.changeViewModeConfirmModal.cancelButtonLabel', { defaultMessage: 'Continue editing' }),\n          defaultFocusedButton: _confirm_modal.ConfirmationButtonTypes.CANCEL,\n          title: i18n('kbn.dashboard.changeViewModeConfirmModal.discardChangesTitle', { defaultMessage: 'Discard changes to dashboard?' })\n        });\n      };\n\n      /**\n       * Saves the dashboard.\n       *\n       * @param {object} [saveOptions={}]\n       * @property {boolean} [saveOptions.confirmOverwrite=false] - If true, attempts to create the source so it\n       * can confirm an overwrite if a document with the id already exists.\n       * @property {boolean} [saveOptions.isTitleDuplicateConfirmed=false] - If true, save allowed with duplicate title\n       * @property {func} [saveOptions.onTitleDuplicate] - function called if duplicate title exists.\n       * When not provided, confirm modal will be displayed asking user to confirm or cancel save.\n       * @return {Promise}\n       * @resolved {String} - The id of the doc\n       */\n      function save(saveOptions) {\n        return (0, _lib.saveDashboard)(_angular2.default.toJson, _timefilter.timefilter, dashboardStateManager, saveOptions).then(function (id) {\n          if (id) {\n            _notify.toastNotifications.addSuccess({\n              title: i18n('kbn.dashboard.dashboardWasSavedSuccessMessage', {\n                defaultMessage: 'Dashboard \\'{dashTitle}\\' was saved',\n                values: { dashTitle: dash.title }\n              }),\n              'data-test-subj': 'saveDashboardSuccess'\n            });\n\n            if (dash.id !== $routeParams.id) {\n              kbnUrl.change((0, _dashboard_constants.createDashboardEditUrl)(dash.id));\n            } else {\n              docTitle.change(dash.lastSavedTitle);\n              updateViewMode(_dashboard_view_mode.DashboardViewMode.VIEW);\n            }\n          }\n          return { id: id };\n        }).catch(function (error) {\n          _notify.toastNotifications.addDanger({\n            title: i18n('kbn.dashboard.dashboardWasNotSavedDangerMessage', {\n              defaultMessage: 'Dashboard \\'{dashTitle}\\' was not saved. Error: {errorMessage}',\n              values: {\n                dashTitle: dash.title,\n                errorMessage: error.message\n              }\n            }),\n            'data-test-subj': 'saveDashboardFailure'\n          });\n          return { error: error };\n        });\n      }\n\n      $scope.showFilterBar = function () {\n        return filterBar.getFilters().length > 0 || !dashboardStateManager.getFullScreenMode();\n      };\n\n      $scope.showAddPanel = function () {\n        dashboardStateManager.setFullScreenMode(false);\n        $scope.kbnTopNav.click(_top_nav_ids.TopNavIds.ADD);\n      };\n      $scope.enterEditMode = function () {\n        dashboardStateManager.setFullScreenMode(false);\n        $scope.kbnTopNav.click('edit');\n      };\n      var navActions = {};\n      navActions[_top_nav_ids.TopNavIds.DOCUMENTATION] = function () {\n        return $window.open(_documentation_links.documentationLinks.kibana.dashboard);\n      };\n      navActions[_top_nav_ids.TopNavIds.FULL_SCREEN] = function () {\n        return dashboardStateManager.setFullScreenMode(true);\n      };\n      navActions[_top_nav_ids.TopNavIds.EXIT_EDIT_MODE] = function () {\n        return onChangeViewMode(_dashboard_view_mode.DashboardViewMode.VIEW);\n      };\n      navActions[_top_nav_ids.TopNavIds.ENTER_EDIT_MODE] = function () {\n        return onChangeViewMode(_dashboard_view_mode.DashboardViewMode.EDIT);\n      };\n      navActions[_top_nav_ids.TopNavIds.SAVE] = function () {\n        var currentTitle = dashboardStateManager.getTitle();\n        var currentDescription = dashboardStateManager.getDescription();\n        var currentTimeRestore = dashboardStateManager.getTimeRestore();\n        var onSave = function onSave(_ref3) {\n          var newTitle = _ref3.newTitle,\n              newDescription = _ref3.newDescription,\n              newCopyOnSave = _ref3.newCopyOnSave,\n              newTimeRestore = _ref3.newTimeRestore,\n              isTitleDuplicateConfirmed = _ref3.isTitleDuplicateConfirmed,\n              onTitleDuplicate = _ref3.onTitleDuplicate;\n\n          dashboardStateManager.setTitle(newTitle);\n          dashboardStateManager.setDescription(newDescription);\n          dashboardStateManager.savedDashboard.copyOnSave = newCopyOnSave;\n          dashboardStateManager.setTimeRestore(newTimeRestore);\n          var saveOptions = {\n            confirmOverwrite: false,\n            isTitleDuplicateConfirmed: isTitleDuplicateConfirmed,\n            onTitleDuplicate: onTitleDuplicate\n          };\n          return save(saveOptions).then(function (_ref4) {\n            var id = _ref4.id,\n                error = _ref4.error;\n\n            // If the save wasn't successful, put the original values back.\n            if (!id || error) {\n              dashboardStateManager.setTitle(currentTitle);\n              dashboardStateManager.setDescription(currentDescription);\n              dashboardStateManager.setTimeRestore(currentTimeRestore);\n            }\n            return { id: id, error: error };\n          });\n        };\n\n        var dashboardSaveModal = _react2.default.createElement(_save_modal.DashboardSaveModal, {\n          onSave: onSave,\n          onClose: function onClose() {},\n          title: currentTitle,\n          description: currentDescription,\n          timeRestore: currentTimeRestore,\n          showCopyOnSave: dash.id ? true : false\n        });\n        (0, _show_saved_object_save_modal.showSaveModal)(dashboardSaveModal);\n      };\n      navActions[_top_nav_ids.TopNavIds.CLONE] = function () {\n        var currentTitle = dashboardStateManager.getTitle();\n        var onClone = function onClone(newTitle, isTitleDuplicateConfirmed, onTitleDuplicate) {\n          dashboardStateManager.savedDashboard.copyOnSave = true;\n          dashboardStateManager.setTitle(newTitle);\n          var saveOptions = {\n            confirmOverwrite: false,\n            isTitleDuplicateConfirmed: isTitleDuplicateConfirmed,\n            onTitleDuplicate: onTitleDuplicate\n          };\n          return save(saveOptions).then(function (_ref5) {\n            var id = _ref5.id,\n                error = _ref5.error;\n\n            // If the save wasn't successful, put the original title back.\n            if (!id || error) {\n              dashboardStateManager.setTitle(currentTitle);\n            }\n            return { id: id, error: error };\n          });\n        };\n\n        (0, _show_clone_modal.showCloneModal)(onClone, currentTitle);\n      };\n      navActions[_top_nav_ids.TopNavIds.ADD] = function () {\n        var addNewVis = function addNewVis() {\n          (0, _wizard.showNewVisModal)(visTypes, { editorParams: [_dashboard_constants.DashboardConstants.ADD_VISUALIZATION_TO_DASHBOARD_MODE_PARAM] });\n        };\n\n        (0, _show_add_panel.showAddPanel)(dashboardStateManager.addNewPanel, addNewVis, visTypes);\n      };\n      navActions[_top_nav_ids.TopNavIds.OPTIONS] = function (menuItem, navController, anchorElement) {\n        (0, _show_options_popover.showOptionsPopover)({\n          anchorElement: anchorElement,\n          darkTheme: dashboardStateManager.getDarkTheme(),\n          onDarkThemeChange: function onDarkThemeChange(isChecked) {\n            dashboardStateManager.setDarkTheme(isChecked);\n            updateTheme();\n          },\n          useMargins: dashboardStateManager.getUseMargins(),\n          onUseMarginsChange: function onUseMarginsChange(isChecked) {\n            dashboardStateManager.setUseMargins(isChecked);\n          },\n          hidePanelTitles: dashboardStateManager.getHidePanelTitles(),\n          onHidePanelTitlesChange: function onHidePanelTitlesChange(isChecked) {\n            dashboardStateManager.setHidePanelTitles(isChecked);\n          }\n        });\n      };\n      navActions[_top_nav_ids.TopNavIds.SHARE] = function (menuItem, navController, anchorElement) {\n        (0, _share.showShareContextMenu)({\n          anchorElement: anchorElement,\n          allowEmbed: true,\n          getUnhashableStates: getUnhashableStates,\n          objectId: dash.id,\n          objectType: 'dashboard',\n          shareContextMenuExtensions: shareContextMenuExtensions,\n          sharingData: {\n            title: dash.title\n          },\n          isDirty: dashboardStateManager.getIsDirty()\n        });\n      };\n\n      updateViewMode(dashboardStateManager.getViewMode());\n\n      // update root source when filters update\n      $scope.$listen(filterBar, 'update', function () {\n        dashboardStateManager.applyFilters($scope.model.query, filterBar.getFilters());\n      });\n\n      // update data when filters fire fetch event\n      $scope.$listen(filterBar, 'fetch', $scope.refresh);\n\n      $scope.$on('$destroy', function () {\n        dashboardStateManager.destroy();\n\n        // Remove dark theme to keep it from affecting the appearance of other apps.\n        setLightTheme();\n      });\n\n      function updateTheme() {\n        dashboardStateManager.getDarkTheme() ? setDarkTheme() : setLightTheme();\n      }\n\n      function setDarkTheme() {\n        _chrome2.default.removeApplicationClass(['theme-light']);\n        _chrome2.default.addApplicationClass('theme-dark');\n        (0, _theme.applyTheme)('dark');\n      }\n\n      function setLightTheme() {\n        _chrome2.default.removeApplicationClass(['theme-dark']);\n        _chrome2.default.addApplicationClass('theme-light');\n        (0, _theme.applyTheme)('light');\n      }\n\n      if ($route.current.params && $route.current.params[_dashboard_constants.DashboardConstants.NEW_VISUALIZATION_ID_PARAM]) {\n        dashboardStateManager.addNewPanel($route.current.params[_dashboard_constants.DashboardConstants.NEW_VISUALIZATION_ID_PARAM], 'visualization');\n\n        kbnUrl.removeParam(_dashboard_constants.DashboardConstants.ADD_VISUALIZATION_TO_DASHBOARD_MODE_PARAM);\n        kbnUrl.removeParam(_dashboard_constants.DashboardConstants.NEW_VISUALIZATION_ID_PARAM);\n      }\n    }\n  };\n});",null]}