{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/index_patterns/_index_pattern.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/index_patterns/_index_pattern.js","mtime":1567631711738},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed to Elasticsearch B.V. under one or more contributor\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * license agreements. See the NOTICE file distributed with\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * this work for additional information regarding copyright\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ownership. Elasticsearch B.V. licenses this file to you under\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the Apache License, Version 2.0 (the \"License\"); you may\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *    http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * software distributed under the License is distributed on an\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * KIND, either express or implied.  See the License for the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * specific language governing permissions and limitations\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * under the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nexports.getRoutes = getRoutes;\nexports.IndexPatternProvider = IndexPatternProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _errors = require('../errors');\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _field_formats = require('../registry/field_formats');\n\nvar _mapping_setup = require('../utils/mapping_setup');\n\nvar _mapping_setup2 = _interopRequireDefault(_mapping_setup);\n\nvar _notify = require('../notify');\n\nvar _get_computed_fields = require('./_get_computed_fields');\n\nvar _format_hit = require('./_format_hit');\n\nvar _get = require('./_get');\n\nvar _intervals = require('./_intervals');\n\nvar _field_list = require('./_field_list');\n\nvar _flatten_hit = require('./_flatten_hit');\n\nvar _pattern_cache = require('./_pattern_cache');\n\nvar _fields_fetcher_provider = require('./fields_fetcher_provider');\n\nvar _unsupported_time_patterns = require('./unsupported_time_patterns');\n\nvar _saved_objects = require('../saved_objects');\n\nvar _i18n = require('@kbn/i18n');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getRoutes() {\n  return {\n    edit: '/management/kibana/indices/{{id}}',\n    addField: '/management/kibana/indices/{{id}}/create-field',\n    indexedFields: '/management/kibana/indices/{{id}}?_a=(tab:indexedFields)',\n    scriptedFields: '/management/kibana/indices/{{id}}?_a=(tab:scriptedFields)',\n    sourceFilters: '/management/kibana/indices/{{id}}?_a=(tab:sourceFilters)'\n  };\n}\n\nvar MAX_ATTEMPTS_TO_RESOLVE_CONFLICTS = 3;\n\nfunction IndexPatternProvider(Private, config, Promise, confirmModalPromise, kbnUrl) {\n  var getConfig = function getConfig() {\n    return config.get.apply(config, arguments);\n  };\n  var getIds = Private(_get.IndexPatternsGetProvider)('id');\n  var fieldsFetcher = Private(_fields_fetcher_provider.FieldsFetcherProvider);\n  var intervals = Private(_intervals.IndexPatternsIntervalsProvider);\n  var mappingSetup = Private(_mapping_setup2.default);\n  var flattenHit = Private(_flatten_hit.IndexPatternsFlattenHitProvider);\n  var patternCache = Private(_pattern_cache.IndexPatternsPatternCacheProvider);\n  var isUserAwareOfUnsupportedTimePattern = Private(_unsupported_time_patterns.IsUserAwareOfUnsupportedTimePatternProvider);\n  var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);\n  var fieldformats = _field_formats.fieldFormats;\n\n  var type = 'index-pattern';\n  var notify = new _notify.Notifier();\n  var configWatchers = new WeakMap();\n\n  var mapping = mappingSetup.expandShorthand({\n    title: 'text',\n    timeFieldName: 'keyword',\n    intervalName: 'keyword',\n    fields: 'json',\n    sourceFilters: 'json',\n    fieldFormatMap: {\n      type: 'text',\n      _serialize: function _serialize() {\n        var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        var serialized = _lodash2.default.transform(map, serializeFieldFormatMap);\n        return _lodash2.default.isEmpty(serialized) ? undefined : _angular2.default.toJson(serialized);\n      },\n      _deserialize: function _deserialize() {\n        var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '{}';\n\n        return _lodash2.default.mapValues(_angular2.default.fromJson(map), deserializeFieldFormatMap);\n      }\n    },\n    type: 'keyword',\n    typeMeta: 'json'\n  });\n\n  function serializeFieldFormatMap(flat, format, field) {\n    if (format) {\n      flat[field] = format;\n    }\n  }\n\n  function deserializeFieldFormatMap(mapping) {\n    var FieldFormat = fieldformats.byId[mapping.id];\n    return FieldFormat && new FieldFormat(mapping.params, getConfig);\n  }\n\n  function updateFromElasticSearch(indexPattern, response) {\n    var forceFieldRefresh = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!response.found) {\n      throw new _errors.SavedObjectNotFound(type, indexPattern.id, '#/management/kibana/index');\n    }\n\n    _lodash2.default.forOwn(mapping, function (fieldMapping, name) {\n      if (!fieldMapping._deserialize) {\n        return;\n      }\n      response._source[name] = fieldMapping._deserialize(response._source[name]);\n    });\n\n    // give index pattern all of the values in _source\n    _lodash2.default.assign(indexPattern, response._source);\n\n    if (!indexPattern.title) {\n      indexPattern.title = indexPattern.id;\n    }\n\n    if (indexPattern.isUnsupportedTimePattern()) {\n      if (!isUserAwareOfUnsupportedTimePattern(indexPattern)) {\n        var warningTitle = _i18n.i18n.translate('common.ui.indexPattern.warningTitle', {\n          defaultMessage: 'Support for time intervals was removed'\n        });\n\n        var warningText = _i18n.i18n.translate('common.ui.indexPattern.warningText', {\n          defaultMessage: 'For more information, view the [\"{title}\" index pattern in management]({link})',\n          values: {\n            title: indexPattern.title,\n            link: kbnUrl.getRouteHref(indexPattern, 'edit')\n          }\n        });\n\n        _notify.toastNotifications.addWarning({\n          title: warningTitle,\n          text: warningText\n        });\n      }\n    }\n\n    return indexFields(indexPattern, forceFieldRefresh);\n  }\n\n  function isFieldRefreshRequired(indexPattern) {\n    if (!indexPattern.fields) {\n      return true;\n    }\n\n    return indexPattern.fields.every(function (field) {\n      // See https://github.com/elastic/kibana/pull/8421\n      var hasFieldCaps = 'aggregatable' in field && 'searchable' in field;\n\n      // See https://github.com/elastic/kibana/pull/11969\n      var hasDocValuesFlag = 'readFromDocValues' in field;\n\n      return !hasFieldCaps || !hasDocValuesFlag;\n    });\n  }\n\n  function indexFields(indexPattern) {\n    var forceFieldRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var promise = Promise.resolve();\n\n    if (!indexPattern.id) {\n      return promise;\n    }\n\n    if (forceFieldRefresh || isFieldRefreshRequired(indexPattern)) {\n      promise = indexPattern.refreshFields();\n    }\n\n    return promise.then(function () {\n      initFields(indexPattern);\n    });\n  }\n\n  function setId(indexPattern, id) {\n    indexPattern.id = id;\n    return id;\n  }\n\n  function setVersion(indexPattern, version) {\n    indexPattern.version = version;\n    return version;\n  }\n\n  function watch(indexPattern) {\n    if (configWatchers.has(indexPattern)) {\n      return;\n    }\n    var unwatch = config.watchAll(function () {\n      if (indexPattern.fields) {\n        initFields(indexPattern); // re-init fields when config changes, but only if we already had fields\n      }\n    });\n    configWatchers.set(indexPattern, { unwatch: unwatch });\n  }\n\n  function unwatch(indexPattern) {\n    if (!configWatchers.has(indexPattern)) {\n      return;\n    }\n    configWatchers.get(indexPattern).unwatch();\n    configWatchers.delete(indexPattern);\n  }\n\n  function initFields(indexPattern, input) {\n    var oldValue = indexPattern.fields;\n    var newValue = input || oldValue || [];\n    indexPattern.fields = new _field_list.FieldList(indexPattern, newValue);\n  }\n\n  function fetchFields(indexPattern) {\n    return Promise.resolve().then(function () {\n      return fieldsFetcher.fetch(indexPattern);\n    }).then(function (fields) {\n      var scripted = indexPattern.getScriptedFields();\n      var all = fields.concat(scripted);\n      initFields(indexPattern, all);\n    });\n  }\n\n  var IndexPattern = function () {\n    function IndexPattern(id) {\n      _classCallCheck(this, IndexPattern);\n\n      setId(this, id);\n      this.metaFields = config.get('metaFields');\n      this.getComputedFields = _get_computed_fields.getComputedFields.bind(this);\n\n      this.flattenHit = flattenHit(this);\n      this.formatHit = (0, _format_hit.formatHit)(this, fieldformats.getDefaultInstance('string'));\n      this.formatField = this.formatHit.formatField;\n    }\n\n    _createClass(IndexPattern, [{\n      key: 'init',\n      value: function init() {\n        var _this = this;\n\n        var forceFieldRefresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        watch(this);\n\n        if (!this.id) {\n          return Promise.resolve(this); // no id === no elasticsearch document\n        }\n\n        return savedObjectsClient.get(type, this.id).then(function (resp) {\n          // temporary compatability for savedObjectsClient\n\n          setVersion(_this, resp._version);\n\n          return {\n            _id: resp.id,\n            _type: resp.type,\n            _source: _lodash2.default.cloneDeep(resp.attributes),\n            found: resp._version ? true : false\n          };\n        })\n        // Do this before we attempt to update from ES\n        // since that call can potentially perform a save\n        .then(function (response) {\n          _this.originalBody = _this.prepBody();\n          return response;\n        }).then(function (response) {\n          return updateFromElasticSearch(_this, response, forceFieldRefresh);\n        })\n        // Do it after to ensure we have the most up to date information\n        .then(function () {\n          _this.originalBody = _this.prepBody();\n        }).then(function () {\n          return _this;\n        });\n      }\n\n      // Get the source filtering configuration for that index.\n\n    }, {\n      key: 'getSourceFiltering',\n      value: function getSourceFiltering() {\n        return {\n          excludes: this.sourceFilters && this.sourceFilters.map(function (filter) {\n            return filter.value;\n          }) || []\n        };\n      }\n    }, {\n      key: 'addScriptedField',\n      value: function addScriptedField(name, script) {\n        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'string';\n        var lang = arguments[3];\n\n        var scriptedFields = this.getScriptedFields();\n        var names = _lodash2.default.pluck(scriptedFields, 'name');\n\n        if (_lodash2.default.contains(names, name)) {\n          throw new _errors.DuplicateField(name);\n        }\n\n        this.fields.push({\n          name: name,\n          script: script,\n          type: type,\n          scripted: true,\n          lang: lang\n        });\n\n        this.save();\n      }\n    }, {\n      key: 'removeScriptedField',\n      value: function removeScriptedField(name) {\n        var fieldIndex = _lodash2.default.findIndex(this.fields, {\n          name: name,\n          scripted: true\n        });\n\n        if (fieldIndex > -1) {\n          this.fields.splice(fieldIndex, 1);\n          delete this.fieldFormatMap[name];\n          return this.save();\n        }\n      }\n    }, {\n      key: 'popularizeField',\n      value: function popularizeField(fieldName) {\n        var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n        var field = _lodash2.default.get(this, ['fields', 'byName', fieldName]);\n        if (!field) {\n          return;\n        }\n        var count = Math.max((field.count || 0) + unit, 0);\n        if (field.count === count) {\n          return;\n        }\n        field.count = count;\n        this.save();\n      }\n    }, {\n      key: 'getNonScriptedFields',\n      value: function getNonScriptedFields() {\n        return _lodash2.default.where(this.fields, { scripted: false });\n      }\n    }, {\n      key: 'getScriptedFields',\n      value: function getScriptedFields() {\n        return _lodash2.default.where(this.fields, { scripted: true });\n      }\n    }, {\n      key: 'getInterval',\n      value: function getInterval() {\n        return this.intervalName && _lodash2.default.find(intervals, { name: this.intervalName });\n      }\n    }, {\n      key: 'toIndexList',\n      value: function toIndexList(start, stop, sortDirection) {\n        return this.toDetailedIndexList(start, stop, sortDirection).then(function (detailedIndices) {\n          if (!Array.isArray(detailedIndices)) {\n            return detailedIndices.index;\n          }\n          return detailedIndices.map(function (_ref) {\n            var index = _ref.index;\n            return index;\n          }).join(',');\n        });\n      }\n    }, {\n      key: 'toDetailedIndexList',\n      value: function toDetailedIndexList(start, stop, sortDirection) {\n        var _this2 = this;\n\n        return Promise.resolve().then(function () {\n          if (_this2.isTimeBasedInterval()) {\n            return intervals.toIndexList(_this2.title, _this2.getInterval(), start, stop, sortDirection);\n          }\n\n          return [{\n            index: _this2.title,\n            min: -Infinity,\n            max: Infinity\n          }];\n        });\n      }\n    }, {\n      key: 'isTimeBased',\n      value: function isTimeBased() {\n        return !!this.timeFieldName && (!this.fields || !!this.getTimeField());\n      }\n    }, {\n      key: 'isTimeBasedInterval',\n      value: function isTimeBasedInterval() {\n        return this.isTimeBased() && !!this.getInterval();\n      }\n    }, {\n      key: 'isUnsupportedTimePattern',\n      value: function isUnsupportedTimePattern() {\n        return !!this.intervalName;\n      }\n    }, {\n      key: 'isTimeBasedWildcard',\n      value: function isTimeBasedWildcard() {\n        return this.isTimeBased() && this.isWildcard();\n      }\n    }, {\n      key: 'getTimeField',\n      value: function getTimeField() {\n        if (!this.timeFieldName || !this.fields || !this.fields.byName) return;\n        return this.fields.byName[this.timeFieldName];\n      }\n    }, {\n      key: 'isWildcard',\n      value: function isWildcard() {\n        return _lodash2.default.includes(this.title, '*');\n      }\n    }, {\n      key: 'prepBody',\n      value: function prepBody() {\n        var _this3 = this;\n\n        var body = {};\n\n        // serialize json fields\n        _lodash2.default.forOwn(mapping, function (fieldMapping, fieldName) {\n          if (_this3[fieldName] != null) {\n            body[fieldName] = fieldMapping._serialize ? fieldMapping._serialize(_this3[fieldName]) : _this3[fieldName];\n          }\n        });\n\n        // clear the indexPattern list cache\n        getIds.clearCache();\n        return body;\n      }\n    }, {\n      key: 'create',\n      value: function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n          var _this4 = this;\n\n          var allowOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n          var showOverridePrompt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n          var _create, potentialDuplicateByTitle, confirmMessage;\n\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _create = function () {\n                    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(duplicateId) {\n                      var duplicatePattern, body, response;\n                      return regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              if (!duplicateId) {\n                                _context.next = 4;\n                                break;\n                              }\n\n                              duplicatePattern = new IndexPattern(duplicateId);\n                              _context.next = 4;\n                              return duplicatePattern.destroy();\n\n                            case 4:\n                              body = _this4.prepBody();\n                              _context.next = 7;\n                              return savedObjectsClient.create(type, body, { id: _this4.id });\n\n                            case 7:\n                              response = _context.sent;\n                              return _context.abrupt('return', setId(_this4, response.id));\n\n                            case 9:\n                            case 'end':\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee, _this4);\n                    }));\n\n                    return function _create(_x10) {\n                      return _ref3.apply(this, arguments);\n                    };\n                  }();\n\n                  _context2.next = 3;\n                  return (0, _saved_objects.findObjectByTitle)(savedObjectsClient, type, this.title);\n\n                case 3:\n                  potentialDuplicateByTitle = _context2.sent;\n\n                  if (potentialDuplicateByTitle) {\n                    _context2.next = 8;\n                    break;\n                  }\n\n                  _context2.next = 7;\n                  return _create();\n\n                case 7:\n                  return _context2.abrupt('return', _context2.sent);\n\n                case 8:\n                  if (allowOverride) {\n                    _context2.next = 19;\n                    break;\n                  }\n\n                  confirmMessage = _i18n.i18n.translate('common.ui.indexPattern.titleExistsLabel', { values: { title: this.title },\n                    defaultMessage: 'An index pattern with the title \\'{title}\\' already exists.' });\n                  _context2.prev = 10;\n                  _context2.next = 13;\n                  return confirmModalPromise(confirmMessage, { confirmButtonText: 'Go to existing pattern' });\n\n                case 13:\n                  return _context2.abrupt('return', kbnUrl.redirect('/management/kibana/indices/{{id}}', { id: potentialDuplicateByTitle.id }));\n\n                case 16:\n                  _context2.prev = 16;\n                  _context2.t0 = _context2['catch'](10);\n                  return _context2.abrupt('return', false);\n\n                case 19:\n                  if (showOverridePrompt) {\n                    _context2.next = 23;\n                    break;\n                  }\n\n                  _context2.next = 22;\n                  return _create(potentialDuplicateByTitle.id);\n\n                case 22:\n                  return _context2.abrupt('return', _context2.sent);\n\n                case 23:\n                  _context2.prev = 23;\n                  _context2.next = 26;\n                  return confirmModalPromise(_i18n.i18n.translate('common.ui.indexPattern.confirmOverwriteLabel', { values: { title: this.title },\n                    defaultMessage: 'Are you sure you want to overwrite \\'{title}\\'?' }), {\n                    title: _i18n.i18n.translate('common.ui.indexPattern.confirmOverwriteTitle', {\n                      defaultMessage: 'Overwrite {type}?',\n                      values: { type: type }\n                    }),\n                    confirmButtonText: _i18n.i18n.translate('common.ui.indexPattern.confirmOverwriteButton', { defaultMessage: 'Overwrite' })\n                  });\n\n                case 26:\n                  _context2.next = 31;\n                  break;\n\n                case 28:\n                  _context2.prev = 28;\n                  _context2.t1 = _context2['catch'](23);\n                  return _context2.abrupt('return', false);\n\n                case 31:\n                  _context2.next = 33;\n                  return _create(potentialDuplicateByTitle.id);\n\n                case 33:\n                  return _context2.abrupt('return', _context2.sent);\n\n                case 34:\n                case 'end':\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this, [[10, 16], [23, 28]]);\n        }));\n\n        function create() {\n          return _ref2.apply(this, arguments);\n        }\n\n        return create;\n      }()\n    }, {\n      key: 'save',\n      value: function save() {\n        var _this5 = this;\n\n        var saveAttempts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n        var body = this.prepBody();\n        // What keys changed since they last pulled the index pattern\n        var originalChangedKeys = Object.keys(body).filter(function (key) {\n          return body[key] !== _this5.originalBody[key];\n        });\n        return savedObjectsClient.update(type, this.id, body, { version: this.version }).then(function (_ref4) {\n          var id = _ref4.id,\n              _version = _ref4._version;\n\n          setId(_this5, id);\n          setVersion(_this5, _version);\n        }).catch(function (err) {\n          if (_lodash2.default.get(err, 'res.status') === 409 && saveAttempts++ < MAX_ATTEMPTS_TO_RESOLVE_CONFLICTS) {\n            var samePattern = new IndexPattern(_this5.id);\n            return samePattern.init().then(function () {\n              // What keys changed from now and what the server returned\n              var updatedBody = samePattern.prepBody();\n\n              // Build a list of changed keys from the server response\n              // and ensure we ignore the key if the server response\n              // is the same as the original response (since that is expected\n              // if we made a change in that key)\n              var serverChangedKeys = Object.keys(updatedBody).filter(function (key) {\n                return updatedBody[key] !== body[key] && _this5.originalBody[key] !== updatedBody[key];\n              });\n\n              var unresolvedCollision = false;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = originalChangedKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var originalKey = _step.value;\n                  var _iteratorNormalCompletion2 = true;\n                  var _didIteratorError2 = false;\n                  var _iteratorError2 = undefined;\n\n                  try {\n                    for (var _iterator2 = serverChangedKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                      var serverKey = _step2.value;\n\n                      if (originalKey === serverKey) {\n                        unresolvedCollision = true;\n                        break;\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                      }\n                    } finally {\n                      if (_didIteratorError2) {\n                        throw _iteratorError2;\n                      }\n                    }\n                  }\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              if (unresolvedCollision) {\n                var message = _i18n.i18n.translate('common.ui.indexPattern.unableWriteLabel', { defaultMessage: 'Unable to write index pattern! Refresh the page to get the most up to date changes for this index pattern.' // eslint-disable-line max-len\n                });\n                _notify.toastNotifications.addDanger(message);\n                throw err;\n              }\n\n              // Set the updated response on this object\n              serverChangedKeys.forEach(function (key) {\n                _this5[key] = samePattern[key];\n              });\n\n              setVersion(_this5, samePattern.version);\n\n              // Clear cache\n              patternCache.clear(_this5.id);\n\n              // Try the save again\n              return _this5.save(saveAttempts);\n            });\n          }\n          throw err;\n        });\n      }\n    }, {\n      key: 'refreshFields',\n      value: function refreshFields() {\n        var _this6 = this;\n\n        return fetchFields(this).then(function () {\n          return _this6.save();\n        }).catch(function (err) {\n          notify.error(err);\n          // https://github.com/elastic/kibana/issues/9224\n          // This call will attempt to remap fields from the matching\n          // ES index which may not actually exist. In that scenario,\n          // we still want to notify the user that there is a problem\n          // but we do not want to potentially make any pages unusable\n          // so do not rethrow the error here\n          if (err instanceof _errors.IndexPatternMissingIndices) {\n            return [];\n          }\n\n          throw err;\n        });\n      }\n    }, {\n      key: 'toJSON',\n      value: function toJSON() {\n        return this.id;\n      }\n    }, {\n      key: 'toString',\n      value: function toString() {\n        return '' + this.toJSON();\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        unwatch(this);\n        patternCache.clear(this.id);\n        return savedObjectsClient.delete(type, this.id);\n      }\n    }, {\n      key: 'routes',\n      get: function get() {\n        return getRoutes();\n      }\n    }]);\n\n    return IndexPattern;\n  }();\n\n  return IndexPattern;\n}",null]}