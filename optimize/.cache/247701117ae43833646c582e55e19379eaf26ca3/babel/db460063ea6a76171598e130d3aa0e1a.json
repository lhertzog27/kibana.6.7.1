{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/kibana/public/discover/controllers/discover.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/kibana/public/discover/controllers/discover.js","mtime":1567631711564},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _get_sort = require('ui/doc_table/lib/get_sort');\n\nvar _columns = require('ui/doc_table/actions/columns');\n\nvar columnActions = _interopRequireWildcard(_columns);\n\nvar _filter = require('ui/doc_table/actions/filter');\n\nvar filterActions = _interopRequireWildcard(_filter);\n\nvar _datemath = require('@elastic/datemath');\n\nvar _datemath2 = _interopRequireDefault(_datemath);\n\nrequire('ui/doc_table');\n\nrequire('ui/visualize');\n\nrequire('ui/fixed_scroll');\n\nrequire('ui/directives/validate_json');\n\nrequire('ui/filters/moment');\n\nrequire('ui/index_patterns');\n\nrequire('ui/state_management/app_state');\n\nvar _timefilter = require('ui/timefilter');\n\nrequire('ui/query_bar');\n\nvar _courier = require('ui/courier');\n\nvar _notify = require('ui/notify');\n\nvar _vis = require('ui/vis');\n\nvar _vislib = require('ui/vis/response_handlers/vislib');\n\nvar _doc_title = require('ui/doc_title');\n\nvar _hit_sort_fn = require('../_hit_sort_fn');\n\nvar _hit_sort_fn2 = _interopRequireDefault(_hit_sort_fn);\n\nvar _query_filter = require('ui/filter_bar/query_filter');\n\nvar _interval_options = require('ui/agg_types/buckets/_interval_options');\n\nvar _state_monitor_factory = require('ui/state_management/state_monitor_factory');\n\nvar _routes = require('ui/routes');\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nvar _modules = require('ui/modules');\n\nvar _index = require('../index.html');\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _state = require('ui/state_management/state');\n\nvar _migrate_legacy_query = require('ui/utils/migrate_legacy_query');\n\nvar _filter_manager = require('ui/filter_manager');\n\nvar _saved_objects = require('ui/saved_objects');\n\nvar _visualize_loader = require('ui/visualize/loader/visualize_loader');\n\nvar _persisted_log = require('ui/persisted_log');\n\nvar _documentation_links = require('ui/documentation_links');\n\nrequire('../components/fetch_error');\n\nvar _get_painless_error = require('./get_painless_error');\n\nvar _share = require('ui/share');\n\nvar _state_hashing = require('ui/state_management/state_hashing');\n\nvar _inspector = require('ui/inspector');\n\nvar _adapters = require('ui/inspector/adapters');\n\nvar _courier_inspector_utils = require('ui/courier/utils/courier_inspector_utils');\n\nvar _show_open_search_panel = require('../top_nav/show_open_search_panel');\n\nvar _tabify = require('ui/agg_response/tabify');\n\nvar _show_saved_object_save_modal = require('ui/saved_objects/show_saved_object_save_modal');\n\nvar _saved_object_save_modal = require('ui/saved_objects/components/saved_object_save_modal');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Licensed to Elasticsearch B.V. under one or more contributor\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * license agreements. See the NOTICE file distributed with\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * this work for additional information regarding copyright\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * ownership. Elasticsearch B.V. licenses this file to you under\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * the Apache License, Version 2.0 (the \"License\"); you may\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *    http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Unless required by applicable law or agreed to in writing,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * software distributed under the License is distributed on an\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * KIND, either express or implied.  See the License for the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * specific language governing permissions and limitations\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * under the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */\n\nvar app = _modules.uiModules.get('apps/discover', ['kibana/notify', 'kibana/courier', 'kibana/url', 'kibana/index_patterns']);\n\n_routes2.default.defaults(/discover/, {\n  requireDefaultIndex: true\n}).when('/discover/:id?', {\n  template: _index2.default,\n  reloadOnSearch: false,\n  resolve: {\n    ip: function ip(Promise, indexPatterns, config, $location, Private) {\n      var State = Private(_state.StateProvider);\n      var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);\n\n      return savedObjectsClient.find({\n        type: 'index-pattern',\n        fields: ['title'],\n        perPage: 10000\n      }).then(function (_ref) {\n        var savedObjects = _ref.savedObjects;\n\n        /**\n         *  In making the indexPattern modifiable it was placed in appState. Unfortunately,\n         *  the load order of AppState conflicts with the load order of many other things\n         *  so in order to get the name of the index we should use, and to switch to the\n         *  default if necessary, we parse the appState with a temporary State object and\n         *  then destroy it immediatly after we're done\n         *\n         *  @type {State}\n         */\n        var state = new State('_a', {});\n\n        var specified = !!state.index;\n        var exists = _lodash2.default.findIndex(savedObjects, function (o) {\n          return o.id === state.index;\n        }) > -1;\n        var id = exists ? state.index : config.get('defaultIndex');\n        state.destroy();\n\n        return Promise.props({\n          list: savedObjects,\n          loaded: indexPatterns.get(id),\n          stateVal: state.index,\n          stateValFound: specified && exists\n        });\n      });\n    },\n    savedSearch: function savedSearch(redirectWhenMissing, savedSearches, $route) {\n      var savedSearchId = $route.current.params.id;\n      return savedSearches.get(savedSearchId).then(function (savedSearch) {\n        if (savedSearchId) {\n          _persisted_log.recentlyAccessed.add(savedSearch.getFullPath(), savedSearch.title, savedSearchId);\n        }\n        return savedSearch;\n      }).catch(redirectWhenMissing({\n        'search': '/discover',\n        'index-pattern': '/management/kibana/objects/savedSearches/' + $route.current.params.id\n      }));\n    }\n  }\n});\n\napp.directive('discoverApp', function () {\n  return {\n    restrict: 'E',\n    controllerAs: 'discoverApp',\n    controller: discoverController\n  };\n});\n\nfunction discoverController($element, $route, $scope, $timeout, $window, AppState, Notifier, Private, Promise, config, courier, kbnUrl, localStorage, i18n) {\n  var _this = this;\n\n  var saveDataSource = function () {\n    var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(saveOptions) {\n      var id;\n      return regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return $scope.updateDataSource();\n\n            case 2:\n\n              savedSearch.columns = $scope.state.columns;\n              savedSearch.sort = $scope.state.sort;\n\n              _context6.prev = 4;\n              _context6.next = 7;\n              return savedSearch.save(saveOptions);\n\n            case 7:\n              id = _context6.sent;\n\n              $scope.$evalAsync(function () {\n                stateMonitor.setInitialState($state.toJSON());\n                if (id) {\n                  _notify.toastNotifications.addSuccess({\n                    title: i18n('kbn.discover.notifications.savedSearchTitle', {\n                      defaultMessage: 'Search \\'{savedSearchTitle}\\' was saved',\n                      values: {\n                        savedSearchTitle: savedSearch.title\n                      }\n                    }),\n                    'data-test-subj': 'saveSearchSuccess'\n                  });\n\n                  if (savedSearch.id !== $route.current.params.id) {\n                    kbnUrl.change('/discover/{{id}}', { id: savedSearch.id });\n                  } else {\n                    // Update defaults so that \"reload saved query\" functions correctly\n                    $state.setDefaults(getStateDefaults());\n                    docTitle.change(savedSearch.lastSavedTitle);\n                  }\n                }\n              });\n              return _context6.abrupt('return', { id: id });\n\n            case 12:\n              _context6.prev = 12;\n              _context6.t0 = _context6['catch'](4);\n\n              _notify.toastNotifications.addDanger({\n                title: i18n('kbn.discover.notifications.notSavedSearchTitle', {\n                  defaultMessage: 'Search \\'{savedSearchTitle}\\' was not saved.',\n                  values: {\n                    savedSearchTitle: savedSearch.title\n                  }\n                }),\n                text: _context6.t0.message\n              });\n              return _context6.abrupt('return', { error: _context6.t0 });\n\n            case 16:\n            case 'end':\n              return _context6.stop();\n          }\n        }\n      }, _callee6, this, [[4, 12]]);\n    }));\n\n    return function saveDataSource(_x4) {\n      return _ref10.apply(this, arguments);\n    };\n  }();\n\n  var setupVisualization = function () {\n    var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {\n      var _this2 = this;\n\n      var visStateAggs, visState, visSavedObject;\n      return regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              if ($scope.opts.timefield) {\n                _context8.next = 2;\n                break;\n              }\n\n              return _context8.abrupt('return');\n\n            case 2:\n              visStateAggs = [{\n                type: 'count',\n                schema: 'metric'\n              }, {\n                type: 'date_histogram',\n                schema: 'segment',\n                params: {\n                  field: $scope.opts.timefield,\n                  interval: $state.interval,\n                  timeRange: _timefilter.timefilter.getTime()\n                }\n              }];\n\n              if (!$scope.vis) {\n                _context8.next = 8;\n                break;\n              }\n\n              visState = $scope.vis.getEnabledState();\n\n              visState.aggs = visStateAggs;\n\n              $scope.vis.setState(visState);\n              return _context8.abrupt('return');\n\n            case 8:\n              visSavedObject = {\n                indexPattern: $scope.indexPattern.id,\n                visState: {\n                  type: 'histogram',\n                  title: savedSearch.title,\n                  params: {\n                    addLegend: false,\n                    addTimeMarker: true\n                  },\n                  aggs: visStateAggs\n                }\n              };\n\n\n              $scope.vis = new Vis($scope.searchSource.getField('index'), visSavedObject.visState);\n              visSavedObject.vis = $scope.vis;\n\n              $scope.searchSource.onRequestStart(function (searchSource, searchRequest) {\n                return $scope.vis.getAggConfig().onSearchRequestStart(searchSource, searchRequest);\n              });\n\n              $scope.searchSource.setField('aggs', function () {\n                return $scope.vis.getAggConfig().toDsl();\n              });\n\n              $timeout(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {\n                var visEl;\n                return regeneratorRuntime.wrap(function _callee7$(_context7) {\n                  while (1) {\n                    switch (_context7.prev = _context7.next) {\n                      case 0:\n                        visEl = $element.find('#discoverHistogram')[0];\n                        _context7.next = 3;\n                        return visualizeLoader.embedVisualizationWithSavedObject(visEl, visSavedObject, {\n                          autoFetch: false\n                        });\n\n                      case 3:\n                        visualizeHandler = _context7.sent;\n\n                      case 4:\n                      case 'end':\n                        return _context7.stop();\n                    }\n                  }\n                }, _callee7, _this2);\n              })));\n\n            case 14:\n            case 'end':\n              return _context8.stop();\n          }\n        }\n      }, _callee8, this);\n    }));\n\n    return function setupVisualization() {\n      return _ref12.apply(this, arguments);\n    };\n  }();\n\n  var visualizeLoader = Private(_visualize_loader.VisualizeLoaderProvider);\n  var visualizeHandler = void 0;\n  var Vis = Private(_vis.VisProvider);\n  var docTitle = Private(_doc_title.DocTitleProvider);\n  var HitSortFn = Private(_hit_sort_fn2.default);\n  var queryFilter = Private(_query_filter.FilterBarQueryFilterProvider);\n  var responseHandler = Private(_vislib.VislibSeriesResponseHandlerProvider).handler;\n  var filterManager = Private(_filter_manager.FilterManagerProvider);\n  var notify = new Notifier({\n    location: 'Discover'\n  });\n  var getUnhashableStates = Private(_state_hashing.getUnhashableStatesProvider);\n  var shareContextMenuExtensions = Private(_share.ShareContextMenuExtensionsRegistryProvider);\n  var inspectorAdapters = {\n    requests: new _adapters.RequestAdapter()\n  };\n\n  $scope.getDocLink = _documentation_links.getDocLink;\n  $scope.intervalOptions = _interval_options.intervalOptions;\n  $scope.showInterval = false;\n  $scope.minimumVisibleRows = 50;\n\n  $scope.intervalEnabled = function (interval) {\n    return interval.val !== 'custom';\n  };\n\n  // the saved savedSearch\n  var savedSearch = $route.current.locals.savedSearch;\n  $scope.$on('$destroy', savedSearch.destroy);\n\n  var $appStatus = $scope.appStatus = this.appStatus = {\n    dirty: !savedSearch.id\n  };\n\n  $scope.topNavMenu = [{\n    key: 'new',\n    label: i18n('kbn.discover.localMenu.localMenu.newSearchTitle', {\n      defaultMessage: 'New'\n    }),\n    description: i18n('kbn.discover.localMenu.newSearchDescription', {\n      defaultMessage: 'New Search'\n    }),\n    run: function run() {\n      kbnUrl.change('/discover');\n    },\n    testId: 'discoverNewButton'\n  }, {\n    key: 'save',\n    label: i18n('kbn.discover.localMenu.saveTitle', {\n      defaultMessage: 'Save'\n    }),\n    description: i18n('kbn.discover.localMenu.saveSearchDescription', {\n      defaultMessage: 'Save Search'\n    }),\n    testId: 'discoverSaveButton',\n    run: function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var onSave, saveModal;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                onSave = function onSave(_ref3) {\n                  var newTitle = _ref3.newTitle,\n                      newCopyOnSave = _ref3.newCopyOnSave,\n                      isTitleDuplicateConfirmed = _ref3.isTitleDuplicateConfirmed,\n                      onTitleDuplicate = _ref3.onTitleDuplicate;\n\n                  var currentTitle = savedSearch.title;\n                  savedSearch.title = newTitle;\n                  savedSearch.copyOnSave = newCopyOnSave;\n                  var saveOptions = {\n                    confirmOverwrite: false,\n                    isTitleDuplicateConfirmed: isTitleDuplicateConfirmed,\n                    onTitleDuplicate: onTitleDuplicate\n                  };\n                  return saveDataSource(saveOptions).then(function (_ref4) {\n                    var id = _ref4.id,\n                        error = _ref4.error;\n\n                    // If the save wasn't successful, put the original values back.\n                    if (!id || error) {\n                      savedSearch.title = currentTitle;\n                    }\n                    return { id: id, error: error };\n                  });\n                };\n\n                saveModal = _react2.default.createElement(_saved_object_save_modal.SavedObjectSaveModal, {\n                  onSave: onSave,\n                  onClose: function onClose() {},\n                  title: savedSearch.title,\n                  showCopyOnSave: savedSearch.id ? true : false,\n                  objectType: 'search'\n                });\n\n                (0, _show_saved_object_save_modal.showSaveModal)(saveModal);\n\n              case 3:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, _this);\n      }));\n\n      function run() {\n        return _ref2.apply(this, arguments);\n      }\n\n      return run;\n    }()\n  }, {\n    key: 'open',\n    label: i18n('kbn.discover.localMenu.openTitle', {\n      defaultMessage: 'Open'\n    }),\n    description: i18n('kbn.discover.localMenu.openSavedSearchDescription', {\n      defaultMessage: 'Open Saved Search'\n    }),\n    testId: 'discoverOpenButton',\n    run: function run() {\n      (0, _show_open_search_panel.showOpenSearchPanel)({\n        makeUrl: function makeUrl(searchId) {\n          return kbnUrl.eval('#/discover/{{id}}', { id: searchId });\n        }\n      });\n    }\n  }, {\n    key: 'share',\n    label: i18n('kbn.discover.localMenu.shareTitle', {\n      defaultMessage: 'Share'\n    }),\n    description: i18n('kbn.discover.localMenu.shareSearchDescription', {\n      defaultMessage: 'Share Search'\n    }),\n    testId: 'shareTopNavButton',\n    run: function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(menuItem, navController, anchorElement) {\n        var sharingData;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _this.getSharingData();\n\n              case 2:\n                sharingData = _context2.sent;\n\n                (0, _share.showShareContextMenu)({\n                  anchorElement: anchorElement,\n                  allowEmbed: false,\n                  getUnhashableStates: getUnhashableStates,\n                  objectId: savedSearch.id,\n                  objectType: 'search',\n                  shareContextMenuExtensions: shareContextMenuExtensions,\n                  sharingData: _extends({}, sharingData, {\n                    title: savedSearch.title\n                  }),\n                  isDirty: $appStatus.dirty\n                });\n\n              case 4:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, _this);\n      }));\n\n      function run(_x, _x2, _x3) {\n        return _ref5.apply(this, arguments);\n      }\n\n      return run;\n    }()\n  }, {\n    key: 'inspect',\n    label: i18n('kbn.discover.localMenu.inspectTitle', {\n      defaultMessage: 'Inspect'\n    }),\n    description: i18n('kbn.discover.localMenu.openInspectorForSearchDescription', {\n      defaultMessage: 'Open Inspector for search'\n    }),\n    testId: 'openInspectorButton',\n    run: function run() {\n      _inspector.Inspector.open(inspectorAdapters, {\n        title: savedSearch.title\n      });\n    }\n  }];\n\n  // the actual courier.SearchSource\n  $scope.searchSource = savedSearch.searchSource;\n  $scope.indexPattern = resolveIndexPatternLoading();\n\n  $scope.searchSource.setField('index', $scope.indexPattern).setField('highlightAll', true).setField('version', true);\n\n  // Even when searching rollups, we want to use the default strategy so that we get back a\n  // document-like response.\n  $scope.searchSource.setPreferredSearchStrategyId('default');\n\n  // searchSource which applies time range\n  var timeRangeSearchSource = savedSearch.searchSource.create();\n  if ((0, _courier.isDefaultTypeIndexPattern)($scope.indexPattern)) {\n    timeRangeSearchSource.setField('filter', function () {\n      return _timefilter.timefilter.createFilter($scope.indexPattern);\n    });\n  }\n\n  $scope.searchSource.setParent(timeRangeSearchSource);\n\n  var pageTitleSuffix = savedSearch.id && savedSearch.title ? ': ' + savedSearch.title : '';\n  docTitle.change('Discover' + pageTitleSuffix);\n  var discoverBreadcrumbsTitle = i18n('kbn.discover.discoverBreadcrumbTitle', {\n    defaultMessage: 'Discover'\n  });\n\n  if (savedSearch.id && savedSearch.title) {\n    _chrome2.default.breadcrumbs.set([{\n      text: discoverBreadcrumbsTitle,\n      href: '#/discover'\n    }, { text: savedSearch.title }]);\n  } else {\n    _chrome2.default.breadcrumbs.set([{\n      text: discoverBreadcrumbsTitle\n    }]);\n  }\n\n  var stateMonitor = void 0;\n\n  var $state = $scope.state = new AppState(getStateDefaults());\n\n  var getFieldCounts = function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if ($scope.fetchStatus) {\n                _context3.next = 2;\n                break;\n              }\n\n              return _context3.abrupt('return', $scope.fieldCounts);\n\n            case 2:\n              _context3.next = 4;\n              return new Promise(function (resolve) {\n                var unwatch = $scope.$watch('fetchStatus', function (newValue) {\n                  if (newValue) {\n                    return;\n                  }\n\n                  unwatch();\n                  resolve($scope.fieldCounts);\n                });\n              });\n\n            case 4:\n              return _context3.abrupt('return', _context3.sent);\n\n            case 5:\n            case 'end':\n              return _context3.stop();\n          }\n        }\n      }, _callee3, _this);\n    }));\n\n    return function getFieldCounts() {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n\n  var getSharingDataFields = function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n      var selectedFields, fieldCounts, timeFieldName, hideTimeColumn, fields;\n      return regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              selectedFields = $state.columns;\n\n              if (!(selectedFields.length === 1 && selectedFields[0] === '_source')) {\n                _context4.next = 6;\n                break;\n              }\n\n              _context4.next = 4;\n              return getFieldCounts();\n\n            case 4:\n              fieldCounts = _context4.sent;\n              return _context4.abrupt('return', {\n                searchFields: null,\n                selectFields: _lodash2.default.keys(fieldCounts).sort()\n              });\n\n            case 6:\n              timeFieldName = $scope.indexPattern.timeFieldName;\n              hideTimeColumn = config.get('doc_table:hideTimeColumn');\n              fields = timeFieldName && !hideTimeColumn ? [timeFieldName].concat(_toConsumableArray(selectedFields)) : selectedFields;\n              return _context4.abrupt('return', {\n                searchFields: fields,\n                selectFields: fields\n              });\n\n            case 10:\n            case 'end':\n              return _context4.stop();\n          }\n        }\n      }, _callee4, _this);\n    }));\n\n    return function getSharingDataFields() {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n\n  this.getSharingData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n    var searchSource, _ref9, searchFields, selectFields, body;\n\n    return regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            searchSource = $scope.searchSource.createCopy();\n            _context5.next = 3;\n            return getSharingDataFields();\n\n          case 3:\n            _ref9 = _context5.sent;\n            searchFields = _ref9.searchFields;\n            selectFields = _ref9.selectFields;\n\n            searchSource.setField('fields', searchFields);\n            searchSource.setField('sort', (0, _get_sort.getSort)($state.sort, $scope.indexPattern));\n            searchSource.setField('highlight', null);\n            searchSource.setField('highlightAll', null);\n            searchSource.setField('aggs', null);\n            searchSource.setField('size', null);\n\n            _context5.next = 14;\n            return searchSource.getSearchRequestBody();\n\n          case 14:\n            body = _context5.sent;\n            return _context5.abrupt('return', {\n              searchRequest: {\n                index: searchSource.getField('index').title,\n                body: body\n              },\n              fields: selectFields,\n              metaFields: $scope.indexPattern.metaFields,\n              conflictedTypesFields: $scope.indexPattern.fields.filter(function (f) {\n                return f.type === 'conflict';\n              }).map(function (f) {\n                return f.name;\n              }),\n              indexPatternId: searchSource.getField('index').id\n            });\n\n          case 16:\n          case 'end':\n            return _context5.stop();\n        }\n      }\n    }, _callee5, _this);\n  }));\n\n  $scope.uiState = $state.makeStateful('uiState');\n\n  function getStateDefaults() {\n    return {\n      query: $scope.searchSource.getField('query') || {\n        query: '',\n        language: localStorage.get('kibana.userQueryLanguage') || config.get('search:queryLanguage')\n      },\n      sort: _get_sort.getSort.array(savedSearch.sort, $scope.indexPattern, config.get('discover:sort:defaultOrder')),\n      columns: savedSearch.columns.length > 0 ? savedSearch.columns : config.get('defaultColumns').slice(),\n      index: $scope.indexPattern.id,\n      interval: 'auto',\n      filters: _lodash2.default.cloneDeep($scope.searchSource.getOwnField('filter'))\n    };\n  }\n\n  $state.index = $scope.indexPattern.id;\n  $state.sort = _get_sort.getSort.array($state.sort, $scope.indexPattern);\n\n  $scope.getBucketIntervalToolTipText = function () {\n    return i18n('kbn.discover.bucketIntervalTooltip', {\n      // eslint-disable-next-line max-len\n      defaultMessage: 'This interval creates {bucketsDescription} to show in the selected time range, so it has been scaled to {bucketIntervalDescription}',\n      values: {\n        bucketsDescription: $scope.bucketInterval.scale > 1 ? i18n('kbn.discover.bucketIntervalTooltip.tooLargeBucketsText', {\n          defaultMessage: 'buckets that are too large'\n        }) : i18n('kbn.discover.bucketIntervalTooltip.tooManyBucketsText', {\n          defaultMessage: 'too many buckets'\n        }),\n        bucketIntervalDescription: $scope.bucketInterval.description\n      }\n    });\n  };\n\n  $scope.$watchCollection('state.columns', function () {\n    $state.save();\n  });\n\n  $scope.opts = {\n    // number of records to fetch, then paginate through\n    sampleSize: config.get('discover:sampleSize'),\n    timefield: (0, _courier.isDefaultTypeIndexPattern)($scope.indexPattern) && $scope.indexPattern.timeFieldName,\n    savedSearch: savedSearch,\n    indexPatternList: $route.current.locals.ip.list\n  };\n\n  var init = _lodash2.default.once(function () {\n    stateMonitor = _state_monitor_factory.stateMonitorFactory.create($state, getStateDefaults());\n    stateMonitor.onChange(function (status) {\n      $appStatus.dirty = status.dirty || !savedSearch.id;\n    });\n    $scope.$on('$destroy', function () {\n      return stateMonitor.destroy();\n    });\n\n    $scope.updateDataSource().then(function () {\n      $scope.$listen(_timefilter.timefilter, 'fetch', function () {\n        $scope.fetch();\n      });\n\n      $scope.$watchCollection('state.sort', function (sort) {\n        if (!sort) return;\n\n        // get the current sort from {key: val} to [\"key\", \"val\"];\n        var currentSort = _lodash2.default.pairs($scope.searchSource.getField('sort')).pop();\n\n        // if the searchSource doesn't know, tell it so\n        if (!_angular2.default.equals(sort, currentSort)) $scope.fetch();\n      });\n\n      // update data source when filters update\n      $scope.$listen(queryFilter, 'update', function () {\n        return $scope.updateDataSource().then(function () {\n          $state.save();\n        });\n      });\n\n      // update data source when hitting forward/back and the query changes\n      $scope.$listen($state, 'fetch_with_changes', function (diff) {\n        if (diff.indexOf('query') >= 0) $scope.fetch();\n      });\n\n      // fetch data when filters fire fetch event\n      $scope.$listen(queryFilter, 'fetch', $scope.fetch);\n\n      _timefilter.timefilter.enableAutoRefreshSelector();\n      $scope.$watch('opts.timefield', function (timefield) {\n        if (!!timefield) {\n          _timefilter.timefilter.enableTimeRangeSelector();\n        } else {\n          _timefilter.timefilter.disableTimeRangeSelector();\n        }\n      });\n\n      $scope.$watch('state.interval', function () {\n        $scope.fetch();\n      });\n\n      $scope.$watch('vis.aggs', function () {\n        // no timefield, no vis, nothing to update\n        if (!$scope.opts.timefield) return;\n\n        var buckets = $scope.vis.getAggConfig().bySchemaGroup.buckets;\n\n        if (buckets && buckets.length === 1) {\n          $scope.bucketInterval = buckets[0].buckets.getInterval();\n        }\n      });\n\n      $scope.$watch('state.query', function (newQuery) {\n        var query = (0, _migrate_legacy_query.migrateLegacyQuery)(newQuery);\n        $scope.updateQueryAndFetch({ query: query });\n      });\n\n      $scope.$watchMulti(['rows', 'fetchStatus'], function updateResultState() {\n        var prev = {};\n        var status = {\n          LOADING: 'loading', // initial data load\n          READY: 'ready', // results came back\n          NO_RESULTS: 'none' // no results came back\n        };\n\n        function pick(rows, oldRows, fetchStatus) {\n          // initial state, pretend we are loading\n          if (rows == null && oldRows == null) return status.LOADING;\n\n          var rowsEmpty = _lodash2.default.isEmpty(rows);\n          // An undefined fetchStatus means the requests are still being\n          // prepared to be sent. When all requests are completed,\n          // fetchStatus is set to null, so it's important that we\n          // specifically check for undefined to determine a loading status.\n          var preparingForFetch = _lodash2.default.isUndefined(fetchStatus);\n          if (preparingForFetch) return status.LOADING;else if (rowsEmpty && fetchStatus) return status.LOADING;else if (!rowsEmpty) return status.READY;else return status.NO_RESULTS;\n        }\n\n        return function () {\n          var current = {\n            rows: $scope.rows,\n            fetchStatus: $scope.fetchStatus\n          };\n\n          $scope.resultState = pick(current.rows, prev.rows, current.fetchStatus, prev.fetchStatus);\n\n          prev = current;\n        };\n      }());\n\n      if ($scope.opts.timefield) {\n        setupVisualization();\n        $scope.updateTime();\n      }\n\n      init.complete = true;\n      $state.replace();\n    });\n  });\n\n  $scope.opts.fetch = $scope.fetch = function () {\n    // ignore requests to fetch before the app inits\n    if (!init.complete) return;\n\n    $scope.fetchError = undefined;\n\n    $scope.updateTime();\n\n    $scope.updateDataSource().then(setupVisualization).then(function () {\n      $state.save();\n      return courier.fetch();\n    }).catch(notify.error);\n  };\n\n  $scope.updateQueryAndFetch = function (_ref11) {\n    var query = _ref11.query;\n\n    $state.query = query;\n    $scope.fetch();\n  };\n\n  function handleSegmentedFetch(segmented) {\n    function flushResponseData() {\n      $scope.fetchError = undefined;\n      $scope.hits = 0;\n      $scope.failures = [];\n      $scope.rows = [];\n      $scope.fieldCounts = {};\n    }\n\n    if (!$scope.rows) flushResponseData();\n\n    var sort = $state.sort;\n    var timeField = $scope.indexPattern.timeFieldName;\n\n    /**\n     * Basically an emum.\n     *\n     * opts:\n     *   \"time\" - sorted by the timefield\n     *   \"non-time\" - explicitly sorted by a non-time field, NOT THE SAME AS `sortBy !== \"time\"`\n     *   \"implicit\" - no sorting set, NOT THE SAME AS \"non-time\"\n     *\n     * @type {String}\n     */\n    var sortBy = function () {\n      if (!Array.isArray(sort)) return 'implicit';else if (sort[0] === '_score') return 'implicit';else if (sort[0] === timeField) return 'time';else return 'non-time';\n    }();\n\n    var sortFn = null;\n    if (sortBy !== 'implicit') {\n      sortFn = new HitSortFn(sort[1]);\n    }\n\n    $scope.updateTime();\n\n    if (sort[0] === '_score') {\n      segmented.setMaxSegments(1);\n    }\n\n    segmented.setDirection(sortBy === 'time' ? sort[1] || 'desc' : 'desc');\n    segmented.setSortFn(sortFn);\n    segmented.setSize($scope.opts.sampleSize);\n\n    var inspectorRequests = [];\n    function logResponseInInspector(resp) {\n      if (inspectorRequests.length > 0) {\n        var inspectorRequest = inspectorRequests.shift();\n        inspectorRequest.stats((0, _courier_inspector_utils.getResponseInspectorStats)($scope.searchSource, resp)).ok({ json: resp });\n      }\n    }\n\n    // triggered when the status updated\n    segmented.on('status', function (status) {\n      $scope.fetchStatus = status;\n      if (status.complete === 0) {\n        // starting new segmented search request\n        inspectorAdapters.requests.reset();\n        inspectorRequests = [];\n      }\n\n      if (status.remaining > 0) {\n        var inspectorRequest = inspectorAdapters.requests.start(i18n('kbn.discover.inspectorRequest.segmentFetchCompleteStatusTitle', {\n          defaultMessage: 'Segment {fetchCompleteStatus}',\n          values: {\n            fetchCompleteStatus: $scope.fetchStatus.complete\n          }\n        }), {\n          description: i18n('kbn.discover.inspectorRequest.segmentFetchCompleteStatusDescription', {\n            defaultMessage: 'This request queries Elasticsearch to fetch the data for the search.'\n          })\n        });\n        inspectorRequest.stats((0, _courier_inspector_utils.getRequestInspectorStats)($scope.searchSource));\n        $scope.searchSource.getSearchRequestBody().then(function (body) {\n          inspectorRequest.json(body);\n        });\n        inspectorRequests.push(inspectorRequest);\n      }\n    });\n\n    segmented.on('first', function () {\n      flushResponseData();\n    });\n\n    segmented.on('segment', function (resp) {\n      logResponseInInspector(resp);\n      if (resp._shards.failed > 0) {\n        $scope.failures = _lodash2.default.union($scope.failures, resp._shards.failures);\n        $scope.failures = _lodash2.default.uniq($scope.failures, false, function (failure) {\n          return failure.index + failure.shard + failure.reason;\n        });\n      }\n    });\n\n    segmented.on('emptySegment', function (resp) {\n      logResponseInInspector(resp);\n    });\n\n    segmented.on('mergedSegment', function (merged) {\n      $scope.mergedEsResp = merged;\n\n      if ($scope.opts.timefield) {\n        var tabifiedData = (0, _tabify.tabifyAggResponse)($scope.vis.aggs, merged);\n        $scope.searchSource.rawResponse = merged;\n        Promise.resolve(responseHandler(tabifiedData)).then(function (resp) {\n          visualizeHandler.render(resp);\n        });\n      }\n\n      $scope.hits = merged.hits.total;\n\n      var indexPattern = $scope.searchSource.getField('index');\n\n      // the merge rows, use a new array to help watchers\n      $scope.rows = merged.hits.hits.slice();\n\n      var counts = $scope.fieldCounts;\n\n      // if we haven't counted yet, or need a fresh count because we are sorting, reset the counts\n      if (!counts || sortFn) counts = $scope.fieldCounts = {};\n\n      $scope.rows.forEach(function (hit) {\n        // skip this work if we have already done it\n        if (hit.$$_counted) return;\n\n        // when we are sorting results, we need to redo the counts each time because the\n        // \"top 500\" may change with each response, so don't mark this as counted\n        if (!sortFn) hit.$$_counted = true;\n\n        var fields = _lodash2.default.keys(indexPattern.flattenHit(hit));\n        var n = fields.length;\n        var field = void 0;\n        while (field = fields[--n]) {\n          if (counts[field]) counts[field] += 1;else counts[field] = 1;\n        }\n      });\n    });\n\n    segmented.on('complete', function () {\n      if ($scope.fetchStatus.hitCount === 0) {\n        flushResponseData();\n      }\n\n      $scope.fetchStatus = null;\n    });\n  }\n\n  function beginSegmentedFetch() {\n    $scope.searchSource.onBeginSegmentedFetch(handleSegmentedFetch).catch(function (error) {\n      var fetchError = (0, _get_painless_error.getPainlessError)(error);\n\n      if (fetchError) {\n        $scope.fetchError = fetchError;\n      } else {\n        notify.error(error);\n      }\n\n      // Restart. This enables auto-refresh functionality.\n      beginSegmentedFetch();\n    });\n  }\n  beginSegmentedFetch();\n\n  $scope.updateTime = function () {\n    $scope.timeRange = {\n      from: _datemath2.default.parse(_timefilter.timefilter.getTime().from),\n      to: _datemath2.default.parse(_timefilter.timefilter.getTime().to, { roundUp: true })\n    };\n  };\n\n  $scope.resetQuery = function () {\n    kbnUrl.change('/discover/{{id}}', { id: $route.current.params.id });\n  };\n\n  $scope.newQuery = function () {\n    kbnUrl.change('/discover');\n  };\n\n  $scope.updateDataSource = Promise.method(function updateDataSource() {\n    $scope.searchSource.setField('size', $scope.opts.sampleSize).setField('sort', (0, _get_sort.getSort)($state.sort, $scope.indexPattern)).setField('query', !$state.query ? null : $state.query).setField('filter', queryFilter.getFilters());\n  });\n\n  $scope.setSortOrder = function setSortOrder(columnName, direction) {\n    $scope.state.sort = [columnName, direction];\n  };\n\n  // TODO: On array fields, negating does not negate the combination, rather all terms\n  $scope.filterQuery = function (field, values, operation) {\n    $scope.indexPattern.popularizeField(field, 1);\n    filterActions.addFilter(field, values, operation, $scope.indexPattern.id, $scope.state, filterManager);\n  };\n\n  $scope.addColumn = function addColumn(columnName) {\n    $scope.indexPattern.popularizeField(columnName, 1);\n    columnActions.addColumn($scope.state.columns, columnName);\n  };\n\n  $scope.removeColumn = function removeColumn(columnName) {\n    $scope.indexPattern.popularizeField(columnName, 1);\n    columnActions.removeColumn($scope.state.columns, columnName);\n  };\n\n  $scope.moveColumn = function moveColumn(columnName, newIndex) {\n    columnActions.moveColumn($scope.state.columns, columnName, newIndex);\n  };\n\n  $scope.scrollToTop = function () {\n    $window.scrollTo(0, 0);\n  };\n\n  $scope.scrollToBottom = function () {\n    // delay scrolling to after the rows have been rendered\n    $timeout(function () {\n      $element.find('#discoverBottomMarker').focus();\n    }, 0);\n  };\n\n  $scope.showAllRows = function () {\n    $scope.minimumVisibleRows = $scope.hits;\n  };\n\n  function resolveIndexPatternLoading() {\n    var _$route$current$local = $route.current.locals.ip,\n        loadedIndexPattern = _$route$current$local.loaded,\n        stateVal = _$route$current$local.stateVal,\n        stateValFound = _$route$current$local.stateValFound;\n\n\n    var ownIndexPattern = $scope.searchSource.getOwnField('index');\n\n    if (ownIndexPattern && !stateVal) {\n      return ownIndexPattern;\n    }\n\n    if (stateVal && !stateValFound) {\n      var warningTitle = i18n('kbn.discover.valueIsNotConfiguredIndexPatternIDWarningTitle', {\n        defaultMessage: '{stateVal} is not a configured index pattern ID',\n        values: {\n          stateVal: '\"' + stateVal + '\"'\n        }\n      });\n\n      if (ownIndexPattern) {\n        _notify.toastNotifications.addWarning({\n          title: warningTitle,\n          text: i18n('kbn.discover.showingSavedIndexPatternWarningDescription', {\n            defaultMessage: 'Showing the saved index pattern: \"{ownIndexPatternTitle}\" ({ownIndexPatternId})',\n            values: {\n              ownIndexPatternTitle: ownIndexPattern.title,\n              ownIndexPatternId: ownIndexPattern.id\n            }\n          })\n        });\n        return ownIndexPattern;\n      }\n\n      _notify.toastNotifications.addWarning({\n        title: warningTitle,\n        text: i18n('kbn.discover.showingDefaultIndexPatternWarningDescription', {\n          defaultMessage: 'Showing the default index pattern: \"{loadedIndexPatternTitle}\" ({loadedIndexPatternId})',\n          values: {\n            loadedIndexPatternTitle: loadedIndexPattern.title,\n            loadedIndexPatternId: loadedIndexPattern.id\n          }\n        })\n      });\n    }\n\n    return loadedIndexPattern;\n  }\n\n  // Block the UI from loading if the user has loaded a rollup index pattern but it isn't\n  // supported.\n  $scope.isUnsupportedIndexPattern = !(0, _courier.isDefaultTypeIndexPattern)($route.current.locals.ip.loaded) && !(0, _courier.hasSearchStategyForIndexPattern)($route.current.locals.ip.loaded);\n\n  if ($scope.isUnsupportedIndexPattern) {\n    $scope.unsupportedIndexPatternType = $route.current.locals.ip.loaded.type;\n    return;\n  }\n\n  init();\n}",null]}