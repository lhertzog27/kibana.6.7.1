{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/packages/kbn-es-query/target/kuery/functions/is.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/packages/kbn-es-query/target/kuery/functions/is.js","mtime":1567666388143},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;_e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }return _arr;\n  }return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}(); /*\n      * Licensed to Elasticsearch B.V. under one or more contributor\n      * license agreements. See the NOTICE file distributed with\n      * this work for additional information regarding copyright\n      * ownership. Elasticsearch B.V. licenses this file to you under\n      * the Apache License, Version 2.0 (the \"License\"); you may\n      * not use this file except in compliance with the License.\n      * You may obtain a copy of the License at\n      *\n      *    http://www.apache.org/licenses/LICENSE-2.0\n      *\n      * Unless required by applicable law or agreed to in writing,\n      * software distributed under the License is distributed on an\n      * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n      * KIND, either express or implied.  See the License for the\n      * specific language governing permissions and limitations\n      * under the License.\n      */\n\nexports.buildNodeParams = buildNodeParams;\nexports.toElasticsearchQuery = toElasticsearchQuery;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _ast = require('../ast');\n\nvar ast = _interopRequireWildcard(_ast);\n\nvar _literal = require('../node_types/literal');\n\nvar literal = _interopRequireWildcard(_literal);\n\nvar _wildcard = require('../node_types/wildcard');\n\nvar wildcard = _interopRequireWildcard(_wildcard);\n\nvar _filters = require('../../filters');\n\nvar _get_fields = require('./utils/get_fields');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }newObj.default = obj;return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n  } else {\n    obj[key] = value;\n  }return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction buildNodeParams(fieldName, value) {\n  var isPhrase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (_lodash2.default.isUndefined(fieldName)) {\n    throw new Error('fieldName is a required argument');\n  }\n  if (_lodash2.default.isUndefined(value)) {\n    throw new Error('value is a required argument');\n  }\n\n  var fieldNode = typeof fieldName === 'string' ? ast.fromLiteralExpression(fieldName) : literal.buildNode(fieldName);\n  var valueNode = typeof value === 'string' ? ast.fromLiteralExpression(value) : literal.buildNode(value);\n  var isPhraseNode = literal.buildNode(isPhrase);\n\n  return {\n    arguments: [fieldNode, valueNode, isPhraseNode]\n  };\n}\n\nfunction toElasticsearchQuery(node, indexPattern) {\n  var _node$arguments = _slicedToArray(node.arguments, 3),\n      fieldNameArg = _node$arguments[0],\n      valueArg = _node$arguments[1],\n      isPhraseArg = _node$arguments[2];\n\n  var fieldName = ast.toElasticsearchQuery(fieldNameArg);\n  var value = !_lodash2.default.isUndefined(valueArg) ? ast.toElasticsearchQuery(valueArg) : valueArg;\n  var type = isPhraseArg.value ? 'phrase' : 'best_fields';\n\n  if (fieldNameArg.value === null) {\n    if (valueArg.type === 'wildcard') {\n      return {\n        query_string: {\n          query: wildcard.toQueryStringQuery(valueArg)\n        }\n      };\n    }\n\n    return {\n      multi_match: {\n        type: type,\n        query: value,\n        lenient: true\n      }\n    };\n  }\n\n  var fields = indexPattern ? (0, _get_fields.getFields)(fieldNameArg, indexPattern) : [];\n\n  // If no fields are found in the index pattern we send through the given field name as-is. We do this to preserve\n  // the behaviour of lucene on dashboards where there are panels based on different index patterns that have different\n  // fields. If a user queries on a field that exists in one pattern but not the other, the index pattern without the\n  // field should return no results. It's debatable whether this is desirable, but it's been that way forever, so we'll\n  // keep things familiar for now.\n  if (fields && fields.length === 0) {\n    fields.push({\n      name: ast.toElasticsearchQuery(fieldNameArg),\n      scripted: false\n    });\n  }\n\n  var isExistsQuery = valueArg.type === 'wildcard' && value === '*';\n  var isAllFieldsQuery = fieldNameArg.type === 'wildcard' && fieldName === '*' || fields && indexPattern && fields.length === indexPattern.fields.length;\n  var isMatchAllQuery = isExistsQuery && isAllFieldsQuery;\n\n  if (isMatchAllQuery) {\n    return { match_all: {} };\n  }\n\n  var queries = fields.reduce(function (accumulator, field) {\n    if (field.scripted) {\n      // Exists queries don't make sense for scripted fields\n      if (!isExistsQuery) {\n        return [].concat(_toConsumableArray(accumulator), [{\n          script: _extends({}, (0, _filters.getPhraseScript)(field, value))\n        }]);\n      }\n    } else if (isExistsQuery) {\n      return [].concat(_toConsumableArray(accumulator), [{\n        exists: {\n          field: field.name\n        }\n      }]);\n    } else if (valueArg.type === 'wildcard') {\n      return [].concat(_toConsumableArray(accumulator), [{\n        query_string: {\n          fields: [field.name],\n          query: wildcard.toQueryStringQuery(valueArg)\n        }\n      }]);\n    } else {\n      var queryType = type === 'phrase' ? 'match_phrase' : 'match';\n      return [].concat(_toConsumableArray(accumulator), [_defineProperty({}, queryType, _defineProperty({}, field.name, value))]);\n    }\n  }, []);\n\n  return {\n    bool: {\n      should: queries,\n      minimum_should_match: 1\n    }\n  };\n}",null]}