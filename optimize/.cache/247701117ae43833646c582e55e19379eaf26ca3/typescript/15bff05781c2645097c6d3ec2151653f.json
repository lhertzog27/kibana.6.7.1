{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/src/core/public/ui_settings/ui_settings_api.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/core/public/ui_settings/ui_settings_api.ts","mtime":1567631711499},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { BehaviorSubject } from 'rxjs';\nvar NOOP_CHANGES = {\n    values: {},\n    callback: function () {\n        // noop\n    },\n};\nvar UiSettingsApi = /** @class */ (function () {\n    function UiSettingsApi(basePath, kibanaVersion) {\n        this.basePath = basePath;\n        this.kibanaVersion = kibanaVersion;\n        this.sendInProgress = false;\n        this.loadingCount$ = new BehaviorSubject(0);\n    }\n    /**\n     * Adds a key+value that will be sent to the server ASAP. If a request is\n     * already in progress it will wait until the previous request is complete\n     * before sending the next request\n     */\n    UiSettingsApi.prototype.batchSet = function (key, value) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var _a;\n            var prev = _this.pendingChanges || NOOP_CHANGES;\n            _this.pendingChanges = {\n                values: tslib_1.__assign({}, prev.values, (_a = {}, _a[key] = value, _a)),\n                callback: function (error, resp) {\n                    prev.callback(error, resp);\n                    if (error) {\n                        reject(error);\n                    }\n                    else {\n                        resolve(resp);\n                    }\n                },\n            };\n            _this.flushPendingChanges();\n        });\n    };\n    /**\n     * Gets an observable that notifies subscribers of the current number of active requests\n     */\n    UiSettingsApi.prototype.getLoadingCount$ = function () {\n        return this.loadingCount$.asObservable();\n    };\n    /**\n     * Prepares the uiSettings API to be discarded\n     */\n    UiSettingsApi.prototype.stop = function () {\n        this.loadingCount$.complete();\n    };\n    /**\n     * If there are changes that need to be sent to the server and there is not already a\n     * request in progress, this method will start a request sending those changes. Once\n     * the request is complete `flushPendingChanges()` will be called again, and if the\n     * prerequisites are still true (because changes were queued while the request was in\n     * progress) then another request will be started until all pending changes have been\n     * sent to the server.\n     */\n    UiSettingsApi.prototype.flushPendingChanges = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var changes, _a, _b, _c, error_1;\n            return tslib_1.__generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        if (!this.pendingChanges) {\n                            return [2 /*return*/];\n                        }\n                        if (this.sendInProgress) {\n                            return [2 /*return*/];\n                        }\n                        changes = this.pendingChanges;\n                        this.pendingChanges = undefined;\n                        _d.label = 1;\n                    case 1:\n                        _d.trys.push([1, 3, 4, 5]);\n                        this.sendInProgress = true;\n                        _b = (_a = changes).callback;\n                        _c = [undefined];\n                        return [4 /*yield*/, this.sendRequest('POST', '/api/kibana/settings', {\n                                changes: changes.values,\n                            })];\n                    case 2:\n                        _b.apply(_a, _c.concat([_d.sent()]));\n                        return [3 /*break*/, 5];\n                    case 3:\n                        error_1 = _d.sent();\n                        changes.callback(error_1);\n                        return [3 /*break*/, 5];\n                    case 4:\n                        this.sendInProgress = false;\n                        this.flushPendingChanges();\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Calls window.fetch() with the proper headers and error handling logic.\n     *\n     * TODO: migrate this to kfetch or whatever the new platform equivalent is once it exists\n     */\n    UiSettingsApi.prototype.sendRequest = function (method, path, body) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var response;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, , 3, 4]);\n                        this.loadingCount$.next(this.loadingCount$.getValue() + 1);\n                        return [4 /*yield*/, fetch(this.basePath.addToPath(path), {\n                                method: method,\n                                body: JSON.stringify(body),\n                                headers: {\n                                    accept: 'application/json',\n                                    'content-type': 'application/json',\n                                    'kbn-version': this.kibanaVersion,\n                                },\n                                credentials: 'same-origin',\n                            })];\n                    case 1:\n                        response = _a.sent();\n                        if (response.status >= 300) {\n                            throw new Error(\"Request failed with status code: \" + response.status);\n                        }\n                        return [4 /*yield*/, response.json()];\n                    case 2: return [2 /*return*/, _a.sent()];\n                    case 3:\n                        this.loadingCount$.next(this.loadingCount$.getValue() - 1);\n                        return [7 /*endfinally*/];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return UiSettingsApi;\n}());\nexport { UiSettingsApi };\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/src/core/public/ui_settings/ui_settings_api.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/src/core/public/ui_settings/ui_settings_api.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { BehaviorSubject } from 'rxjs';\n\nimport { BasePathStartContract } from '../base_path';\nimport { UiSettingsState } from './types';\n\nexport interface UiSettingsApiResponse {\n  settings: UiSettingsState;\n}\n\ninterface Changes {\n  values: {\n    [key: string]: any;\n  };\n\n  callback(error?: Error, response?: UiSettingsApiResponse): void;\n}\n\nconst NOOP_CHANGES = {\n  values: {},\n  callback: () => {\n    // noop\n  },\n};\n\nexport class UiSettingsApi {\n  private pendingChanges?: Changes;\n  private sendInProgress = false;\n\n  private readonly loadingCount$ = new BehaviorSubject(0);\n\n  constructor(\n    private readonly basePath: BasePathStartContract,\n    private readonly kibanaVersion: string\n  ) {}\n\n  /**\n   * Adds a key+value that will be sent to the server ASAP. If a request is\n   * already in progress it will wait until the previous request is complete\n   * before sending the next request\n   */\n  public batchSet(key: string, value: any) {\n    return new Promise<UiSettingsApiResponse>((resolve, reject) => {\n      const prev = this.pendingChanges || NOOP_CHANGES;\n\n      this.pendingChanges = {\n        values: {\n          ...prev.values,\n          [key]: value,\n        },\n\n        callback(error, resp) {\n          prev.callback(error, resp);\n\n          if (error) {\n            reject(error);\n          } else {\n            resolve(resp);\n          }\n        },\n      };\n\n      this.flushPendingChanges();\n    });\n  }\n\n  /**\n   * Gets an observable that notifies subscribers of the current number of active requests\n   */\n  public getLoadingCount$() {\n    return this.loadingCount$.asObservable();\n  }\n\n  /**\n   * Prepares the uiSettings API to be discarded\n   */\n  public stop() {\n    this.loadingCount$.complete();\n  }\n\n  /**\n   * If there are changes that need to be sent to the server and there is not already a\n   * request in progress, this method will start a request sending those changes. Once\n   * the request is complete `flushPendingChanges()` will be called again, and if the\n   * prerequisites are still true (because changes were queued while the request was in\n   * progress) then another request will be started until all pending changes have been\n   * sent to the server.\n   */\n  private async flushPendingChanges() {\n    if (!this.pendingChanges) {\n      return;\n    }\n\n    if (this.sendInProgress) {\n      return;\n    }\n\n    const changes = this.pendingChanges;\n    this.pendingChanges = undefined;\n\n    try {\n      this.sendInProgress = true;\n      changes.callback(\n        undefined,\n        await this.sendRequest('POST', '/api/kibana/settings', {\n          changes: changes.values,\n        })\n      );\n    } catch (error) {\n      changes.callback(error);\n    } finally {\n      this.sendInProgress = false;\n      this.flushPendingChanges();\n    }\n  }\n\n  /**\n   * Calls window.fetch() with the proper headers and error handling logic.\n   *\n   * TODO: migrate this to kfetch or whatever the new platform equivalent is once it exists\n   */\n  private async sendRequest(method: string, path: string, body: any) {\n    try {\n      this.loadingCount$.next(this.loadingCount$.getValue() + 1);\n      const response = await fetch(this.basePath.addToPath(path), {\n        method,\n        body: JSON.stringify(body),\n        headers: {\n          accept: 'application/json',\n          'content-type': 'application/json',\n          'kbn-version': this.kibanaVersion,\n        },\n        credentials: 'same-origin',\n      });\n\n      if (response.status >= 300) {\n        throw new Error(`Request failed with status code: ${response.status}`);\n      }\n\n      return await response.json();\n    } finally {\n      this.loadingCount$.next(this.loadingCount$.getValue() - 1);\n    }\n  }\n}\n"]}]}