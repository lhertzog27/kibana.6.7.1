{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/src/ui/public/time_buckets/calc_auto_interval.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/time_buckets/calc_auto_interval.ts","mtime":1567631711760},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport moment from 'moment';\nvar boundsDescending = [\n    {\n        bound: Infinity,\n        interval: Number(moment.duration(1, 'year')),\n    },\n    {\n        bound: Number(moment.duration(1, 'year')),\n        interval: Number(moment.duration(1, 'month')),\n    },\n    {\n        bound: Number(moment.duration(3, 'week')),\n        interval: Number(moment.duration(1, 'week')),\n    },\n    {\n        bound: Number(moment.duration(1, 'week')),\n        interval: Number(moment.duration(1, 'd')),\n    },\n    {\n        bound: Number(moment.duration(24, 'hour')),\n        interval: Number(moment.duration(12, 'hour')),\n    },\n    {\n        bound: Number(moment.duration(6, 'hour')),\n        interval: Number(moment.duration(3, 'hour')),\n    },\n    {\n        bound: Number(moment.duration(2, 'hour')),\n        interval: Number(moment.duration(1, 'hour')),\n    },\n    {\n        bound: Number(moment.duration(45, 'minute')),\n        interval: Number(moment.duration(30, 'minute')),\n    },\n    {\n        bound: Number(moment.duration(20, 'minute')),\n        interval: Number(moment.duration(10, 'minute')),\n    },\n    {\n        bound: Number(moment.duration(9, 'minute')),\n        interval: Number(moment.duration(5, 'minute')),\n    },\n    {\n        bound: Number(moment.duration(3, 'minute')),\n        interval: Number(moment.duration(1, 'minute')),\n    },\n    {\n        bound: Number(moment.duration(45, 'second')),\n        interval: Number(moment.duration(30, 'second')),\n    },\n    {\n        bound: Number(moment.duration(15, 'second')),\n        interval: Number(moment.duration(10, 'second')),\n    },\n    {\n        bound: Number(moment.duration(7.5, 'second')),\n        interval: Number(moment.duration(5, 'second')),\n    },\n    {\n        bound: Number(moment.duration(5, 'second')),\n        interval: Number(moment.duration(1, 'second')),\n    },\n    {\n        bound: Number(moment.duration(500, 'ms')),\n        interval: Number(moment.duration(100, 'ms')),\n    },\n];\nfunction getPerBucketMs(count, duration) {\n    var ms = duration / count;\n    return isFinite(ms) ? ms : NaN;\n}\nfunction normalizeMinimumInterval(targetMs) {\n    var value = isNaN(targetMs) ? 0 : Math.max(Math.floor(targetMs), 1);\n    return moment.duration(value);\n}\n/**\n * Using some simple rules we pick a \"pretty\" interval that will\n * produce around the number of buckets desired given a time range.\n *\n * @param targetBucketCount desired number of buckets\n * @param duration time range the agg covers\n */\nexport function calcAutoIntervalNear(targetBucketCount, duration) {\n    var targetPerBucketMs = getPerBucketMs(targetBucketCount, duration);\n    // Find the first bound which is smaller than our target.\n    var lowerBoundIndex = boundsDescending.findIndex(function (_a) {\n        var bound = _a.bound;\n        var boundMs = Number(bound);\n        return boundMs <= targetPerBucketMs;\n    });\n    // The bound immediately preceeding that lower bound contains the\n    // interval most closely matching our target.\n    if (lowerBoundIndex !== -1) {\n        var nearestInterval = boundsDescending[lowerBoundIndex - 1].interval;\n        return moment.duration(nearestInterval);\n    }\n    // If the target is smaller than any of our bounds, then we'll use it for the interval as-is.\n    return normalizeMinimumInterval(targetPerBucketMs);\n}\n/**\n * Pick a \"pretty\" interval that produces no more than the maxBucketCount\n * for the given time range.\n *\n * @param maxBucketCount maximum number of buckets to create\n * @param duration amount of time covered by the agg\n */\nexport function calcAutoIntervalLessThan(maxBucketCount, duration) {\n    var e_1, _a;\n    var maxPerBucketMs = getPerBucketMs(maxBucketCount, duration);\n    try {\n        for (var boundsDescending_1 = tslib_1.__values(boundsDescending), boundsDescending_1_1 = boundsDescending_1.next(); !boundsDescending_1_1.done; boundsDescending_1_1 = boundsDescending_1.next()) {\n            var interval = boundsDescending_1_1.value.interval;\n            // Find the highest interval which meets our per bucket limitation.\n            if (interval <= maxPerBucketMs) {\n                return moment.duration(interval);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (boundsDescending_1_1 && !boundsDescending_1_1.done && (_a = boundsDescending_1.return)) _a.call(boundsDescending_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // If the max is smaller than any of our intervals, then we'll use it for the interval as-is.\n    return normalizeMinimumInterval(maxPerBucketMs);\n}\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/src/ui/public/time_buckets/calc_auto_interval.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/src/ui/public/time_buckets/calc_auto_interval.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport moment from 'moment';\n\nconst boundsDescending = [\n  {\n    bound: Infinity,\n    interval: Number(moment.duration(1, 'year')),\n  },\n  {\n    bound: Number(moment.duration(1, 'year')),\n    interval: Number(moment.duration(1, 'month')),\n  },\n  {\n    bound: Number(moment.duration(3, 'week')),\n    interval: Number(moment.duration(1, 'week')),\n  },\n  {\n    bound: Number(moment.duration(1, 'week')),\n    interval: Number(moment.duration(1, 'd')),\n  },\n  {\n    bound: Number(moment.duration(24, 'hour')),\n    interval: Number(moment.duration(12, 'hour')),\n  },\n  {\n    bound: Number(moment.duration(6, 'hour')),\n    interval: Number(moment.duration(3, 'hour')),\n  },\n  {\n    bound: Number(moment.duration(2, 'hour')),\n    interval: Number(moment.duration(1, 'hour')),\n  },\n  {\n    bound: Number(moment.duration(45, 'minute')),\n    interval: Number(moment.duration(30, 'minute')),\n  },\n  {\n    bound: Number(moment.duration(20, 'minute')),\n    interval: Number(moment.duration(10, 'minute')),\n  },\n  {\n    bound: Number(moment.duration(9, 'minute')),\n    interval: Number(moment.duration(5, 'minute')),\n  },\n  {\n    bound: Number(moment.duration(3, 'minute')),\n    interval: Number(moment.duration(1, 'minute')),\n  },\n  {\n    bound: Number(moment.duration(45, 'second')),\n    interval: Number(moment.duration(30, 'second')),\n  },\n  {\n    bound: Number(moment.duration(15, 'second')),\n    interval: Number(moment.duration(10, 'second')),\n  },\n  {\n    bound: Number(moment.duration(7.5, 'second')),\n    interval: Number(moment.duration(5, 'second')),\n  },\n  {\n    bound: Number(moment.duration(5, 'second')),\n    interval: Number(moment.duration(1, 'second')),\n  },\n  {\n    bound: Number(moment.duration(500, 'ms')),\n    interval: Number(moment.duration(100, 'ms')),\n  },\n];\n\nfunction getPerBucketMs(count: number, duration: number) {\n  const ms = duration / count;\n  return isFinite(ms) ? ms : NaN;\n}\n\nfunction normalizeMinimumInterval(targetMs: number) {\n  const value = isNaN(targetMs) ? 0 : Math.max(Math.floor(targetMs), 1);\n  return moment.duration(value);\n}\n\n/**\n * Using some simple rules we pick a \"pretty\" interval that will\n * produce around the number of buckets desired given a time range.\n *\n * @param targetBucketCount desired number of buckets\n * @param duration time range the agg covers\n */\nexport function calcAutoIntervalNear(targetBucketCount: number, duration: number) {\n  const targetPerBucketMs = getPerBucketMs(targetBucketCount, duration);\n\n  // Find the first bound which is smaller than our target.\n  const lowerBoundIndex = boundsDescending.findIndex(({ bound }) => {\n    const boundMs = Number(bound);\n    return boundMs <= targetPerBucketMs;\n  });\n\n  // The bound immediately preceeding that lower bound contains the\n  // interval most closely matching our target.\n  if (lowerBoundIndex !== -1) {\n    const nearestInterval = boundsDescending[lowerBoundIndex - 1].interval;\n    return moment.duration(nearestInterval);\n  }\n\n  // If the target is smaller than any of our bounds, then we'll use it for the interval as-is.\n  return normalizeMinimumInterval(targetPerBucketMs);\n}\n\n/**\n * Pick a \"pretty\" interval that produces no more than the maxBucketCount\n * for the given time range.\n *\n * @param maxBucketCount maximum number of buckets to create\n * @param duration amount of time covered by the agg\n */\nexport function calcAutoIntervalLessThan(maxBucketCount: number, duration: number) {\n  const maxPerBucketMs = getPerBucketMs(maxBucketCount, duration);\n\n  for (const { interval } of boundsDescending) {\n    // Find the highest interval which meets our per bucket limitation.\n    if (interval <= maxPerBucketMs) {\n      return moment.duration(interval);\n    }\n  }\n\n  // If the max is smaller than any of our intervals, then we'll use it for the interval as-is.\n  return normalizeMinimumInterval(maxPerBucketMs);\n}\n"]}]}