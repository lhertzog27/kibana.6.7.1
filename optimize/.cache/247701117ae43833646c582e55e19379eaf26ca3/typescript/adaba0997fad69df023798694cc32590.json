{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/src/ui/public/timefilter/get_time.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/timefilter/get_time.ts","mtime":1567631711761},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport dateMath from '@elastic/datemath';\nimport { find } from 'lodash';\nexport function calculateBounds(timeRange, options) {\n    if (options === void 0) { options = {}; }\n    return {\n        min: dateMath.parse(timeRange.from, { forceNow: options.forceNow }),\n        max: dateMath.parse(timeRange.to, { roundUp: true, forceNow: options.forceNow }),\n    };\n}\nexport function getTime(indexPattern, timeRange, forceNow) {\n    if (!indexPattern) {\n        // in CI, we sometimes seem to fail here.\n        return;\n    }\n    var filter;\n    var timefield = indexPattern.timeFieldName && find(indexPattern.fields, { name: indexPattern.timeFieldName });\n    if (!timefield) {\n        return;\n    }\n    var bounds = calculateBounds(timeRange, { forceNow: forceNow });\n    if (!bounds) {\n        return;\n    }\n    filter = { range: {} };\n    var min = bounds.min ? bounds.min.valueOf() : 0;\n    var max = bounds.max ? bounds.max.valueOf() : 0;\n    filter.range[timefield.name] = {\n        gte: min,\n        lte: max,\n        format: 'epoch_millis',\n    };\n    return filter;\n}\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/src/ui/public/timefilter/get_time.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/src/ui/public/timefilter/get_time.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;GAiBG;AAEH,OAAO,QAAQ,MAAM,mBAAmB,CAAC;AACzC,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAsB9B,MAAM,UAAU,eAAe,CAAC,SAAoB,EAAE,OAAoC;IAApC,wBAAA,EAAA,YAAoC;IACxF,OAAO;QACL,GAAG,EAAE,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,EAAE,EAAE,QAAQ,EAAE,OAAO,CAAC,QAAQ,EAAE,CAAC;QACnE,GAAG,EAAE,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,QAAQ,EAAE,CAAC;KACjF,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,OAAO,CACrB,YAA0B,EAC1B,SAAoB,EACpB,QAAe;IAEf,IAAI,CAAC,YAAY,EAAE;QACjB,yCAAyC;QACzC,OAAO;KACR;IAED,IAAI,MAAc,CAAC;IACnB,IAAM,SAAS,GACb,YAAY,CAAC,aAAa,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,EAAE,IAAI,EAAE,YAAY,CAAC,aAAa,EAAE,CAAC,CAAC;IAEhG,IAAI,CAAC,SAAS,EAAE;QACd,OAAO;KACR;IAED,IAAM,MAAM,GAAG,eAAe,CAAC,SAAS,EAAE,EAAE,QAAQ,UAAA,EAAE,CAAC,CAAC;IACxD,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IACD,MAAM,GAAG,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC;IACvB,IAAM,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAClD,IAAM,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAClD,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG;QAC7B,GAAG,EAAE,GAAG;QACR,GAAG,EAAE,GAAG;QACR,MAAM,EAAE,cAAc;KACvB,CAAC;IAEF,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport dateMath from '@elastic/datemath';\nimport { find } from 'lodash';\nimport { IndexPattern } from 'ui/index_patterns';\n\ninterface CalculateBoundsOptions {\n  forceNow?: Date;\n}\n\ninterface TimeRange {\n  to: string;\n  from: string;\n}\n\ninterface RangeFilter {\n  gte?: number;\n  lte?: number;\n  format: string;\n}\n\ninterface Filter {\n  range: { [s: string]: RangeFilter };\n}\n\nexport function calculateBounds(timeRange: TimeRange, options: CalculateBoundsOptions = {}) {\n  return {\n    min: dateMath.parse(timeRange.from, { forceNow: options.forceNow }),\n    max: dateMath.parse(timeRange.to, { roundUp: true, forceNow: options.forceNow }),\n  };\n}\n\nexport function getTime(\n  indexPattern: IndexPattern,\n  timeRange: TimeRange,\n  forceNow?: Date\n): Filter | undefined {\n  if (!indexPattern) {\n    // in CI, we sometimes seem to fail here.\n    return;\n  }\n\n  let filter: Filter;\n  const timefield: { name: string } | undefined =\n    indexPattern.timeFieldName && find(indexPattern.fields, { name: indexPattern.timeFieldName });\n\n  if (!timefield) {\n    return;\n  }\n\n  const bounds = calculateBounds(timeRange, { forceNow });\n  if (!bounds) {\n    return;\n  }\n  filter = { range: {} };\n  const min = bounds.min ? bounds.min.valueOf() : 0;\n  const max = bounds.max ? bounds.max.valueOf() : 0;\n  filter.range[timefield.name] = {\n    gte: min,\n    lte: max,\n    format: 'epoch_millis',\n  };\n\n  return filter;\n}\n"]}]}