{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/src/ui/public/visualize/loader/embedded_visualize_handler.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/visualize/loader/embedded_visualize_handler.ts","mtime":1567631711781},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { EventEmitter } from 'events';\nimport { debounce, forEach } from 'lodash';\nimport * as Rx from 'rxjs';\nimport { share } from 'rxjs/operators';\nimport { Inspector } from '../../inspector';\nimport { RenderCompleteHelper } from '../../render_complete';\nimport { timefilter } from '../../timefilter';\nimport { visualizationLoader } from './visualization_loader';\nimport { VisualizeDataLoader } from './visualize_data_loader';\nimport { DataAdapter, RequestAdapter } from '../../inspector/adapters';\nimport { queryGeohashBounds } from './utils';\nvar RENDER_COMPLETE_EVENT = 'render_complete';\nvar LOADING_ATTRIBUTE = 'data-loading';\nvar RENDERING_COUNT_ATTRIBUTE = 'data-rendering-count';\n/**\n * A handler to the embedded visualization. It offers several methods to interact\n * with the visualization.\n */\nvar EmbeddedVisualizeHandler = /** @class */ (function () {\n    function EmbeddedVisualizeHandler(element, savedObject, params) {\n        var _this = this;\n        this.element = element;\n        this.inspectorAdapters = {};\n        this.loaded = false;\n        this.destroyed = false;\n        this.listeners = new EventEmitter();\n        this.shouldForceNextFetch = false;\n        this.debouncedFetchAndRender = debounce(function () {\n            if (_this.destroyed) {\n                return;\n            }\n            var forceFetch = _this.shouldForceNextFetch;\n            _this.shouldForceNextFetch = false;\n            _this.fetch(forceFetch).then(_this.render);\n        }, 100);\n        this.actions = {};\n        /**\n         * renders visualization with provided data\n         * @param visData: visualization data\n         */\n        this.render = function (visData) {\n            if (visData === void 0) { visData = null; }\n            return visualizationLoader\n                .render(_this.element, _this.vis, visData, _this.uiState, {\n                listenOnChange: false,\n            })\n                .then(function () {\n                if (!_this.loaded) {\n                    _this.loaded = true;\n                    if (_this.autoFetch) {\n                        _this.fetchAndRender();\n                    }\n                }\n            });\n        };\n        /**\n         * Opens the inspector for the embedded visualization. This will return an\n         * handler to the inspector to close and interact with it.\n         * @return An inspector session to interact with the opened inspector.\n         */\n        this.openInspector = function () {\n            return Inspector.open(_this.inspectorAdapters, {\n                title: _this.vis.title,\n            });\n        };\n        this.hasInspector = function () {\n            return Inspector.isAvailable(_this.inspectorAdapters);\n        };\n        /**\n         * Force the fetch of new data and renders the chart again.\n         */\n        this.reload = function () {\n            _this.fetchAndRender(true);\n        };\n        this.incrementRenderingCount = function () {\n            var renderingCount = Number(_this.element.getAttribute(RENDERING_COUNT_ATTRIBUTE) || 0);\n            _this.element.setAttribute(RENDERING_COUNT_ATTRIBUTE, \"\" + (renderingCount + 1));\n        };\n        this.onRenderCompleteListener = function () {\n            _this.listeners.emit(RENDER_COMPLETE_EVENT);\n            _this.element.removeAttribute(LOADING_ATTRIBUTE);\n            _this.incrementRenderingCount();\n        };\n        this.onUiStateChange = function () {\n            _this.fetchAndRender();\n        };\n        /**\n         * Returns an object of all inspectors for this vis object.\n         * This must only be called after this.type has properly be initialized,\n         * since we need to read out data from the the vis type to check which\n         * inspectors are available.\n         */\n        this.getActiveInspectorAdapters = function () {\n            var adapters = {};\n            var typeAdapters = _this.vis.type.inspectorAdapters;\n            // Add the requests inspector adapters if the vis type explicitly requested it via\n            // inspectorAdapters.requests: true in its definition or if it's using the courier\n            // request handler, since that will automatically log its requests.\n            if ((typeAdapters && typeAdapters.requests) || _this.vis.type.requestHandler === 'courier') {\n                adapters.requests = new RequestAdapter();\n            }\n            // Add the data inspector adapter if the vis type requested it or if the\n            // vis is using courier, since we know that courier supports logging\n            // its data.\n            if ((typeAdapters && typeAdapters.data) || _this.vis.type.requestHandler === 'courier') {\n                adapters.data = new DataAdapter();\n            }\n            // Add all inspectors, that are explicitly registered with this vis type\n            if (typeAdapters && typeAdapters.custom) {\n                Object.entries(typeAdapters.custom).forEach(function (_a) {\n                    var _b = tslib_1.__read(_a, 2), key = _b[0], Adapter = _b[1];\n                    adapters[key] = new Adapter();\n                });\n            }\n            return adapters;\n        };\n        /**\n         * Fetches new data and renders the chart. This will happen debounced for a couple\n         * of milliseconds, to bundle fast successive calls into one fetch and render,\n         * e.g. while resizing the window, this will be triggered constantly on the resize\n         * event.\n         *\n         * @param  forceFetch=false Whether the request handler should be signaled to forceFetch\n         *    (i.e. ignore caching in case it supports it). If at least one call to this\n         *    passed `true` the debounced fetch and render will be a force fetch.\n         */\n        this.fetchAndRender = function (forceFetch) {\n            if (forceFetch === void 0) { forceFetch = false; }\n            _this.shouldForceNextFetch = forceFetch || _this.shouldForceNextFetch;\n            _this.element.setAttribute(LOADING_ATTRIBUTE, '');\n            _this.debouncedFetchAndRender();\n        };\n        this.handleVisUpdate = function () {\n            if (_this.appState) {\n                _this.appState.vis = _this.vis.getState();\n                _this.appState.save();\n            }\n            _this.fetchAndRender();\n        };\n        this.fetch = function (forceFetch) {\n            if (forceFetch === void 0) { forceFetch = false; }\n            _this.dataLoaderParams.aggs = _this.vis.getAggConfig();\n            _this.dataLoaderParams.forceFetch = forceFetch;\n            _this.dataLoaderParams.inspectorAdapters = _this.inspectorAdapters;\n            return _this.dataLoader.fetch(_this.dataLoaderParams).then(function (data) {\n                _this.dataSubject.next(data);\n                return data;\n            });\n        };\n        var searchSource = savedObject.searchSource, vis = savedObject.vis;\n        var appState = params.appState, uiState = params.uiState, queryFilter = params.queryFilter, timeRange = params.timeRange, filters = params.filters, query = params.query, _a = params.autoFetch, autoFetch = _a === void 0 ? true : _a, Private = params.Private;\n        this.dataLoaderParams = {\n            searchSource: searchSource,\n            timeRange: timeRange,\n            query: query,\n            queryFilter: queryFilter,\n            filters: filters,\n            uiState: uiState,\n            aggs: vis.getAggConfig(),\n            forceFetch: false,\n        };\n        // Listen to the first RENDER_COMPLETE_EVENT to resolve this promise\n        this.firstRenderComplete = new Promise(function (resolve) {\n            _this.listeners.once(RENDER_COMPLETE_EVENT, resolve);\n        });\n        element.setAttribute(LOADING_ATTRIBUTE, '');\n        element.setAttribute(RENDERING_COUNT_ATTRIBUTE, '0');\n        element.addEventListener('renderComplete', this.onRenderCompleteListener);\n        this.autoFetch = autoFetch;\n        this.appState = appState;\n        this.vis = vis;\n        if (uiState) {\n            vis._setUiState(uiState);\n        }\n        this.uiState = this.vis.getUiState();\n        this.vis.on('update', this.handleVisUpdate);\n        this.vis.on('reload', this.reload);\n        this.uiState.on('change', this.onUiStateChange);\n        if (autoFetch) {\n            timefilter.on('autoRefreshFetch', this.reload);\n        }\n        // This is a hack to give maps visualizations access to data in the\n        // globalState, since they can no longer access it via searchSource.\n        // TODO: Remove this as a part of elastic/kibana#30593\n        this.vis.API.getGeohashBounds = function () {\n            return queryGeohashBounds(_this.vis, {\n                filters: _this.dataLoaderParams.filters,\n                query: _this.dataLoaderParams.query,\n            });\n        };\n        this.dataLoader = new VisualizeDataLoader(vis, Private);\n        this.renderCompleteHelper = new RenderCompleteHelper(element);\n        this.inspectorAdapters = this.getActiveInspectorAdapters();\n        this.vis.openInspector = this.openInspector;\n        this.vis.hasInspector = this.hasInspector;\n        // init default actions\n        forEach(this.vis.type.events, function (event, eventName) {\n            if (event.disabled || !eventName) {\n                return;\n            }\n            else {\n                _this.actions[eventName] = event.defaultAction;\n            }\n        });\n        this.vis.eventsSubject = new Rx.Subject();\n        this.events$ = this.vis.eventsSubject.asObservable().pipe(share());\n        this.events$.subscribe(function (event) {\n            if (_this.actions[event.name]) {\n                _this.actions[event.name](event.data);\n            }\n        });\n        this.dataSubject = new Rx.Subject();\n        this.data$ = this.dataSubject.asObservable().pipe(share());\n        this.render();\n    }\n    /**\n     * Update properties of the embedded visualization. This method does not allow\n     * updating all initial parameters, but only a subset of the ones allowed\n     * in {@link VisualizeUpdateParams}.\n     *\n     * @param params The parameters that should be updated.\n     */\n    EmbeddedVisualizeHandler.prototype.update = function (params) {\n        var _this = this;\n        if (params === void 0) { params = {}; }\n        // Apply data- attributes to the element if specified\n        var dataAttrs = params.dataAttrs;\n        if (dataAttrs) {\n            Object.keys(dataAttrs).forEach(function (key) {\n                if (dataAttrs[key] === null) {\n                    _this.element.removeAttribute(\"data-\" + key);\n                    return;\n                }\n                _this.element.setAttribute(\"data-\" + key, dataAttrs[key]);\n            });\n        }\n        var fetchRequired = false;\n        if (params.hasOwnProperty('timeRange')) {\n            fetchRequired = true;\n            this.dataLoaderParams.timeRange = params.timeRange;\n        }\n        if (params.hasOwnProperty('filters')) {\n            fetchRequired = true;\n            this.dataLoaderParams.filters = params.filters;\n        }\n        if (params.hasOwnProperty('query')) {\n            fetchRequired = true;\n            this.dataLoaderParams.query = params.query;\n        }\n        if (fetchRequired) {\n            this.fetchAndRender();\n        }\n    };\n    /**\n     * Destroy the underlying Angular scope of the visualization. This should be\n     * called whenever you remove the visualization.\n     */\n    EmbeddedVisualizeHandler.prototype.destroy = function () {\n        this.destroyed = true;\n        this.debouncedFetchAndRender.cancel();\n        if (this.autoFetch) {\n            timefilter.off('autoRefreshFetch', this.reload);\n        }\n        this.vis.removeListener('reload', this.reload);\n        this.vis.removeListener('update', this.handleVisUpdate);\n        this.element.removeEventListener('renderComplete', this.onRenderCompleteListener);\n        this.uiState.off('change', this.onUiStateChange);\n        visualizationLoader.destroy(this.element);\n        this.renderCompleteHelper.destroy();\n    };\n    /**\n     * Return the actual DOM element (wrapped in jQuery) of the rendered visualization.\n     * This is especially useful if you used `append: true` in the parameters where\n     * the visualization will be appended to the specified container.\n     */\n    EmbeddedVisualizeHandler.prototype.getElement = function () {\n        return this.element;\n    };\n    /**\n     * Returns a promise, that will resolve (without a value) once the first rendering of\n     * the visualization has finished. If you want to listen to consecutive rendering\n     * events, look into the `addRenderCompleteListener` method.\n     *\n     * @returns Promise, that resolves as soon as the visualization is done rendering\n     *    for the first time.\n     */\n    EmbeddedVisualizeHandler.prototype.whenFirstRenderComplete = function () {\n        return this.firstRenderComplete;\n    };\n    /**\n     * Adds a listener to be called whenever the visualization finished rendering.\n     * This can be called multiple times, when the visualization rerenders, e.g. due\n     * to new data.\n     *\n     * @param {function} listener The listener to be notified about complete renders.\n     */\n    EmbeddedVisualizeHandler.prototype.addRenderCompleteListener = function (listener) {\n        this.listeners.addListener(RENDER_COMPLETE_EVENT, listener);\n    };\n    /**\n     * Removes a previously registered render complete listener from this handler.\n     * This listener will no longer be called when the visualization finished rendering.\n     *\n     * @param {function} listener The listener to remove from this handler.\n     */\n    EmbeddedVisualizeHandler.prototype.removeRenderCompleteListener = function (listener) {\n        this.listeners.removeListener(RENDER_COMPLETE_EVENT, listener);\n    };\n    return EmbeddedVisualizeHandler;\n}());\nexport { EmbeddedVisualizeHandler };\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/src/ui/public/visualize/loader/embedded_visualize_handler.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/src/ui/public/visualize/loader/embedded_visualize_handler.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n// @ts-ignore untyped dependency\nimport { registries } from '@kbn/interpreter/public';\nimport { EventEmitter } from 'events';\nimport { debounce, forEach } from 'lodash';\nimport * as Rx from 'rxjs';\nimport { share } from 'rxjs/operators';\nimport { Inspector } from '../../inspector';\nimport { Adapters } from '../../inspector/types';\nimport { PersistedState } from '../../persisted_state';\nimport { IPrivate } from '../../private';\nimport { RenderCompleteHelper } from '../../render_complete';\nimport { AppState } from '../../state_management/app_state';\nimport { timefilter } from '../../timefilter';\nimport { RequestHandlerParams, Vis } from '../../vis';\nimport { visualizationLoader } from './visualization_loader';\nimport { VisualizeDataLoader } from './visualize_data_loader';\n\nimport { DataAdapter, RequestAdapter } from '../../inspector/adapters';\n\nimport { VisSavedObject, VisualizeLoaderParams, VisualizeUpdateParams } from './types';\nimport { queryGeohashBounds } from './utils';\n\ninterface EmbeddedVisualizeHandlerParams extends VisualizeLoaderParams {\n  Private: IPrivate;\n  queryFilter: any;\n  autoFetch?: boolean;\n}\n\nconst RENDER_COMPLETE_EVENT = 'render_complete';\nconst LOADING_ATTRIBUTE = 'data-loading';\nconst RENDERING_COUNT_ATTRIBUTE = 'data-rendering-count';\n\n/**\n * A handler to the embedded visualization. It offers several methods to interact\n * with the visualization.\n */\nexport class EmbeddedVisualizeHandler {\n  /**\n   * This observable will emit every time new data is loaded for the\n   * visualization. The emitted value is the loaded data after it has\n   * been transformed by the visualization's response handler.\n   * This should not be used by any plugin.\n   * @ignore\n   */\n  public readonly data$: Rx.Observable<any>;\n  public readonly inspectorAdapters: Adapters = {};\n  private vis: Vis;\n  private loaded: boolean = false;\n  private destroyed: boolean = false;\n\n  private listeners = new EventEmitter();\n  private firstRenderComplete: Promise<void>;\n  private renderCompleteHelper: RenderCompleteHelper;\n  private shouldForceNextFetch: boolean = false;\n  private debouncedFetchAndRender = debounce(() => {\n    if (this.destroyed) {\n      return;\n    }\n\n    const forceFetch = this.shouldForceNextFetch;\n    this.shouldForceNextFetch = false;\n    this.fetch(forceFetch).then(this.render);\n  }, 100);\n\n  private dataLoaderParams: RequestHandlerParams;\n  private readonly appState?: AppState;\n  private uiState: PersistedState;\n  private dataLoader: VisualizeDataLoader;\n  private dataSubject: Rx.Subject<any>;\n  private actions: any = {};\n  private events$: Rx.Observable<any>;\n  private autoFetch: boolean;\n\n  constructor(\n    private readonly element: HTMLElement,\n    savedObject: VisSavedObject,\n    params: EmbeddedVisualizeHandlerParams\n  ) {\n    const { searchSource, vis } = savedObject;\n\n    const {\n      appState,\n      uiState,\n      queryFilter,\n      timeRange,\n      filters,\n      query,\n      autoFetch = true,\n      Private,\n    } = params;\n\n    this.dataLoaderParams = {\n      searchSource,\n      timeRange,\n      query,\n      queryFilter,\n      filters,\n      uiState,\n      aggs: vis.getAggConfig(),\n      forceFetch: false,\n    };\n\n    // Listen to the first RENDER_COMPLETE_EVENT to resolve this promise\n    this.firstRenderComplete = new Promise(resolve => {\n      this.listeners.once(RENDER_COMPLETE_EVENT, resolve);\n    });\n\n    element.setAttribute(LOADING_ATTRIBUTE, '');\n    element.setAttribute(RENDERING_COUNT_ATTRIBUTE, '0');\n    element.addEventListener('renderComplete', this.onRenderCompleteListener);\n\n    this.autoFetch = autoFetch;\n    this.appState = appState;\n    this.vis = vis;\n    if (uiState) {\n      vis._setUiState(uiState);\n    }\n    this.uiState = this.vis.getUiState();\n\n    this.vis.on('update', this.handleVisUpdate);\n    this.vis.on('reload', this.reload);\n    this.uiState.on('change', this.onUiStateChange);\n    if (autoFetch) {\n      timefilter.on('autoRefreshFetch', this.reload);\n    }\n\n    // This is a hack to give maps visualizations access to data in the\n    // globalState, since they can no longer access it via searchSource.\n    // TODO: Remove this as a part of elastic/kibana#30593\n    this.vis.API.getGeohashBounds = () => {\n      return queryGeohashBounds(this.vis, {\n        filters: this.dataLoaderParams.filters,\n        query: this.dataLoaderParams.query,\n      });\n    };\n\n    this.dataLoader = new VisualizeDataLoader(vis, Private);\n    this.renderCompleteHelper = new RenderCompleteHelper(element);\n    this.inspectorAdapters = this.getActiveInspectorAdapters();\n    this.vis.openInspector = this.openInspector;\n    this.vis.hasInspector = this.hasInspector;\n\n    // init default actions\n    forEach(this.vis.type.events, (event, eventName) => {\n      if (event.disabled || !eventName) {\n        return;\n      } else {\n        this.actions[eventName] = event.defaultAction;\n      }\n    });\n\n    this.vis.eventsSubject = new Rx.Subject();\n    this.events$ = this.vis.eventsSubject.asObservable().pipe(share());\n    this.events$.subscribe(event => {\n      if (this.actions[event.name]) {\n        this.actions[event.name](event.data);\n      }\n    });\n\n    this.dataSubject = new Rx.Subject();\n    this.data$ = this.dataSubject.asObservable().pipe(share());\n\n    this.render();\n  }\n\n  /**\n   * Update properties of the embedded visualization. This method does not allow\n   * updating all initial parameters, but only a subset of the ones allowed\n   * in {@link VisualizeUpdateParams}.\n   *\n   * @param params The parameters that should be updated.\n   */\n  public update(params: VisualizeUpdateParams = {}) {\n    // Apply data- attributes to the element if specified\n    const dataAttrs = params.dataAttrs;\n    if (dataAttrs) {\n      Object.keys(dataAttrs).forEach(key => {\n        if (dataAttrs[key] === null) {\n          this.element.removeAttribute(`data-${key}`);\n          return;\n        }\n\n        this.element.setAttribute(`data-${key}`, dataAttrs[key]);\n      });\n    }\n\n    let fetchRequired = false;\n    if (params.hasOwnProperty('timeRange')) {\n      fetchRequired = true;\n      this.dataLoaderParams.timeRange = params.timeRange;\n    }\n    if (params.hasOwnProperty('filters')) {\n      fetchRequired = true;\n      this.dataLoaderParams.filters = params.filters;\n    }\n    if (params.hasOwnProperty('query')) {\n      fetchRequired = true;\n      this.dataLoaderParams.query = params.query;\n    }\n\n    if (fetchRequired) {\n      this.fetchAndRender();\n    }\n  }\n\n  /**\n   * Destroy the underlying Angular scope of the visualization. This should be\n   * called whenever you remove the visualization.\n   */\n  public destroy(): void {\n    this.destroyed = true;\n    this.debouncedFetchAndRender.cancel();\n    if (this.autoFetch) {\n      timefilter.off('autoRefreshFetch', this.reload);\n    }\n    this.vis.removeListener('reload', this.reload);\n    this.vis.removeListener('update', this.handleVisUpdate);\n    this.element.removeEventListener('renderComplete', this.onRenderCompleteListener);\n    this.uiState.off('change', this.onUiStateChange);\n    visualizationLoader.destroy(this.element);\n    this.renderCompleteHelper.destroy();\n  }\n\n  /**\n   * Return the actual DOM element (wrapped in jQuery) of the rendered visualization.\n   * This is especially useful if you used `append: true` in the parameters where\n   * the visualization will be appended to the specified container.\n   */\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  /**\n   * renders visualization with provided data\n   * @param visData: visualization data\n   */\n  public render = (visData: any = null) => {\n    return visualizationLoader\n      .render(this.element, this.vis, visData, this.uiState, {\n        listenOnChange: false,\n      })\n      .then(() => {\n        if (!this.loaded) {\n          this.loaded = true;\n          if (this.autoFetch) {\n            this.fetchAndRender();\n          }\n        }\n      });\n  };\n\n  /**\n   * Opens the inspector for the embedded visualization. This will return an\n   * handler to the inspector to close and interact with it.\n   * @return An inspector session to interact with the opened inspector.\n   */\n  public openInspector = () => {\n    return Inspector.open(this.inspectorAdapters, {\n      title: this.vis.title,\n    });\n  };\n\n  public hasInspector = () => {\n    return Inspector.isAvailable(this.inspectorAdapters);\n  };\n\n  /**\n   * Returns a promise, that will resolve (without a value) once the first rendering of\n   * the visualization has finished. If you want to listen to consecutive rendering\n   * events, look into the `addRenderCompleteListener` method.\n   *\n   * @returns Promise, that resolves as soon as the visualization is done rendering\n   *    for the first time.\n   */\n  public whenFirstRenderComplete(): Promise<void> {\n    return this.firstRenderComplete;\n  }\n\n  /**\n   * Adds a listener to be called whenever the visualization finished rendering.\n   * This can be called multiple times, when the visualization rerenders, e.g. due\n   * to new data.\n   *\n   * @param {function} listener The listener to be notified about complete renders.\n   */\n  public addRenderCompleteListener(listener: () => void) {\n    this.listeners.addListener(RENDER_COMPLETE_EVENT, listener);\n  }\n\n  /**\n   * Removes a previously registered render complete listener from this handler.\n   * This listener will no longer be called when the visualization finished rendering.\n   *\n   * @param {function} listener The listener to remove from this handler.\n   */\n  public removeRenderCompleteListener(listener: () => void) {\n    this.listeners.removeListener(RENDER_COMPLETE_EVENT, listener);\n  }\n\n  /**\n   * Force the fetch of new data and renders the chart again.\n   */\n  public reload = () => {\n    this.fetchAndRender(true);\n  };\n\n  private incrementRenderingCount = () => {\n    const renderingCount = Number(this.element.getAttribute(RENDERING_COUNT_ATTRIBUTE) || 0);\n    this.element.setAttribute(RENDERING_COUNT_ATTRIBUTE, `${renderingCount + 1}`);\n  };\n\n  private onRenderCompleteListener = () => {\n    this.listeners.emit(RENDER_COMPLETE_EVENT);\n    this.element.removeAttribute(LOADING_ATTRIBUTE);\n    this.incrementRenderingCount();\n  };\n\n  private onUiStateChange = () => {\n    this.fetchAndRender();\n  };\n\n  /**\n   * Returns an object of all inspectors for this vis object.\n   * This must only be called after this.type has properly be initialized,\n   * since we need to read out data from the the vis type to check which\n   * inspectors are available.\n   */\n  private getActiveInspectorAdapters = (): Adapters => {\n    const adapters: Adapters = {};\n    const { inspectorAdapters: typeAdapters } = this.vis.type;\n\n    // Add the requests inspector adapters if the vis type explicitly requested it via\n    // inspectorAdapters.requests: true in its definition or if it's using the courier\n    // request handler, since that will automatically log its requests.\n    if ((typeAdapters && typeAdapters.requests) || this.vis.type.requestHandler === 'courier') {\n      adapters.requests = new RequestAdapter();\n    }\n\n    // Add the data inspector adapter if the vis type requested it or if the\n    // vis is using courier, since we know that courier supports logging\n    // its data.\n    if ((typeAdapters && typeAdapters.data) || this.vis.type.requestHandler === 'courier') {\n      adapters.data = new DataAdapter();\n    }\n\n    // Add all inspectors, that are explicitly registered with this vis type\n    if (typeAdapters && typeAdapters.custom) {\n      Object.entries(typeAdapters.custom).forEach(([key, Adapter]) => {\n        adapters[key] = new (Adapter as any)();\n      });\n    }\n\n    return adapters;\n  };\n\n  /**\n   * Fetches new data and renders the chart. This will happen debounced for a couple\n   * of milliseconds, to bundle fast successive calls into one fetch and render,\n   * e.g. while resizing the window, this will be triggered constantly on the resize\n   * event.\n   *\n   * @param  forceFetch=false Whether the request handler should be signaled to forceFetch\n   *    (i.e. ignore caching in case it supports it). If at least one call to this\n   *    passed `true` the debounced fetch and render will be a force fetch.\n   */\n  private fetchAndRender = (forceFetch = false): void => {\n    this.shouldForceNextFetch = forceFetch || this.shouldForceNextFetch;\n    this.element.setAttribute(LOADING_ATTRIBUTE, '');\n    this.debouncedFetchAndRender();\n  };\n\n  private handleVisUpdate = () => {\n    if (this.appState) {\n      this.appState.vis = this.vis.getState();\n      this.appState.save();\n    }\n\n    this.fetchAndRender();\n  };\n\n  private fetch = (forceFetch: boolean = false) => {\n    this.dataLoaderParams.aggs = this.vis.getAggConfig();\n    this.dataLoaderParams.forceFetch = forceFetch;\n    this.dataLoaderParams.inspectorAdapters = this.inspectorAdapters;\n\n    return this.dataLoader.fetch(this.dataLoaderParams).then(data => {\n      this.dataSubject.next(data);\n      return data;\n    });\n  };\n}\n"]}]}