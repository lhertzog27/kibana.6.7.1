{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/vis/agg_configs.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/vis/agg_configs.js","mtime":1567631711768},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggConfigs = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /*\n                                                                                                                                                                                                                                                                               * Licensed to Elasticsearch B.V. under one or more contributor\n                                                                                                                                                                                                                                                                               * license agreements. See the NOTICE file distributed with\n                                                                                                                                                                                                                                                                               * this work for additional information regarding copyright\n                                                                                                                                                                                                                                                                               * ownership. Elasticsearch B.V. licenses this file to you under\n                                                                                                                                                                                                                                                                               * the Apache License, Version 2.0 (the \"License\"); you may\n                                                                                                                                                                                                                                                                               * not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                               * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               *    http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * Unless required by applicable law or agreed to in writing,\n                                                                                                                                                                                                                                                                               * software distributed under the License is distributed on an\n                                                                                                                                                                                                                                                                               * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                                                                                                                                                                                                                                                                               * KIND, either express or implied.  See the License for the\n                                                                                                                                                                                                                                                                               * specific language governing permissions and limitations\n                                                                                                                                                                                                                                                                               * under the License.\n                                                                                                                                                                                                                                                                               */\n\n/**\n * @name AggConfig\n *\n * @extends IndexedArray\n *\n * @description A \"data structure\"-like class with methods for indexing and\n * accessing instances of AggConfig.\n */\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _indexed_array = require('../indexed_array');\n\nvar _agg_config = require('./agg_config');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction removeParentAggs(obj) {\n  for (var prop in obj) {\n    if (prop === 'parentAggs') delete obj[prop];else if (_typeof(obj[prop]) === 'object') removeParentAggs(obj[prop]);\n  }\n}\n\nfunction parseParentAggs(dslLvlCursor, dsl) {\n  if (dsl.parentAggs) {\n    _lodash2.default.each(dsl.parentAggs, function (agg, key) {\n      dslLvlCursor[key] = agg;\n      parseParentAggs(dslLvlCursor, agg);\n    });\n  }\n}\n\nvar AggConfigs = function (_IndexedArray) {\n  _inherits(AggConfigs, _IndexedArray);\n\n  function AggConfigs(indexPattern) {\n    var configStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var schemas = arguments[2];\n\n    _classCallCheck(this, AggConfigs);\n\n    configStates = _agg_config.AggConfig.ensureIds(configStates);\n\n    var _this = _possibleConstructorReturn(this, (AggConfigs.__proto__ || Object.getPrototypeOf(AggConfigs)).call(this, {\n      index: ['id'],\n      group: ['schema.group', 'type.name', 'type.type', 'schema.name']\n    }));\n\n    _this.indexPattern = indexPattern;\n    _this.schemas = schemas;\n\n    configStates.forEach(function (params) {\n      return _this.createAggConfig(params);\n    });\n\n    if (_this.schemas) {\n      _this.initializeDefaultsFromSchemas(schemas);\n    }\n    return _this;\n  }\n\n  _createClass(AggConfigs, [{\n    key: 'initializeDefaultsFromSchemas',\n    value: function initializeDefaultsFromSchemas(schemas) {\n      var _this2 = this;\n\n      // Set the defaults for any schema which has them. If the defaults\n      // for some reason has more then the max only set the max number\n      // of defaults (not sure why a someone define more...\n      // but whatever). Also if a schema.name is already set then don't\n      // set anything.\n      (0, _lodash2.default)(schemas).filter(function (schema) {\n        return Array.isArray(schema.defaults) && schema.defaults.length > 0;\n      }).each(function (schema) {\n        if (!_this2.bySchemaName[schema.name]) {\n          var defaults = schema.defaults.slice(0, schema.max);\n          _lodash2.default.each(defaults, function (defaultState) {\n            var state = _lodash2.default.defaults({ id: _agg_config.AggConfig.nextId(_this2) }, defaultState);\n            _this2.push(new _agg_config.AggConfig(_this2, state));\n          });\n        }\n      }).commit();\n    }\n  }, {\n    key: 'setTimeRange',\n    value: function setTimeRange(timeRange) {\n      this.timeRange = timeRange;\n\n      var updateAggTimeRange = function updateAggTimeRange(agg) {\n        _lodash2.default.each(agg.params, function (param) {\n          if (param instanceof _agg_config.AggConfig) {\n            updateAggTimeRange(param);\n          }\n        });\n        if (_lodash2.default.get(agg, 'type.name') === 'date_histogram') {\n          agg.params.timeRange = timeRange;\n        }\n      };\n\n      this.forEach(updateAggTimeRange);\n    }\n\n    // clone method will reuse existing AggConfig in the list (will not create new instances)\n\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$enabledOnly = _ref.enabledOnly,\n          enabledOnly = _ref$enabledOnly === undefined ? true : _ref$enabledOnly;\n\n      var filterAggs = function filterAggs(agg) {\n        if (!enabledOnly) return true;\n        return agg.enabled;\n      };\n      var aggConfigs = new AggConfigs(this.indexPattern, this.raw.filter(filterAggs), this.schemas);\n      return aggConfigs;\n    }\n  }, {\n    key: 'createAggConfig',\n    value: function createAggConfig(params) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$addToAggConfigs = _ref2.addToAggConfigs,\n          addToAggConfigs = _ref2$addToAggConfigs === undefined ? true : _ref2$addToAggConfigs;\n\n      var aggConfig = void 0;\n      if (params instanceof _agg_config.AggConfig) {\n        aggConfig = params;\n        params.parent = this;\n      } else {\n        aggConfig = new _agg_config.AggConfig(this, params);\n      }\n      if (addToAggConfigs) {\n        this.push(aggConfig);\n      }\n      return aggConfig;\n    }\n\n    /**\n     * Data-by-data comparison of this Aggregation\n     * Ignores the non-array indexes\n     * @param aggConfigs an AggConfigs instance\n     */\n\n  }, {\n    key: 'jsonDataEquals',\n    value: function jsonDataEquals(aggConfigs) {\n      if (aggConfigs.length !== this.length) {\n        return false;\n      }\n      for (var i = 0; i < this.length; i += 1) {\n        if (!_lodash2.default.isEqual(aggConfigs[i].toJSON(), this[i].toJSON())) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'toDsl',\n    value: function toDsl() {\n      var _this3 = this;\n\n      var hierarchical = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      var dslTopLvl = {};\n      var dslLvlCursor = void 0;\n      var nestedMetrics = void 0;\n\n      if (hierarchical) {\n        // collect all metrics, and filter out the ones that we won't be copying\n        nestedMetrics = (0, _lodash2.default)(this.byTypeType.metrics).filter(function (agg) {\n          return agg.type.name !== 'count';\n        }).map(function (agg) {\n          return {\n            config: agg,\n            dsl: agg.toDsl(_this3)\n          };\n        }).value();\n      }\n      this.getRequestAggs().filter(function (config) {\n        return !config.type.hasNoDsl;\n      }).forEach(function (config, i, list) {\n        if (!dslLvlCursor) {\n          // start at the top level\n          dslLvlCursor = dslTopLvl;\n        } else {\n          var prevConfig = list[i - 1];\n          var prevDsl = dslLvlCursor[prevConfig.id];\n\n          // advance the cursor and nest under the previous agg, or\n          // put it on the same level if the previous agg doesn't accept\n          // sub aggs\n          dslLvlCursor = prevDsl.aggs || dslLvlCursor;\n        }\n\n        var dsl = dslLvlCursor[config.id] = config.toDsl(_this3);\n        var subAggs = void 0;\n\n        parseParentAggs(dslLvlCursor, dsl);\n\n        if (config.type.type === 'buckets' && i < list.length - 1) {\n          // buckets that are not the last item in the list accept sub-aggs\n          subAggs = dsl.aggs || (dsl.aggs = {});\n        }\n\n        if (subAggs && nestedMetrics) {\n          nestedMetrics.forEach(function (agg) {\n            subAggs[agg.config.id] = agg.dsl;\n            // if a nested metric agg has parent aggs, we have to add them to every level of the tree\n            // to make sure \"bucket_path\" references in the nested metric agg itself are still working\n            if (agg.dsl.parentAggs) {\n              Object.entries(agg.dsl.parentAggs).forEach(function (_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2),\n                    parentAggId = _ref4[0],\n                    parentAgg = _ref4[1];\n\n                subAggs[parentAggId] = parentAgg;\n              });\n            }\n          });\n        }\n      });\n\n      removeParentAggs(dslTopLvl);\n      return dslTopLvl;\n    }\n  }, {\n    key: 'getRequestAggs',\n    value: function getRequestAggs() {\n      //collect all the aggregations\n      var aggregations = this.reduce(function (requestValuesAggs, agg) {\n        var aggs = agg.getRequestAggs();\n        return aggs ? requestValuesAggs.concat(aggs) : requestValuesAggs;\n      }, []);\n      //move metrics to the end\n      return _lodash2.default.sortBy(aggregations, function (agg) {\n        return agg.type.type === 'metrics' ? 1 : 0;\n      });\n    }\n\n    /**\n     * Gets the AggConfigs (and possibly ResponseAggConfigs) that\n     * represent the values that will be produced when all aggs\n     * are run.\n     *\n     * With multi-value metric aggs it is possible for a single agg\n     * request to result in multiple agg values, which is why the length\n     * of a vis' responseValuesAggs may be different than the vis' aggs\n     *\n     * @return {array[AggConfig]}\n     */\n\n  }, {\n    key: 'getResponseAggs',\n    value: function getResponseAggs() {\n      return this.getRequestAggs().reduce(function (responseValuesAggs, agg) {\n        var aggs = agg.getResponseAggs();\n        return aggs ? responseValuesAggs.concat(aggs) : responseValuesAggs;\n      }, []);\n    }\n\n    /**\n     * Find a response agg by it's id. This may be an agg in the aggConfigs, or one\n     * created specifically for a response value\n     *\n     * @param  {string} id - the id of the agg to find\n     * @return {AggConfig}\n     */\n\n  }, {\n    key: 'getResponseAggById',\n    value: function getResponseAggById(id) {\n      id = String(id);\n      var reqAgg = _lodash2.default.find(this.getRequestAggs(), function (agg) {\n        return id.substr(0, String(agg.id).length) === agg.id;\n      });\n      if (!reqAgg) return;\n      return _lodash2.default.find(reqAgg.getResponseAggs(), { id: id });\n    }\n  }, {\n    key: 'onSearchRequestStart',\n    value: function onSearchRequestStart(searchSource, searchRequest) {\n      return Promise.all(this.getRequestAggs().map(function (agg) {\n        return agg.onSearchRequestStart(searchSource, searchRequest);\n      }));\n    }\n  }]);\n\n  return AggConfigs;\n}(_indexed_array.IndexedArray);\n\nexports.AggConfigs = AggConfigs;",null]}