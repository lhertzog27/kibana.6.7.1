{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/vis/editors/default/agg_params.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/vis/editors/default/agg_params.js","mtime":1567631711770},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _lodash = require('lodash');\n\nvar _agg_select = require('./agg_select.html');\n\nvar _agg_select2 = _interopRequireDefault(_agg_select);\n\nvar _advanced_toggle = require('./advanced_toggle.html');\n\nvar _advanced_toggle2 = _interopRequireDefault(_advanced_toggle);\n\nrequire('../../../filters/match_any');\n\nrequire('./agg_param');\n\nvar _agg_types = require('../../../agg_types');\n\nvar _modules = require('../../../modules');\n\nvar _documentation_links = require('../../../documentation_links/documentation_links');\n\nvar _agg_params = require('./agg_params.html');\n\nvar _agg_params2 = _interopRequireDefault(_agg_params);\n\nvar _filter = require('../../../agg_types/filter');\n\nvar _editor_config_providers = require('../config/editor_config_providers');\n\nvar _filter2 = require('../../../agg_types/param_types/filter');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_modules.uiModules.get('app/visualize').directive('visEditorAggParams', function ($compile) {\n\n  return {\n    restrict: 'E',\n    template: _agg_params2.default,\n    scope: true,\n    link: function link($scope, $el, attr) {\n      $scope.$bind('agg', attr.agg);\n      $scope.$bind('groupName', attr.groupName);\n      $scope.$bind('indexPattern', attr.indexPattern);\n\n      $scope.aggTypeOptions = _filter.aggTypeFilters.filter(_agg_types.aggTypes.byType[$scope.groupName], $scope.indexPattern, $scope.agg);\n\n      $scope.advancedToggled = false;\n\n      // We set up this watch prior to adding the controls below, because when the controls are added,\n      // there is a possibility that the agg type can be automatically selected (if there is only one)\n      $scope.$watch('agg.type', function () {\n        updateAggParamEditor();\n        updateEditorConfig('default');\n      });\n\n      function updateEditorConfig() {\n        var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'fixedValue';\n\n        $scope.editorConfig = _editor_config_providers.editorConfigProviders.getConfigForAgg(_agg_types.aggTypes.byType[$scope.groupName], $scope.indexPattern, $scope.agg);\n\n        Object.keys($scope.editorConfig).forEach(function (param) {\n          var config = $scope.editorConfig[param];\n          var paramOptions = $scope.agg.type.params.find(function (paramOption) {\n            return paramOption.name === param;\n          });\n          // If the parameter has a fixed value in the config, set this value.\n          // Also for all supported configs we should freeze the editor for this param.\n          if (config.hasOwnProperty(property)) {\n            if (paramOptions && paramOptions.deserialize) {\n              $scope.agg.params[param] = paramOptions.deserialize(config[property]);\n            } else {\n              $scope.agg.params[param] = config[property];\n            }\n          }\n        });\n      }\n\n      updateEditorConfig();\n      $scope.$watchCollection('agg.params', updateEditorConfig);\n\n      // this will contain the controls for the schema (rows or columns?), which are unrelated to\n      // controls for the agg, which is why they are first\n      addSchemaEditor();\n\n      // allow selection of an aggregation\n      addAggSelector();\n\n      function addSchemaEditor() {\n        var $schemaEditor = (0, _jquery2.default)('<div>').addClass('schemaEditors').appendTo($el);\n\n        if ($scope.agg.schema.editor) {\n          $schemaEditor.append($scope.agg.schema.editor);\n          $compile($schemaEditor)($scope.$new());\n        }\n      }\n\n      function addAggSelector() {\n        var $aggSelect = (0, _jquery2.default)(_agg_select2.default).appendTo($el);\n        $compile($aggSelect)($scope);\n      }\n\n      // params for the selected agg, these are rebuilt every time the agg in $aggSelect changes\n      var $aggParamEditors = void 0; //  container for agg type param editors\n      var $aggParamEditorsScope = void 0;\n\n      function updateAggParamEditor() {\n        updateEditorConfig();\n        $scope.aggHelpLink = null;\n        if ((0, _lodash.has)($scope, 'agg.type.name')) {\n          $scope.aggHelpLink = (0, _lodash.get)(_documentation_links.documentationLinks, ['aggs', $scope.agg.type.name]);\n        }\n\n        if ($aggParamEditors) {\n          $aggParamEditors.remove();\n          $aggParamEditors = null;\n        }\n\n        // if there's an old scope, destroy it\n        if ($aggParamEditorsScope) {\n          $aggParamEditorsScope.$destroy();\n          $aggParamEditorsScope = null;\n        }\n\n        if (!$scope.agg || !$scope.agg.type) {\n          return;\n        }\n\n        // create child scope, used in the editors\n        $aggParamEditorsScope = $scope.$new();\n        var aggParamHTML = {\n          basic: [],\n          advanced: []\n        };\n\n        // build collection of agg params html\n        $scope.agg.type.params\n        // Filter out, i.e. don't render, any parameter that is hidden via the editor config.\n        .filter(function (param) {\n          return !(0, _lodash.get)($scope, ['editorConfig', param.name, 'hidden'], false);\n        }).forEach(function (param, i) {\n          var aggParam = void 0;\n          var fields = void 0;\n          if ($scope.agg.schema.hideCustomLabel && param.name === 'customLabel') {\n            return;\n          }\n          // if field param exists, compute allowed fields\n          if (param.type === 'field') {\n            var availableFields = param.getAvailableFields($scope.agg.getIndexPattern().fields);\n            fields = $scope.indexedFields = $aggParamEditorsScope[param.name + 'Options'] = _filter2.aggTypeFieldFilters.filter(availableFields, param.type, $scope.agg, $scope.vis);\n          }\n\n          if (fields) {\n            var hasIndexedFields = fields.length > 0;\n            var isExtraParam = i > 0;\n            if (!hasIndexedFields && isExtraParam) {\n              // don't draw the rest of the options if there are no indexed fields.\n              return;\n            }\n          }\n\n          var type = 'basic';\n          if (param.advanced) type = 'advanced';\n\n          if (aggParam = getAggParamHTML(param, i)) {\n            aggParamHTML[type].push(aggParam);\n          }\n        });\n\n        // compile the paramEditors html elements\n        var paramEditors = aggParamHTML.basic;\n\n        if (aggParamHTML.advanced.length) {\n          paramEditors.push((0, _jquery2.default)(_advanced_toggle2.default).get(0));\n          paramEditors = paramEditors.concat(aggParamHTML.advanced);\n        }\n\n        $aggParamEditors = (0, _jquery2.default)(paramEditors).appendTo($el);\n        $compile($aggParamEditors)($aggParamEditorsScope);\n      }\n\n      // build HTML editor given an aggParam and index\n      function getAggParamHTML(param, idx) {\n        // don't show params without an editor\n        if (!param.editor) {\n          return;\n        }\n\n        var attrs = {\n          'agg-param': 'agg.type.params[' + idx + ']'\n        };\n\n        if (param.advanced) {\n          attrs['ng-show'] = 'advancedToggled';\n        }\n\n        return (0, _jquery2.default)('<vis-agg-param-editor>').attr(attrs).append(param.editor).get(0);\n      }\n    }\n  };\n}); /*\n     * Licensed to Elasticsearch B.V. under one or more contributor\n     * license agreements. See the NOTICE file distributed with\n     * this work for additional information regarding copyright\n     * ownership. Elasticsearch B.V. licenses this file to you under\n     * the Apache License, Version 2.0 (the \"License\"); you may\n     * not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *    http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing,\n     * software distributed under the License is distributed on an\n     * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     * KIND, either express or implied.  See the License for the\n     * specific language governing permissions and limitations\n     * under the License.\n     */",null]}