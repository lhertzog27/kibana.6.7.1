{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/router_provider.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/router_provider.js","mtime":1567631711934},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nexports.routerProvider = routerProvider;\n\nvar _router = require('@scant/router');\n\nvar _router2 = _interopRequireDefault(_router);\n\nvar _get_window = require('./get_window');\n\nvar _history_provider = require('./history_provider');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// used to make this provider a singleton\nvar router = void 0;\n\nfunction routerProvider(routes) {\n  if (router) {\n    return router;\n  }\n\n  var baseRouter = (0, _router2.default)(routes);\n  var history = (0, _history_provider.historyProvider)((0, _get_window.getWindow)());\n  var componentListener = null;\n\n  var isPath = function isPath(str) {\n    return typeof str === 'string' && str.substr(0, 1) === '/';\n  };\n\n  var getState = function getState(name, params, state) {\n    // given a path, assuming params is the state\n    if (isPath(name)) {\n      return params || history.getLocation().state;\n    }\n    return state || history.getLocation().state;\n  };\n\n  var updateLocation = function updateLocation(name, params, state) {\n    var replace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    var currentState = getState(name, params, state);\n    var method = replace ? 'replace' : 'push';\n\n    // given a path, go there directly\n    if (isPath(name)) {\n      return history[method](currentState, name);\n    }\n    history[method](currentState, baseRouter.create(name, params));\n  };\n\n  // our router is an extended version of the imported router\n  // which mixes in history methods for navigation\n  router = _extends({}, baseRouter, {\n    execute: function execute() {\n      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : history.getPath();\n\n      return this.parse(path);\n    },\n\n    getPath: history.getPath,\n    getFullPath: history.getFullPath,\n    navigateTo: function navigateTo(name, params, state) {\n      updateLocation(name, params, state);\n    },\n    redirectTo: function redirectTo(name, params, state) {\n      updateLocation(name, params, state, true);\n    },\n    onPathChange: function onPathChange(fn) {\n      var _this = this;\n\n      if (componentListener != null) {\n        throw new Error('Only one route component listener is allowed');\n      }\n\n      var execOnMatch = function execOnMatch(location) {\n        var pathname = location.pathname;\n\n        var match = _this.match(pathname);\n\n        if (!match) {\n          // TODO: show some kind of error, or redirect somewhere; maybe home?\n          console.error('No route found for path: ', pathname);\n          return;\n        }\n\n        fn(_extends({}, match, { location: location }));\n      };\n\n      // on path changes, fire the path change handler\n      componentListener = history.onChange(function (locationObj, prevLocationObj) {\n        if (locationObj.pathname !== prevLocationObj.pathname) {\n          execOnMatch(locationObj);\n        }\n      });\n\n      // initially fire the path change handler\n      execOnMatch(history.getLocation());\n    }\n  });\n\n  return router;\n}",null]}