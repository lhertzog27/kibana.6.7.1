{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/components/utils/chart_data_utils.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/components/utils/chart_data_utils.js","mtime":1567631712057},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChartDataUtilsProvider = ChartDataUtilsProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _ml_time_buckets = require('plugins/ml/util/ml_time_buckets');\n\nvar _string_utils = require('plugins/ml/util/string_utils');\n\nvar _results_service = require('plugins/ml/services/results_service');\n\nvar _search_service = require('plugins/ml/jobs/new_job/simple/components/utils/search_service');\n\nvar _timefilter = require('ui/timefilter');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\n// various util functions for populating the chartData object used by the job wizards\n\nfunction ChartDataUtilsProvider(Private) {\n  var TimeBuckets = Private(_ml_time_buckets.IntervalHelperProvider);\n\n  function loadDocCountData(formConfig, chartData) {\n    return new Promise(function (resolve, reject) {\n      // set doc count chart to be 10x less than detector charts\n      var BAR_TARGET = Math.ceil(formConfig.chartInterval.barTarget / 10);\n      var MAX_BARS = BAR_TARGET + BAR_TARGET / 100 * 100; // 100% larger that bar target\n      var query = formConfig.combinedQuery;\n      var bounds = _timefilter.timefilter.getActiveBounds();\n      var buckets = new TimeBuckets();\n      buckets.setBarTarget(BAR_TARGET);\n      buckets.setMaxBars(MAX_BARS);\n      buckets.setInterval('auto');\n      buckets.setBounds(bounds);\n\n      var interval = buckets.getInterval().asMilliseconds();\n\n      var end = formConfig.end;\n      var start = formConfig.start;\n\n      _results_service.mlResultsService.getEventRateData(formConfig.indexPattern.title, query, formConfig.timeField, start, end, interval + 'ms').then(function (resp) {\n        var highestValue = 0;\n        chartData.job.bars = [];\n\n        _lodash2.default.each(resp.results, function (value, t) {\n          if (!isFinite(value)) {\n            value = 0;\n          }\n\n          if (value > highestValue) {\n            highestValue = value;\n          }\n\n          var time = +t;\n          var date = new Date(time);\n          chartData.job.barsInterval = interval;\n          chartData.job.bars.push({\n            date: date,\n            time: time,\n            value: value\n          });\n        });\n\n        chartData.totalResults = resp.total;\n        chartData.eventRateHighestValue = Math.ceil(highestValue);\n\n        resolve(chartData);\n      }).catch(function (resp) {\n        console.log('getEventRate visualization - error getting event rate data from elasticsearch:', resp);\n        reject(resp);\n      });\n    });\n  }\n\n  function loadJobSwimlaneData(formConfig, chartData) {\n    return new Promise(function (resolve) {\n      _results_service.mlResultsService.getScoresByBucket([formConfig.jobId], formConfig.start, formConfig.end, formConfig.resultsIntervalSeconds + 's', 1).then(function (data) {\n        var time = formConfig.start;\n\n        var jobResults = data.results[formConfig.jobId];\n\n        chartData.job.swimlane = [];\n        _lodash2.default.each(jobResults, function (value, t) {\n          time = +t;\n          var date = new Date(time);\n          chartData.job.swimlane.push({\n            date: date,\n            time: time,\n            value: value,\n            color: ''\n          });\n        });\n\n        var pcnt = (time - formConfig.start + formConfig.resultsIntervalSeconds) / (formConfig.end - formConfig.start) * 100;\n\n        chartData.percentComplete = Math.round(pcnt);\n        chartData.job.percentComplete = chartData.percentComplete;\n        chartData.job.swimlaneInterval = formConfig.resultsIntervalSeconds * 1000;\n\n        resolve(chartData);\n      }).catch(function () {\n        resolve(chartData);\n      });\n    });\n  }\n\n  function loadDetectorSwimlaneData(formConfig, chartData) {\n    return new Promise(function (resolve) {\n      _search_service.mlSimpleJobSearchService.getScoresByRecord(formConfig.jobId, formConfig.start, formConfig.end, formConfig.resultsIntervalSeconds + 's', {\n        name: formConfig.splitField !== undefined ? formConfig.splitField.name : undefined,\n        value: formConfig.firstSplitFieldName\n      }).then(function (data) {\n        var dtrIndex = 0;\n        _lodash2.default.each(formConfig.fields, function (field, key) {\n\n          var dtr = chartData.detectors[key];\n          var times = data.results[dtrIndex];\n\n          dtr.swimlane = [];\n          _lodash2.default.each(times, function (timeObj, t) {\n            var time = +t;\n            var date = new Date(time);\n            dtr.swimlane.push({\n              date: date,\n              time: time,\n              value: timeObj.recordScore,\n              color: ''\n            });\n          });\n\n          dtr.percentComplete = chartData.percentComplete;\n          dtr.swimlaneInterval = formConfig.resultsIntervalSeconds * 1000;\n\n          dtrIndex++;\n        });\n\n        resolve(chartData);\n      }).catch(function () {\n        resolve(chartData);\n      });\n    });\n  }\n\n  function getSplitFields(formConfig, splitFieldName, size) {\n    var query = formConfig.combinedQuery;\n    return _search_service.mlSimpleJobSearchService.getCategoryFields(formConfig.indexPattern.title, splitFieldName, size, query);\n  }\n\n  function updateChartMargin(chartData) {\n    // Find the formatted value with the longest width across charts.\n    var longestTextWidth = (0, _string_utils.calculateTextWidth)(chartData.eventRateHighestValue, true);\n\n    // For fields with formatters, check the width for the value, plus a secondary check\n    // on the highest value multiplied by an irrational number, to minimize the chances\n    // of the highestValue not corresponding to the full quota of decimal places\n    // when formatted e.g. 12.340KB would be formatted to only 2 decimal places 12.34KB\n    var textCheckMultiplier = 1 + Math.sqrt(2) / 100;\n    _lodash2.default.each(chartData.detectors, function (detector) {\n      var longestWidthForDetector = 0;\n      if (detector.fieldFormat !== undefined) {\n        var longestTextForDetector = detector.fieldFormat.convert(detector.highestValue, 'text');\n        longestWidthForDetector = (0, _string_utils.calculateTextWidth)(longestTextForDetector, false);\n        var longestTextCheck = detector.fieldFormat.convert(detector.highestValue * textCheckMultiplier, 'text');\n        var longestWidthCheck = (0, _string_utils.calculateTextWidth)(longestTextCheck, false);\n        longestWidthForDetector = Math.max(longestWidthForDetector, longestWidthCheck);\n      } else {\n        longestWidthForDetector = (0, _string_utils.calculateTextWidth)(detector.highestValue, true);\n      }\n      longestTextWidth = Math.max(longestTextWidth, longestWidthForDetector);\n    });\n\n    // Append extra 10px to width of tick label for highest axis value to allow for tick padding.\n    chartData.chartTicksMargin.width = longestTextWidth + 10;\n  }\n\n  return {\n    loadDocCountData: loadDocCountData,\n    loadJobSwimlaneData: loadJobSwimlaneData,\n    loadDetectorSwimlaneData: loadDetectorSwimlaneData,\n    getSplitFields: getSplitFields,\n    updateChartMargin: updateChartMargin\n  };\n}",null]}