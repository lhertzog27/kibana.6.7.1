{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/functions/common/timefilter.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/functions/common/timefilter.js","mtime":1567631711899},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.timefilter = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nvar _datemath = require('@elastic/datemath');\n\nvar _datemath2 = _interopRequireDefault(_datemath);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar timefilter = exports.timefilter = function timefilter() {\n  return {\n    name: 'timefilter',\n    aliases: [],\n    type: 'filter',\n    context: {\n      types: ['filter']\n    },\n    help: 'Create a timefilter for querying a source',\n    args: {\n      column: {\n        type: ['string'],\n        aliases: ['field', 'c'],\n        default: '@timestamp',\n        help: 'The column or field to attach the filter to'\n      },\n      from: {\n        types: ['string', 'null'],\n        aliases: ['f', 'start'],\n        help: 'Beginning of the range, in ISO8601 or Elasticsearch datemath format'\n      },\n      to: {\n        types: ['string', 'null'],\n        aliases: ['t', 'end'],\n        help: 'End of the range, in ISO8601 or Elasticsearch datemath format'\n      }\n    },\n    fn: function fn(context, args) {\n      if (!args.from && !args.to) {\n        return context;\n      }\n\n      var from = args.from,\n          to = args.to,\n          column = args.column;\n\n      var filter = {\n        type: 'time',\n        column: column\n      };\n\n      function parseAndValidate(str) {\n        if (!str) {\n          return;\n        }\n\n        var moment = _datemath2.default.parse(str);\n        if (!moment || !moment.isValid()) {\n          throw new Error('Invalid date/time string: \\'' + str + '\\'');\n        }\n        return moment.toISOString();\n      }\n\n      if (to != null) {\n        filter.to = parseAndValidate(to);\n      }\n\n      if (from != null) {\n        filter.from = parseAndValidate(from);\n      }\n\n      return _extends({}, context, { and: [].concat(_toConsumableArray(context.and), [filter]) });\n    }\n  };\n};",null]}