{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/renderers/pie/plugins/pie.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/renderers/pie/plugins/pie.js","mtime":1567631711904},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pie = undefined;\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* Flot plugin for rendering pie charts.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\n\nLicensed under the MIT license.\n\nThe plugin assumes that each series has a single data value, and that each\nvalue is a positive integer or zero.  Negative numbers don't make sense for a\npie chart, and have unpredictable results.  The values do NOT need to be\npassed in as percentages; the plugin will calculate the total and per-slice\npercentages internally.\n\n* Created by Brian Medendorp\n\n* Updated with contributions from btburnett3, Anthony Aragues and Xavi Ivars\n* Updated 2018 for Kibana Canvas by Rashid Khan\n\nThe plugin supports these options:\n\n\tseries: {\n\t\tpie: {\n\t\t\tshow: true/false\n\t\t\tradius: 0-1 for percentage of fullsize, or a specified pixel length, or 'auto'\n\t\t\tinnerRadius: 0-1 for percentage of fullsize or a specified pixel length, for creating a donut effect\n\t\t\tstartAngle: 0-2 factor of PI used for starting angle (in radians) i.e 3/2 starts at the top, 0 and 2 have the same result\n\t\t\ttilt: 0-1 for percentage to tilt the pie, where 1 is no tilt, and 0 is completely flat (nothing will show)\n\t\t\toffset: {\n\t\t\t\ttop: integer value to move the pie up or down\n\t\t\t\tleft: integer value to move the pie left or right, or 'auto'\n\t\t\t},\n\t\t\tstroke: {\n\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#FFF')\n\t\t\t\twidth: integer pixel width of the stroke\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\tshow: true/false, or 'auto'\n\t\t\t\tformatter:  a user-defined function that modifies the text/style of the label text\n\t\t\t\tradius: 0-1 for percentage of fullsize, or a specified pixel length\n\t\t\t\tbackground: {\n\t\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#000')\n\t\t\t\t\topacity: 0-1\n\t\t\t\t},\n\t\t\t\tthreshold: 0-1 for the percentage value at which to hide labels (if they're too small)\n\t\t\t},\n\t\t\tcombine: {\n\t\t\t\tthreshold: 0-1 for the percentage value at which to combine slices (if they're too small)\n\t\t\t\tcolor: any hexidecimal color value (other formats may or may not work, so best to stick with something like '#CCC'), if null, the plugin will automatically use the color of the first slice to be combined\n\t\t\t\tlabel: any text value of what the combined slice should be labeled\n\t\t\t}\n\t\t\thighlight: {\n\t\t\t\topacity: 0-1\n\t\t\t}\n\t\t}\n\t}\n\nMore detail and specific examples can be found in the included HTML file.\n\n*/\n\n// Maximum redraw attempts when fitting labels within the plot\n\nvar REDRAW_ATTEMPTS = 10;\n\n// Factor by which to shrink the pie when fitting labels within the plot\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nvar REDRAW_SHRINK = 0.95;\n\nfunction init(plot) {\n  var canvas = null;\n  var target = null;\n  var options = null;\n  var maxRadius = null;\n  var centerLeft = null;\n  var centerTop = null;\n  var processed = false;\n  var ctx = null;\n\n  // interactive variables\n\n  var highlights = [];\n\n  // add hook to determine if pie plugin in enabled, and then perform necessary operations\n\n  plot.hooks.processOptions.push(function (plot, options) {\n    if (options.series.pie.show) {\n      options.grid.show = false;\n\n      // set labels.show\n\n      if (options.series.pie.label.show === 'auto') {\n        if (options.legend.show) {\n          options.series.pie.label.show = false;\n        } else {\n          options.series.pie.label.show = true;\n        }\n      }\n\n      // set radius\n\n      if (options.series.pie.radius === 'auto') {\n        if (options.series.pie.label.show) {\n          options.series.pie.radius = 3 / 4;\n        } else {\n          options.series.pie.radius = 1;\n        }\n      }\n\n      // ensure sane tilt\n\n      if (options.series.pie.tilt > 1) {\n        options.series.pie.tilt = 1;\n      } else if (options.series.pie.tilt < 0) {\n        options.series.pie.tilt = 0;\n      }\n    }\n  });\n\n  plot.hooks.bindEvents.push(function (plot, eventHolder) {\n    var options = plot.getOptions();\n    if (options.series.pie.show) {\n      if (options.grid.hoverable) {\n        eventHolder.unbind('mousemove').mousemove(onMouseMove);\n      }\n\n      if (options.grid.clickable) {\n        eventHolder.unbind('click').click(onClick);\n      }\n    }\n  });\n\n  plot.hooks.processDatapoints.push(function (plot, series, data, datapoints) {\n    var options = plot.getOptions();\n    if (options.series.pie.show) {\n      processDatapoints(plot, series, data, datapoints);\n    }\n  });\n\n  plot.hooks.drawOverlay.push(function (plot, octx) {\n    var options = plot.getOptions();\n    if (options.series.pie.show) {\n      drawOverlay(plot, octx);\n    }\n  });\n\n  plot.hooks.draw.push(function (plot, newCtx) {\n    var options = plot.getOptions();\n    if (options.series.pie.show) {\n      draw(plot, newCtx);\n    }\n  });\n\n  function processDatapoints(plot) {\n    if (!processed) {\n      processed = true;\n      canvas = plot.getCanvas();\n      target = (0, _jquery2.default)(canvas).parent();\n      options = plot.getOptions();\n      plot.setData(combine(plot.getData()));\n    }\n  }\n\n  function combine(data) {\n    var total = 0;\n    var combined = 0;\n    var numCombined = 0;\n    var color = options.series.pie.combine.color;\n    var newdata = [];\n\n    // Fix up the raw data from Flot, ensuring the data is numeric\n\n    for (var i = 0; i < data.length; ++i) {\n      var value = data[i].data;\n\n      // If the data is an array, we'll assume that it's a standard\n      // Flot x-y pair, and are concerned only with the second value.\n\n      // Note how we use the original array, rather than creating a\n      // new one; this is more efficient and preserves any extra data\n      // that the user may have stored in higher indexes.\n\n      if (Array.isArray(value) && value.length === 1) {\n        value = value[0];\n      }\n\n      if (Array.isArray(value)) {\n        // Equivalent to $.isNumeric() but compatible with jQuery < 1.7\n        if (!isNaN(parseFloat(value[1])) && isFinite(value[1])) {\n          value[1] = +value[1];\n        } else {\n          value[1] = 0;\n        }\n      } else if (!isNaN(parseFloat(value)) && isFinite(value)) {\n        value = [1, +value];\n      } else {\n        value = [1, 0];\n      }\n\n      data[i].data = [value];\n    }\n\n    // Sum up all the slices, so we can calculate percentages for each\n\n    for (var _i = 0; _i < data.length; ++_i) {\n      total += data[_i].data[0][1];\n    }\n\n    // Count the number of slices with percentages below the combine\n    // threshold; if it turns out to be just one, we won't combine.\n\n    for (var _i2 = 0; _i2 < data.length; ++_i2) {\n      var _value = data[_i2].data[0][1];\n      if (_value / total <= options.series.pie.combine.threshold) {\n        combined += _value;\n        numCombined++;\n        if (!color) {\n          color = data[_i2].color;\n        }\n      }\n    }\n\n    for (var _i3 = 0; _i3 < data.length; ++_i3) {\n      var _value2 = data[_i3].data[0][1];\n      if (numCombined < 2 || _value2 / total > options.series.pie.combine.threshold) {\n        newdata.push(_jquery2.default.extend(data[_i3], {\n          /* extend to allow keeping all other original data values\n                               and using them e.g. in labelFormatter. */\n          data: [[1, _value2]],\n          color: data[_i3].color,\n          label: data[_i3].label,\n          angle: _value2 * Math.PI * 2 / total,\n          percent: _value2 / (total / 100)\n        }));\n      }\n    }\n\n    if (numCombined > 1) {\n      newdata.push({\n        data: [[1, combined]],\n        color: color,\n        label: options.series.pie.combine.label,\n        angle: combined * Math.PI * 2 / total,\n        percent: combined / (total / 100)\n      });\n    }\n\n    return newdata;\n  }\n\n  function draw(plot, newCtx) {\n    if (!target) {\n      return;\n    } // if no series were passed\n\n    var canvasWidth = plot.getPlaceholder().width();\n    var canvasHeight = plot.getPlaceholder().height();\n    var legendWidth = target.children().filter('.legend').children().width() || 0;\n\n    ctx = newCtx;\n\n    // WARNING: HACK! REWRITE THIS CODE AS SOON AS POSSIBLE!\n\n    // When combining smaller slices into an 'other' slice, we need to\n    // add a new series.  Since Flot gives plugins no way to modify the\n    // list of series, the pie plugin uses a hack where the first call\n    // to processDatapoints results in a call to setData with the new\n    // list of series, then subsequent processDatapoints do nothing.\n\n    // The plugin-global 'processed' flag is used to control this hack;\n    // it starts out false, and is set to true after the first call to\n    // processDatapoints.\n\n    // Unfortunately this turns future setData calls into no-ops; they\n    // call processDatapoints, the flag is true, and nothing happens.\n\n    // To fix this we'll set the flag back to false here in draw, when\n    // all series have been processed, so the next sequence of calls to\n    // processDatapoints once again starts out with a slice-combine.\n    // This is really a hack; in 0.9 we need to give plugins a proper\n    // way to modify series before any processing begins.\n\n    processed = false;\n\n    // calculate maximum radius and center point\n\n    maxRadius = Math.min(canvasWidth, canvasHeight / options.series.pie.tilt) / 2;\n    centerTop = canvasHeight / 2 + options.series.pie.offset.top;\n    centerLeft = canvasWidth / 2;\n\n    if (options.series.pie.offset.left === 'auto') {\n      if (options.legend.position.match('w')) {\n        centerLeft += legendWidth / 2;\n      } else {\n        centerLeft -= legendWidth / 2;\n      }\n\n      if (centerLeft < maxRadius) {\n        centerLeft = maxRadius;\n      } else if (centerLeft > canvasWidth - maxRadius) {\n        centerLeft = canvasWidth - maxRadius;\n      }\n    } else {\n      centerLeft += options.series.pie.offset.left;\n    }\n\n    var slices = plot.getData();\n    var attempts = 0;\n\n    // Keep shrinking the pie's radius until drawPie returns true,\n    // indicating that all the labels fit, or we try too many times.\n\n    do {\n      if (attempts > 0) {\n        maxRadius *= REDRAW_SHRINK;\n      }\n\n      attempts += 1;\n      clear();\n      if (options.series.pie.tilt <= 0.8) {\n        drawShadow();\n      }\n    } while (!drawPie() && attempts < REDRAW_ATTEMPTS);\n\n    if (attempts >= REDRAW_ATTEMPTS) {\n      clear();\n      target.prepend(\"<div class='error'>Could not draw pie with labels contained inside canvas</div>\");\n    }\n\n    if (plot.setSeries && plot.insertLegend) {\n      plot.setSeries(slices);\n      plot.insertLegend();\n    }\n\n    // we're actually done at this point, just defining internal functions at this point\n\n    function clear() {\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n      target.children().filter('.pieLabel, .pieLabelBackground').remove();\n    }\n\n    function drawShadow() {\n      var shadowLeft = options.series.pie.shadow.left;\n      var shadowTop = options.series.pie.shadow.top;\n      var edge = 10;\n      var alpha = options.series.pie.shadow.alpha;\n      var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n      if (radius >= canvasWidth / 2 - shadowLeft || radius * options.series.pie.tilt >= canvasHeight / 2 - shadowTop || radius <= edge) {\n        return;\n      } // shadow would be outside canvas, so don't draw it\n\n      ctx.save();\n      ctx.translate(shadowLeft, shadowTop);\n      ctx.globalAlpha = alpha;\n      ctx.fillStyle = '#000';\n\n      // center and rotate to starting position\n\n      ctx.translate(centerLeft, centerTop);\n      ctx.scale(1, options.series.pie.tilt);\n\n      //radius -= edge;\n\n      for (var i = 1; i <= edge; i++) {\n        ctx.beginPath();\n        ctx.arc(0, 0, radius, 0, Math.PI * 2, false);\n        ctx.fill();\n        radius -= i;\n      }\n\n      ctx.restore();\n    }\n\n    function drawPie() {\n      var startAngle = Math.PI * options.series.pie.startAngle;\n      var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n      // center and rotate to starting position\n\n      ctx.save();\n      ctx.translate(centerLeft, centerTop);\n      ctx.scale(1, options.series.pie.tilt);\n      //ctx.rotate(startAngle); // start at top; -- This doesn't work properly in Opera\n\n      // draw slices\n\n      ctx.save();\n      var currentAngle = startAngle;\n      for (var i = 0; i < slices.length; ++i) {\n        slices[i].startAngle = currentAngle;\n        drawSlice(slices[i].angle, slices[i].color, true);\n      }\n      ctx.restore();\n\n      // draw slice outlines\n\n      if (options.series.pie.stroke.width > 0) {\n        ctx.save();\n        ctx.lineWidth = options.series.pie.stroke.width;\n        currentAngle = startAngle;\n        for (var _i4 = 0; _i4 < slices.length; ++_i4) {\n          drawSlice(slices[_i4].angle, options.series.pie.stroke.color, false);\n        }\n\n        ctx.restore();\n      }\n\n      // draw donut hole\n\n      drawDonutHole(ctx);\n\n      ctx.restore();\n\n      // Draw the labels, returning true if they fit within the plot\n\n      if (options.series.pie.label.show) {\n        return drawLabels();\n      } else {\n        return true;\n      }\n\n      function drawSlice(angle, color, fill) {\n        if (angle <= 0 || isNaN(angle)) {\n          return;\n        }\n\n        if (fill) {\n          ctx.fillStyle = color;\n        } else {\n          ctx.strokeStyle = color;\n          ctx.lineJoin = 'round';\n        }\n\n        ctx.beginPath();\n        if (Math.abs(angle - Math.PI * 2) > 0.000000001) {\n          ctx.moveTo(0, 0);\n        } // Center of the pie\n\n        //ctx.arc(0, 0, radius, 0, angle, false); // This doesn't work properly in Opera\n        ctx.arc(0, 0, radius, currentAngle, currentAngle + angle / 2, false);\n        ctx.arc(0, 0, radius, currentAngle + angle / 2, currentAngle + angle, false);\n        ctx.closePath();\n        //ctx.rotate(angle); // This doesn't work properly in Opera\n        currentAngle += angle;\n\n        if (fill) {\n          ctx.fill();\n        } else {\n          ctx.stroke();\n        }\n      }\n\n      function drawLabels() {\n        var currentAngle = startAngle;\n        var radius = options.series.pie.label.radius > 1 ? options.series.pie.label.radius : maxRadius * options.series.pie.label.radius;\n\n        for (var _i5 = 0; _i5 < slices.length; ++_i5) {\n          if (slices[_i5].percent >= options.series.pie.label.threshold * 100) {\n            if (!drawLabel(slices[_i5], currentAngle, _i5)) {\n              return false;\n            }\n          }\n\n          currentAngle += slices[_i5].angle;\n        }\n\n        return true;\n\n        function drawLabel(slice, startAngle, index) {\n          if (slice.data[0][1] === 0) {\n            return true;\n          }\n\n          // format label text\n\n          var lf = options.legend.labelFormatter;\n          var text = void 0;\n          var plf = options.series.pie.label.formatter;\n\n          if (lf) {\n            text = lf(slice.label, slice);\n          } else {\n            text = slice.label;\n          }\n\n          if (plf) {\n            text = plf(text, slice);\n          }\n\n          var halfAngle = (startAngle + slice.angle + startAngle) / 2;\n          var x = centerLeft + Math.round(Math.cos(halfAngle) * radius);\n          var y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;\n\n          var html = \"<span class='pieLabel' id='pieLabel\" + index + \"' style='position:absolute;top:\" + y + 'px;left:' + x + \"px;'>\" + text + '</span>';\n          target.append(html);\n\n          var label = target.children('#pieLabel' + index);\n          var labelTop = y - label.height() / 2;\n          var labelLeft = x - label.width() / 2;\n\n          label.css('top', labelTop);\n          label.css('left', labelLeft);\n\n          // check to make sure that the label is not outside the canvas\n\n          if (0 - labelTop > 0 || 0 - labelLeft > 0 || canvasHeight - (labelTop + label.height()) < 0 || canvasWidth - (labelLeft + label.width()) < 0) {\n            return false;\n          }\n\n          if (options.series.pie.label.background.opacity !== 0) {\n            // put in the transparent background separately to avoid blended labels and label boxes\n\n            var c = options.series.pie.label.background.color;\n\n            if (c == null) {\n              c = slice.color;\n            }\n\n            var pos = 'top:' + labelTop + 'px;left:' + labelLeft + 'px;';\n            (0, _jquery2.default)(\"<div class='pieLabelBackground' style='position:absolute;width:\" + label.width() + 'px;height:' + label.height() + 'px;' + pos + 'background-color:' + c + \";'></div>\").css('opacity', options.series.pie.label.background.opacity).insertBefore(label);\n          }\n\n          return true;\n        } // end individual label function\n      } // end drawLabels function\n    } // end drawPie function\n  } // end draw function\n\n  // Placed here because it needs to be accessed from multiple locations\n\n  function drawDonutHole(layer) {\n    if (options.series.pie.innerRadius > 0) {\n      // subtract the center\n\n      layer.save();\n      var innerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;\n      layer.globalCompositeOperation = 'destination-out'; // this does not work with excanvas, but it will fall back to using the stroke color\n      layer.beginPath();\n      layer.fillStyle = options.series.pie.stroke.color;\n      layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n      layer.fill();\n      layer.closePath();\n      layer.restore();\n\n      // add inner stroke\n      // TODO: Canvas forked flot here!\n      if (options.series.pie.stroke.width > 0) {\n        layer.save();\n        layer.beginPath();\n        layer.strokeStyle = options.series.pie.stroke.color;\n        layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n        layer.stroke();\n        layer.closePath();\n        layer.restore();\n      }\n\n      // TODO: add extra shadow inside hole (with a mask) if the pie is tilted.\n    }\n  }\n\n  //-- Additional Interactive related functions --\n\n  function isPointInPoly(poly, pt) {\n    var c = false;\n    var l = poly.length;\n    var j = l - 1;\n    for (var i = -1; ++i < l; j = i) {\n      (poly[i][1] <= pt[1] && pt[1] < poly[j][1] || poly[j][1] <= pt[1] && pt[1] < poly[i][1]) && pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0] && (c = !c);\n    }\n    return c;\n  }\n\n  function findNearbySlice(mouseX, mouseY) {\n    var slices = plot.getData();\n    var options = plot.getOptions();\n    var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n    var x = void 0;\n    var y = void 0;\n\n    for (var i = 0; i < slices.length; ++i) {\n      var s = slices[i];\n\n      if (s.pie.show) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(0, 0); // Center of the pie\n        //ctx.scale(1, options.series.pie.tilt);\t// this actually seems to break everything when here.\n        ctx.arc(0, 0, radius, s.startAngle, s.startAngle + s.angle / 2, false);\n        ctx.arc(0, 0, radius, s.startAngle + s.angle / 2, s.startAngle + s.angle, false);\n        ctx.closePath();\n        x = mouseX - centerLeft;\n        y = mouseY - centerTop;\n\n        if (ctx.isPointInPath) {\n          if (ctx.isPointInPath(mouseX - centerLeft, mouseY - centerTop)) {\n            ctx.restore();\n            return {\n              datapoint: [s.percent, s.data],\n              dataIndex: 0,\n              series: s,\n              seriesIndex: i\n            };\n          }\n        } else {\n          // excanvas for IE doesn;t support isPointInPath, this is a workaround.\n\n          var p1X = radius * Math.cos(s.startAngle);\n          var p1Y = radius * Math.sin(s.startAngle);\n          var p2X = radius * Math.cos(s.startAngle + s.angle / 4);\n          var p2Y = radius * Math.sin(s.startAngle + s.angle / 4);\n          var p3X = radius * Math.cos(s.startAngle + s.angle / 2);\n          var p3Y = radius * Math.sin(s.startAngle + s.angle / 2);\n          var p4X = radius * Math.cos(s.startAngle + s.angle / 1.5);\n          var p4Y = radius * Math.sin(s.startAngle + s.angle / 1.5);\n          var p5X = radius * Math.cos(s.startAngle + s.angle);\n          var p5Y = radius * Math.sin(s.startAngle + s.angle);\n          var arrPoly = [[0, 0], [p1X, p1Y], [p2X, p2Y], [p3X, p3Y], [p4X, p4Y], [p5X, p5Y]];\n          var arrPoint = [x, y];\n\n          // TODO: perhaps do some mathmatical trickery here with the Y-coordinate to compensate for pie tilt?\n\n          if (isPointInPoly(arrPoly, arrPoint)) {\n            ctx.restore();\n            return {\n              datapoint: [s.percent, s.data],\n              dataIndex: 0,\n              series: s,\n              seriesIndex: i\n            };\n          }\n        }\n\n        ctx.restore();\n      }\n    }\n\n    return null;\n  }\n\n  function onMouseMove(e) {\n    triggerClickHoverEvent('plothover', e);\n  }\n\n  function onClick(e) {\n    triggerClickHoverEvent('plotclick', e);\n  }\n\n  // trigger click or hover event (they send the same parameters so we share their code)\n\n  function triggerClickHoverEvent(eventname, e) {\n    var offset = plot.offset();\n    var canvasX = parseInt(e.pageX - offset.left, 10);\n    var canvasY = parseInt(e.pageY - offset.top, 10);\n    var item = findNearbySlice(canvasX, canvasY);\n\n    if (options.grid.autoHighlight) {\n      // clear auto-highlights\n\n      for (var i = 0; i < highlights.length; ++i) {\n        var h = highlights[i];\n        if (h.auto === eventname && !(item && h.series === item.series)) {\n          unhighlight(h.series);\n        }\n      }\n    }\n\n    // highlight the slice\n\n    if (item) {\n      highlight(item.series, eventname);\n    }\n\n    // trigger any hover bind events\n\n    var pos = { pageX: e.pageX, pageY: e.pageY };\n    target.trigger(eventname, [pos, item]);\n  }\n\n  function highlight(s, auto) {\n    //if (typeof s == \"number\") {\n    //\ts = series[s];\n    //}\n\n    var i = indexOfHighlight(s);\n\n    if (i === -1) {\n      highlights.push({ series: s, auto: auto });\n      plot.triggerRedrawOverlay();\n    } else if (!auto) {\n      highlights[i].auto = false;\n    }\n  }\n\n  function unhighlight(s) {\n    if (s == null) {\n      highlights = [];\n      plot.triggerRedrawOverlay();\n    }\n\n    //if (typeof s == \"number\") {\n    //\ts = series[s];\n    //}\n\n    var i = indexOfHighlight(s);\n\n    if (i !== -1) {\n      highlights.splice(i, 1);\n      plot.triggerRedrawOverlay();\n    }\n  }\n\n  function indexOfHighlight(s) {\n    for (var i = 0; i < highlights.length; ++i) {\n      var h = highlights[i];\n      if (h.series === s) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  function drawOverlay(plot, octx) {\n    var options = plot.getOptions();\n\n    var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n    octx.save();\n    octx.translate(centerLeft, centerTop);\n    octx.scale(1, options.series.pie.tilt);\n\n    for (var i = 0; i < highlights.length; ++i) {\n      drawHighlight(highlights[i].series);\n    }\n\n    drawDonutHole(octx);\n\n    octx.restore();\n\n    function drawHighlight(series) {\n      if (series.angle <= 0 || isNaN(series.angle)) {\n        return;\n      }\n\n      //octx.fillStyle = parseColor(options.series.pie.highlight.color).scale(null, null, null, options.series.pie.highlight.opacity).toString();\n      octx.fillStyle = 'rgba(255, 255, 255, ' + options.series.pie.highlight.opacity + ')'; // this is temporary until we have access to parseColor\n      octx.beginPath();\n      if (Math.abs(series.angle - Math.PI * 2) > 0.000000001) {\n        octx.moveTo(0, 0);\n      } // Center of the pie\n\n      octx.arc(0, 0, radius, series.startAngle, series.startAngle + series.angle / 2, false);\n      octx.arc(0, 0, radius, series.startAngle + series.angle / 2, series.startAngle + series.angle, false);\n      octx.closePath();\n      octx.fill();\n    }\n  }\n} // end init (plugin body)\n\n// define pie specific options and their default values\n\nvar options = {\n  series: {\n    pie: {\n      show: false,\n      radius: 'auto', // actual radius of the visible pie (based on full calculated radius if <=1, or hard pixel value)\n      innerRadius: 0 /* for donut */\n      , startAngle: 3 / 2,\n      tilt: 1,\n      shadow: {\n        left: 5, // shadow left offset\n        top: 15, // shadow top offset\n        alpha: 0.02 // shadow alpha\n      },\n      offset: {\n        top: 0,\n        left: 'auto'\n      },\n      stroke: {\n        color: '#fff',\n        width: 1\n      },\n      label: {\n        show: 'auto',\n        formatter: function formatter(label, slice) {\n          return \"<div style='font-size:x-small;text-align:center;padding:2px;color:\" + slice.color + \";'>\" + label + '<br/>' + Math.round(slice.percent) + '%</div>';\n        }, // formatter function\n        radius: 1, // radius at which to place the labels (based on full calculated radius if <=1, or hard pixel value)\n        background: {\n          color: null,\n          opacity: 0\n        },\n        threshold: 0 // percentage at which to hide the label (i.e. the slice is too narrow)\n      },\n      combine: {\n        threshold: -1, // percentage at which to combine little slices into one larger slice\n        color: null, // color to give the new slice (auto-generated if null)\n        label: 'Other' // label to give the new slice\n      },\n      highlight: {\n        //color: \"#fff\",\t\t// will add this functionality once parseColor is available\n        opacity: 0.5\n      }\n    }\n  }\n};\n\nvar pie = exports.pie = {\n  init: init,\n  options: options,\n  name: 'pie',\n  version: '1.1'\n};",null]}