{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/searchprofiler/public/directives/profile_tree/index.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/searchprofiler/public/directives/profile_tree/index.js","mtime":1567631712295},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _index = require('plugins/searchprofiler/directives/profile_tree/index.html');\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _util = require('plugins/searchprofiler/directives/profile_tree/util');\n\nvar _modules = require('ui/modules');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar uiModule = _modules.uiModules.get('app/searchprofiler/directives', []); /*\n                                                                             * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                             * or more contributor license agreements. Licensed under the Elastic License;\n                                                                             * you may not use this file except in compliance with the Elastic License.\n                                                                             */\n\nuiModule.directive('profiletree', function (HighlightService) {\n  return {\n    restrict: 'E',\n    scope: {\n      data: '=',\n      target: '@'\n    },\n    template: _index2.default,\n    link: function link($scope) {\n      $scope.visible = {\n        'foo': {}\n      };\n      $scope.indexVisibility = {};\n      $scope.highlightedRow = null;\n\n      $scope.updateDetail = function (row, indexName, shardID, shardNumber) {\n        HighlightService.details = row;\n        HighlightService.details.indexName = indexName;\n        HighlightService.details.shardID = shardID;\n        HighlightService.details.shardNumber = shardNumber;\n        HighlightService.details.highlightedRow = row.id;\n      };\n\n      $scope.getHighlightedRow = function () {\n        if (HighlightService.details) {\n          return HighlightService.details.highlightedRow;\n        }\n        return null;\n      };\n\n      $scope.toggle = function (id) {\n        // If the branch is open and toggled close, we need to\n        // also close the children\n        if ($scope.visible[id].visible === true) {\n          (0, _util.closeNode)($scope.visible, id);\n        } else {\n          // Otherwise just toggle on\n          $scope.visible[id].visible = true;\n        }\n      };\n\n      function render(data) {\n        if (data.length === 0) {\n          return;\n        }\n\n        $scope.visible = {};\n        var indices = {};\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var shard = _step.value;\n\n            initShardTargets(shard);\n\n            if ($scope.target === 'searches') {\n              shard.time[$scope.target] = collectSearchTimes(shard);\n            } else if ($scope.target === 'aggregations') {\n              shard.time[$scope.target] = collectAggTimes(shard);\n            }\n            if (!indices[shard.id[1]]) {\n              indices[shard.id[1]] = {\n                shards: [],\n                time: {\n                  searches: 0,\n                  aggregations: 0\n                },\n                name: shard.id[1]\n              };\n            }\n            indices[shard.id[1]].shards.push(shard);\n            indices[shard.id[1]].time[$scope.target] += shard.time[$scope.target];\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        data = null;\n        var finalIndices = (0, _util.normalizeIndices)(indices, $scope.indexVisibility, $scope.target);\n        indices = null;\n\n        $scope.profileResponse = finalIndices;\n      }\n\n      function collectSearchTimes(shard) {\n        if (shard.searches == null) {\n          return 0;\n        }\n        shard.rewrite_time = 0;\n\n        var shardTime = 0;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = shard.searches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var search = _step2.value;\n\n            shard.rewrite_time += search.rewrite_time;\n            var totalTime = (0, _util.calcTimes)(search.query);\n            shardTime += totalTime;\n            (0, _util.normalizeTimes)(search.query, totalTime, 0);\n\n            var flat = [];\n            (0, _util.flattenResults)(search.query, flat, 0, $scope.visible);\n            search.flat = flat;\n            search.query = null;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return shardTime;\n      }\n\n      function collectAggTimes(shard) {\n        if (shard.aggregations == null) {\n          return 0;\n        }\n        var shardTime = 0;\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = shard.aggregations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var agg = _step3.value;\n\n            var totalTime = (0, _util.calcTimes)([agg]);\n            shardTime += totalTime;\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = shard.aggregations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _agg = _step4.value;\n\n            (0, _util.normalizeTimes)([_agg], shardTime, 0);\n\n            var flat = [];\n            (0, _util.flattenResults)([_agg], flat, 0, $scope.visible);\n            _agg.flat = flat;\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        return shardTime;\n      }\n\n      // TODO the addition of aggregation profiling made the mutability of\n      // `shards` a liability.  Previously we set things directly on the shards\n      // tree because it was the only source of data.  Now we have agg data,\n      // so final, accumulated stats need to be saved on a per-target basis\n      //\n      // In the future, we should really remove this setup and create two immutable\n      // result sets that are generated from a single (also immutable) input set of\n      // `shards` data\n      //\n      // Particularly important if/when we add a third target\n      function initShardTargets(shard) {\n        if (!shard.time) {\n          shard.time = {\n            searches: 0,\n            aggregations: 0\n          };\n        }\n\n        if (!shard.color) {\n          shard.color = {\n            searches: 0,\n            aggregations: 0\n          };\n        }\n\n        if (!shard.relative) {\n          shard.relative = {\n            searches: 0,\n            aggregations: 0\n          };\n        }\n      }\n\n      $scope.$watch('data', render);\n    }\n  };\n});",null]}