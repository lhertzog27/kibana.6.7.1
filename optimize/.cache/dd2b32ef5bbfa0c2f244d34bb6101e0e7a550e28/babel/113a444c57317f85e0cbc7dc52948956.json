{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/aeroelastic/layout.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/aeroelastic/layout.js","mtime":1567631711932},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nextScene = exports.focusedShape = exports.shapes = undefined;\n\nvar _state = require('./state');\n\nvar _gestures = require('./gestures');\n\nvar _layout_functions = require('./layout_functions');\n\n/**\n * Scenegraph update based on events, gestures...\n */\n\nvar shapes = exports.shapes = (0, _state.select)(_layout_functions.getShapes)(_layout_functions.getScene); /*\n                                                                                                            * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                            * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                            * you may not use this file except in compliance with the Elastic License.\n                                                                                                            */\n\nvar hoveredShapes = (0, _state.select)(_layout_functions.getHoveredShapes)(_layout_functions.configuration, shapes, _gestures.cursorPosition);\n\nvar hoveredShape = (0, _state.select)(_layout_functions.getHoveredShape)(hoveredShapes);\n\nvar draggedShape = (0, _state.select)(_layout_functions.draggingShape)(_layout_functions.getScene, hoveredShape, _gestures.mouseIsDown, _gestures.mouseDowned);\n\nvar focusedShape = exports.focusedShape = (0, _state.select)(_layout_functions.getFocusedShape)(draggedShape, hoveredShape);\n\nvar alterSnapGesture = (0, _state.select)(_layout_functions.getAlterSnapGesture)(_gestures.metaHeld);\n\nvar multiselectModifier = _gestures.shiftHeld; // todo abstract out keybindings\n\nvar mouseTransformGesturePrev = (0, _state.select)(_layout_functions.getMouseTransformGesturePrev)(_layout_functions.getScene);\n\nvar mouseTransformState = (0, _state.select)(_layout_functions.getMouseTransformState)(mouseTransformGesturePrev, _gestures.dragging, _gestures.dragVector);\n\nvar mouseTransformGesture = (0, _state.select)(_layout_functions.getMouseTransformGesture)(mouseTransformState);\n\nvar transformGestures = mouseTransformGesture;\n\nvar restateShapesEvent = (0, _state.select)(_layout_functions.getRestateShapesEvent)(_layout_functions.primaryUpdate);\n\n// directSelect is an API entry point (via the `shapeSelect` action) that lets the client directly specify what thing\nvar directSelect = (0, _state.select)(_layout_functions.getDirectSelect)(_layout_functions.primaryUpdate);\n\nvar selectedShapeObjects = (0, _state.select)(_layout_functions.getSelectedShapeObjects)(_layout_functions.getScene);\n\nvar selectedShapesPrev = (0, _state.select)(_layout_functions.getSelectedShapesPrev)(_layout_functions.getScene);\n\nvar selectionState = (0, _state.select)(_layout_functions.getSelectionState)(selectedShapesPrev, _layout_functions.configuration, selectedShapeObjects, hoveredShapes, _gestures.mouseButton, _gestures.metaHeld, multiselectModifier, directSelect, shapes);\n\nvar selectedShapes = (0, _state.select)(_layout_functions.getSelectedShapes)(selectionState);\n\nvar selectedPrimaryShapeIds = (0, _state.select)(_layout_functions.getSelectedPrimaryShapeIds)(selectedShapes); // fixme unify with contentShape\n\nvar symmetricManipulation = _gestures.optionHeld; // as in comparable software applications, todo: make configurable\n\nvar resizeManipulator = (0, _state.select)(_layout_functions.getResizeManipulator)(_layout_functions.configuration, symmetricManipulation);\n\nvar transformIntents = (0, _state.select)(_layout_functions.getTransformIntents)(_layout_functions.configuration, transformGestures, selectedShapes, shapes, _gestures.cursorPosition, alterSnapGesture, resizeManipulator);\n\n// \"cumulative\" is the effect of the ongoing interaction; \"baseline\" is sans \"cumulative\", plain \"localTransformMatrix\"\n\nvar nextShapes = (0, _state.select)(_layout_functions.getNextShapes)(shapes, restateShapesEvent);\n\nvar transformedShapes = (0, _state.select)(_layout_functions.applyLocalTransforms)(nextShapes, transformIntents);\n\nvar draggedPrimaryShape = (0, _state.select)(_layout_functions.getDraggedPrimaryShape)(shapes, draggedShape);\n\nvar alignmentGuideAnnotations = (0, _state.select)(_layout_functions.getAlignmentGuideAnnotations)(_layout_functions.configuration, transformedShapes, draggedPrimaryShape, draggedShape);\n\nvar hoverAnnotations = (0, _state.select)(_layout_functions.getHoverAnnotations)(_layout_functions.configuration, hoveredShape, selectedPrimaryShapeIds, draggedShape);\n\n// Once the interaction is over, ensure that the shape stays put where the constraint led it - distance is no longer relevant\n// Note that this is what standard software (Adobe Illustrator, Google Slides, PowerPoint, Sketch etc.) do, but it's in\n// stark contrast with the concept of StickyLines - whose central idea is that constraints remain applied until explicitly\n\nvar snappedShapes = (0, _state.select)(_layout_functions.getSnappedShapes)(_layout_functions.configuration, transformedShapes, draggedShape, draggedPrimaryShape, alignmentGuideAnnotations, alterSnapGesture, symmetricManipulation);\n\nvar constrainedShapesWithPreexistingAnnotations = (0, _state.select)(_layout_functions.getConstrainedShapesWithPreexistingAnnotations)(snappedShapes, transformedShapes);\n\nvar rotationTooltipAnnotation = (0, _state.select)(_layout_functions.getRotationTooltipAnnotation)(_layout_functions.configuration, draggedPrimaryShape, draggedShape, transformIntents, _gestures.cursorPosition);\n\nvar groupAction = (0, _state.select)(_layout_functions.getGroupAction)(_gestures.actionEvent, _gestures.mouseIsDown);\n\nvar grouping = (0, _state.select)(_layout_functions.getGrouping)(_layout_functions.configuration, constrainedShapesWithPreexistingAnnotations, selectedShapes, groupAction);\n\nvar groupedSelectedShapes = (0, _state.select)(_layout_functions.getGroupedSelectedShapes)(grouping);\n\nvar groupedSelectedShapeIds = (0, _state.select)(_layout_functions.getGroupedSelectedShapeIds)(groupedSelectedShapes);\n\nvar groupedSelectedPrimaryShapeIds = (0, _state.select)(_layout_functions.getGroupedSelectedPrimaryShapeIds)(groupedSelectedShapes);\n\nvar adHocChildrenAnnotations = (0, _state.select)(_layout_functions.getAdHocChildrenAnnotations)(_layout_functions.configuration, grouping);\n\nvar resizeAnnotations = (0, _state.select)(_layout_functions.resizeAnnotationsFunction)(_layout_functions.configuration, grouping);\n\nvar rotationAnnotations = (0, _state.select)(_layout_functions.getRotationAnnotations)(_layout_functions.configuration, grouping);\n\nvar annotatedShapes = (0, _state.select)(_layout_functions.getAnnotatedShapes)(grouping, alignmentGuideAnnotations, hoverAnnotations, rotationAnnotations, resizeAnnotations, rotationTooltipAnnotation, adHocChildrenAnnotations);\n\nvar globalTransformShapes = (0, _state.select)(_layout_functions.cascadeProperties)(annotatedShapes);\n\nvar cursor = (0, _state.select)(_layout_functions.getCursor)(_layout_functions.configuration, focusedShape, draggedPrimaryShape);\n\n// this is the core scenegraph update invocation: upon new cursor position etc. emit the new scenegraph\n// it's _the_ state representation (at a PoC level...) comprising of transient properties eg. draggedShape, and the\nvar nextScene = exports.nextScene = (0, _state.select)(_layout_functions.getNextScene)(_layout_functions.configuration, hoveredShape, groupedSelectedShapeIds, groupedSelectedPrimaryShapeIds, globalTransformShapes, _gestures.gestureEnd, draggedShape, cursor, selectionState, mouseTransformState, groupedSelectedShapes);",null]}