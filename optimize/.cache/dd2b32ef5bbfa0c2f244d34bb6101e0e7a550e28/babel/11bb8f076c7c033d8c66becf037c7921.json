{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/agg_types/param_types/field.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/agg_types/param_types/field.js","mtime":1567631711701},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FieldParamType = FieldParamType;\n\nvar _lodash = require('lodash');\n\nvar _errors = require('../../errors');\n\nvar _field = require('../controls/field.html');\n\nvar _field2 = _interopRequireDefault(_field);\n\nvar _base = require('./base');\n\nrequire('../../filters/field_type');\n\nvar _indexed_array = require('../../indexed_array');\n\nvar _notify = require('../../notify');\n\nvar _legacy_class = require('../../utils/legacy_class');\n\nvar _prop_filter = require('../../filters/_prop_filter');\n\nvar _i18n = require('@kbn/i18n');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar filterByType = (0, _prop_filter.propFilter)('type');\n\nfunction FieldParamType(config) {\n  FieldParamType.Super.call(this, config);\n}\n\n(0, _legacy_class.createLegacyClass)(FieldParamType).inherits(_base.BaseParamType);\n\nFieldParamType.prototype.editor = _field2.default;\nFieldParamType.prototype.scriptable = true;\nFieldParamType.prototype.filterFieldTypes = '*';\n// retain only the fields with the aggregatable property if the onlyAggregatable option is true\nFieldParamType.prototype.onlyAggregatable = true;\n\n/**\n * Called to serialize values for saving an aggConfig object\n *\n * @param  {field} field - the field that was selected\n * @return {string}\n */\nFieldParamType.prototype.serialize = function (field) {\n  return field.name;\n};\n\n/**\n * Called to read values from a database record into the\n * aggConfig object\n *\n * @param  {string} fieldName\n * @return {field}\n */\nFieldParamType.prototype.deserialize = function (fieldName, aggConfig) {\n  var field = aggConfig.getIndexPattern().fields.byName[fieldName];\n\n  if (!field) {\n    throw new _errors.SavedObjectNotFound('index-pattern-field', fieldName);\n  }\n\n  var validField = this.getAvailableFields(aggConfig.getIndexPattern().fields).byName[fieldName];\n  if (!validField) {\n    _notify.toastNotifications.addDanger(_i18n.i18n.translate('common.ui.aggTypes.paramTypes.field.invalidSavedFieldParameterErrorMessage', {\n      defaultMessage: 'Saved {fieldParameter} parameter is now invalid. Please select a new field.',\n      values: {\n        fieldParameter: '\"field\"'\n      }\n    }));\n  }\n\n  return validField;\n};\n\n/**\n * filter the fields to the available ones\n */\nFieldParamType.prototype.getAvailableFields = function (fields) {\n  var _this = this;\n\n  var filteredFields = fields.filter(function (field) {\n    var onlyAggregatable = _this.onlyAggregatable,\n        scriptable = _this.scriptable,\n        filterFieldTypes = _this.filterFieldTypes;\n\n\n    if (onlyAggregatable && !field.aggregatable || !scriptable && field.scripted) {\n      return false;\n    }\n\n    if (!filterFieldTypes) {\n      return true;\n    }\n\n    return filterByType([field], filterFieldTypes).length !== 0;\n  });\n\n  return new _indexed_array.IndexedArray({\n    index: ['name'],\n    group: ['type'],\n    initialSet: (0, _lodash.sortBy)(filteredFields, ['type', 'name'])\n  });\n};\n\n/**\n * Write the aggregation parameter.\n *\n * @param  {AggConfig} aggConfig - the entire configuration for this agg\n * @param  {object} output - the result of calling write on all of the aggregations\n *                         parameters.\n * @param  {object} output.params - the final object that will be included as the params\n *                               for the agg\n * @return {undefined}\n */\nFieldParamType.prototype.write = function (aggConfig, output) {\n  var field = aggConfig.getField();\n\n  if (!field) {\n    throw new TypeError(_i18n.i18n.translate('common.ui.aggTypes.paramTypes.field.requiredFieldParameterErrorMessage', {\n      defaultMessage: '{fieldParameter} is a required parameter',\n      values: {\n        fieldParameter: '\"field\"'\n      }\n    }));\n  }\n\n  if (field.scripted) {\n    output.params.script = {\n      source: field.script,\n      lang: field.lang\n    };\n  } else {\n    output.params.field = field.name;\n  }\n};",null]}