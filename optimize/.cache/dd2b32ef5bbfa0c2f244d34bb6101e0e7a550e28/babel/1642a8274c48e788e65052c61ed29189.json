{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/advanced/new_job_controller.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/advanced/new_job_controller.js","mtime":1567631712054},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nrequire('ace');\n\nrequire('angular-ui-select');\n\nvar _parse_interval = require('ui/utils/parse_interval');\n\nvar _timefilter = require('ui/timefilter');\n\nvar _routes = require('ui/routes');\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nvar _check_license = require('plugins/ml/license/check_license');\n\nvar _check_privilege = require('plugins/ml/privilege/check_privilege');\n\nvar _new_job = require('./new_job.html');\n\nvar _new_job2 = _interopRequireDefault(_new_job);\n\nvar _save_status_modal = require('plugins/ml/jobs/new_job/advanced/save_status_modal/save_status_modal.html');\n\nvar _save_status_modal2 = _interopRequireDefault(_save_status_modal);\n\nvar _new_job_utils = require('plugins/ml/jobs/new_job/utils/new_job_utils');\n\nvar _index_utils = require('plugins/ml/util/index_utils');\n\nvar _field_types = require('plugins/ml/../common/constants/field_types');\n\nvar _validation = require('plugins/ml/../common/constants/validation');\n\nvar _check_ml_nodes = require('plugins/ml/ml_nodes_check/check_ml_nodes');\n\nvar _new_job_defaults = require('plugins/ml/jobs/new_job/utils/new_job_defaults');\n\nvar _job_utils = require('plugins/ml/../common/util/job_utils');\n\nvar _job_service = require('plugins/ml/services/job_service');\n\nvar _messagebar_service = require('plugins/ml/components/messagebar/messagebar_service');\n\nvar _ml_api_service = require('plugins/ml/services/ml_api_service');\n\nvar _modules = require('ui/modules');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /*\n                                                                                                                                                                                                     * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                     * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                     * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                     */\n\n_routes2.default.when('/jobs/new_job/advanced', {\n  template: _new_job2.default,\n  resolve: {\n    CheckLicense: _check_license.checkFullLicense,\n    privileges: _check_privilege.checkCreateJobsPrivilege,\n    indexPattern: _index_utils.loadCurrentIndexPattern,\n    indexPatterns: _index_utils.loadIndexPatterns,\n    savedSearch: _index_utils.loadCurrentSavedSearch,\n    checkMlNodesAvailable: _check_ml_nodes.checkMlNodesAvailable,\n    loadNewJobDefaults: _new_job_defaults.loadNewJobDefaults\n  }\n}).when('/jobs/new_job/advanced/:jobId', {\n  template: _new_job2.default,\n  resolve: {\n    CheckLicense: _check_license.checkFullLicense,\n    privileges: _check_privilege.checkCreateJobsPrivilege,\n    indexPattern: _index_utils.loadCurrentIndexPattern,\n    indexPatterns: _index_utils.loadIndexPatterns,\n    savedSearch: _index_utils.loadCurrentSavedSearch,\n    checkMlNodesAvailable: _check_ml_nodes.checkMlNodesAvailable,\n    loadNewJobDefaults: _new_job_defaults.loadNewJobDefaults\n  }\n});\n\nvar _module = _modules.uiModules.get('apps/ml');\n\n_module.controller('MlNewJob', function ($scope, $route, $location, $modal, Private, mlDatafeedService, mlConfirmModalService, i18n) {\n\n  _timefilter.timefilter.disableTimeRangeSelector(); // remove time picker from top of page\n  _timefilter.timefilter.disableAutoRefreshSelector(); // remove time picker from top of page\n  var MODE = {\n    NEW: 0,\n    EDIT: 1,\n    CLONE: 2\n  };\n\n  var INDEX_INPUT_TYPE = {\n    TEXT: 'TEXT',\n    LIST: 'LIST'\n  };\n  $scope.INDEX_INPUT_TYPE = INDEX_INPUT_TYPE;\n\n  var fieldsToIgnore = ['_id', '_field_names', '_index', '_parent', '_routing', '_seq_no', '_source', '_type', '_uid', '_version', '_feature', '_ignored'];\n\n  var allowedInfluencerTypes = [_field_types.ES_FIELD_TYPES.TEXT, _field_types.ES_FIELD_TYPES.KEYWORD, _field_types.ES_FIELD_TYPES.IP];\n\n  // ui model, used to store and control job data that wont be posted to the server.\n  var msgs = _messagebar_service.mlMessageBarService;\n  var mlConfirm = mlConfirmModalService;\n  msgs.clear();\n  var jobDefaults = (0, _new_job_defaults.newJobDefaults)();\n  // For keeping a copy of the detectors for comparison\n  var currentConfigs = { detectors: [], model_plot_config: { enabled: false } };\n\n  $scope.job = {};\n  $scope.mode = MODE.NEW;\n  $scope.saveLock = false;\n  $scope.indices = {};\n  $scope.types = {};\n  $scope.fields = {};\n  $scope.dateFields = {};\n  $scope.catFields = {};\n  $scope.maximumFileSize;\n  $scope.mlElasticDataDescriptionExposedFunctions = {};\n  $scope.elasticServerInfo = {};\n  $scope.jobGroupsUpdateFunction = {};\n\n  $scope.enterJobNameLabel = i18n('xpack.ml.newJob.advanced.jobDetails.enterJobNameLabel', {\n    defaultMessage: 'Enter a name for the job'\n  });\n  $scope.bucketSpanNotValidFormatLabel = i18n('xpack.ml.newJob.advanced.analysisConfiguration.bucketSpanNotValidFormatLabel', {\n    defaultMessage: '{bucketSpan} is not a valid time interval format',\n    values: { bucketSpan: 'bucket_span' }\n  });\n  $scope.categorizationFiltersNotValidLabel = i18n('xpack.ml.newJob.advanced.analysisConfiguration.categorizationFiltersNotValidLabel', {\n    defaultMessage: 'Categorization filters must all be valid regular expressions'\n  });\n  $scope.detectorNotConfiguredLabel = i18n('xpack.ml.newJob.advanced.analysisConfiguration.detectorNotConfiguredLabel', {\n    defaultMessage: 'At least one detector should be configured'\n  });\n  $scope.influencerNotSelectedLabel = i18n('xpack.ml.newJob.advanced.analysisConfiguration.influencerNotSelectedLabel', {\n    defaultMessage: 'At least one influencer should be selected'\n  });\n  $scope.validatingCardinalityLabel = i18n('xpack.ml.newJob.advanced.analysisConfiguration.validatingCardinalityLabel', {\n    defaultMessage: 'Validating cardinalityâ€¦'\n  });\n  $scope.enableModelPlotLabel = i18n('xpack.ml.newJob.advanced.analysisConfiguration.enableModelPlotLabel', {\n    defaultMessage: 'Enable model plot'\n  });\n  $scope.specifyTimeFieldLabel = i18n('xpack.ml.newJob.advanced.dataDescription.specifyTimeFieldLabel', {\n    defaultMessage: 'Time field should be specified'\n  });\n  $scope.specifyTimeFormatLabel = i18n('xpack.ml.newJob.advanced.dataDescription.specifyTimeFormatLabel', {\n    defaultMessage: 'Time format should be specified'\n  });\n\n  $scope.ui = {\n    pageTitle: i18n('xpack.ml.newJob.advanced.createNewJobTitle', {\n      defaultMessage: 'Create a new job'\n    }),\n    dataLocation: 'ES',\n    dataPreview: '',\n    currentTab: 0,\n    tabs: [{ index: 0, title: i18n('xpack.ml.newJob.advanced.tabs.jobDetailsLabel', { defaultMessage: 'Job Details' }) }, { index: 1, title: i18n('xpack.ml.newJob.advanced.tabs.analysisConfigurationLabel', { defaultMessage: 'Analysis Configuration' }) }, {\n      index: 2,\n      title: i18n('xpack.ml.newJob.advanced.tabs.dataDescriptionLabel', { defaultMessage: 'Data Description' }),\n      hidden: true\n    }, { index: 3, title: i18n('xpack.ml.newJob.advanced.tabs.datafeedLabel', { defaultMessage: 'Datafeed' }) }, { index: 4, title: i18n('xpack.ml.newJob.advanced.tabs.editJsonLabel', { defaultMessage: 'Edit JSON' }) }, { index: 5, title: i18n('xpack.ml.newJob.advanced.tabs.dataPreviewLabel', { defaultMessage: 'Data Preview' }), hidden: true }],\n    validation: {\n      tabs: [{ index: 0, valid: true, checks: { jobId: { valid: true }, groupIds: { valid: true }, modelMemoryLimit: { valid: true } } }, { index: 1, valid: true, checks: {\n          detectors: { valid: true }, influencers: { valid: true }, categorizationFilters: { valid: true }, bucketSpan: { valid: true }\n        } }, { index: 2, valid: true, checks: { timeField: { valid: true }, timeFormat: { valid: true } } }, { index: 3, valid: true, checks: { isDatafeed: { valid: true }, hasAccessToIndex: { valid: true } } }, { index: 4, valid: true, checks: {} }, { index: 5, valid: true, checks: {} }],\n      setTabValid: function setTabValid(tab, valid) {\n        $scope.ui.validation.tabs[tab].valid = valid;\n      }\n    },\n    cardinalityValidator: {\n      status: 0, message: '', STATUS: {\n        FAILED: -1,\n        NOT_RUNNING: 0,\n        RUNNING: 1,\n        FINISHED: 2,\n        WARNING: 3\n      }\n    },\n    jsonText: '',\n    changeTab: changeTab,\n    influencers: [],\n    allInfluencers: allInfluencers,\n    customInfluencers: [],\n    tempCustomInfluencer: '',\n    inputDataFormat: [{ value: 'delimited', title: i18n('xpack.ml.newJob.advanced.delimitedLabel', { defaultMessage: 'Delimited' }) }, { value: 'json', title: 'JSON' }],\n    fieldDelimiterOptions: [{ value: '\\t', title: i18n('xpack.ml.newJob.advanced.tabLabel', { defaultMessage: 'tab' }) }, { value: ' ', title: i18n('xpack.ml.newJob.advanced.spaceLabel', { defaultMessage: 'space' }) }, { value: ',', title: ',' }, { value: ';', title: ';' }, { value: 'custom', title: i18n('xpack.ml.newJob.advanced.customLabel', { defaultMessage: 'custom' }) }],\n    selectedFieldDelimiter: ',',\n    customFieldDelimiter: '',\n    indexTextOk: false,\n    fieldsUpToDate: false,\n    indices: {},\n    types: {},\n    isDatafeed: true,\n    useDedicatedIndex: false,\n    enableModelPlot: false,\n    modelMemoryLimit: '',\n    modelMemoryLimitDefault: jobDefaults.anomaly_detectors.model_memory_limit,\n\n    datafeed: {\n      queryText: '{\"match_all\":{}}',\n      queryDelayText: '',\n      queryDelayDefault: '60s',\n      frequencyText: '',\n      frequencyDefault: '',\n      scrollSizeText: '',\n      scrollSizeDefault: 1000,\n      indicesText: '',\n      typesText: '',\n      scriptFields: []\n    },\n    saveStatus: {\n      job: 0\n    }\n  };\n\n  function init() {\n    // load the jobs list for job id validation later on\n    _job_service.mlJobService.loadJobs();\n\n    // check to see whether currentJob is set.\n    // if it is, this isn't a new job, it's either a clone or an edit.\n    if (_job_service.mlJobService.currentJob) {\n      // try to get the jobId from the url.\n      // if it's set, this is a job edit\n      var jobId = $route.current.params.jobId;\n\n      // make a copy of the currentJob object. so we don't corrupt the real job\n      $scope.job = _job_service.mlJobService.cloneJob(_job_service.mlJobService.currentJob);\n\n      if (jobId) {\n        $scope.mode = MODE.EDIT;\n        console.log('Editing job', _job_service.mlJobService.currentJob);\n        $scope.ui.pageTitle = i18n('xpack.ml.newJob.advanced.editingJobPageTitle', {\n          defaultMessage: 'Editing Job {jobId}',\n          values: { jobId: $scope.job.job_id }\n        });\n      } else {\n        // if the job_version is undefined, assume we have transferred to this page from\n        // a new job wizard.\n        // Alternatively, we are cloning a job and so the job already has a job_version\n        if (_job_service.mlJobService.currentJob.job_version === undefined) {\n          $scope.mode = MODE.NEW;\n\n          // if results_index_name exists, the dedicated index checkbox has been checked\n          if ($scope.job.results_index_name !== undefined) {\n            $scope.ui.useDedicatedIndex = true;\n          }\n        } else {\n          $scope.mode = MODE.CLONE;\n          console.log('Cloning job', _job_service.mlJobService.currentJob);\n          $scope.ui.pageTitle = i18n('xpack.ml.newJob.advanced.cloneJobFromPageTitle', {\n            defaultMessage: 'Clone Job from {jobId}',\n            values: { jobId: $scope.job.job_id }\n          });\n          $scope.job.job_id = '';\n\n          if ($scope.job.results_index_name === 'shared') {\n            delete $scope.job.results_index_name;\n          } else {\n            $scope.ui.useDedicatedIndex = true;\n            $scope.job.results_index_name = '';\n          }\n        }\n        setDatafeedUIText();\n        setFieldDelimiterControlsFromText();\n\n        // if the datafeedConfig doesn't exist, assume we're cloning from a job with no datafeed\n        if (!$scope.job.datafeed_config) {\n          $scope.ui.dataLocation = 'NONE';\n\n          $scope.ui.influencers = _angular2.default.copy($scope.job.analysis_config.influencers);\n        }\n\n        if ($scope.job.analysis_limits && $scope.job.analysis_limits.model_memory_limit) {\n          $scope.ui.modelMemoryLimitText = $scope.job.analysis_limits.model_memory_limit;\n        }\n      }\n\n      // clear the current job\n      _job_service.mlJobService.currentJob = undefined;\n    } else {\n      $scope.mode = MODE.NEW;\n      console.log('Creating new job');\n      $scope.job = _job_service.mlJobService.getBlankJob();\n      $scope.job.data_description.format = 'json';\n      delete $scope.job.data_description.time_format;\n      delete $scope.job.data_description.format;\n\n      populateFormFromUrl();\n    }\n\n    loadFields().then(function () {\n      calculateDatafeedFrequencyDefaultSeconds();\n      showDataPreviewTab();\n    }).catch(function () {\n      calculateDatafeedFrequencyDefaultSeconds();\n    });\n  }\n\n  function checkForConfigUpdates() {\n    var STATUS = $scope.ui.cardinalityValidator.STATUS;\n    // Check if enable model plot was set/has changed and update if it has.\n\n    var jobModelPlotValue = $scope.job.model_plot_config ? $scope.job.model_plot_config : { enabled: false };\n    var modelPlotSettingsEqual = _lodash2.default.isEqual(currentConfigs.model_plot_config, jobModelPlotValue);\n\n    if (!modelPlotSettingsEqual) {\n      // Update currentConfigs.\n      currentConfigs.model_plot_config.enabled = jobModelPlotValue.enabled;\n      // Update ui portion so checkbox is checked\n      $scope.ui.enableModelPlot = jobModelPlotValue.enabled;\n    }\n\n    if ($scope.ui.enableModelPlot === true) {\n      var unchanged = _lodash2.default.isEqual(currentConfigs.detectors, $scope.job.analysis_config.detectors);\n      // if detectors changed OR model plot was just toggled on run cardinality\n      if (!unchanged || !modelPlotSettingsEqual) {\n        runValidateCardinality();\n      }\n    } else {\n      $scope.ui.cardinalityValidator.status = STATUS.FINISHED;\n      $scope.ui.cardinalityValidator.message = '';\n    }\n  }\n\n  function changeTab(tab) {\n    $scope.ui.currentTab = tab.index;\n    // Selecting Analysis Configuration tab\n    if (tab.index === 1) {\n      checkForConfigUpdates();\n    } else if (tab.index === 4) {\n      createJSONText();\n    } else if (tab.index === 5) {\n      if ($scope.ui.dataLocation === 'ES') {\n        loadDataPreview();\n      }\n    }\n  }\n\n  $scope.indexChanged = function () {\n    $scope.ui.fieldsUpToDate = false;\n  };\n\n  $scope.loadFields = function () {\n    loadFields().catch(function () {\n      // No need to do anything here as loadFields handles the displaying of any errors.\n    }).then(function () {\n      $scope.$applyAsync();\n    });\n  };\n\n  function loadFields() {\n    return new Promise(function (resolve, reject) {\n      clear($scope.fields);\n      clear($scope.dateFields);\n      clear($scope.catFields);\n      clear($scope.ui.influencers);\n\n      var index = $scope.ui.datafeed.indicesText;\n      if (index !== '') {\n        _ml_api_service.ml.getFieldCaps({ index: index }).then(function (resp) {\n          $scope.ui.fieldsUpToDate = true;\n          _lodash2.default.each(resp, function (fieldList) {\n            _lodash2.default.each(fieldList, function (field, fieldName) {\n              _lodash2.default.each(field, function (type) {\n                if (fieldsToIgnore.indexOf(fieldName) === -1) {\n\n                  var addField = true;\n                  if (fieldName.match(/\\.keyword$/)) {\n                    // if this is a keyword version of a field, check to see whether a non-keyword\n                    // version has already been added. if so, delete it.\n                    var keywordLess = fieldName.replace('.keyword');\n                    if ($scope.fields[keywordLess] !== undefined) {\n                      delete $scope.fields[keywordLess];\n                    }\n                  } else if ($scope.fields[fieldName + '.keyword'] !== undefined) {\n                    // if this is not a keyword version of a field, but a keyword version has already been\n                    // added, don't add this field.\n                    addField = false;\n                  }\n\n                  if (addField) {\n                    $scope.fields[fieldName] = type;\n\n                    if (type.type === _field_types.ML_JOB_FIELD_TYPES.DATE) {\n                      $scope.dateFields[fieldName] = type;\n                    }\n                    if (type.type === _field_types.ML_JOB_FIELD_TYPES.TEXT || type.type === _field_types.ML_JOB_FIELD_TYPES.KEYWORD) {\n                      $scope.catFields[fieldName] = type;\n                    }\n                    if (allowedInfluencerTypes.indexOf(type.type) !== -1) {\n                      $scope.ui.influencers.push(fieldName);\n                    }\n                  }\n                }\n              });\n            });\n          });\n\n          // Add script fields from the job configuration to $scope.fields\n          // so they're available from within the dropdown in the detector modal.\n          var scriptFields = Object.keys(_lodash2.default.get($scope.job, 'datafeed_config.script_fields', {}));\n          // This type information is retrieved via fieldCaps for regular fields,\n          // here we're creating a similar object so the script field is usable further on.\n          var scriptType = { type: 'script_fields', searchable: false, aggregatable: true };\n          scriptFields.forEach(function (fieldName) {\n            $scope.fields[fieldName] = scriptType;\n          });\n\n          if (Object.keys($scope.fields).length) {\n            $scope.ui.indexTextOk = true;\n          }\n          validateIndex($scope.ui.validation.tabs);\n          guessTimeField();\n          resolve();\n        }).catch(function (error) {\n          $scope.ui.indexTextOk = false;\n          validateIndex($scope.ui.validation.tabs);\n          reject(error);\n        });\n      } else {\n        reject();\n      }\n    });\n  }\n\n  function guessTimeField() {\n    var currentTimeField = $scope.job.data_description.time_field;\n    if ($scope.dateFields[currentTimeField] === undefined) {\n      currentTimeField = '';\n      $scope.job.data_description.time_field = '';\n    }\n    if (currentTimeField === '' && Object.keys($scope.dateFields).length) {\n      $scope.job.data_description.time_field = Object.keys($scope.dateFields)[0];\n      console.log('guessTimeField: guessed time fields: ', $scope.job.data_description.time_field);\n    }\n  }\n\n  // isCurrentJobConfig is used to track if the form configuration\n  // changed since the last job validation was done\n  $scope.isCurrentJobConfig = false;\n  // need to pass true as third argument here to track granular changes\n  $scope.$watch('job', function () {\n    $scope.isCurrentJobConfig = false;\n  }, true);\n  $scope.getJobConfig = function () {\n    getDelimiterSelection();\n    getDatafeedSelection();\n    getAnalysisLimitsSelection();\n    $scope.isCurrentJobConfig = true;\n    return $scope.job;\n  };\n\n  $scope.save = function () {\n    console.log('save() job: ', $scope.job);\n    msgs.clear();\n    getDelimiterSelection();\n    getDatafeedSelection();\n    getAnalysisLimitsSelection();\n\n    var jobValid = validateJob();\n\n    if (jobValid.valid) {\n      // if basic validation passes\n      // refresh jobs list to check that the job id doesn't already exist.\n      _job_service.mlJobService.loadJobs().then(function () {\n        // check that the job id doesn't already exist\n        var tempJob = _job_service.mlJobService.getJob($scope.job.job_id);\n        if (tempJob) {\n          var tab = $scope.ui.validation.tabs[0];\n          tab.valid = false;\n          tab.checks.jobId.valid = false;\n          tab.checks.jobId.message = i18n('xpack.ml.newJob.advanced.jobAlreadyExistsLabel', {\n            defaultMessage: '\\'{jobId}\\' already exists, please choose a different name',\n            values: { jobId: $scope.job.job_id }\n          });\n          changeTab({ index: 0 });\n          $scope.$applyAsync();\n        } else {\n          checkInfluencers();\n        }\n\n        function checkInfluencers() {\n          // check that they have chosen some influencers\n          if ($scope.job.analysis_config.influencers && $scope.job.analysis_config.influencers.length) {\n            saveFunc();\n          } else {\n            // if there are no influencers set, open a confirmation\n            mlConfirm.open({\n              message: i18n('xpack.ml.newJob.advanced.noInfluencersChosenConfirmModalDescription', {\n                defaultMessage: 'You have not chosen any influencers, do you want to continue?'\n              }),\n              title: i18n('xpack.ml.newJob.advanced.noInfluencersChosenConfirmModalTitle', {\n                defaultMessage: 'No Influencers'\n              })\n            }).then(saveFunc).catch(function () {\n              changeTab({ index: 1 });\n            });\n          }\n        }\n\n        function saveFunc() {\n\n          if ($scope.ui.useDedicatedIndex) {\n            // if the dedicated index checkbox has been ticked\n            // and the user hasn't added a custom value for it\n            // in the JSON, use the job id.\n            if ($scope.job.results_index_name === '') {\n              $scope.job.results_index_name = $scope.job.job_id;\n            }\n          } else {\n            // otherwise delete it, just to be sure.\n            delete $scope.job.results_index_name;\n          }\n\n          $scope.saveLock = true;\n          $scope.ui.saveStatus.job = 1;\n          openSaveStatusWindow();\n\n          var job = (0, _new_job_utils.createJobForSaving)($scope.job);\n\n          _job_service.mlJobService.saveNewJob(job).then(function (result) {\n            if (result.success) {\n              var saveNewDatafeed = function saveNewDatafeed(datafeedConfig, jobId) {\n                if (datafeedConfig) {\n                  // open job successful, create a new datafeed\n                  _job_service.mlJobService.saveNewDatafeed(datafeedConfig, jobId).then(function () {\n                    $scope.saveLock = false;\n                  }).catch(function (resp) {\n                    msgs.error(i18n('xpack.ml.newJob.advanced.couldNotCreateDatafeedErrorMessage', {\n                      defaultMessage: 'Could not create datafeed:'\n                    }), resp);\n                    $scope.saveLock = false;\n                  }).then(function () {\n                    $scope.$applyAsync();\n                  });\n                } else {\n                  // no datafeed, so save is complete\n                  $scope.saveLock = false;\n                  $scope.$applyAsync();\n                }\n              };\n\n              // });\n              //  });\n\n\n              // TODO - re-enable the refreshing of the index pattern fields once there is a\n              // resolution to https://github.com/elastic/kibana/issues/9466\n              // In the meantime, to prevent the aggregatable and searchable properties of any\n              // fields configured in the job (i.e. influencer, by, over, partition field_name/value)\n              // but not present in any results being set back to false by Kibana's call to the\n              // field stats API, comment out the call to refreshFields().\n              // The user will have to hit the 'Refresh field List' button in Kibana's Index Patterns\n              // management page for the .ml-anomalies-* index pattern for any new fields.\n              //\n              // After the job has been successfully created the Elasticsearch\n              // mappings should be fully set up, but the Kibana mappings then\n              // need to be refreshed to reflect the Elasticsearch mappings for\n              // any new analytical fields that have been configured in the job.\n              //indexPatterns.get('.ml-anomalies-*')\n              //.then((indexPattern) => {\n              //  indexPattern.refreshFields()\n              //  .then(() => {\n              //    console.log('refreshed fields for index pattern .ml-anomalies-*');\n              //    wait for mappings refresh before continuing on with the post save stuff\n              msgs.info(i18n('xpack.ml.newJob.advanced.newJobAddedNotificationMessage', {\n                defaultMessage: 'New Job \\'{jobId}\\' added',\n                values: { jobId: result.resp.job_id }\n              }));\n              // update status\n              $scope.ui.saveStatus.job = 2;\n              $scope.$applyAsync();\n\n              // save successful, attempt to open the job\n              _job_service.mlJobService.openJob($scope.job.job_id).then(function () {\n                saveNewDatafeed($scope.job.datafeed_config, $scope.job.job_id);\n              }).catch(function (resp) {\n                msgs.error(i18n('xpack.ml.newJob.advanced.couldNotOpenJobErrorMessage', {\n                  defaultMessage: 'Could not open job:'\n                }), resp);\n                msgs.error(i18n('xpack.ml.newJob.advanced.jobCreatedAndCreatingDatafeedAnywayErrorMessage', {\n                  defaultMessage: 'Job created, creating datafeed anyway'\n                }));\n                saveNewDatafeed($scope.job.datafeed_config, $scope.job.job_id);\n              });\n            } else {\n              // save failed, unlock the buttons and tell the user\n              $scope.ui.saveStatus.job = -1;\n              $scope.saveLock = false;\n              msgs.error(i18n('xpack.ml.newJob.advanced.unsuccessfulSavingResultErrorMessage', {\n                defaultMessage: 'Save failed: {message}',\n                values: { message: result.resp.message }\n              }));\n              $scope.$applyAsync();\n            }\n          }).catch(function (result) {\n            $scope.ui.saveStatus.job = -1;\n            $scope.saveLock = false;\n            msgs.error(i18n('xpack.ml.newJob.advanced.saveFailedWithMessageErrorMessage', {\n              defaultMessage: 'Save failed: {message}',\n              values: { message: result.resp.message }\n            }));\n            $scope.$applyAsync();\n          });\n        }\n      }).catch(function () {\n        msgs.error(i18n('xpack.ml.newJob.advanced.saveFailedErrorMessage', {\n          defaultMessage: 'Save failed'\n        }));\n        console.log('save(): job validation failed. Jobs list could not be loaded.');\n        $scope.$applyAsync();\n      });\n    } else {\n      msgs.error(jobValid.message);\n      console.log('save(): job validation failed');\n      $scope.$applyAsync();\n    }\n  };\n\n  $scope.cancel = function () {\n    mlConfirm.open({\n      message: i18n('xpack.ml.newJob.advanced.cancelJobCreationConfirmModalDescription', {\n        defaultMessage: 'Are you sure you want to cancel job creation?'\n      }),\n      title: i18n('xpack.ml.newJob.advanced.cancelJobCreationConfirmModalTitle', {\n        defaultMessage: 'Are you sure?'\n      })\n    }).then(function () {\n      msgs.clear();\n      $scope.$applyAsync();\n      $location.path('jobs');\n    });\n  };\n\n  // called after loading ES data when cloning a job\n  $scope.cloneJobDataDescriptionCallback = function () {\n    extractCustomInfluencers();\n  };\n\n  // if an index pattern or saved search has been added to the url\n  // populate those items in the form and datafeed config\n  function populateFormFromUrl() {\n    var createSearchItems = Private(_new_job_utils.SearchItemsProvider);\n\n    var _createSearchItems = createSearchItems(),\n        indexPattern = _createSearchItems.indexPattern,\n        savedSearch = _createSearchItems.savedSearch,\n        combinedQuery = _createSearchItems.combinedQuery;\n\n    if (indexPattern.id !== undefined) {\n      (0, _index_utils.timeBasedIndexCheck)(indexPattern, true);\n      $scope.ui.datafeed.indicesText = indexPattern.title;\n      $scope.job.data_description.time_field = indexPattern.timeFieldName;\n\n      if (savedSearch.id !== undefined) {\n        $scope.ui.datafeed.queryText = JSON.stringify(combinedQuery);\n      }\n    }\n  }\n\n  $scope.timeFieldSelected = function () {\n    return $scope.job.data_description.time_field === '' ? false : true;\n  };\n\n  $scope.jsonTextChange = function () {\n    try {\n      // create the job from the json text.\n      $scope.job = JSON.parse($scope.ui.jsonText);\n      $scope.changeJobIDCase();\n\n      // update the job groups ui component\n      if ($scope.jobGroupsUpdateFunction.update !== undefined) {\n        $scope.jobGroupsUpdateFunction.update($scope.job.groups);\n      }\n\n      // in case influencers have been added into the json. treat them as custom if unrecognised\n      extractCustomInfluencers();\n\n      setFieldDelimiterControlsFromText();\n      setDatafeedUIText();\n      setAnalysisLimitsUIText();\n\n      // if results_index_name exists, tick the dedicated index checkbox\n      if ($scope.job.results_index_name !== undefined) {\n        $scope.ui.useDedicatedIndex = true;\n      } else {\n        $scope.ui.useDedicatedIndex = false;\n      }\n    } catch (e) {\n      console.log('JSON could not be parsed');\n      // a better warning should be used.\n      // colour the json text area red and display a warning somewhere. possibly in the message bar.\n    }\n  };\n\n  // force job ids to be lowercase\n  $scope.changeJobIDCase = function () {\n    if ($scope.job.job_id) {\n      $scope.job.job_id = $scope.job.job_id.toLowerCase();\n    }\n  };\n\n  // called when the datafeed tickbox is toggled.\n  // creates or destroys the datafeed section in the config\n  $scope.datafeedChange = function () {\n    if ($scope.ui.isDatafeed) {\n      $scope.job.datafeed_config = {};\n      $scope.ui.tabs[2].hidden = true;\n      calculateDatafeedFrequencyDefaultSeconds();\n    } else {\n      delete $scope.job.datafeed_config;\n      $scope.ui.tabs[2].hidden = false;\n      $scope.job.data_description.format = 'json';\n    }\n\n    showDataPreviewTab();\n  };\n\n  $scope.setDedicatedIndex = function () {\n    if ($scope.ui.useDedicatedIndex) {\n      $scope.job.results_index_name = '';\n    } else {\n      delete $scope.job.results_index_name;\n    }\n  };\n\n  function runValidateCardinality() {\n    var STATUS = $scope.ui.cardinalityValidator.STATUS;\n\n    $scope.ui.cardinalityValidator.status = $scope.ui.cardinalityValidator.STATUS.RUNNING;\n\n    var tempJob = _job_service.mlJobService.cloneJob($scope.job);\n    _lodash2.default.merge(tempJob, (0, _new_job_utils.getMinimalValidJob)());\n\n    _ml_api_service.ml.validateCardinality(tempJob).then(function (response) {\n      var validationResult = (0, _new_job_utils.checkCardinalitySuccess)(response);\n\n      if (validationResult.success === true) {\n        $scope.ui.cardinalityValidator.status = STATUS.FINISHED;\n        $scope.ui.cardinalityValidator.message = '';\n      } else {\n        $scope.ui.cardinalityValidator.message = i18n('xpack.ml.newJob.advanced.recommendationForUsingModelPlotWithCardinalityDescription', {\n          defaultMessage: 'Creating model plots is resource intensive and not recommended' + 'where the cardinality of the selected fields is greater than 100. Estimated cardinality' + 'for this job is {highCardinality}.' + 'If you enable model plot with this configuration' + 'we recommend you select a dedicated results index on the Job Details tab.',\n          values: { highCardinality: validationResult.highCardinality }\n        });\n\n        $scope.ui.cardinalityValidator.status = STATUS.WARNING;\n      }\n    }).catch(function (error) {\n      console.log('Cardinality check error:', error);\n      $scope.ui.cardinalityValidator.message = i18n('xpack.ml.newJob.advanced.cardinalityNotValidErrorMessage', {\n        defaultMessage: 'An error occurred validating the configuration' + 'for running the job with model plot enabled.' + 'Creating model plots can be resource intensive and not recommended where the cardinality of the selected fields is high.' + 'You may want to select a dedicated results index on the Job Details tab.'\n      });\n      $scope.ui.cardinalityValidator.status = STATUS.FAILED;\n    }).then(function () {\n      $scope.$applyAsync();\n    });\n  }\n\n  $scope.onDetectorsUpdate = function () {\n    var STATUS = $scope.ui.cardinalityValidator.STATUS;\n\n\n    if ($scope.ui.enableModelPlot === true) {\n      // Update currentConfigs since config changed\n      currentConfigs.detectors = _lodash2.default.cloneDeep($scope.job.analysis_config.detectors);\n\n      if ($scope.job.analysis_config.detectors.length === 0) {\n        $scope.ui.cardinalityValidator.status = STATUS.FINISHED;\n        $scope.ui.cardinalityValidator.message = '';\n      } else {\n        runValidateCardinality();\n      }\n    }\n  };\n\n  $scope.setModelPlotEnabled = function () {\n    var STATUS = $scope.ui.cardinalityValidator.STATUS;\n\n\n    if ($scope.ui.enableModelPlot === true) {\n      // Start keeping track of the config in case of changes from Edit JSON tab requiring another cardinality check\n      currentConfigs.detectors = _lodash2.default.cloneDeep($scope.job.analysis_config.detectors);\n\n      $scope.job.model_plot_config = {\n        enabled: true\n      };\n\n      currentConfigs.model_plot_config.enabled = true;\n      // return early if there's nothing to run a check on yet.\n      if ($scope.job.analysis_config.detectors.length === 0) {\n        return;\n      }\n\n      runValidateCardinality();\n    } else {\n      currentConfigs.model_plot_config.enabled = false;\n      $scope.ui.cardinalityValidator.status = STATUS.FINISHED;\n      $scope.ui.cardinalityValidator.message = '';\n      delete $scope.job.model_plot_config;\n    }\n  };\n\n  // function called by field-select components to set\n  // properties in the analysis_config\n  $scope.setAnalysisConfigProperty = function (value, field) {\n    if (value === '') {\n      // remove the property from the job JSON\n      delete $scope.job.analysis_config[field];\n    } else {\n      $scope.job.analysis_config[field] = value;\n    }\n  };\n\n  function clear(obj) {\n    Object.keys(obj).forEach(function (key) {\n      delete obj[key];\n    });\n    if (Array.isArray(obj)) {\n      obj.length = 0;\n    }\n  }\n\n  // triggered when the user changes the JSON text\n  // reflect the changes in the UI\n  function setDatafeedUIText() {\n    if ($scope.job.datafeed_config && Object.keys($scope.job.datafeed_config).length) {\n      var datafeedConfig = $scope.job.datafeed_config;\n\n      $scope.ui.isDatafeed = true;\n      $scope.ui.tabs[2].hidden = true;\n      $scope.ui.dataLocation = 'ES';\n      showDataPreviewTab();\n\n      var queryDelayDefault = $scope.ui.datafeed.queryDelayDefault;\n      var queryDelay = datafeedConfig.query_delay;\n      if (datafeedConfig.query_delay === undefined || $scope.ui.datafeed.queryDelayDefault === datafeedConfig.query_delay) {\n        queryDelay = '';\n      }\n\n      var frequencyDefault = $scope.ui.datafeed.frequencyDefault;\n      var freq = datafeedConfig.frequency;\n      if (datafeedConfig.frequency === undefined || $scope.ui.datafeed.frequencyDefault === datafeedConfig.frequency) {\n        freq = '';\n      }\n\n      var scrollSizeDefault = $scope.ui.datafeed.scrollSizeDefault;\n      var scrollSize = datafeedConfig.scroll_size;\n      if (datafeedConfig.scroll_size === undefined || $scope.ui.datafeed.scrollSizeDefault === datafeedConfig.scroll_size) {\n        scrollSize = '';\n      }\n\n      clear($scope.types);\n      _lodash2.default.each(datafeedConfig.types, function (type) {\n        $scope.types[type] = $scope.ui.types[type];\n      });\n\n      clear($scope.indices);\n      _lodash2.default.each(datafeedConfig.indices, function (index) {\n        $scope.indices[index] = $scope.ui.indices[index];\n      });\n\n      var indicesText = datafeedConfig.indices.join(',');\n\n      var scriptFields = datafeedConfig.script_fields !== undefined ? Object.keys(datafeedConfig.script_fields) : [];\n\n      var fieldsUpToDate = true;\n      if (indicesText !== $scope.ui.datafeed.indicesText || _lodash2.default.isEqual(scriptFields, $scope.ui.datafeed.scriptFields) === false) {\n        fieldsUpToDate = false;\n      }\n\n      $scope.ui.fieldsUpToDate = fieldsUpToDate;\n\n      var types = Array.isArray(datafeedConfig.types) ? datafeedConfig.types : [];\n\n      $scope.ui.datafeed = {\n        queryText: _angular2.default.toJson(datafeedConfig.query, true),\n        queryDelayText: queryDelay,\n        queryDelayDefault: queryDelayDefault,\n        frequencyText: freq,\n        frequencyDefault: frequencyDefault,\n        scrollSizeText: scrollSize,\n        scrollSizeDefault: scrollSizeDefault,\n        indicesText: indicesText,\n        typesText: types.join(','),\n        scriptFields: scriptFields\n      };\n\n      if ($scope.ui.fieldsUpToDate === false) {\n        $scope.loadFields();\n      }\n    } else {\n      $scope.ui.isDatafeed = false;\n      $scope.ui.tabs[2].hidden = false;\n    }\n  }\n\n  // set the analysis limits items, such as model memory limit\n  function setAnalysisLimitsUIText() {\n    if ($scope.job.analysis_limits !== undefined) {\n      if ($scope.job.analysis_limits.model_memory_limit !== undefined) {\n        $scope.ui.modelMemoryLimitText = $scope.job.analysis_limits.model_memory_limit;\n      }\n    }\n  }\n\n  // work out the default frequency based on the bucket_span\n  function calculateDatafeedFrequencyDefaultSeconds() {\n    var bucketSpan = (0, _parse_interval.parseInterval)($scope.job.analysis_config.bucket_span);\n    if (bucketSpan !== null) {\n      $scope.ui.datafeed.frequencyDefault = (0, _job_utils.calculateDatafeedFrequencyDefaultSeconds)(bucketSpan.asSeconds()) + 's';\n    }\n  }\n\n  // scope version of the above function\n  $scope.calculateDatafeedFrequencyDefaultSeconds = calculateDatafeedFrequencyDefaultSeconds;\n\n  function setFieldDelimiterControlsFromText() {\n    if ($scope.job.data_description && $scope.job.data_description.field_delimiter) {\n\n      // if the data format has not been set and fieldDelimiter exists,\n      // assume the format is delimited\n      if ($scope.job.data_description.format === undefined) {\n        $scope.job.data_description.format = 'delimited';\n      }\n\n      var fieldDelimiter = $scope.job.data_description.field_delimiter;\n      $scope.ui.selectedFieldDelimiter = 'custom';\n      $scope.ui.customFieldDelimiter = '';\n      var isCustom = true;\n      for (var i = 0; i < $scope.ui.fieldDelimiterOptions.length - 1; i++) {\n        if ($scope.ui.fieldDelimiterOptions[i].value === fieldDelimiter) {\n          isCustom = false;\n          $scope.ui.selectedFieldDelimiter = $scope.ui.fieldDelimiterOptions[i].value;\n        }\n      }\n      if (isCustom) {\n        $scope.ui.customFieldDelimiter = fieldDelimiter;\n      }\n    }\n  }\n\n  function getDelimiterSelection() {\n    if ($scope.job.data_description.format === 'delimited') {\n      var selectedFieldDelimiter = $scope.ui.selectedFieldDelimiter;\n      if (selectedFieldDelimiter === 'custom') {\n        $scope.job.data_description.field_delimiter = $scope.ui.customFieldDelimiter;\n      } else {\n        $scope.job.data_description.field_delimiter = selectedFieldDelimiter;\n      }\n    } else {\n      delete $scope.job.data_description.field_delimiter;\n      delete $scope.job.data_description.quote_character;\n    }\n  }\n\n  // create the analysis limits section of the job\n  // if there are no settings (e.g. model_memory_limit is not set) delete the\n  // analysis_limits section entirely\n  function getAnalysisLimitsSelection() {\n    var ui = $scope.ui;\n    var job = $scope.job;\n    if (ui.modelMemoryLimitText === '' || ui.modelMemoryLimitText === null || ui.modelMemoryLimitText === undefined) {\n      if (job.analysis_limits !== undefined) {\n        delete job.analysis_limits.model_memory_limit;\n\n        if (Object.keys(job.analysis_limits).length === 0) {\n          // analysis_limits section is empty, so delete it\n          delete job.analysis_limits;\n        }\n      }\n    } else {\n      // create the analysis_limits section if it doesn't already exist\n      if (job.analysis_limits === undefined) {\n        job.analysis_limits = {};\n      }\n      job.analysis_limits.model_memory_limit = ui.modelMemoryLimitText;\n    }\n  }\n\n  // create the datafeedConfig section of the job config\n  function getDatafeedSelection() {\n    if ($scope.ui.isDatafeed) {\n      var df = $scope.ui.datafeed;\n\n      if (df.queryText === '') {\n        df.queryText = '{\"match_all\":{}}';\n      }\n      var query = df.queryText;\n      try {\n        query = JSON.parse(query);\n      } catch (e) {\n        console.log('getDatafeedSelection(): could not parse query JSON');\n      }\n\n      var indices = [];\n      if (df.indicesText) {\n        indices = df.indicesText.split(',').map(function (i) {\n          return i.trim();\n        });\n      }\n\n      var types = [];\n      if (df.typesText) {\n        types = df.typesText.split(',');\n        for (var i = 0; i < types.length; i++) {\n          types[i] = types[i].trim();\n        }\n      }\n      // if the selected types is different to all types\n      // the user must have edited the json, so use the types object\n      // otherwise, the types object is the same as all types, so set\n      // types to an empty array\n      var typeKeys = Object.keys($scope.ui.types);\n      if (_lodash2.default.difference(typeKeys, types).length === 0) {\n        types = [];\n      }\n\n      // create datafeedConfig if it doesn't already exist\n      if (!$scope.job.datafeed_config) {\n        $scope.job.datafeed_config = {};\n      }\n\n      var config = $scope.job.datafeed_config;\n\n      config.query = query;\n\n      if (df.queryDelayText === '' || df.queryDelayText === null || df.queryDelayText === undefined) {\n        delete config.query_delay;\n      } else {\n        config.query_delay = df.queryDelayText;\n      }\n\n      if (df.frequencyText === '' || df.frequencyText === null || df.frequencyText === undefined) {\n        delete config.frequency;\n      } else {\n        config.frequency = df.frequencyText;\n      }\n\n      if (df.scrollSizeText === '' || df.scrollSizeText === null || df.scrollSizeText === undefined) {\n        delete config.scroll_size;\n      } else {\n        config.scroll_size = df.scrollSizeText;\n      }\n\n      config.indices = indices;\n      config.types = types;\n    }\n  }\n\n  function getCustomUrlSelection() {\n    // if no custom urls have been created, delete the whole custom settings item\n    if ($scope.job.custom_settings && $scope.job.custom_settings.custom_urls) {\n      if ($scope.job.custom_settings.custom_urls.length === 0) {\n        delete $scope.job.custom_settings;\n      }\n    }\n  }\n\n  function getCategorizationFilterSelection() {\n    // if no filters have been created, delete the filter array\n    if ($scope.job.analysis_config && $scope.job.analysis_config.categorization_filters) {\n      if ($scope.job.analysis_config.categorization_filters.length === 0) {\n        delete $scope.job.analysis_config.categorization_filters;\n      }\n    }\n  }\n\n  function createJSONText() {\n    getDelimiterSelection();\n    getAnalysisLimitsSelection();\n    getDatafeedSelection();\n    getCustomUrlSelection();\n    getCategorizationFilterSelection();\n    $scope.ui.jsonText = _angular2.default.toJson($scope.job, true);\n    setTimeout(function () {\n      $scope.$applyAsync();\n    }, 0);\n  }\n\n  // add new custom URL\n  $scope.addCustomUrl = function () {\n    if (!$scope.job.custom_settings) {\n      $scope.job.custom_settings = {};\n    }\n    if (!$scope.job.custom_settings.custom_urls) {\n      $scope.job.custom_settings.custom_urls = [];\n    }\n\n    $scope.job.custom_settings.custom_urls.push({ url_name: '', url_value: '' });\n  };\n\n  // remove selected custom URL\n  $scope.removeCustomUrl = function (index) {\n    $scope.job.custom_settings.custom_urls.splice(index, 1);\n  };\n\n  // add new categorization filter\n  $scope.addCategorizationFilter = function () {\n    if ($scope.job.analysis_config) {\n      if (!$scope.job.analysis_config.categorization_filters) {\n        $scope.job.analysis_config.categorization_filters = [];\n      }\n\n      $scope.job.analysis_config.categorization_filters.push('');\n    }\n  };\n\n  // remove selected categorization filter\n  $scope.removeCategorizationFilter = function (index) {\n    if ($scope.job.analysis_config && $scope.job.analysis_config.categorization_filters) {\n      $scope.job.analysis_config.categorization_filters.splice(index, 1);\n    }\n  };\n\n  $scope.influencerChecked = function (inf) {\n    return _lodash2.default.contains($scope.job.analysis_config.influencers, inf);\n  };\n\n  $scope.toggleInfluencer = function (inf) {\n    var influencers = $scope.job.analysis_config.influencers;\n    if ($scope.influencerChecked(inf)) {\n      for (var i = 0; i < influencers.length; i++) {\n        if (influencers[i] === inf) {\n          $scope.job.analysis_config.influencers.splice(i, 1);\n        }\n      }\n    } else {\n      $scope.job.analysis_config.influencers.push(inf);\n    }\n  };\n\n  $scope.addCustomInfluencer = function () {\n    if ($scope.ui.tempCustomInfluencer !== '') {\n      $scope.ui.customInfluencers.push($scope.ui.tempCustomInfluencer);\n      $scope.ui.tempCustomInfluencer = '';\n    }\n  };\n\n  // look at the difference between loaded ES influencers and the ones in the current job.\n  // unrecognised influencers must have been added by the user.\n  function extractCustomInfluencers() {\n    var allInfluencersList = $scope.ui.influencers;\n    $scope.ui.customInfluencers = _lodash2.default.difference($scope.job.analysis_config.influencers, allInfluencersList);\n    console.log('extractCustomInfluencers: ', $scope.ui.customInfluencers);\n  }\n\n  // function used to check that all required fields are filled in\n  function validateJob() {\n    var limits = (0, _new_job_defaults.newJobLimits)();\n    var validationResults = (0, _job_utils.basicJobValidation)($scope.job, $scope.fields, limits);\n\n    var valid = validationResults.valid;\n    var message = i18n('xpack.ml.newJob.advanced.fillInAllrequiredFieldsValidationMessage', {\n      defaultMessage: 'Fill in all required fields'\n    });\n\n    var tabs = $scope.ui.validation.tabs;\n    // reset validations\n    _lodash2.default.each(tabs, function (tab) {\n      tab.valid = true;\n      for (var check in tab.checks) {\n        if (tab.checks.hasOwnProperty(check)) {\n          tab.checks[check].valid = true;\n          tab.checks[check].message = '';\n        }\n      }\n    });\n\n    var job = $scope.job;\n    if (job) {\n      // tab 0 - Job Details\n      // job already exists check happens in save function\n      // as users may wish to continue and overwrite existing job\n      if (validationResults.contains('job_id_empty')) {\n        tabs[0].checks.jobId.valid = false;\n      } else if (validationResults.contains('job_id_invalid')) {\n        tabs[0].checks.jobId.valid = false;\n        var msg = i18n('xpack.ml.newJob.advanced.validateJob.jobNameAllowedCharactersDescription', {\n          defaultMessage: 'Job name can contain lowercase alphanumeric (a-z and 0-9), hyphens or underscores; ' + 'must start and end with an alphanumeric character'\n        });\n        tabs[0].checks.jobId.message = msg;\n      }\n\n      if (validationResults.contains('job_group_id_invalid')) {\n        tabs[0].checks.groupIds.valid = false;\n        var _msg = i18n('xpack.ml.newJob.advanced.validateJob.jobGroupNamesAllowedCharactersDescription', {\n          defaultMessage: 'Job group names can contain lowercase alphanumeric (a-z and 0-9), hyphens or underscores; ' + 'must start and end with an alphanumeric character'\n        });\n        tabs[0].checks.groupIds.message = _msg;\n      }\n\n      if (validationResults.contains('model_memory_limit_units_invalid')) {\n        tabs[0].checks.modelMemoryLimit.valid = false;\n        var _msg2 = i18n('xpack.ml.newJob.advanced.validateJob.modelMemoryLimitUnrecognizedUnitsErrorMessage', {\n          defaultMessage: 'Model memory limit data unit unrecognized. It must be {allowedDataUnits} or {allowedDataUnit}',\n          values: {\n            allowedDataUnits: _validation.ALLOWED_DATA_UNITS.slice(0, _validation.ALLOWED_DATA_UNITS.length - 1).join(', '),\n            allowedDataUnit: [].concat(_toConsumableArray(_validation.ALLOWED_DATA_UNITS)).pop()\n          }\n        });\n        tabs[0].checks.modelMemoryLimit.message = _msg2;\n      }\n\n      if (validationResults.contains('model_memory_limit_invalid')) {\n        tabs[0].checks.modelMemoryLimit.valid = false;\n        var _msg3 = i18n('xpack.ml.newJob.advanced.validateJob.modelMemoryLimitInvalidRangeErrorMessage', {\n          defaultMessage: 'Model memory limit cannot be higher than the maximum value of {maxModelMemoryLimit}',\n          values: { maxModelMemoryLimit: limits.max_model_memory_limit.toUpperCase() }\n        });\n        tabs[0].checks.modelMemoryLimit.message = _msg3;\n      }\n\n      // tab 1 - Analysis Configuration\n      if (validationResults.contains('categorization_filter_invalid')) {\n        tabs[1].checks.categorizationFilters.message = i18n('xpack.ml.newJob.advanced.validateJob.howToAllowFiltersDescription', {\n          defaultMessage: '{categorizationFieldName} must be set to allow filters',\n          values: { categorizationFieldName: 'categorizationFieldName' }\n        });\n        tabs[1].checks.categorizationFilters.valid = false;\n      }\n\n      if (validationResults.contains('detectors_empty')) {\n        tabs[1].checks.detectors.valid = false;\n      }\n      if (validationResults.contains('detectors_duplicates')) {\n        var _msg4 = i18n('xpack.ml.newJob.advanced.validateJob.duplicateDetectorsFoundErrorMessage', {\n          defaultMessage: 'Duplicate detectors were found. Detectors having the same combined configuration for ' + '\\'{function}\\', \\'{fieldName}\\', \\'{byFieldName}\\', \\'{overFieldName}\\' and \\'{partitionFieldName}\\' ' + 'are not allowed within the same job.',\n          values: {\n            function: 'function',\n            fieldName: 'field_name',\n            byFieldName: 'by_field_name',\n            overFieldName: 'over_field_name',\n            partitionFieldName: 'partition_field_name'\n          }\n        });\n        tabs[1].checks.detectors.message = _msg4;\n        tabs[1].checks.detectors.valid = false;\n      }\n\n      if (validationResults.contains('influencers_empty')) {\n        // tabs[1].checks.influencers.valid = false;\n      }\n\n      if (validationResults.contains('bucket_span_empty')) {\n        tabs[1].checks.bucketSpan.message = i18n('xpack.ml.newJob.advanced.validateJob.bucketSpanMustBeSetErrorMessage', {\n          defaultMessage: '{bucketSpan} must be set',\n          values: { bucketSpan: 'bucket_span' }\n        });\n        tabs[1].checks.bucketSpan.valid = false;\n      } else if (validationResults.contains('bucket_span_invalid')) {\n        var _msg5 = i18n('xpack.ml.newJob.advanced.validateJob.bucketSpanInvalidTimeIntervalFormatErrorMessage', {\n          defaultMessage: '{bucketSpan} is not a valid time interval format e.g. {tenMinutes}, {oneHour}. It also needs to be higher than zero.',\n          values: { bucketSpan: job.analysis_config.bucket_span, tenMinutes: '10m', oneHour: '1h' }\n        });\n        tabs[1].checks.bucketSpan.message = _msg5;\n        tabs[1].checks.bucketSpan.valid = false;\n      }\n\n      // tab 3 - Datafeed\n      validateIndex(tabs, function () {\n        return validationResults.contains('index_fields_invalid');\n      });\n    }\n\n    // for each tab, set its validity based on its contained checks\n    _lodash2.default.each(tabs, function (tab) {\n      _lodash2.default.each(tab.checks, function (item) {\n        if (item.valid === false) {\n          // set tab valid state to false\n          tab.valid = false;\n        }\n      });\n    });\n\n    return {\n      valid: valid,\n      message: message\n    };\n  }\n\n  // the dataFeedTest argument is a function with the default test used by the directive.\n  // it can be overridden with a custom function to do an alternative test\n  function validateIndex(tabs) {\n    var dataFeedTest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n      return Object.keys($scope.fields).length === 0;\n    };\n\n    if (dataFeedTest()) {\n      var msg = i18n('xpack.ml.newJob.advanced.validateJob.couldNotLoadFieldsFromIndexErrorMessage', {\n        defaultMessage: 'Could not load fields from index'\n      });\n      tabs[3].checks.hasAccessToIndex.valid = false;\n      tabs[3].checks.hasAccessToIndex.message = msg;\n      tabs[3].valid = false;\n    } else {\n      tabs[3].checks.hasAccessToIndex.valid = true;\n      tabs[3].valid = true;\n    }\n  }\n\n  function openSaveStatusWindow() {\n    $modal.open({\n      template: _save_status_modal2.default,\n      controller: 'MlSaveStatusModal',\n      backdrop: 'static',\n      keyboard: false,\n      size: 'sm',\n      resolve: {\n        params: function params() {\n          return {\n            pscope: $scope,\n            openDatafeed: function openDatafeed() {\n              mlDatafeedService.openJobTimepickerWindow($scope.job);\n            }\n          };\n        }\n      }\n    });\n  }\n\n  // using the selected indices and types, perform a search\n  // on the ES server and display the results in the Data preview tab\n  function loadDataPreview() {\n    createJSONText();\n    $scope.ui.dataPreview = '';\n\n    var job = $scope.job;\n\n    if (job.datafeed_config && job.datafeed_config.indices.length) {\n      _job_service.mlJobService.searchPreview(job).then(function (resp) {\n        var data = void 0;\n\n        if (resp.aggregations) {\n          data = resp.aggregations.buckets.buckets.slice(0, _job_utils.ML_DATA_PREVIEW_COUNT);\n        } else {\n          data = resp.hits.hits;\n        }\n\n        $scope.ui.dataPreview = _angular2.default.toJson(data, true);\n      }).catch(function (resp) {\n        $scope.ui.dataPreview = _angular2.default.toJson(resp, true);\n      }).then(function () {\n        $scope.$applyAsync();\n      });\n    } else {\n      $scope.ui.dataPreview = i18n('xpack.ml.newJob.advanced.dataPreview.datafeedDoesNotExistLabel', {\n        defaultMessage: 'Datafeed does not exist'\n      });\n      $scope.$applyAsync();\n    }\n  }\n\n  function showDataPreviewTab() {\n    var hidden = true;\n    // if this is a datafeed job, make the Data Preview tab available\n    if ($scope.ui.isDatafeed) {\n      hidden = false;\n    }\n\n    // however, if cloning a datafeedless, don't display the preview tab\n    if ($scope.ui.dataLocation === 'NONE' && $scope.mode === MODE.CLONE) {\n      hidden = true;\n    }\n\n    $scope.ui.tabs[5].hidden = hidden;\n    $scope.$applyAsync();\n  }\n\n  // combine all influencers into a sorted array\n  function allInfluencers() {\n    var influencers = $scope.ui.influencers.concat($scope.ui.customInfluencers);\n    // deduplicate to play well with ng-repeat\n    influencers = _lodash2.default.uniq(influencers);\n\n    return _lodash2.default.sortBy(influencers, function (inf) {\n      return inf;\n    });\n  }\n\n  $scope.aceLoaded = function (editor) {\n    $scope.$applyAsync();\n    if (editor.container.id === 'datafeed-preview') {\n      editor.setReadOnly(true);\n    }\n  };\n\n  init();\n});",null]}