{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/actions/elements.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/actions/elements.js","mtime":1567631711935},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addElement = exports.deleteArgumentAtIndex = exports.addArgumentValueAtIndex = exports.setArgumentAtIndex = exports.setAstAtIndex = exports.setExpression = exports.setFilter = exports.removeElements = exports.insertNodes = exports.fetchAllRenderables = exports.fetchRenderable = exports.fetchRenderableWithContext = exports.fetchContext = exports.flushContextAfterIndex = exports.flushContext = exports.setMultiplePositions = exports.elementLayer = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nexports.getSiblingContext = getSiblingContext;\n\nvar _interpreter = require('plugins/interpreter/interpreter');\n\nvar _reduxActions = require('redux-actions');\n\nvar _reduxThunks = require('redux-thunks');\n\nvar _objectPathImmutable = require('object-path-immutable');\n\nvar _lodash = require('lodash');\n\nvar _common = require('@kbn/interpreter/common');\n\nvar _workpad = require('../selectors/workpad');\n\nvar _resolved_args = require('../selectors/resolved_args');\n\nvar _defaults = require('../defaults');\n\nvar _notify = require('../../lib/notify');\n\nvar _run_interpreter = require('../../lib/run_interpreter');\n\nvar _functional = require('../../lib/aeroelastic/functional');\n\nvar _transient = require('./transient');\n\nvar _resolved_args2 = require('./resolved_args');\n\nvar args = _interopRequireWildcard(_resolved_args2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction getSiblingContext(state, elementId, checkIndex) {\n  var prevContextPath = [elementId, 'expressionContext', checkIndex];\n  var prevContextValue = (0, _resolved_args.getValue)(state, prevContextPath);\n\n  // if a value is found, return it, along with the index it was found at\n  if (prevContextValue != null) {\n    return {\n      index: checkIndex,\n      context: prevContextValue\n    };\n  }\n\n  // check previous index while we're still above 0\n  var prevContextIndex = checkIndex - 1;\n  if (prevContextIndex < 0) {\n    return {};\n  }\n\n  // walk back up to find the closest cached context available\n  return getSiblingContext(state, elementId, prevContextIndex);\n}\n\nfunction getBareElement(el) {\n  var includeId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var props = ['position', 'expression', 'filter'];\n  if (includeId) {\n    return (0, _lodash.pick)(el, props.concat('id'));\n  }\n  return (0, _lodash.cloneDeep)((0, _lodash.pick)(el, props));\n}\n\nvar elementLayer = exports.elementLayer = (0, _reduxActions.createAction)('elementLayer');\n\nvar setMultiplePositions = exports.setMultiplePositions = (0, _reduxActions.createAction)('setMultiplePosition', function (repositionedElements) {\n  return {\n    repositionedElements: repositionedElements\n  };\n});\n\nvar flushContext = exports.flushContext = (0, _reduxActions.createAction)('flushContext');\nvar flushContextAfterIndex = exports.flushContextAfterIndex = (0, _reduxActions.createAction)('flushContextAfterIndex');\n\nvar fetchContext = exports.fetchContext = (0, _reduxThunks.createThunk)('fetchContext', function (_ref, index, element) {\n  var dispatch = _ref.dispatch,\n      getState = _ref.getState;\n  var fullRefresh = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  var chain = (0, _lodash.get)(element, ['ast', 'chain']);\n  var invalidIndex = chain ? index >= chain.length : true;\n\n  if (!element || !chain || invalidIndex) {\n    throw new Error('Invalid argument index: ' + index);\n  }\n\n  // cache context as the previous index\n  var contextIndex = index - 1;\n  var contextPath = [element.id, 'expressionContext', contextIndex];\n\n  // set context state to loading\n  dispatch(args.setLoading({\n    path: contextPath\n  }));\n\n  // function to walk back up to find the closest context available\n  var getContext = function getContext() {\n    return getSiblingContext(getState(), element.id, contextIndex - 1);\n  };\n\n  var _ref2 = fullRefresh !== true ? getContext() : {},\n      prevContextIndex = _ref2.index,\n      prevContextValue = _ref2.context;\n\n  // modify the ast chain passed to the interpreter\n\n\n  var astChain = element.ast.chain.filter(function (exp, i) {\n    if (prevContextValue != null) {\n      return i > prevContextIndex && i < index;\n    }\n    return i < index;\n  });\n\n  // get context data from a partial AST\n  return (0, _interpreter.interpretAst)(_extends({}, element.ast, {\n    chain: astChain\n  }), prevContextValue).then(function (value) {\n    dispatch(args.setValue({\n      path: contextPath,\n      value: value\n    }));\n  });\n});\n\nvar fetchRenderableWithContextFn = function fetchRenderableWithContextFn(_ref3, element, ast, context) {\n  var dispatch = _ref3.dispatch;\n\n  var argumentPath = [element.id, 'expressionRenderable'];\n\n  dispatch(args.setLoading({\n    path: argumentPath\n  }));\n\n  var getAction = function getAction(renderable) {\n    return args.setValue({\n      path: argumentPath,\n      value: renderable\n    });\n  };\n\n  return (0, _run_interpreter.runInterpreter)(ast, context, { castToRender: true }).then(function (renderable) {\n    dispatch(getAction(renderable));\n  }).catch(function (err) {\n    _notify.notify.error(err);\n    dispatch(getAction(err));\n  });\n};\n\nvar fetchRenderableWithContext = exports.fetchRenderableWithContext = (0, _reduxThunks.createThunk)('fetchRenderableWithContext', fetchRenderableWithContextFn);\n\nvar fetchRenderable = exports.fetchRenderable = (0, _reduxThunks.createThunk)('fetchRenderable', function (_ref4, element) {\n  var dispatch = _ref4.dispatch;\n\n  var ast = element.ast || (0, _common.safeElementFromExpression)(element.expression);\n\n  dispatch(fetchRenderableWithContext(element, ast, null));\n});\n\nvar fetchAllRenderables = exports.fetchAllRenderables = (0, _reduxThunks.createThunk)('fetchAllRenderables', function (_ref5) {\n  var dispatch = _ref5.dispatch,\n      getState = _ref5.getState;\n\n  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref6$onlyActivePage = _ref6.onlyActivePage,\n      onlyActivePage = _ref6$onlyActivePage === undefined ? false : _ref6$onlyActivePage;\n\n  var workpadPages = (0, _workpad.getPages)(getState());\n  var currentPageIndex = (0, _workpad.getSelectedPageIndex)(getState());\n\n  var currentPage = workpadPages[currentPageIndex];\n  var otherPages = (0, _lodash.without)(workpadPages, currentPage);\n\n  dispatch(args.inFlightActive());\n\n  function fetchElementsOnPages(pages) {\n    var elements = [];\n    pages.forEach(function (page) {\n      page.elements.forEach(function (element) {\n        elements.push(element);\n      });\n    });\n\n    var renderablePromises = elements.map(function (element) {\n      var ast = element.ast || (0, _common.safeElementFromExpression)(element.expression);\n      var argumentPath = [element.id, 'expressionRenderable'];\n\n      return (0, _run_interpreter.runInterpreter)(ast, null, { castToRender: true }).then(function (renderable) {\n        return { path: argumentPath, value: renderable };\n      }).catch(function (err) {\n        _notify.notify.error(err);\n        return { path: argumentPath, value: err };\n      });\n    });\n\n    return Promise.all(renderablePromises).then(function (renderables) {\n      dispatch(args.setValues(renderables));\n    });\n  }\n\n  if (onlyActivePage) {\n    fetchElementsOnPages([currentPage]).then(function () {\n      return dispatch(args.inFlightComplete());\n    });\n  } else {\n    fetchElementsOnPages([currentPage]).then(function () {\n      return otherPages.reduce(function (chain, page) {\n        return chain.then(function () {\n          return fetchElementsOnPages([page]);\n        });\n      }, Promise.resolve());\n    }).then(function () {\n      return dispatch(args.inFlightComplete());\n    });\n  }\n});\n\nvar insertNodes = exports.insertNodes = (0, _reduxThunks.createThunk)('insertNodes', function (_ref7, elements, pageId) {\n  var dispatch = _ref7.dispatch,\n      type = _ref7.type;\n\n  var _insertNodes = (0, _reduxActions.createAction)(type);\n  var newElements = elements.map(_lodash.cloneDeep);\n  // move the root element so users can see that it was added\n  newElements.forEach(function (newElement) {\n    newElement.position.top = newElement.position.top + 10;\n    newElement.position.left = newElement.position.left + 10;\n  });\n  dispatch(_insertNodes({ pageId: pageId, elements: newElements }));\n\n  // refresh all elements just once per `insertNodes call` if there's a filter on any, otherwise just render the new element\n  if (elements.some(function (element) {\n    return element.filter;\n  })) {\n    dispatch(fetchAllRenderables());\n  } else {\n    newElements.forEach(function (newElement) {\n      return dispatch(fetchRenderable(newElement));\n    });\n  }\n});\n\nvar removeElements = exports.removeElements = (0, _reduxThunks.createThunk)('removeElements', function (_ref8, rootElementIds, pageId) {\n  var dispatch = _ref8.dispatch,\n      getState = _ref8.getState;\n\n  var state = getState();\n\n  // todo consider doing the group membership collation in aeroelastic, or the Redux reducer, when adding templates\n  var allElements = (0, _workpad.getNodes)(state, pageId);\n  var allRoots = rootElementIds.map(function (id) {\n    return allElements.find(function (e) {\n      return id === e.id;\n    });\n  });\n  if (allRoots.indexOf(undefined) !== -1) {\n    throw new Error('Some of the elements to be deleted do not exist');\n  }\n  var elementIds = (0, _functional.subMultitree)(function (e) {\n    return e.id;\n  }, function (e) {\n    return e.position.parent;\n  }, allElements, allRoots).map(function (e) {\n    return e.id;\n  });\n\n  var shouldRefresh = elementIds.some(function (elementId) {\n    var element = (0, _workpad.getNodeById)(state, elementId, pageId);\n    var filterIsApplied = element.filter && element.filter.length > 0;\n    return filterIsApplied;\n  });\n\n  var _removeElements = (0, _reduxActions.createAction)('removeElements', function (elementIds, pageId) {\n    return {\n      pageId: pageId,\n      elementIds: elementIds\n    };\n  });\n  dispatch(_removeElements(elementIds, pageId));\n\n  if (shouldRefresh) {\n    dispatch(fetchAllRenderables());\n  }\n});\n\nvar setFilter = exports.setFilter = (0, _reduxThunks.createThunk)('setFilter', function (_ref9, filter, elementId, pageId) {\n  var dispatch = _ref9.dispatch;\n  var doRender = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  var _setFilter = (0, _reduxActions.createAction)('setFilter');\n  dispatch(_setFilter({ filter: filter, elementId: elementId, pageId: pageId }));\n\n  if (doRender === true) {\n    dispatch(fetchAllRenderables());\n  }\n});\n\nvar setExpression = exports.setExpression = (0, _reduxThunks.createThunk)('setExpression', setExpressionFn);\nfunction setExpressionFn(_ref10, expression, elementId, pageId) {\n  var dispatch = _ref10.dispatch,\n      getState = _ref10.getState;\n  var doRender = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  // dispatch action to update the element in state\n  var _setExpression = (0, _reduxActions.createAction)('setExpression');\n  dispatch(_setExpression({ expression: expression, elementId: elementId, pageId: pageId }));\n\n  // read updated element from state and fetch renderable\n  var updatedElement = (0, _workpad.getNodeById)(getState(), elementId, pageId);\n\n  // reset element.filter if element is no longer a filter\n  // TODO: find a way to extract a list of filter renderers from the functions registry\n  if (updatedElement.filter && !['dropdownControl', 'timefilterControl', 'exactly'].some(function (filter) {\n    return updatedElement.expression.includes(filter);\n  })) {\n    dispatch(setFilter('', elementId, pageId, doRender));\n    // setFilter will trigger a re-render so we can skip the fetch here\n  } else if (doRender === true) {\n    dispatch(fetchRenderable(updatedElement));\n  }\n}\n\nvar setAst = (0, _reduxThunks.createThunk)('setAst', function (_ref11, ast, element, pageId) {\n  var dispatch = _ref11.dispatch;\n  var doRender = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  try {\n    var expression = (0, _common.toExpression)(ast);\n    dispatch(setExpression(expression, element.id, pageId, doRender));\n  } catch (err) {\n    _notify.notify.error(err);\n\n    // TODO: remove this, may have been added just to cause a re-render, but why?\n    dispatch(setExpression(element.expression, element.id, pageId, doRender));\n  }\n});\n\n// index here is the top-level argument in the expression. for example in the expression\n// demodata().pointseries().plot(), demodata is 0, pointseries is 1, and plot is 2\nvar setAstAtIndex = exports.setAstAtIndex = (0, _reduxThunks.createThunk)('setAstAtIndex', function (_ref12, index, ast, element, pageId) {\n  var dispatch = _ref12.dispatch,\n      getState = _ref12.getState;\n\n  // invalidate cached context for elements after this index\n  dispatch(flushContextAfterIndex({ elementId: element.id, index: index }));\n\n  var newElement = (0, _objectPathImmutable.set)(element, ['ast', 'chain', index], ast);\n  var newAst = (0, _lodash.get)(newElement, 'ast');\n\n  // fetch renderable using existing context, if available (value is null if not cached)\n\n  var _getSiblingContext = getSiblingContext(getState(), element.id, index - 1),\n      contextIndex = _getSiblingContext.index,\n      contextValue = _getSiblingContext.context;\n\n  // if we have a cached context, update the expression, but use cache when updating the renderable\n\n\n  if (contextValue) {\n    // set the expression, but skip the fetchRenderable step\n    dispatch(setAst(newAst, element, pageId, false));\n\n    // use context when updating the expression, it will be passed to the intepreter\n    var partialAst = _extends({}, newAst, {\n      chain: newAst.chain.filter(function (exp, i) {\n        if (contextValue) {\n          return i > contextIndex;\n        }\n        return i >= index;\n      })\n    });\n    return dispatch(fetchRenderableWithContext(newElement, partialAst, contextValue));\n  }\n\n  // if no cached context, update the ast like normal\n  dispatch(setAst(newAst, element, pageId));\n});\n\n// index here is the top-level argument in the expression. for example in the expression\n// demodata().pointseries().plot(), demodata is 0, pointseries is 1, and plot is 2\n// argIndex is the index in multi-value arguments, and is optional. excluding it will cause\n// the entire argument from be set to the passed value\nvar setArgumentAtIndex = exports.setArgumentAtIndex = (0, _reduxThunks.createThunk)('setArgumentAtIndex', function (_ref13, args) {\n  var dispatch = _ref13.dispatch;\n  var index = args.index,\n      argName = args.argName,\n      value = args.value,\n      valueIndex = args.valueIndex,\n      element = args.element,\n      pageId = args.pageId;\n\n  var selector = ['ast', 'chain', index, 'arguments', argName];\n  if (valueIndex != null) {\n    selector.push(valueIndex);\n  }\n\n  var newElement = (0, _objectPathImmutable.set)(element, selector, value);\n  var newAst = (0, _lodash.get)(newElement, ['ast', 'chain', index]);\n  dispatch(setAstAtIndex(index, newAst, element, pageId));\n});\n\n// index here is the top-level argument in the expression. for example in the expression\n// demodata().pointseries().plot(), demodata is 0, pointseries is 1, and plot is 2\nvar addArgumentValueAtIndex = exports.addArgumentValueAtIndex = (0, _reduxThunks.createThunk)('addArgumentValueAtIndex', function (_ref14, args) {\n  var dispatch = _ref14.dispatch;\n  var index = args.index,\n      argName = args.argName,\n      value = args.value,\n      element = args.element;\n\n\n  var values = (0, _lodash.get)(element, ['ast', 'chain', index, 'arguments', argName], []);\n  var newValue = values.concat(value);\n\n  dispatch(setArgumentAtIndex(_extends({}, args, {\n    value: newValue\n  })));\n});\n\n// index here is the top-level argument in the expression. for example in the expression\n// demodata().pointseries().plot(), demodata is 0, pointseries is 1, and plot is 2\n// argIndex is the index in multi-value arguments, and is optional. excluding it will remove\n// the entire argument from the expresion\nvar deleteArgumentAtIndex = exports.deleteArgumentAtIndex = (0, _reduxThunks.createThunk)('deleteArgumentAtIndex', function (_ref15, args) {\n  var dispatch = _ref15.dispatch;\n  var index = args.index,\n      element = args.element,\n      pageId = args.pageId,\n      argName = args.argName,\n      argIndex = args.argIndex;\n\n  var curVal = (0, _lodash.get)(element, ['ast', 'chain', index, 'arguments', argName]);\n\n  var newElement = argIndex != null && curVal.length > 1 ? // if more than one val, remove the specified val\n  (0, _objectPathImmutable.del)(element, ['ast', 'chain', index, 'arguments', argName, argIndex]) : // otherwise, remove the entire key\n  (0, _objectPathImmutable.del)(element, ['ast', 'chain', index, 'arguments', argName]);\n\n  dispatch(setAstAtIndex(index, (0, _lodash.get)(newElement, ['ast', 'chain', index]), element, pageId));\n});\n\n/*\n  payload: element defaults. Eg {expression: 'foo'}\n*/\nvar addElement = exports.addElement = (0, _reduxThunks.createThunk)('addElement', function (_ref16, pageId, element) {\n  var dispatch = _ref16.dispatch;\n\n  var newElement = _extends({}, (0, _defaults.getDefaultElement)(), getBareElement(element, true));\n  if (element.width) {\n    newElement.position.width = element.width;\n  }\n  if (element.height) {\n    newElement.position.height = element.height;\n  }\n  var _addElement = (0, _reduxActions.createAction)('addElement');\n  dispatch(_addElement({ pageId: pageId, element: newElement }));\n\n  // refresh all elements if there's a filter, otherwise just render the new element\n  if (element.filter) {\n    dispatch(fetchAllRenderables());\n  } else {\n    dispatch(fetchRenderable(newElement));\n  }\n\n  // select the new element\n  dispatch((0, _transient.selectElement)(newElement.id));\n});",null]}