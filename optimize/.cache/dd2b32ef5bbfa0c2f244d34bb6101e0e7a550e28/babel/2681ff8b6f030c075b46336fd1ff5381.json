{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/util/ml_time_buckets.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/util/ml_time_buckets.js","mtime":1567631712071},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IntervalHelperProvider = IntervalHelperProvider;\nexports.getBoundsRoundedToInterval = getBoundsRoundedToInterval;\nexports.calcEsInterval = calcEsInterval;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _datemath = require('@elastic/datemath');\n\nvar _datemath2 = _interopRequireDefault(_datemath);\n\nvar _ml_calc_auto_interval = require('plugins/ml/util/ml_calc_auto_interval');\n\nvar _inherits = require('plugins/ml/util/inherits');\n\nvar _time_buckets = require('ui/time_buckets');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar unitsDesc = _datemath2.default.unitsDesc; /*\n                                               * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                               * or more contributor license agreements. Licensed under the Elastic License;\n                                               * you may not use this file except in compliance with the Elastic License.\n                                               */\n\n// custom TimeBuckets which inherits from the standard kibana TimeBuckets\n// this adds the ability to override the barTarget and maxBars settings\n// allowing for a more granular visualization interval without having to\n// modify the global settings stored in the kibana config\n\nvar largeMax = unitsDesc.indexOf('w'); // Multiple units of week or longer converted to days for ES intervals.\n\nfunction IntervalHelperProvider(Private, config) {\n\n  var calcAuto = Private(_ml_calc_auto_interval.TimeBucketsCalcAutoIntervalProvider);\n\n  (0, _inherits.inherits)(TimeBuckets, _time_buckets.TimeBuckets);\n\n  function TimeBuckets() {\n    this.barTarget = config.get('histogram:barTarget');\n    this.maxBars = config.get('histogram:maxBars');\n\n    // return TimeBuckets.Super.call(this);\n  }\n\n  TimeBuckets.prototype.setBarTarget = function (bt) {\n    this.barTarget = bt;\n  };\n\n  TimeBuckets.prototype.setMaxBars = function (mb) {\n    this.maxBars = mb;\n  };\n\n  TimeBuckets.prototype.getInterval = function () {\n    var self = this;\n    var duration = self.getDuration();\n    return decorateInterval(maybeScaleInterval(readInterval()), duration);\n\n    // either pull the interval from state or calculate the auto-interval\n    function readInterval() {\n      var interval = self._i;\n      if (_moment2.default.isDuration(interval)) return interval;\n      return calcAuto.near(self.barTarget, duration);\n    }\n\n    // check to see if the interval should be scaled, and scale it if so\n    function maybeScaleInterval(interval) {\n      if (!self.hasBounds()) return interval;\n\n      var maxLength = self.maxBars;\n      var approxLen = duration / interval;\n      var scaled = void 0;\n\n      // If the number of buckets we got back from using the barTarget is less than\n      // maxBars, than use the lessThan rule to try and get closer to maxBars.\n      if (approxLen > maxLength) {\n        scaled = calcAuto.lessThan(maxLength, duration);\n      } else {\n        return interval;\n      }\n\n      if (+scaled === +interval) return interval;\n\n      decorateInterval(interval, duration);\n      return _lodash2.default.assign(scaled, {\n        preScaled: interval,\n        scale: interval / scaled,\n        scaled: true\n      });\n    }\n  };\n\n  // Returns an interval which in the last step of calculation is rounded to\n  // the closest multiple of the supplied divisor (in seconds).\n  TimeBuckets.prototype.getIntervalToNearestMultiple = function (divisorSecs) {\n    var interval = this.getInterval();\n    var intervalSecs = interval.asSeconds();\n\n    var remainder = intervalSecs % divisorSecs;\n    if (remainder === 0) {\n      return interval;\n    }\n\n    // Create a new interval which is a multiple of the supplied divisor (not zero).\n    var nearestMultiple = remainder > divisorSecs / 2 ? intervalSecs + divisorSecs - remainder : intervalSecs - remainder;\n    nearestMultiple = nearestMultiple === 0 ? divisorSecs : nearestMultiple;\n    var nearestMultipleInt = _moment2.default.duration(nearestMultiple, 'seconds');\n    decorateInterval(nearestMultipleInt, this.getDuration());\n\n    // Check to see if the new interval is scaled compared to the original.\n    var preScaled = _lodash2.default.get(interval, 'preScaled');\n    if (preScaled !== undefined && preScaled < nearestMultipleInt) {\n      nearestMultipleInt.preScaled = preScaled;\n      nearestMultipleInt.scale = preScaled / nearestMultipleInt;\n      nearestMultipleInt.scaled = true;\n    }\n\n    return nearestMultipleInt;\n  };\n\n  // Appends some TimeBuckets specific properties to the momentjs duration interval.\n  // Uses the originalDuration from which the time bucket was created to calculate the overflow\n  // property (i.e. difference between the supplied duration and the calculated bucket interval).\n  function decorateInterval(interval, originalDuration) {\n    var esInterval = calcEsInterval(interval);\n    interval.esValue = esInterval.value;\n    interval.esUnit = esInterval.unit;\n    interval.expression = esInterval.expression;\n    interval.overflow = originalDuration > interval ? _moment2.default.duration(interval - originalDuration) : false;\n\n    var prettyUnits = _moment2.default.normalizeUnits(esInterval.unit);\n    if (esInterval.value === 1) {\n      interval.description = prettyUnits;\n    } else {\n      interval.description = esInterval.value + ' ' + prettyUnits + 's';\n    }\n\n    return interval;\n  }\n\n  return TimeBuckets;\n}\n\nfunction getBoundsRoundedToInterval(bounds, interval) {\n  var inclusiveEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  // Returns new bounds, created by flooring the min of the provided bounds to the start of\n  // the specified interval (a moment duration), and rounded upwards (Math.ceil) to 1ms before\n  // the start of the next interval (Kibana dashboards search >= bounds min, and <= bounds max,\n  // so we subtract 1ms off the max to avoid querying start of the new Elasticsearch aggregation bucket).\n  var intervalMs = interval.asMilliseconds();\n  var adjustedMinMs = Math.floor(bounds.min.valueOf() / intervalMs) * intervalMs;\n  var adjustedMaxMs = Math.ceil(bounds.max.valueOf() / intervalMs) * intervalMs;\n\n  // Don't include the start ms of the next bucket unless specified..\n  if (inclusiveEnd === false) {\n    adjustedMaxMs = adjustedMaxMs - 1;\n  }\n  return { min: (0, _moment2.default)(adjustedMinMs), max: (0, _moment2.default)(adjustedMaxMs) };\n}\n\nfunction calcEsInterval(duration) {\n  // Converts a moment.duration into an Elasticsearch compatible interval expression,\n  // and provides associated metadata.\n\n  // Note this is a copy of Kibana's ui/time_buckets/calc_es_interval,\n  // but with the definition of a 'large' unit changed from 'M' to 'w',\n  // bringing it into line with the time units supported by Elasticsearch\n  for (var i = 0; i < unitsDesc.length; i++) {\n    var unit = unitsDesc[i];\n    var val = duration.as(unit);\n    // find a unit that rounds neatly\n    if (val >= 1 && Math.floor(val) === val) {\n\n      // if the unit is \"large\", like years, but isn't set to 1, ES will throw an error.\n      // So keep going until we get out of the \"large\" units.\n      if (i <= largeMax && val !== 1) {\n        continue;\n      }\n\n      return {\n        value: val,\n        unit: unit,\n        expression: val + unit\n      };\n    }\n  }\n\n  var ms = duration.as('ms');\n  return {\n    value: ms,\n    unit: 'ms',\n    expression: ms + 'ms'\n  };\n}",null]}