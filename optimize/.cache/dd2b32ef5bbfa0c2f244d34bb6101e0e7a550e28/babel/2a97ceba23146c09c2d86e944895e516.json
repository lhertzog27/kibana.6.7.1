{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/aeroelastic/functional.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/aeroelastic/functional.js","mtime":1567631711932},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\n/**\n * flatten\n *\n * Flattens an array of arrays into an array\n *\n * @param {*[][]} arrays\n * @returns *[]\n */\nvar flatten = exports.flatten = function flatten(arrays) {\n  var _ref;\n\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(arrays));\n};\n\n/**\n * identity\n *\n * @param d\n * @returns d\n */\nvar identity = exports.identity = function identity(d) {\n  return d;\n};\n\n/**\n * map\n *\n * Maps a function over an array\n *\n * Passing the index and the array are avoided\n *\n * @param {Function} fun\n * @returns {function(*): *}\n */\nvar map = exports.map = function map(fun) {\n  return function (array) {\n    return array.map(function (value) {\n      return fun(value);\n    });\n  };\n};\n\n/**\n * disjunctiveUnion\n *\n * @param {Function} keyFun\n * @param {*[]} set1\n * @param {*[]} set2\n * @returns *[]\n */\nvar disjunctiveUnion = exports.disjunctiveUnion = function disjunctiveUnion(keyFun, set1, set2) {\n  return set1.filter(function (s1) {\n    return !set2.find(function (s2) {\n      return keyFun(s2) === keyFun(s1);\n    });\n  }).concat(set2.filter(function (s2) {\n    return !set1.find(function (s1) {\n      return keyFun(s1) === keyFun(s2);\n    });\n  }));\n};\n\n/**\n *\n * @param {number} a\n * @param {number} b\n * @returns {number} the mean of the two parameters\n */\nvar mean = exports.mean = function mean(a, b) {\n  return (a + b) / 2;\n};\n\nvar shallowEqual = exports.shallowEqual = function shallowEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nvar not = exports.not = function not(fun) {\n  return function () {\n    return !fun.apply(undefined, arguments);\n  };\n};\n\nvar removeDuplicates = exports.removeDuplicates = function removeDuplicates(idFun, a) {\n  return a.filter(function (d, i) {\n    return a.findIndex(function (s) {\n      return idFun(s) === idFun(d);\n    }) === i;\n  });\n};\n\nvar arrayToMap = exports.arrayToMap = function arrayToMap(a) {\n  return Object.assign.apply(Object, [{}].concat(_toConsumableArray(a.map(function (d) {\n    return _defineProperty({}, d, true);\n  }))));\n};\n\nvar subMultitree = exports.subMultitree = function subMultitree(pk, fk, elements, inputRoots) {\n  var getSubgraphs = function getSubgraphs(roots) {\n    var children = flatten(roots.map(function (r) {\n      return elements.filter(function (e) {\n        return fk(e) === pk(r);\n      });\n    }));\n    if (children.length) {\n      return [].concat(_toConsumableArray(roots), _toConsumableArray(getSubgraphs(children, elements)));\n    } else {\n      return roots;\n    }\n  };\n  return getSubgraphs(inputRoots);\n};",null]}