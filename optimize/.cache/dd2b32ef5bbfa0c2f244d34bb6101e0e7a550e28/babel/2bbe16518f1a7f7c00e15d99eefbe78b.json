{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/shared/layers/styles/vector_style.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/shared/layers/styles/vector_style.js","mtime":1567631712022},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VectorStyle = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _i18n = require('@kbn/i18n');\n\nvar _additional_layer_icons = require('../../icons/additional_layer_icons');\n\nvar _color_gradient = require('../../icons/color_gradient');\n\nvar _color_utils = require('../../utils/color_utils');\n\nvar _vector_style_editor = require('./components/vector/vector_style_editor');\n\nvar _vector_style_defaults = require('./vector_style_defaults');\n\nvar _abstract_style = require('./abstract_style');\n\nvar _constants = require('../../../../common/constants');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar VectorStyle = exports.VectorStyle = function (_AbstractStyle) {\n  _inherits(VectorStyle, _AbstractStyle);\n\n  _createClass(VectorStyle, null, [{\n    key: 'getComputedFieldName',\n    value: function getComputedFieldName(fieldName) {\n      return '__kbn__scaled(' + fieldName + ')';\n    }\n  }]);\n\n  function VectorStyle() {\n    var descriptor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, VectorStyle);\n\n    var _this = _possibleConstructorReturn(this, (VectorStyle.__proto__ || Object.getPrototypeOf(VectorStyle)).call(this));\n\n    _this.getIcon = function () {\n      var defaultStyle = {\n        stroke: 'grey',\n        strokeWidth: '1px',\n        fill: 'none'\n      };\n\n      return function () {\n        var isPointsOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        var style = _extends({}, defaultStyle);\n        var isDynamic = _this._isPropertyDynamic('fillColor');\n        if (!isDynamic) {\n          var _this$_descriptor$pro = _this._descriptor.properties,\n              fillColor = _this$_descriptor$pro.fillColor,\n              lineColor = _this$_descriptor$pro.lineColor;\n\n          var stroke = _lodash2.default.get(lineColor, 'options.color');\n          var fill = _lodash2.default.get(fillColor, 'options.color');\n\n          style = _extends({}, style, stroke && { stroke: stroke }, fill && { fill: fill });\n        }\n\n        return isPointsOnly ? _react2.default.createElement(_additional_layer_icons.FillableCircle, { style: style }) : _react2.default.createElement(_additional_layer_icons.FillableVector, { style: style });\n      };\n    }();\n\n    _this._descriptor = VectorStyle.createDescriptor(descriptor.properties);\n    return _this;\n  }\n\n  _createClass(VectorStyle, [{\n    key: 'getDescriptorWithMissingStylePropsRemoved',\n\n\n    /*\n     * Changes to source descriptor and join descriptor will impact style properties.\n     * For instance, a style property may be dynamically tied to the value of an ordinal field defined\n     * by a join or a metric aggregation. The metric aggregation or join may be edited or removed.\n     * When this happens, the style will be linked to a no-longer-existing ordinal field.\n     * This method provides a way for a style to clean itself and return a descriptor that unsets any dynamic\n     * properties that are tied to missing oridinal fields\n     *\n     * This method does not update its descriptor. It just returns a new descriptor that the caller\n     * can then use to update store state via dispatch.\n     */\n    value: function getDescriptorWithMissingStylePropsRemoved(nextOrdinalFields) {\n      var _this2 = this;\n\n      var originalProperties = this.getProperties();\n      var updatedProperties = {};\n      Object.keys(originalProperties).forEach(function (propertyName) {\n        if (!_this2._isPropertyDynamic(propertyName)) {\n          return;\n        }\n\n        var fieldName = _lodash2.default.get(originalProperties[propertyName], 'options.field.name');\n        if (!fieldName) {\n          return;\n        }\n\n        var matchingOrdinalField = nextOrdinalFields.find(function (oridinalField) {\n          return fieldName === oridinalField.name;\n        });\n\n        if (matchingOrdinalField) {\n          return;\n        }\n\n        updatedProperties[propertyName] = {\n          type: VectorStyle.STYLE_TYPE.DYNAMIC,\n          options: _extends({}, originalProperties[propertyName].options)\n        };\n        delete updatedProperties[propertyName].options.field;\n      });\n\n      if (Object.keys(updatedProperties).length === 0) {\n        return {\n          hasChanges: false,\n          nextStyleDescriptor: _extends({}, this._descriptor)\n        };\n      }\n\n      return {\n        hasChanges: true,\n        nextStyleDescriptor: VectorStyle.createDescriptor(_extends({}, originalProperties, updatedProperties))\n      };\n    }\n  }, {\n    key: 'getSourceFieldNames',\n    value: function getSourceFieldNames() {\n      var _this3 = this;\n\n      var properties = this.getProperties();\n      var fieldNames = [];\n      Object.keys(properties).forEach(function (propertyName) {\n        if (!_this3._isPropertyDynamic(propertyName)) {\n          return;\n        }\n\n        var field = _lodash2.default.get(properties[propertyName], 'options.field', {});\n        if (field.origin === _constants.SOURCE_DATA_ID_ORIGIN && field.name) {\n          fieldNames.push(field.name);\n        }\n      });\n\n      return fieldNames;\n    }\n  }, {\n    key: 'getProperties',\n    value: function getProperties() {\n      return this._descriptor.properties || {};\n    }\n  }, {\n    key: '_isPropertyDynamic',\n    value: function _isPropertyDynamic(property) {\n      if (!this._descriptor.properties[property]) {\n        return false;\n      }\n      return this._descriptor.properties[property].type === VectorStyle.STYLE_TYPE.DYNAMIC;\n    }\n  }, {\n    key: 'getColorRamp',\n    value: function getColorRamp() {\n      var color = _lodash2.default.get(this._descriptor, 'properties.fillColor.options.color');\n      return color && this._isPropertyDynamic('fillColor') ? _react2.default.createElement(_color_gradient.ColorGradient, { color: color }) : null;\n    }\n  }, {\n    key: 'getTOCDetails',\n    value: function getTOCDetails() {\n      var isDynamic = this._isPropertyDynamic('fillColor');\n      if (isDynamic) {\n        return _react2.default.createElement(\n          _react2.default.Fragment,\n          null,\n          this.getColorRamp()\n        );\n      }\n      return null;\n    }\n  }, {\n    key: 'addScaledPropertiesBasedOnStyle',\n    value: function addScaledPropertiesBasedOnStyle(featureCollection) {\n      if (!this._isPropertyDynamic('fillColor') && !this._isPropertyDynamic('lineColor') && !this._isPropertyDynamic('iconSize') && !this._isPropertyDynamic('lineWidth')) {\n        return false;\n      }\n\n      if (!featureCollection) {\n        return false;\n      }\n\n      if (!featureCollection.computed) {\n        featureCollection.computed = [];\n      }\n\n      var dynamicFields = [];\n      //todo: should always be intialized really\n      //todo: don't hardcode styling properties. can be discovered automatically\n      //todo: this is adding duplicate fields..\n      if (this._descriptor.properties.fillColor && this._descriptor.properties.fillColor.options && this._descriptor.properties.fillColor.options.field) {\n        dynamicFields.push(this._descriptor.properties.fillColor.options.field);\n      }\n      if (this._descriptor.properties.lineColor && this._descriptor.properties.lineColor.options && this._descriptor.properties.lineColor.options.field) {\n        dynamicFields.push(this._descriptor.properties.lineColor.options.field);\n      }\n      if (this._descriptor.properties.iconSize && this._descriptor.properties.iconSize.options && this._descriptor.properties.iconSize.options.field) {\n        dynamicFields.push(this._descriptor.properties.iconSize.options.field);\n      }\n      if (this._descriptor.properties.lineWidth && this._descriptor.properties.lineWidth.options && this._descriptor.properties.lineWidth.options.field) {\n        dynamicFields.push(this._descriptor.properties.lineWidth.options.field);\n      }\n\n      var updateStatuses = dynamicFields.map(function (field) {\n        return VectorStyle.computeScaledValues(featureCollection, field);\n      });\n      return updateStatuses.some(function (r) {\n        return r === true;\n      });\n    }\n  }, {\n    key: '_getMBDataDrivenColor',\n    value: function _getMBDataDrivenColor(_ref) {\n      var fieldName = _ref.fieldName,\n          color = _ref.color;\n\n      var colorRange = (0, _color_utils.getHexColorRangeStrings)(color, 8).reduce(function (accu, curColor, idx, srcArr) {\n        accu = [].concat(_toConsumableArray(accu), [idx / srcArr.length, curColor]);\n        return accu;\n      }, []);\n      var targetName = VectorStyle.getComputedFieldName(fieldName);\n      return ['interpolate', ['linear'], ['coalesce', ['get', targetName], -1], -1, 'rgba(0,0,0,0)'].concat(_toConsumableArray(colorRange));\n    }\n  }, {\n    key: '_getMbDataDrivenSize',\n    value: function _getMbDataDrivenSize(_ref2) {\n      var fieldName = _ref2.fieldName,\n          minSize = _ref2.minSize,\n          maxSize = _ref2.maxSize;\n\n      var targetName = VectorStyle.getComputedFieldName(fieldName);\n      return ['interpolate', ['linear'], ['get', targetName], 0, minSize, 1, maxSize];\n    }\n  }, {\n    key: '_getMBColor',\n    value: function _getMBColor(styleDescriptor) {\n      var isStatic = styleDescriptor.type === VectorStyle.STYLE_TYPE.STATIC;\n      if (isStatic) {\n        return _lodash2.default.get(styleDescriptor, 'options.color', null);\n      }\n\n      var isDynamicConfigComplete = _lodash2.default.has(styleDescriptor, 'options.field.name') && _lodash2.default.has(styleDescriptor, 'options.color');\n      if (isDynamicConfigComplete) {\n        return this._getMBDataDrivenColor({\n          fieldName: styleDescriptor.options.field.name,\n          color: styleDescriptor.options.color\n        });\n      }\n\n      return null;\n    }\n  }, {\n    key: '_getMbSize',\n    value: function _getMbSize(styleDescriptor) {\n      if (styleDescriptor.type === VectorStyle.STYLE_TYPE.STATIC) {\n        return styleDescriptor.options.size;\n      }\n\n      var isDynamicConfigComplete = _lodash2.default.has(styleDescriptor, 'options.field.name') && _lodash2.default.has(styleDescriptor, 'options.minSize') && _lodash2.default.has(styleDescriptor, 'options.maxSize');\n      if (isDynamicConfigComplete) {\n        return this._getMbDataDrivenSize({\n          fieldName: styleDescriptor.options.field.name,\n          minSize: styleDescriptor.options.minSize,\n          maxSize: styleDescriptor.options.maxSize\n        });\n      }\n\n      return null;\n    }\n  }, {\n    key: 'setMBPaintProperties',\n    value: function setMBPaintProperties(_ref3) {\n      var alpha = _ref3.alpha,\n          mbMap = _ref3.mbMap,\n          fillLayerId = _ref3.fillLayerId,\n          lineLayerId = _ref3.lineLayerId;\n\n      if (this._descriptor.properties.fillColor) {\n        var color = this._getMBColor(this._descriptor.properties.fillColor);\n        mbMap.setPaintProperty(fillLayerId, 'fill-color', color);\n        mbMap.setPaintProperty(fillLayerId, 'fill-opacity', alpha);\n      } else {\n        mbMap.setPaintProperty(fillLayerId, 'fill-color', null);\n        mbMap.setPaintProperty(fillLayerId, 'fill-opacity', 0);\n      }\n\n      if (this._descriptor.properties.lineColor) {\n        var _color = this._getMBColor(this._descriptor.properties.lineColor);\n        mbMap.setPaintProperty(lineLayerId, 'line-color', _color);\n        mbMap.setPaintProperty(lineLayerId, 'line-opacity', alpha);\n      } else {\n        mbMap.setPaintProperty(lineLayerId, 'line-color', null);\n        mbMap.setPaintProperty(lineLayerId, 'line-opacity', 0);\n      }\n\n      if (this._descriptor.properties.lineWidth) {\n        var lineWidth = this._getMbSize(this._descriptor.properties.lineWidth);\n        mbMap.setPaintProperty(lineLayerId, 'line-width', lineWidth);\n      } else {\n        mbMap.setPaintProperty(lineLayerId, 'line-width', 0);\n      }\n    }\n  }, {\n    key: 'setMBPaintPropertiesForPoints',\n    value: function setMBPaintPropertiesForPoints(_ref4) {\n      var alpha = _ref4.alpha,\n          mbMap = _ref4.mbMap,\n          pointLayerId = _ref4.pointLayerId;\n\n      if (this._descriptor.properties.fillColor) {\n        var color = this._getMBColor(this._descriptor.properties.fillColor);\n        mbMap.setPaintProperty(pointLayerId, 'circle-color', color);\n        mbMap.setPaintProperty(pointLayerId, 'circle-opacity', alpha);\n      } else {\n        mbMap.setPaintProperty(pointLayerId, 'circle-color', null);\n        mbMap.setPaintProperty(pointLayerId, 'circle-opacity', 0);\n      }\n      if (this._descriptor.properties.lineColor) {\n        var _color2 = this._getMBColor(this._descriptor.properties.lineColor);\n        mbMap.setPaintProperty(pointLayerId, 'circle-stroke-color', _color2);\n        mbMap.setPaintProperty(pointLayerId, 'circle-stroke-opacity', alpha);\n      } else {\n        mbMap.setPaintProperty(pointLayerId, 'circle-stroke-color', null);\n        mbMap.setPaintProperty(pointLayerId, 'circle-stroke-opacity', 0);\n      }\n      if (this._descriptor.properties.lineWidth) {\n        var lineWidth = this._getMbSize(this._descriptor.properties.lineWidth);\n        mbMap.setPaintProperty(pointLayerId, 'circle-stroke-width', lineWidth);\n      } else {\n        mbMap.setPaintProperty(pointLayerId, 'circle-stroke-width', 0);\n      }\n      if (this._descriptor.properties.iconSize) {\n        var iconSize = this._getMbSize(this._descriptor.properties.iconSize);\n        mbMap.setPaintProperty(pointLayerId, 'circle-radius', iconSize);\n      } else {\n        mbMap.setPaintProperty(pointLayerId, 'circle-radius', 0);\n      }\n    }\n  }], [{\n    key: 'canEdit',\n    value: function canEdit(styleInstance) {\n      return styleInstance.constructor === VectorStyle;\n    }\n  }, {\n    key: 'createDescriptor',\n    value: function createDescriptor() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return {\n        type: VectorStyle.type,\n        properties: _extends({}, (0, _vector_style_defaults.getDefaultStaticProperties)(), properties)\n      };\n    }\n  }, {\n    key: 'createDefaultStyleProperties',\n    value: function createDefaultStyleProperties(mapColors) {\n      return (0, _vector_style_defaults.getDefaultStaticProperties)(mapColors);\n    }\n  }, {\n    key: 'getDisplayName',\n    value: function getDisplayName() {\n      return _i18n.i18n.translate('xpack.maps.style.vector.displayNameLabel', {\n        defaultMessage: 'Vector style'\n      });\n    }\n  }, {\n    key: 'renderEditor',\n    value: function renderEditor(_ref5) {\n      var handleStyleChange = _ref5.handleStyleChange,\n          style = _ref5.style,\n          layer = _ref5.layer;\n\n\n      var styleProperties = _extends({}, style.getProperties());\n      var handlePropertyChange = function handlePropertyChange(propertyName, settings) {\n        styleProperties[propertyName] = settings; //override single property, but preserve the rest\n        var vectorStyleDescriptor = VectorStyle.createDescriptor(styleProperties);\n        handleStyleChange(vectorStyleDescriptor);\n      };\n\n      return _react2.default.createElement(_vector_style_editor.VectorStyleEditor, {\n        handlePropertyChange: handlePropertyChange,\n        styleProperties: styleProperties,\n        layer: layer\n      });\n    }\n  }, {\n    key: 'computeScaledValues',\n    value: function computeScaledValues(featureCollection, field) {\n      var fieldName = field.name;\n      var features = featureCollection.features;\n      if (!features.length) {\n        return false;\n      }\n\n      var min = Infinity;\n      var max = -Infinity;\n      for (var i = 0; i < features.length; i++) {\n        var newValue = parseFloat(features[i].properties[fieldName]);\n        if (!isNaN(newValue)) {\n          min = Math.min(min, newValue);\n          max = Math.max(max, newValue);\n        }\n      }\n      var diff = max - min;\n      var propName = VectorStyle.getComputedFieldName(fieldName);\n\n      //scale to [0,1] domain\n      for (var _i = 0; _i < features.length; _i++) {\n        var unscaledValue = parseFloat(features[_i].properties[fieldName]);\n        var scaledValue = void 0;\n        if (isNaN(unscaledValue)) {\n          //cannot scale\n          scaledValue = -1; //put outside range\n        } else if (diff === 0) {\n          //values are identical\n          scaledValue = 1; //snap to end of color range\n        } else {\n          scaledValue = (features[_i].properties[fieldName] - min) / diff;\n        }\n        features[_i].properties[propName] = scaledValue;\n      }\n      featureCollection.computed.push(fieldName);\n      return true;\n    }\n  }]);\n\n  return VectorStyle;\n}(_abstract_style.AbstractStyle);\n\nVectorStyle.type = 'VECTOR';\nVectorStyle.STYLE_TYPE = { 'DYNAMIC': 'DYNAMIC', 'STATIC': 'STATIC' };\nVectorStyle.description = '';",null]}