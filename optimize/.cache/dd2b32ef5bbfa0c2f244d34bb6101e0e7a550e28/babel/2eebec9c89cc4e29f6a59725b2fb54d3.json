{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/population/create_job/create_job_controller.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/population/create_job/create_job_controller.js","mtime":1567631712059},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nrequire('angular-ui-select');\n\nvar _index = require('ui/agg_types/index');\n\nvar _validation_utils = require('plugins/ml/../common/util/validation_utils');\n\nvar _parse_interval = require('plugins/ml/../common/util/parse_interval');\n\nvar _datemath = require('@elastic/datemath');\n\nvar _datemath2 = _interopRequireDefault(_datemath);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _routes = require('ui/routes');\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nvar _check_license = require('plugins/ml/license/check_license');\n\nvar _check_privilege = require('plugins/ml/privilege/check_privilege');\n\nvar _ml_time_buckets = require('plugins/ml/util/ml_time_buckets');\n\nvar _filter_agg_types = require('plugins/ml/jobs/new_job/simple/components/utils/filter_agg_types');\n\nvar _validate_job = require('plugins/ml/jobs/new_job/simple/components/utils/validate_job');\n\nvar _adjust_interval = require('plugins/ml/jobs/new_job/simple/components/utils/adjust_interval');\n\nvar _states = require('plugins/ml/jobs/new_job/simple/components/constants/states');\n\nvar _create_fields = require('plugins/ml/jobs/new_job/simple/components/utils/create_fields');\n\nvar _index_utils = require('plugins/ml/util/index_utils');\n\nvar _chart_data_utils = require('plugins/ml/jobs/new_job/simple/components/utils/chart_data_utils.js');\n\nvar _check_ml_nodes = require('plugins/ml/ml_nodes_check/check_ml_nodes');\n\nvar _new_job_defaults = require('plugins/ml/jobs/new_job/utils/new_job_defaults');\n\nvar _string_utils = require('plugins/ml/util/string_utils');\n\nvar _new_job_utils = require('plugins/ml/jobs/new_job/utils/new_job_utils');\n\nvar _job_service = require('plugins/ml/services/job_service');\n\nvar _prepopulate_job_settings = require('plugins/ml/jobs/new_job/simple/components/utils/prepopulate_job_settings');\n\nvar _create_job_service = require('./create_job_service');\n\nvar _full_time_range_selector_service = require('plugins/ml/components/full_time_range_selector/full_time_range_selector_service');\n\nvar _messagebar_service = require('plugins/ml/components/messagebar/messagebar_service');\n\nvar _create_job = require('./create_job.html');\n\nvar _create_job2 = _interopRequireDefault(_create_job);\n\nvar _timefilter = require('ui/timefilter');\n\nvar _modules = require('ui/modules');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_routes2.default.when('/jobs/new_job/simple/population', {\n  template: _create_job2.default,\n  resolve: {\n    CheckLicense: _check_license.checkLicenseExpired,\n    privileges: _check_privilege.checkCreateJobsPrivilege,\n    indexPattern: _index_utils.loadCurrentIndexPattern,\n    savedSearch: _index_utils.loadCurrentSavedSearch,\n    checkMlNodesAvailable: _check_ml_nodes.checkMlNodesAvailable,\n    loadNewJobDefaults: _new_job_defaults.loadNewJobDefaults\n  }\n}); /*\n     * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n     * or more contributor license agreements. Licensed under the Elastic License;\n     * you may not use this file except in compliance with the Elastic License.\n     */\n\nvar _module = _modules.uiModules.get('apps/ml');\n\n_module.controller('MlCreatePopulationJob', function ($scope, $timeout, Private, AppState, i18n) {\n\n  _timefilter.timefilter.enableTimeRangeSelector();\n  _timefilter.timefilter.disableAutoRefreshSelector();\n  var msgs = _messagebar_service.mlMessageBarService;\n  var MlTimeBuckets = Private(_ml_time_buckets.IntervalHelperProvider);\n  var moveToAdvancedJobCreation = Private(_new_job_utils.moveToAdvancedJobCreationProvider);\n  var chartDataUtils = Private(_chart_data_utils.ChartDataUtilsProvider);\n  var mlPopulationJobService = Private(_create_job_service.PopulationJobServiceProvider);\n  var mlFullTimeRangeSelectorService = Private(_full_time_range_selector_service.FullTimeRangeSelectorServiceProvider);\n  $scope.addNewJobToRecentlyAccessed = _new_job_utils.addNewJobToRecentlyAccessed;\n\n  var stateDefaults = {\n    mlJobSettings: {}\n  };\n  var appState = new AppState(stateDefaults);\n\n  mlPopulationJobService.clearChartData();\n  $scope.chartData = mlPopulationJobService.chartData;\n  var jobDefaults = (0, _new_job_defaults.newJobDefaults)();\n\n  var PAGE_WIDTH = _angular2.default.element('.population-job-container').width();\n  var BAR_TARGET = PAGE_WIDTH > 1600 ? 800 : PAGE_WIDTH / 2;\n  var MAX_BARS = BAR_TARGET + BAR_TARGET / 100 * 100; // 100% larger that bar target\n  var REFRESH_INTERVAL_MS = 100;\n  var MAX_BUCKET_DIFF = 3;\n  var METRIC_AGG_TYPE = 'metrics';\n  var DEFAULT_MODEL_MEMORY_LIMIT = jobDefaults.anomaly_detectors.model_memory_limit;\n\n  var refreshCounter = 0;\n\n  $scope.JOB_STATE = _states.JOB_STATE;\n  $scope.jobState = $scope.JOB_STATE.NOT_STARTED;\n\n  $scope.CHART_STATE = _states.CHART_STATE;\n  $scope.chartStates = {\n    eventRate: _states.CHART_STATE.LOADING,\n    fields: {}\n  };\n\n  // flag to stop all results polling if the user navigates away from this page\n  var globalForceStop = false;\n\n  var createSearchItems = Private(_new_job_utils.SearchItemsProvider);\n\n  var _createSearchItems = createSearchItems(),\n      indexPattern = _createSearchItems.indexPattern,\n      savedSearch = _createSearchItems.savedSearch,\n      query = _createSearchItems.query,\n      filters = _createSearchItems.filters,\n      combinedQuery = _createSearchItems.combinedQuery;\n\n  (0, _index_utils.timeBasedIndexCheck)(indexPattern, true);\n\n  var pageTitle = savedSearch.id !== undefined ? i18n('xpack.ml.newJob.simple.population.savedSearchPageTitle', {\n    defaultMessage: 'saved search {savedSearchTitle}',\n    values: { savedSearchTitle: savedSearch.title }\n  }) : i18n('xpack.ml.newJob.simple.population.indexPatternPageTitle', {\n    defaultMessage: 'index pattern {indexPatternTitle}',\n    values: { indexPatternTitle: indexPattern.title }\n  });\n\n  $scope.analysisStoppingLabel = i18n('xpack.ml.newJob.simple.population.analysisStoppingLabel', {\n    defaultMessage: 'Analysis stopping'\n  });\n  $scope.stopAnalysisLabel = i18n('xpack.ml.newJob.simple.population.stopAnalysisLabel', {\n    defaultMessage: 'Stop analysis'\n  });\n\n  $scope.ui = {\n    indexPattern: indexPattern,\n    pageTitle: pageTitle,\n    showJobInput: true,\n    showJobFinished: false,\n    dirty: false,\n    formValid: false,\n    bucketSpanValid: true,\n    bucketSpanEstimator: { status: 0, message: '' },\n    cardinalityValidator: { status: 0, message: '' },\n    aggTypeOptions: (0, _filter_agg_types.filterAggTypes)(_index.aggTypes.byType[METRIC_AGG_TYPE]),\n    fields: [],\n    overFields: [],\n    splitFields: [],\n    timeFields: [],\n    splitText: '',\n    intervals: [{\n      title: i18n('xpack.ml.newJob.simple.population.intervals.autoTitle', {\n        defaultMessage: 'Auto'\n      }),\n      value: 'auto'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.population.intervals.millisecondTitle', {\n        defaultMessage: 'Millisecond'\n      }),\n      value: 'ms'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.population.intervals.secondTitle', {\n        defaultMessage: 'Second'\n      }),\n      value: 's'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.population.intervals.minuteTitle', {\n        defaultMessage: 'Minute'\n      }),\n      value: 'm'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.population.intervals.hourlyTitle', {\n        defaultMessage: 'Hourly'\n      }),\n      value: 'h'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.population.intervals.dailyTitle', {\n        defaultMessage: 'Daily'\n      }),\n      value: 'd'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.population.intervals.weeklyTitle', {\n        defaultMessage: 'Weekly'\n      }),\n      value: 'w'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.population.intervals.monthlyTitle', {\n        defaultMessage: 'Monthly'\n      }),\n      value: 'M'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.population.intervals.yearlyTitle', {\n        defaultMessage: 'Yearly'\n      }),\n      value: 'y'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.population.intervals.customTitle', {\n        defaultMessage: 'Custom'\n      }),\n      value: 'custom'\n    }],\n    eventRateChartHeight: 100,\n    chartHeight: 150,\n    showFieldCharts: false,\n    showAdvanced: false,\n    validation: {\n      checks: {\n        jobId: { valid: true },\n        groupIds: { valid: true },\n        modelMemoryLimit: { valid: true },\n        duplicateDetectors: { valid: true }\n      }\n    },\n    isOverField: function isOverField(field) {\n      return field.name === $scope.formConfig.overField.name ? null : field;\n    }\n  };\n\n  $scope.formConfig = {\n    agg: {\n      type: undefined\n    },\n    fields: [],\n    bucketSpan: '15m',\n    chartInterval: undefined,\n    resultsIntervalSeconds: undefined,\n    start: 0,\n    end: 0,\n    overField: undefined,\n    timeField: indexPattern.timeFieldName,\n    influencerFields: [],\n    firstSplitFieldName: undefined,\n    indexPattern: indexPattern,\n    query: query,\n    filters: filters,\n    combinedQuery: combinedQuery,\n    usesSavedSearch: savedSearch.id !== undefined,\n    jobId: '',\n    description: '',\n    jobGroups: [],\n    useDedicatedIndex: false,\n    enableModelPlot: false,\n    modelMemoryLimit: DEFAULT_MODEL_MEMORY_LIMIT\n  };\n\n  $scope.formChange = function (refreshCardLayout) {\n    $scope.ui.isFormValid();\n    $scope.ui.dirty = true;\n\n    $scope.loadVis();\n    if (refreshCardLayout) {\n      sortSplitCards();\n    }\n  };\n\n  $scope.overChange = function () {\n    $scope.addDefaultFieldsToInfluencerList();\n    $scope.formChange();\n  };\n\n  $scope.splitChange = function (fieldIndex, splitField) {\n    return new Promise(function (resolve) {\n      $scope.formConfig.fields[fieldIndex].firstSplitFieldName = undefined;\n\n      if (splitField !== undefined) {\n        $scope.formConfig.fields[fieldIndex].splitField = splitField;\n\n        $scope.addDefaultFieldsToInfluencerList();\n\n        chartDataUtils.getSplitFields($scope.formConfig, splitField.name, 10).then(function (resp) {\n          if (resp.results.values && resp.results.values.length) {\n            $scope.formConfig.fields[fieldIndex].firstSplitFieldName = resp.results.values[0];\n            $scope.formConfig.fields[fieldIndex].cardLabels = resp.results.values;\n          }\n\n          drawCards(fieldIndex, true);\n          $scope.formChange();\n          resolve();\n        });\n      } else {\n        $scope.formConfig.fields[fieldIndex].splitField = undefined;\n        $scope.formConfig.fields[fieldIndex].cardLabels = undefined;\n        setFieldsChartStates(_states.CHART_STATE.LOADING);\n        $scope.toggleInfluencerChange();\n        $scope.ui.splitText = '';\n        destroyCards(fieldIndex);\n        $scope.formChange();\n        resolve();\n      }\n    });\n  };\n\n  $scope.splitReset = function (fieldIndex) {\n    $scope.splitChange(fieldIndex, undefined);\n  };\n\n  function setTime() {\n    $scope.ui.bucketSpanValid = true;\n    $scope.formConfig.start = _datemath2.default.parse(_timefilter.timefilter.getTime().from).valueOf();\n    $scope.formConfig.end = _datemath2.default.parse(_timefilter.timefilter.getTime().to).valueOf();\n    $scope.formConfig.format = 'epoch_millis';\n\n    var bucketSpanInterval = (0, _parse_interval.parseInterval)($scope.formConfig.bucketSpan);\n    if (bucketSpanInterval === null || bucketSpanInterval.asMilliseconds() === 0) {\n      $scope.ui.bucketSpanValid = false;\n    }\n\n    var bounds = _timefilter.timefilter.getActiveBounds();\n    $scope.formConfig.chartInterval = new MlTimeBuckets();\n    $scope.formConfig.chartInterval.setBarTarget(BAR_TARGET);\n    $scope.formConfig.chartInterval.setMaxBars(MAX_BARS);\n    $scope.formConfig.chartInterval.setInterval('auto');\n    $scope.formConfig.chartInterval.setBounds(bounds);\n\n    (0, _adjust_interval.adjustIntervalDisplayed)($scope.formConfig);\n\n    $scope.ui.isFormValid();\n    $scope.ui.dirty = true;\n  }\n\n  function initAgg() {\n    _lodash2.default.each($scope.ui.aggTypeOptions, function (agg) {\n      if (agg.mlName === 'mean') {\n        $scope.formConfig.agg.type = agg;\n      }\n    });\n  }\n\n  $scope.ui.isFormValid = function () {\n    if ($scope.formConfig.agg.type === undefined || $scope.formConfig.timeField === undefined || $scope.formConfig.fields.length === 0) {\n\n      $scope.ui.formValid = false;\n    } else {\n      $scope.ui.formValid = true;\n    }\n    return $scope.ui.formValid;\n  };\n\n  $scope.loadVis = function () {\n    var thisLoadTimestamp = Date.now();\n    $scope.chartData.lastLoadTimestamp = thisLoadTimestamp;\n\n    setTime();\n    $scope.ui.isFormValid();\n\n    $scope.ui.showJobInput = true;\n    $scope.ui.showJobFinished = false;\n\n    $scope.ui.dirty = false;\n\n    mlPopulationJobService.clearChartData();\n\n    setFieldsChartStates(_states.CHART_STATE.LOADING);\n\n    if ($scope.formConfig.fields.length) {\n      $scope.ui.showFieldCharts = true;\n      mlPopulationJobService.getLineChartResults($scope.formConfig, thisLoadTimestamp).then(function (resp) {\n        $scope.$applyAsync();\n        loadDocCountData(resp.detectors);\n      }).catch(function (resp) {\n        msgs.error(resp.message);\n        $scope.formConfig.fields.forEach(function (field) {\n          var id = field.id;\n          $scope.chartStates.fields[id] = _states.CHART_STATE.NO_RESULTS;\n        });\n        $scope.$applyAsync();\n      });\n    } else {\n      $scope.ui.showFieldCharts = false;\n      loadDocCountData([]);\n    }\n\n    function loadDocCountData(dtrs) {\n      chartDataUtils.loadDocCountData($scope.formConfig, $scope.chartData).then(function (resp) {\n        if (thisLoadTimestamp === $scope.chartData.lastLoadTimestamp) {\n          _lodash2.default.each(dtrs, function (dtr, id) {\n            var state = resp.totalResults ? _states.CHART_STATE.LOADED : _states.CHART_STATE.NO_RESULTS;\n            $scope.chartStates.fields[id] = state;\n          });\n\n          $scope.chartData.lastLoadTimestamp = null;\n          chartDataUtils.updateChartMargin($scope.chartData);\n          $scope.chartStates.eventRate = resp.totalResults ? _states.CHART_STATE.LOADED : _states.CHART_STATE.NO_RESULTS;\n          $scope.$broadcast('render');\n        }\n      }).catch(function (resp) {\n        $scope.chartStates.eventRate = _states.CHART_STATE.NO_RESULTS;\n        msgs.error(resp.message);\n      }).then(function () {\n        $scope.$applyAsync();\n      });\n    }\n  };\n\n  function setFieldsChartStates(state) {\n    _lodash2.default.each($scope.chartStates.fields, function (chart, key) {\n      $scope.chartStates.fields[key] = state;\n    });\n    $scope.$applyAsync();\n  }\n\n  function drawCards(fieldIndex) {\n    var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    var labels = $scope.formConfig.fields[fieldIndex].cardLabels;\n    var $frontCard = _angular2.default.element('.population-job-container .detector-container.card-' + fieldIndex + ' .card-front');\n    $frontCard.addClass('card');\n    $frontCard.find('.card-title').text(labels[0]);\n\n    var marginTop = labels.length > 1 ? 54 : 0;\n    $frontCard.css('margin-top', marginTop);\n\n    var backCardTitle = '';\n    if (labels.length === 2) {\n      // create a dummy label if there are only 2 cards, as the space will be visible\n      backCardTitle = $scope.formConfig.fields[Object.keys($scope.formConfig.fields)[0]].agg.type.title;\n      backCardTitle += ' ';\n      backCardTitle += Object.keys($scope.formConfig.fields)[0];\n    }\n\n    _angular2.default.element('.detector-container.card-' + fieldIndex + ' .card-behind').remove();\n\n    for (var _i = 0; _i < labels.length; _i++) {\n      var el = '<div class=\"card card-behind card-behind-' + _i + '\"><div class=\"card-title\">';\n      el += (0, _string_utils.mlEscape)(labels[_i]);\n      el += '</div><label class=\"kuiFormLabel\">';\n      el += (0, _string_utils.mlEscape)(backCardTitle);\n      el += '</label></div>';\n\n      var $backCard = _angular2.default.element(el);\n      $backCard.css('z-index', 9 - _i);\n\n      $backCard.insertBefore($frontCard);\n    }\n\n    var cardsBehind = _angular2.default.element('.detector-container.card-' + fieldIndex + ' .card-behind');\n\n    for (var _i2 = 0; _i2 < cardsBehind.length; _i2++) {\n      cardsBehind[_i2].style.marginTop = marginTop + 'px';\n\n      marginTop -= (10 - _i2 * (10 / labels.length)) * (10 / labels.length);\n    }\n    var i = 0;\n    var then = window.performance.now();\n    var fps = 20;\n    var fpsInterval = 1000 / fps;\n\n    function fadeCard(callTime) {\n      if (i < cardsBehind.length) {\n        var now = callTime;\n        var elapsed = now - then;\n        if (elapsed > fpsInterval) {\n          cardsBehind[i].style.opacity = 1;\n          i++;\n          then = now - elapsed % fpsInterval;\n        }\n        window.requestAnimationFrame(fadeCard);\n      }\n    }\n    if (animate) {\n      fadeCard();\n    } else {\n      for (var j = 0; j < cardsBehind.length; j++) {\n        cardsBehind[j].style.opacity = 1;\n      }\n    }\n  }\n\n  function destroyCards(fieldIndex) {\n    _angular2.default.element('.detector-container.card-' + fieldIndex + ' .card-behind').remove();\n\n    var $frontCard = _angular2.default.element('.population-job-container .detector-container.card-' + fieldIndex + ' .card-front');\n    $frontCard.removeClass('card');\n    $frontCard.find('.card-title').text('');\n    $frontCard.css('margin-top', 0);\n  }\n\n  function sortSplitCards() {\n    // cards may have moved, so redraw or remove the splits if needed\n    // wrapped in a timeout to allow the digest to complete after the charts\n    // has been placed on the page\n    $timeout(function () {\n      $scope.formConfig.fields.forEach(function (f, i) {\n        if (f.splitField === undefined) {\n          destroyCards(i);\n        } else {\n          drawCards(i, false);\n        }\n      });\n    }, 0);\n  }\n\n  var refreshInterval = REFRESH_INTERVAL_MS;\n  // function for creating a new job.\n  // creates the job, opens it, creates the datafeed and starts it.\n  // the job may fail to open, but the datafeed should still be created\n  // if the job save was successful.\n  $scope.createJob = function () {\n    var tempJob = mlPopulationJobService.getJobFromConfig($scope.formConfig);\n    if ((0, _validate_job.validateJob)(tempJob, $scope.ui.validation.checks)) {\n      msgs.clear();\n      // create the new job\n      mlPopulationJobService.createJob($scope.formConfig).then(function (job) {\n        // if save was successful, open the job\n        _job_service.mlJobService.openJob(job.job_id).then(function () {\n          // if open was successful create a new datafeed\n          saveNewDatafeed(job, true);\n        }).catch(function (resp) {\n          msgs.error(i18n('xpack.ml.newJob.simple.population.couldNotOpenJobErrorMessage', {\n            defaultMessage: 'Could not open job:'\n          }), resp);\n          msgs.error(i18n('xpack.ml.newJob.simple.population.jobCreatedAndDatafeedCreatingAnywayErrorMessage', {\n            defaultMessage: 'Job created, creating datafeed anyway'\n          }));\n          // if open failed, still attempt to create the datafeed\n          // as it may have failed because we've hit the limit of open jobs\n          saveNewDatafeed(job, false);\n        });\n      }).catch(function (resp) {\n        // save failed\n        msgs.error(i18n('xpack.ml.newJob.simple.population.saveFailedErrorMessage', {\n          defaultMessage: 'Save failed:'\n        }), resp.resp);\n        $scope.$applyAsync();\n      });\n    } else {\n      // show the advanced section as the model memory limit is invalid\n      if ($scope.ui.validation.checks.modelMemoryLimit.valid === false) {\n        $scope.ui.showAdvanced = true;\n      }\n    }\n\n    // save new datafeed internal function\n    // creates a new datafeed and attempts to start it depending\n    // on startDatafeedAfterSave flag\n    function saveNewDatafeed(job, startDatafeedAfterSave) {\n      _job_service.mlJobService.saveNewDatafeed(job.datafeed_config, job.job_id).then(function () {\n        if (startDatafeedAfterSave) {\n          mlPopulationJobService.startDatafeed($scope.formConfig).then(function () {\n            $scope.jobState = _states.JOB_STATE.RUNNING;\n            refreshCounter = 0;\n            refreshInterval = REFRESH_INTERVAL_MS;\n\n            // create the interval size for querying results.\n            // it should not be smaller than the bucket_span\n            $scope.formConfig.resultsIntervalSeconds = $scope.formConfig.chartInterval.getInterval().asSeconds();\n            var bucketSpanSeconds = (0, _parse_interval.parseInterval)($scope.formConfig.bucketSpan).asSeconds();\n            if ($scope.formConfig.resultsIntervalSeconds < bucketSpanSeconds) {\n              $scope.formConfig.resultsIntervalSeconds = bucketSpanSeconds;\n            }\n\n            $scope.resultsUrl = _job_service.mlJobService.createResultsUrl([$scope.formConfig.jobId], $scope.formConfig.start, $scope.formConfig.end, 'explorer');\n\n            (0, _new_job_utils.focusOnResultsLink)('job_running_view_results_link', $timeout);\n\n            loadCharts();\n          }).catch(function (resp) {\n            // datafeed failed\n            msgs.error(i18n('xpack.ml.newJob.simple.population.couldNotStartDatafeedErrorMessage', {\n              defaultMessage: 'Could not start datafeed:'\n            }), resp);\n          }).then(function () {\n            $scope.$applyAsync();\n          });\n        } else {\n          $scope.$applyAsync();\n        }\n      }).catch(function (resp) {\n        msgs.error(i18n('xpack.ml.newJob.simple.population.saveDatafeedFailedErrorMessage', {\n          defaultMessage: 'Save datafeed failed:'\n        }), resp);\n        $scope.$applyAsync();\n      });\n    }\n  };\n\n  // expose this function so it can be used in the enable model plot checkbox directive\n  $scope.getJobFromConfig = mlPopulationJobService.getJobFromConfig;\n\n  (0, _validation_utils.addJobValidationMethods)($scope, mlPopulationJobService);\n\n  function loadCharts() {\n    var forceStop = globalForceStop;\n    // the percentage doesn't always reach 100, so periodically check the datafeed status\n    // to see if the datafeed has stopped\n    var counterLimit = 20 - refreshInterval / REFRESH_INTERVAL_MS;\n    if (refreshCounter >= counterLimit) {\n      refreshCounter = 0;\n      _job_service.mlJobService.updateSingleJobDatafeedState($scope.formConfig.jobId).then(function (state) {\n        if (state === 'stopped') {\n          console.log('Stopping poll because datafeed state is: ' + state);\n          $scope.$applyAsync();\n          $scope.$broadcast('render-results');\n          forceStop = true;\n        }\n        run();\n      });\n    } else {\n      run();\n    }\n\n    function run() {\n      refreshCounter++;\n      reloadJobSwimlaneData().then(function () {\n        reloadDetectorSwimlane().then(function () {\n          if (forceStop === false && $scope.chartData.percentComplete < 100) {\n            // if state has been set to stopping (from the stop button), leave state as it is\n            if ($scope.jobState === _states.JOB_STATE.STOPPING) {\n              $scope.jobState = _states.JOB_STATE.STOPPING;\n            } else {\n              // otherwise assume the job is running\n              $scope.jobState = _states.JOB_STATE.RUNNING;\n            }\n          } else {\n            $scope.jobState = _states.JOB_STATE.FINISHED;\n            (0, _new_job_utils.focusOnResultsLink)('job_finished_view_results_link', $timeout);\n          }\n          jobCheck();\n        });\n      });\n    }\n  }\n\n  function jobCheck() {\n    if ($scope.jobState === _states.JOB_STATE.RUNNING || $scope.jobState === _states.JOB_STATE.STOPPING) {\n      refreshInterval = adjustRefreshInterval($scope.chartData.loadingDifference, refreshInterval);\n      _lodash2.default.delay(loadCharts, refreshInterval);\n    } else {\n      _lodash2.default.each($scope.chartData.detectors, function (chart) {\n        chart.percentComplete = 100;\n      });\n    }\n    if ($scope.chartData.percentComplete > 0) {\n      // fade the bar chart once we have results\n      toggleSwimlaneVisibility();\n    }\n    $scope.$applyAsync();\n    $scope.$broadcast('render-results');\n  }\n\n  function reloadJobSwimlaneData() {\n    return chartDataUtils.loadJobSwimlaneData($scope.formConfig, $scope.chartData);\n  }\n\n  function reloadDetectorSwimlane() {\n    return chartDataUtils.loadDetectorSwimlaneData($scope.formConfig, $scope.chartData);\n  }\n\n  function adjustRefreshInterval(loadingDifference, currentInterval) {\n    var INTERVAL_INCREASE_MS = 100;\n    var MAX_INTERVAL = 10000;\n    var interval = currentInterval;\n\n    if (interval < MAX_INTERVAL) {\n      if (loadingDifference < MAX_BUCKET_DIFF) {\n        interval = interval + INTERVAL_INCREASE_MS;\n      } else {\n        if (interval - INTERVAL_INCREASE_MS >= REFRESH_INTERVAL_MS) {\n          interval = interval - INTERVAL_INCREASE_MS;\n        }\n      }\n    }\n    return interval;\n  }\n\n  $scope.resetJob = function () {\n    $scope.jobState = _states.JOB_STATE.NOT_STARTED;\n    toggleSwimlaneVisibility();\n\n    window.setTimeout(function () {\n      $scope.ui.showJobInput = true;\n      $scope.loadVis();\n    }, 500);\n  };\n\n  function toggleSwimlaneVisibility() {\n    if ($scope.jobState === _states.JOB_STATE.NOT_STARTED) {\n      _angular2.default.element('.swimlane-cells').css('opacity', 0);\n      _angular2.default.element('.bar').css('opacity', 1);\n    } else {\n      _angular2.default.element('.bar').css('opacity', 0.1);\n    }\n  }\n\n  $scope.stopJob = function () {\n    // setting the status to STOPPING disables the stop button\n    $scope.jobState = _states.JOB_STATE.STOPPING;\n    mlPopulationJobService.stopDatafeed($scope.formConfig).catch(function () {}).then(function () {\n      $scope.$applyAsync();\n    });\n  };\n\n  $scope.moveToAdvancedJobCreation = function () {\n    var job = mlPopulationJobService.getJobFromConfig($scope.formConfig);\n    moveToAdvancedJobCreation(job);\n  };\n\n  $scope.setFullTimeRange = function () {\n    return mlFullTimeRangeSelectorService.setFullTimeRange($scope.ui.indexPattern, $scope.formConfig.combinedQuery);\n  };\n\n  initAgg();\n  (0, _create_fields.createFields)($scope, indexPattern);\n\n  $scope.loadVis();\n\n  $scope.$evalAsync(function () {\n    (0, _prepopulate_job_settings.preLoadJob)($scope, appState);\n  });\n\n  $scope.$listenAndDigestAsync(_timefilter.timefilter, 'fetch', $scope.loadVis);\n\n  $scope.$on('$destroy', function () {\n    globalForceStop = true;\n    _angular2.default.element(window).off('resize');\n  });\n});",null]}