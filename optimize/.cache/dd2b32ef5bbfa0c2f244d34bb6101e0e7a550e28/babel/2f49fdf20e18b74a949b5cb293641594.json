{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/reporting/public/hacks/job_completion_notifier.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/reporting/public/hacks/job_completion_notifier.js","mtime":1567631712281},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _react3 = require('@kbn/i18n/react');\n\nvar _notify = require('ui/notify');\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _modules = require('ui/modules');\n\nvar _lodash = require('lodash');\n\nvar _job_queue_client = require('plugins/reporting/lib/job_queue_client');\n\nvar _job_completion_notifications = require('plugins/reporting/lib/job_completion_notifications');\n\nvar _job_statuses = require('../constants/job_statuses');\n\nvar _path = require('plugins/xpack_main/services/path');\n\nvar _xpack_info = require('plugins/xpack_main/services/xpack_info');\n\nvar _poller = require('../../../../common/poller');\n\nvar _eui = require('@elastic/eui');\n\nvar _download_report = require('../lib/download_report');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */\n\n/**\n * Poll for changes to reports. Inform the user of changes when the license is active.\n */\n_modules.uiModules.get('kibana').run(function (Private, reportingPollConfig) {\n  var showCompletionNotification = function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(job) {\n      var reportObjectTitle, reportObjectType, isJobSuccessful, errorDoc, text, seeReportLink, managementUrl, reportingSectionUrl, downloadReportButton, maxSizeReached;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              reportObjectTitle = job._source.payload.title;\n              reportObjectType = job._source.payload.type;\n              isJobSuccessful = (0, _lodash.get)(job, '_source.status') === _job_statuses.JobStatuses.COMPLETED;\n\n              if (isJobSuccessful) {\n                _context.next = 9;\n                break;\n              }\n\n              _context.next = 6;\n              return _job_queue_client.jobQueueClient.getContent(job._id);\n\n            case 6:\n              errorDoc = _context.sent;\n              text = errorDoc.content;\n              return _context.abrupt('return', _notify.toastNotifications.addDanger({\n                title: _react2.default.createElement(_react3.FormattedMessage, {\n                  id: 'xpack.reporting.jobCompletionNotifier.couldNotCreateReportTitle',\n                  defaultMessage: 'Couldn\\'t create report for {reportObjectType} \\'{reportObjectTitle}\\'',\n                  values: { reportObjectType: reportObjectType, reportObjectTitle: reportObjectTitle }\n                }),\n                text: text\n              }));\n\n            case 9:\n              seeReportLink = void 0;\n\n              // In-case the license expired/changed between the time they queued the job and the time that\n              // the job completes, that way we don't give the user a toast to download their report if they can't.\n\n              if (_chrome2.default.navLinkExists('kibana:management')) {\n                managementUrl = _chrome2.default.getNavLinkById('kibana:management').url;\n                reportingSectionUrl = managementUrl + '/kibana/reporting';\n\n                seeReportLink = _react2.default.createElement(\n                  'p',\n                  null,\n                  _react2.default.createElement(_react3.FormattedMessage, {\n                    id: 'xpack.reporting.jobCompletionNotifier.reportLink.pickItUpFromPathDescription',\n                    defaultMessage: 'Pick it up from {path}.',\n                    values: { path: _react2.default.createElement(\n                        'a',\n                        { href: reportingSectionUrl },\n                        _react2.default.createElement(_react3.FormattedMessage, {\n                          id: 'xpack.reporting.jobCompletionNotifier.reportLink.reportingSectionUrlLinkLabel',\n                          defaultMessage: 'Management > Kibana > Reporting'\n                        })\n                      )\n                    }\n                  })\n                );\n              }\n\n              downloadReportButton = _react2.default.createElement(\n                _eui.EuiButton,\n                {\n                  size: 's',\n                  'data-test-subj': 'downloadCompletedReportButton',\n                  onClick: function onClick() {\n                    (0, _download_report.downloadReport)(job._id);\n                  }\n                },\n                _react2.default.createElement(_react3.FormattedMessage, {\n                  id: 'xpack.reporting.jobCompletionNotifier.downloadReportButtonLabel',\n                  defaultMessage: 'Download report'\n                })\n              );\n              maxSizeReached = (0, _lodash.get)(job, '_source.output.max_size_reached');\n\n              if (!maxSizeReached) {\n                _context.next = 15;\n                break;\n              }\n\n              return _context.abrupt('return', _notify.toastNotifications.addWarning({\n                title: _react2.default.createElement(_react3.FormattedMessage, {\n                  id: 'xpack.reporting.jobCompletionNotifier.maxSizeReached.partialReportTitle',\n                  defaultMessage: 'Created partial report for {reportObjectType} \\'{reportObjectTitle}\\'',\n                  values: { reportObjectType: reportObjectType, reportObjectTitle: reportObjectTitle }\n                }),\n                text: _react2.default.createElement(\n                  'div',\n                  null,\n                  _react2.default.createElement(\n                    'p',\n                    null,\n                    _react2.default.createElement(_react3.FormattedMessage, {\n                      id: 'xpack.reporting.jobCompletionNotifier.maxSizeReached.partialReportDescription',\n                      defaultMessage: 'The report reached the max size and contains partial data.'\n                    })\n                  ),\n                  seeReportLink,\n                  downloadReportButton\n                ),\n                'data-test-subj': 'completeReportSuccess'\n              }));\n\n            case 15:\n\n              _notify.toastNotifications.addSuccess({\n                title: _react2.default.createElement(_react3.FormattedMessage, {\n                  id: 'xpack.reporting.jobCompletionNotifier.successfullyCreatedReportNotificationTitle',\n                  defaultMessage: 'Created report for {reportObjectType} \\'{reportObjectTitle}\\'',\n                  values: { reportObjectType: reportObjectType, reportObjectTitle: reportObjectTitle }\n                }),\n                text: _react2.default.createElement(\n                  'div',\n                  null,\n                  seeReportLink,\n                  downloadReportButton\n                ),\n                'data-test-subj': 'completeReportSuccess'\n              });\n\n            case 16:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    return function showCompletionNotification(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  // Don't show users any reporting toasts until they're logged in.\n  if (Private(_path.PathProvider).isUnauthenticated()) {\n    return;\n  }\n\n  // We assume that all license types offer Reporting, and that we only need to check if the\n  // license is active or expired.\n  var xpackInfo = Private(_xpack_info.XPackInfoProvider);\n  var isLicenseActive = xpackInfo.getLicense().isActive;\n\n  var jobCompletionNotifier = reportingPollConfig.jobCompletionNotifier;\n\n\n  var poller = new _poller.Poller({\n    functionToPoll: function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var jobIds, jobs;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (isLicenseActive) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt('return');\n\n              case 2:\n                jobIds = _job_completion_notifications.jobCompletionNotifications.getAll();\n\n                if (jobIds.length) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                return _context3.abrupt('return');\n\n              case 5:\n                _context3.next = 7;\n                return _job_queue_client.jobQueueClient.list(0, jobIds);\n\n              case 7:\n                jobs = _context3.sent;\n\n                jobIds.forEach(function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(jobId) {\n                    var job;\n                    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            job = jobs.find(function (j) {\n                              return j._id === jobId;\n                            });\n\n                            if (job) {\n                              _context2.next = 4;\n                              break;\n                            }\n\n                            _job_completion_notifications.jobCompletionNotifications.remove(jobId);\n                            return _context2.abrupt('return');\n\n                          case 4:\n                            if (!(job._source.status === _job_statuses.JobStatuses.COMPLETED || job._source.status === _job_statuses.JobStatuses.FAILED)) {\n                              _context2.next = 9;\n                              break;\n                            }\n\n                            _context2.next = 7;\n                            return showCompletionNotification(job);\n\n                          case 7:\n                            _job_completion_notifications.jobCompletionNotifications.remove(job.id);\n                            return _context2.abrupt('return');\n\n                          case 9:\n                          case 'end':\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, undefined);\n                  }));\n\n                  return function (_x2) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }());\n\n              case 9:\n              case 'end':\n                return _context3.stop();\n            }\n          }\n        }, _callee3, undefined);\n      }));\n\n      function functionToPoll() {\n        return _ref2.apply(this, arguments);\n      }\n\n      return functionToPoll;\n    }(),\n    pollFrequencyInMillis: jobCompletionNotifier.interval,\n    trailing: true,\n    continuePollingOnError: true,\n    pollFrequencyErrorMultiplier: jobCompletionNotifier.intervalErrorMultiplier\n  });\n  poller.start();\n});",null]}