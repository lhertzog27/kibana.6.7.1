{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/packages/kbn-interpreter/target/public/batched_fetch.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/packages/kbn-interpreter/target/public/batched_fetch.js","mtime":1567666389959},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\n/**\n * Runs the specified batch of functions on the server, then resolves\n * the related promises.\n */\nvar processBatch = function () {\n  var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(kfetch, batch) {\n    var _ref4, results;\n\n    return _regenerator2.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return kfetch({\n              pathname: _consts.FUNCTIONS_URL,\n              method: 'POST',\n              body: JSON.stringify({\n                functions: Object.values(batch).map(function (_ref5) {\n                  var request = _ref5.request;\n                  return request;\n                })\n              })\n            });\n\n          case 3:\n            _ref4 = _context.sent;\n            results = _ref4.results;\n\n            results.forEach(function (_ref6) {\n              var id = _ref6.id,\n                  result = _ref6.result;\n              var future = batch[id].future;\n\n              if (result.statusCode && result.err) {\n                future.reject(result);\n              } else {\n                future.resolve(result);\n              }\n            });\n            _context.next = 11;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context['catch'](0);\n\n            Object.values(batch).forEach(function (_ref7) {\n              var future = _ref7.future;\n\n              future.reject(_context.t0);\n            });\n\n          case 11:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[0, 8]]);\n  }));\n\n  return function processBatch(_x, _x2) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexports.batchedFetch = batchedFetch;\n\nvar _consts = require('./consts');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\n/**\n * Create a function which executes an Expression function on the\n * server as part of a larger batch of executions.\n */\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nfunction batchedFetch(_ref) {\n  var kfetch = _ref.kfetch,\n      serialize = _ref.serialize,\n      _ref$ms = _ref.ms,\n      ms = _ref$ms === undefined ? 10 : _ref$ms;\n\n  // Uniquely identifies each function call in a batch operation\n  // so that the appropriate promise can be resolved / rejected later.\n  var id = 0;\n\n  // A map like { id: { future, request } }, which is used to\n  // track all of the function calls in a batch operation.\n  var batch = {};\n  var timeout = void 0;\n\n  var nextId = function nextId() {\n    return ++id;\n  };\n\n  var reset = function reset() {\n    id = 0;\n    batch = {};\n    timeout = undefined;\n  };\n\n  var runBatch = function runBatch() {\n    processBatch(kfetch, batch);\n    reset();\n  };\n\n  return function (_ref2) {\n    var functionName = _ref2.functionName,\n        context = _ref2.context,\n        args = _ref2.args;\n\n    if (!timeout) {\n      timeout = setTimeout(runBatch, ms);\n    }\n\n    var request = {\n      functionName: functionName,\n      args: args,\n      context: serialize(context)\n    };\n\n    // Check to see if this is a duplicate server function.\n    var duplicate = Object.values(batch).find(function (batchedRequest) {\n      return _lodash2.default.isMatch(batchedRequest.request, request);\n    });\n\n    // If it is, just return the promise of the duplicated request.\n    if (duplicate) {\n      return duplicate.future.promise;\n    }\n\n    // If not, create a new promise, id, and add it to the batched collection.\n    var future = createFuture();\n    var id = nextId();\n    request.id = id;\n\n    batch[id] = {\n      future: future,\n      request: request\n    };\n\n    return future.promise;\n  };\n}\n\n/**\n * An externally resolvable / rejectable promise, used to make sure\n * individual batch responses go to the correct caller.\n */\nfunction createFuture() {\n  var _resolve = void 0;\n  var _reject = void 0;\n\n  return {\n    resolve: function resolve(val) {\n      return _resolve(val);\n    },\n    reject: function reject(val) {\n      return _reject(val);\n    },\n\n    promise: new Promise(function (res, rej) {\n      _resolve = res;\n      _reject = rej;\n    })\n  };\n}",null]}