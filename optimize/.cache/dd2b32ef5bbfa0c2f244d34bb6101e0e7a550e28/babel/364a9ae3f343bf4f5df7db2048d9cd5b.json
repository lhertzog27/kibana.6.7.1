{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/graph/public/graphClientWorkspace.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/graph/public/graphClientWorkspace.js","mtime":1567631711958},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\n// Kibana wrapper\nvar d3 = require('d3');\n\nmodule.exports = function () {\n\n  // Pluggable function to handle the comms with a server. Default impl here is\n  // for use outside of Kibana server with direct access to elasticsearch\n  var graphExplorer = function graphExplorer(indexName, typeName, request, responseHandler) {\n    var dataForServer = JSON.stringify(request);\n    $.ajax({\n      type: 'POST',\n      url: 'http://localhost:9200/' + indexName + '/_xpack/graph/_explore',\n      dataType: 'json',\n      contentType: 'application/json;charset=utf-8',\n      async: true,\n      data: dataForServer,\n      success: function success(data) {\n        responseHandler(data);\n      }\n    });\n  };\n  var searcher = function searcher(indexName, request, responseHandler) {\n    var dataForServer = JSON.stringify(request);\n    $.ajax({\n      type: 'POST',\n      url: 'http://localhost:9200/' + indexName + '/_search?rest_total_hits_as_int=true',\n      dataType: 'json',\n      contentType: 'application/json;charset=utf-8', //Not sure why this was necessary - worked without elsewhere\n      async: true,\n      data: dataForServer,\n      success: function success(data) {\n        responseHandler(data);\n      }\n    });\n  };\n\n  // ====== Undo operations =============\n\n  function AddNodeOperation(node, owner) {\n    var self = this;\n    var vm = owner;\n    self.node = node;\n    self.undo = function () {\n      vm.arrRemove(vm.nodes, self.node);\n      vm.arrRemove(vm.selectedNodes, self.node);\n      self.node.isSelected = false;\n\n      delete vm.nodesMap[self.node.id];\n    };\n    self.redo = function () {\n      vm.nodes.push(self.node);\n      vm.nodesMap[self.node.id] = self.node;\n    };\n  }\n\n  function AddEdgeOperation(edge, owner) {\n    var self = this;\n    var vm = owner;\n    self.edge = edge;\n    self.undo = function () {\n      vm.arrRemove(vm.edges, self.edge);\n      delete vm.edgesMap[self.edge.id];\n    };\n    self.redo = function () {\n      vm.edges.push(self.edge);\n      vm.edgesMap[self.edge.id] = self.edge;\n    };\n  }\n\n  function ReverseOperation(operation) {\n    var self = this;\n    var reverseOperation = operation;\n    self.undo = reverseOperation.redo;\n    self.redo = reverseOperation.undo;\n  }\n\n  function GroupOperation(receiver, orphan, vm) {\n    var self = this;\n    self.receiver = receiver;\n    self.orphan = orphan;\n    self.undo = function () {\n      self.orphan.parent = undefined;\n    };\n    self.redo = function () {\n      self.orphan.parent = self.receiver;\n    };\n  }\n\n  function UnGroupOperation(parent, child, vm) {\n    var self = this;\n    self.parent = parent;\n    self.child = child;\n    self.undo = function () {\n      self.child.parent = self.parent;\n    };\n    self.redo = function () {\n      self.child.parent = undefined;\n    };\n  }\n\n  function createWorkspace(options) {\n    return new GraphWorkspace(options);\n  }\n\n  // The main constructor for our GraphWorkspace\n  function GraphWorkspace(options) {\n    var self = this;\n    this.blacklistedNodes = [];\n    this.options = options;\n    this.undoLog = [];\n    this.redoLog = [];\n    this.selectedNodes = [];\n\n    if (!options) {\n      this.options = {};\n    }\n    this.nodesMap = {};\n    this.edgesMap = {};\n    this.searchTerm = '';\n\n    //A sequence number used to know when a node was added\n    this.seqNumber = 0;\n\n    this.nodes = [];\n    this.edges = [];\n    this.lastRequest = null;\n    this.lastResponse = null;\n    this.changeHandler = options.changeHandler;\n    if (options.graphExploreProxy) {\n      graphExplorer = options.graphExploreProxy;\n    }\n    if (options.searchProxy) {\n      searcher = options.searchProxy;\n    }\n\n    this.addUndoLogEntry = function (undoOperations) {\n      self.undoLog.push(undoOperations);\n      if (self.undoLog.length > 50) {\n        //Remove the oldest\n        self.undoLog.splice(0, 1);\n      }\n      self.redoLog = [];\n    };\n\n    this.undo = function () {\n      var lastOps = this.undoLog.pop();\n      if (lastOps) {\n        this.stopLayout();\n        this.redoLog.push(lastOps);\n        for (var i in lastOps) {\n          lastOps[i].undo();\n        }\n        this.runLayout();\n      }\n    };\n    this.redo = function () {\n      var lastOps = this.redoLog.pop();\n      if (lastOps) {\n        this.stopLayout();\n        this.undoLog.push(lastOps);\n        for (var i in lastOps) {\n          lastOps[i].redo();\n        }\n        this.runLayout();\n      }\n    };\n\n    //Determines if 2 nodes are connected via an edge\n    this.areLinked = function (a, b) {\n      if (a == b) return true;\n      var allEdges = this.edges;\n      for (var e in allEdges) {\n        if (e.source == a) {\n          if (e.target == b) {\n            return true;\n          }\n        }\n        if (e.source == b) {\n          if (e.target == a) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n\n    //======== Selection functions ========\n\n    this.selectAll = function () {\n      self.selectedNodes = [];\n      for (var n in self.nodes) {\n        var node = self.nodes[n];\n        if (node.parent == undefined) {\n          node.isSelected = true;\n          self.selectedNodes.push(node);\n        } else {\n          node.isSelected = false;\n        }\n      }\n    };\n\n    this.selectNone = function () {\n      self.selectedNodes = [];\n      for (var n in self.nodes) {\n        var node = self.nodes[n];\n        node.isSelected = false;\n      }\n    };\n\n    this.selectInvert = function () {\n      self.selectedNodes = [];\n      for (var n in self.nodes) {\n        var node = self.nodes[n];\n        if (node.parent != undefined) {\n          continue;\n        }\n        node.isSelected = !node.isSelected;\n        if (node.isSelected) {\n          self.selectedNodes.push(node);\n        }\n      }\n    };\n\n    this.selectNodes = function (nodes) {\n      for (var n in nodes) {\n        var node = nodes[n];\n        node.isSelected = true;\n        if (self.selectedNodes.indexOf(node) < 0) {\n          self.selectedNodes.push(node);\n        }\n      }\n    };\n\n    this.selectNode = function (node) {\n      node.isSelected = true;\n      if (self.selectedNodes.indexOf(node) < 0) {\n        self.selectedNodes.push(node);\n      }\n    };\n\n    this.deleteSelection = function () {\n      var allAndGrouped = self.returnUnpackedGroupeds(self.selectedNodes);\n\n      // Nothing selected so process all nodes\n      if (allAndGrouped.length == 0) {\n        allAndGrouped = self.nodes.slice(0);\n      }\n\n      var undoOperations = [];\n      for (var i in allAndGrouped) {\n        var node = allAndGrouped[i];\n        //We set selected to false because despite being deleted, node objects sit in an undo log\n        node.isSelected = false;\n        delete self.nodesMap[node.id];\n        undoOperations.push(new ReverseOperation(new AddNodeOperation(node, self)));\n      }\n      self.arrRemoveAll(self.nodes, allAndGrouped);\n      self.arrRemoveAll(self.selectedNodes, allAndGrouped);\n\n      var danglingEdges = self.edges.filter(function (edge) {\n        return self.nodes.indexOf(edge.source) < 0 || self.nodes.indexOf(edge.target) < 0;\n      });\n      for (var _i in danglingEdges) {\n        var edge = danglingEdges[_i];\n        delete self.edgesMap[edge.id];\n        undoOperations.push(new ReverseOperation(new AddEdgeOperation(edge, self)));\n      }\n      self.addUndoLogEntry(undoOperations);\n      self.arrRemoveAll(self.edges, danglingEdges);\n      self.runLayout();\n    };\n\n    this.selectNeighbours = function () {\n      var newSelections = [];\n      for (var n in self.edges) {\n        var edge = self.edges[n];\n        if (!edge.topSrc.isSelected) {\n          if (self.selectedNodes.indexOf(edge.topTarget) >= 0) {\n            if (newSelections.indexOf(edge.topSrc) < 0) {\n              newSelections.push(edge.topSrc);\n            }\n          }\n        }\n        if (!edge.topTarget.isSelected) {\n          if (self.selectedNodes.indexOf(edge.topSrc) >= 0) {\n            if (newSelections.indexOf(edge.topTarget) < 0) {\n              newSelections.push(edge.topTarget);\n            }\n          }\n        }\n      }\n      for (var i in newSelections) {\n        var newlySelectedNode = newSelections[i];\n        self.selectedNodes.push(newlySelectedNode);\n        newlySelectedNode.isSelected = true;\n      }\n    };\n\n    this.selectNone = function () {\n      for (var n in self.selectedNodes) {\n        self.selectedNodes[n].isSelected = false;\n      }\n      self.selectedNodes = [];\n    };\n\n    this.deselectNode = function (node) {\n      node.isSelected = false;\n      self.arrRemove(self.selectedNodes, node);\n    };\n\n    this.getAllSelectedNodes = function () {\n      return this.returnUnpackedGroupeds(self.selectedNodes);\n    };\n\n    this.colorSelected = function (colorNum) {\n      var selections = self.getAllSelectedNodes();\n      for (var i in selections) {\n        selections[i].color = colorNum;\n      }\n    };\n\n    this.getSelectionsThatAreGrouped = function () {\n      var result = [];\n      var selections = self.selectedNodes;\n      for (var i in selections) {\n        var node = selections[i];\n        if (node.numChildren > 0) {\n          result.push(node);\n        }\n      }\n      return result;\n    };\n\n    this.ungroupSelection = function () {\n      var selections = self.getSelectionsThatAreGrouped();\n      for (var i in selections) {\n        var node = selections[i];\n        self.ungroup(node);\n      }\n    };\n\n    this.toggleNodeSelection = function (node) {\n      if (node.isSelected) {\n        self.deselectNode(node);\n      } else {\n        node.isSelected = true;\n        self.selectedNodes.push(node);\n      }\n      return node.isSelected;\n    };\n\n    this.returnUnpackedGroupeds = function (topLevelNodeArray) {\n      //Gather any grouped nodes that are part of this top-level selection\n      var result = topLevelNodeArray.slice();\n\n      // We iterate over edges not nodes because edges conveniently hold the top-most\n      // node information.\n\n      var edges = this.edges;\n      for (var i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n\n        var topLevelSource = edge.topSrc;\n        var topLevelTarget = edge.topTarget;\n\n        if (result.indexOf(topLevelTarget) >= 0) {\n          //visible top-level node is selected - add all nesteds starting from bottom up\n          var target = edge.target;\n          while (target.parent != undefined) {\n            if (result.indexOf(target) < 0) {\n              result.push(target);\n            }\n            target = target.parent;\n          }\n        }\n\n        if (result.indexOf(topLevelSource) >= 0) {\n          //visible top-level node is selected - add all nesteds starting from bottom up\n          var source = edge.source;\n          while (source.parent != undefined) {\n            if (result.indexOf(source) < 0) {\n              result.push(source);\n            }\n            source = source.parent;\n          }\n        }\n      } //end of edges loop\n\n      return result;\n    };\n\n    // ======= Miscellaneous functions\n\n    this.clearGraph = function () {\n      this.stopLayout();\n      this.nodes = [];\n      this.edges = [];\n      this.undoLog = [];\n      this.redoLog = [];\n      this.nodesMap = {};\n      this.edgesMap = {};\n      this.blacklistedNodes = [];\n      this.selectedNodes = [];\n      this.lastResponse = null;\n    };\n\n    this.arrRemoveAll = function remove(arr, items) {\n      for (var i = items.length; i--;) {\n        self.arrRemove(arr, items[i]);\n      }\n    };\n\n    this.arrRemove = function remove(arr, item) {\n      for (var i = arr.length; i--;) {\n        if (arr[i] === item) {\n          arr.splice(i, 1);\n        }\n      }\n    };\n\n    this.getNeighbours = function (node) {\n      var neighbourNodes = [];\n      for (var e in self.edges) {\n        var edge = self.edges[e];\n        if (edge.topSrc == edge.topTarget) {\n          continue;\n        }\n        if (edge.topSrc == node) {\n          if (neighbourNodes.indexOf(edge.topTarget) < 0) {\n            neighbourNodes.push(edge.topTarget);\n          }\n        }\n        if (edge.topTarget == node) {\n          if (neighbourNodes.indexOf(edge.topSrc) < 0) {\n            neighbourNodes.push(edge.topSrc);\n          }\n        }\n      }\n      return neighbourNodes;\n    };\n\n    //Creates a query that represents a node - either simple term query or boolean if grouped\n    this.buildNodeQuery = function (topLevelNode) {\n      var containedNodes = [topLevelNode];\n      containedNodes = self.returnUnpackedGroupeds(containedNodes);\n      if (containedNodes.length == 1) {\n        //Simple case - return a single-term query\n        var tq = {};\n        tq[topLevelNode.data.field] = topLevelNode.data.term;\n        return {\n          'term': tq\n        };\n      }\n      var termsByField = {};\n      for (var i in containedNodes) {\n        var node = containedNodes[i];\n        var termsList = termsByField[node.data.field];\n        if (!termsList) {\n          termsList = [];\n          termsByField[node.data.field] = termsList;\n        }\n        termsList.push(node.data.term);\n      }\n      //Single field case\n      if (Object.keys(termsByField).length == 1) {\n        return {\n          'terms': termsByField\n        };\n      }\n      //Multi-field case - build a bool query with per-field terms clauses.\n      var q = {\n        'bool': {\n          'should': []\n        }\n      };\n      for (var field in termsByField) {\n        var _tq = {};\n        _tq[field] = termsByField[field];\n        q.bool.should.push({\n          'terms': _tq\n        });\n      }\n      return q;\n    };\n\n    //====== Layout functions ========\n\n    this.stopLayout = function () {\n      if (this.force) {\n        this.force.stop();\n      }\n      this.force = null;\n    };\n\n    this.runLayout = function () {\n      this.stopLayout();\n      // The set of nodes and edges we present to the d3 layout algorithms\n      // is potentially a reduced set of nodes if the client has used any\n      // grouping of nodes into parent nodes.\n      var effectiveEdges = [];\n      var edges = self.edges;\n      for (var e in edges) {\n        var edge = edges[e];\n        var topSrc = edge.source;\n        var topTarget = edge.target;\n        while (topSrc.parent != undefined) {\n          topSrc = topSrc.parent;\n        }\n        while (topTarget.parent != undefined) {\n          topTarget = topTarget.parent;\n        }\n        edge.topSrc = topSrc;\n        edge.topTarget = topTarget;\n\n        if (topSrc != topTarget) {\n          effectiveEdges.push({\n            'source': topSrc,\n            'target': topTarget\n          });\n        }\n      }\n      var visibleNodes = self.nodes.filter(function (n) {\n        return n.parent == undefined;\n      });\n      //reset then roll-up all the counts\n      var allNodes = self.nodes;\n      for (var n in allNodes) {\n        var node = allNodes[n];\n        node.numChildren = 0;\n      }\n      for (var _n in allNodes) {\n        var _node = allNodes[_n];\n        while (_node.parent != undefined) {\n          _node = _node.parent;\n          _node.numChildren = _node.numChildren + 1;\n        }\n      }\n      this.force = d3.layout.force().nodes(visibleNodes).links(effectiveEdges).friction(0.8).linkDistance(100).charge(-1500).gravity(0.15).theta(0.99).alpha(0.5).size([800, 600]).on('tick', function (e) {\n        var nodeArray = self.nodes;\n        var hasRollups = false;\n        //Update the position of all \"top level nodes\"\n        for (var i in nodeArray) {\n          var _n2 = nodeArray[i];\n          //Code to support roll-ups\n          if (_n2.parent == undefined) {\n            _n2.kx = _n2.x;\n            _n2.ky = _n2.y;\n          } else {\n            hasRollups = true;\n          }\n        }\n        if (hasRollups) {\n          for (var _i2 in nodeArray) {\n            var _n3 = nodeArray[_i2];\n            //Code to support roll-ups\n            if (_n3.parent != undefined) {\n              // Is a grouped node - inherit parent's position so edges point into parent\n              // d3 thinks it has moved it to x and y but we have final say using kx and ky.\n              var topLevelNode = _n3.parent;\n              while (topLevelNode.parent != undefined) {\n                topLevelNode = topLevelNode.parent;\n              }\n\n              _n3.kx = topLevelNode.x;\n              _n3.ky = topLevelNode.y;\n            }\n          }\n        }\n        if (self.changeHandler) {\n          // Hook to allow any client to respond to position changes\n          // e.g. angular adjusts and repaints node positions on screen.\n          self.changeHandler();\n        }\n      });\n      this.force.start();\n    };\n\n    //========Grouping functions==========\n\n    //Merges all selected nodes into node\n    this.groupSelections = function (node) {\n      var ops = [];\n      self.nodes.forEach(function (otherNode) {\n        if (otherNode != node && otherNode.isSelected && otherNode.parent == undefined) {\n          otherNode.parent = node;\n          otherNode.isSelected = false;\n          self.arrRemove(self.selectedNodes, otherNode);\n          ops.push(new GroupOperation(node, otherNode, self));\n        }\n      });\n      self.selectNone();\n      self.selectNode(node);\n      self.addUndoLogEntry(ops);\n      self.runLayout();\n    };\n\n    this.mergeNeighbours = function (node) {\n      var neighbours = self.getNeighbours(node);\n      var ops = [];\n      neighbours.forEach(function (otherNode) {\n        if (otherNode != node && otherNode.parent == undefined) {\n          otherNode.parent = node;\n          otherNode.isSelected = false;\n          self.arrRemove(self.selectedNodes, otherNode);\n          ops.push(new GroupOperation(node, otherNode, self));\n        }\n      });\n      self.addUndoLogEntry(ops);\n      self.runLayout();\n    };\n\n    this.mergeSelections = function (targetNode) {\n      if (!targetNode) {\n        console.log('Error - merge called on undefined target');\n        return;\n      }\n      var selClone = self.selectedNodes.slice();\n      var ops = [];\n      selClone.forEach(function (otherNode) {\n        if (otherNode != targetNode && otherNode.parent == undefined) {\n          otherNode.parent = targetNode;\n          otherNode.isSelected = false;\n          self.arrRemove(self.selectedNodes, otherNode);\n          ops.push(new GroupOperation(targetNode, otherNode, self));\n        }\n      });\n      self.addUndoLogEntry(ops);\n      self.runLayout();\n    };\n\n    this.ungroup = function (node) {\n      var ops = [];\n      self.nodes.forEach(function (other) {\n        if (other.parent == node) {\n          other.parent = undefined;\n          ops.push(new UnGroupOperation(node, other, self));\n        }\n      });\n      self.addUndoLogEntry(ops);\n      self.runLayout();\n    };\n\n    this.unblacklist = function (node) {\n      self.arrRemove(self.blacklistedNodes, node);\n    };\n\n    this.blacklistSelection = function () {\n      var selection = self.getAllSelectedNodes();\n      var danglingEdges = [];\n      self.edges.forEach(function (edge) {\n        if (selection.indexOf(edge.source) >= 0 || selection.indexOf(edge.target) >= 0) {\n          delete self.edgesMap[edge.id];\n          danglingEdges.push(edge);\n        }\n      });\n      for (var n in selection) {\n        var node = selection[n];\n        delete self.nodesMap[node.id];\n        self.blacklistedNodes.push(node);\n        node.isSelected = false;\n      }\n      self.arrRemoveAll(self.nodes, selection);\n      self.arrRemoveAll(self.edges, danglingEdges);\n      self.selectedNodes = [];\n      self.runLayout();\n    };\n\n    // A \"simple search\" operation that requires no parameters from the client.\n    // Performs numHops hops pulling in field-specific number of terms each time\n    this.simpleSearch = function (searchTerm, fieldsChoice, numHops) {\n      var qs = {\n        'query_string': {\n          'query': searchTerm\n        }\n      };\n      return this.search(qs, fieldsChoice, numHops);\n    };\n\n    this.search = function (query, fieldsChoice, numHops) {\n      if (!fieldsChoice) {\n        fieldsChoice = self.options.vertex_fields;\n      }\n      var step = {};\n\n      //Add any blacklisted nodes to exclusion list\n      var excludeNodesByField = {};\n      var nots = [];\n      var avoidNodes = this.blacklistedNodes;\n      for (var i = 0; i < avoidNodes.length; i++) {\n        var n = avoidNodes[i];\n        var arr = excludeNodesByField[n.data.field];\n        if (!arr) {\n          arr = [];\n          excludeNodesByField[n.data.field] = arr;\n        }\n        arr.push(n.data.term);\n        //Add to list of must_nots in guiding query\n        var tq = {};\n        tq[n.data.field] = n.data.term;\n        nots.push({\n          'term': tq\n        });\n      }\n\n      var rootStep = step;\n      for (var hopNum = 0; hopNum < numHops; hopNum++) {\n        var _arr = [];\n\n        for (var f in fieldsChoice) {\n          var field = fieldsChoice[f].name;\n          var hopSize = fieldsChoice[f].hopSize;\n          var excludes = excludeNodesByField[field];\n          var stepField = {\n            'field': field,\n            'size': hopSize,\n            'min_doc_count': parseInt(self.options.exploreControls.minDocCount)\n          };\n          if (excludes) {\n            stepField.exclude = excludes;\n          }\n          _arr.push(stepField);\n        }\n        step.vertices = _arr;\n        if (hopNum < numHops - 1) {\n          // if (s < (stepSizes.length - 1)) {\n          var nextStep = {};\n          step.connections = nextStep;\n          step = nextStep;\n        }\n      }\n\n      if (nots.length > 0) {\n        query = {\n          'bool': {\n            'must': [query],\n            'must_not': nots\n          }\n        };\n      }\n\n      var request = {\n        'query': query,\n        'controls': self.buildControls(),\n        'connections': rootStep.connections,\n        'vertices': rootStep.vertices\n      };\n      self.callElasticsearch(request);\n    };\n\n    this.buildControls = function () {\n      //This is an object managed by the client that may be subject to change\n      var guiSettingsObj = self.options.exploreControls;\n\n      var controls = {\n        use_significance: guiSettingsObj.useSignificance,\n        sample_size: guiSettingsObj.sampleSize,\n        timeout: parseInt(guiSettingsObj.timeoutMillis)\n      };\n      // console.log(\"guiSettingsObj\",guiSettingsObj);\n      if (guiSettingsObj.sampleDiversityField != null) {\n        controls.sample_diversity = {\n          field: guiSettingsObj.sampleDiversityField.name,\n          max_docs_per_value: guiSettingsObj.maxValuesPerDoc\n        };\n      }\n      return controls;\n    };\n\n    this.makeNodeId = function (field, term) {\n      return field + '..' + term;\n    };\n\n    this.makeEdgeId = function (srcId, targetId) {\n      var id = srcId + '->' + targetId;\n      if (srcId > targetId) {\n        id = targetId + '->' + srcId;\n      }\n      return id;\n    };\n\n    //=======  Adds new nodes retrieved from an elasticsearch search ========\n    this.mergeGraph = function (newData) {\n      this.stopLayout();\n\n      if (!newData.nodes) {\n        newData.nodes = [];\n      }\n      var lastOps = [];\n\n      // === Commented out - not sure it was obvious to users what various circle sizes meant\n      // var minCircleSize = 5;\n      // var maxCircleSize = 25;\n      // var sizeScale = d3.scale.pow().exponent(0.15)\n      //   .domain([0, d3.max(newData.nodes, function(d) {\n      //     return d.weight;\n      //   })])\n      //   .range([minCircleSize, maxCircleSize]);\n\n      //Remove nodes we already have\n      var dedupedNodes = [];\n      for (var o in newData.nodes) {\n        var node = newData.nodes[o];\n        //Assign an ID\n        node.id = self.makeNodeId(node.field, node.term);\n        if (!this.nodesMap[node.id]) {\n          //Default the label\n          if (!node.label) {\n            node.label = node.term;\n          }\n          dedupedNodes.push(node);\n        }\n      }\n      if (dedupedNodes.length > 0 && this.options.nodeLabeller) {\n        // A hook for client code to attach labels etc to newly introduced nodes.\n        this.options.nodeLabeller(dedupedNodes);\n      }\n\n      for (var _o in dedupedNodes) {\n        var dedupedNode = dedupedNodes[_o];\n        var label = dedupedNode.term;\n        if (dedupedNode.label) {\n          label = dedupedNode.label;\n        }\n\n        var _node2 = {\n          x: 1,\n          y: 1,\n          numChildren: 0,\n          parent: undefined,\n          isSelected: false,\n          id: dedupedNode.id,\n          label: label,\n          color: dedupedNode.color,\n          icon: dedupedNode.icon,\n          data: dedupedNode\n        };\n        //        node.scaledSize = sizeScale(node.data.weight);\n        _node2.scaledSize = 15;\n        _node2.seqNumber = this.seqNumber++;\n        this.nodes.push(_node2);\n        lastOps.push(new AddNodeOperation(_node2, self));\n        this.nodesMap[_node2.id] = _node2;\n      }\n\n      for (var _o2 in newData.edges) {\n        var edge = newData.edges[_o2];\n        var src = newData.nodes[edge.source];\n        var target = newData.nodes[edge.target];\n        edge.id = this.makeEdgeId(src.id, target.id);\n\n        //Lookup the wrappers object that will hold display Info like x/y coordinates\n        var srcWrapperObj = this.nodesMap[src.id];\n        var targetWrapperObj = this.nodesMap[target.id];\n\n        var existingEdge = this.edgesMap[edge.id];\n        if (existingEdge) {\n          existingEdge.weight = Math.max(existingEdge.weight, edge.weight);\n          //TODO update width too?\n          existingEdge.doc_count = Math.max(existingEdge.doc_count, edge.doc_count);\n          continue;\n        }\n        // Inferred edges were a feature that used Levenshtein edit distance on node labels\n        // to determine connections - removed that feature but may bring back.\n\n        var inferred = edge.inferred ? true : false;\n        var newEdge = {\n          'source': srcWrapperObj,\n          'target': targetWrapperObj,\n          'weight': edge.weight,\n          'width': edge.width,\n          'id': edge.id,\n          'doc_count': edge.doc_count,\n          'inferred': inferred\n        };\n        if (edge.label) {\n          newEdge.label = edge.label;\n        }\n\n        this.edgesMap[newEdge.id] = newEdge;\n        this.edges.push(newEdge);\n        lastOps.push(new AddEdgeOperation(newEdge, self));\n      }\n\n      if (lastOps.length > 0) {\n        self.addUndoLogEntry(lastOps);\n      }\n\n      this.runLayout();\n    };\n\n    this.mergeIds = function (parentId, childId) {\n      var parent = self.getNode(parentId);\n      var child = self.getNode(childId);\n      if (child.isSelected) {\n        child.isSelected = false;\n        self.arrRemove(self.selectedNodes, child);\n      }\n      child.parent = parent;\n      self.addUndoLogEntry([new GroupOperation(parent, child, self)]);\n      self.runLayout();\n    };\n\n    this.getNode = function (nodeId) {\n      return this.nodesMap[nodeId];\n    };\n    this.getEdge = function (edgeId) {\n      return this.edgesMap[edgeId];\n    };\n\n    //======= Expand functions to request new additions to the graph\n\n    this.expandSelecteds = function () {\n      var targetOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var startNodes = self.getAllSelectedNodes();\n      if (startNodes.length == 0) {\n        startNodes = self.nodes;\n      }\n      var clone = startNodes.slice();\n      self.expand(clone, targetOptions);\n    };\n\n    this.expandGraph = function () {\n      self.expandSelecteds();\n    };\n\n    //Find new nodes to link to existing selected nodes\n    this.expandNode = function (node) {\n      self.expand(self.returnUnpackedGroupeds([node]), {});\n    };\n\n    // A manual expand function where the client provides the list\n    // of existing nodes that are the start points and some options\n    // about what targets are of interest.\n    this.expand = function (startNodes, targetOptions) {\n      //=============================\n      var nodesByField = {};\n      var excludeNodesByField = {};\n\n      //Add any blacklisted nodes to exclusion list\n      var avoidNodes = this.blacklistedNodes;\n      for (var i = 0; i < avoidNodes.length; i++) {\n        var n = avoidNodes[i];\n        var arr = excludeNodesByField[n.data.field];\n        if (!arr) {\n          arr = [];\n          excludeNodesByField[n.data.field] = arr;\n        }\n        if (arr.indexOf(n.data.term) < 0) {\n          arr.push(n.data.term);\n        }\n      }\n\n      var allExistingNodes = this.nodes;\n      for (var _i3 = 0; _i3 < allExistingNodes.length; _i3++) {\n        var _n4 = allExistingNodes[_i3];\n        var _arr2 = excludeNodesByField[_n4.data.field];\n        if (!_arr2) {\n          _arr2 = [];\n          excludeNodesByField[_n4.data.field] = _arr2;\n        }\n        _arr2.push(_n4.data.term);\n      }\n\n      //Organize nodes by field\n      for (var _i4 = 0; _i4 < startNodes.length; _i4++) {\n        var _n5 = startNodes[_i4];\n        var _arr3 = nodesByField[_n5.data.field];\n        if (!_arr3) {\n          _arr3 = [];\n          nodesByField[_n5.data.field] = _arr3;\n        }\n        // pushing boosts server-side to influence sampling/direction\n        _arr3.push({\n          'term': _n5.data.term,\n          'boost': _n5.data.weight\n        });\n\n        _arr3 = excludeNodesByField[_n5.data.field];\n        if (!_arr3) {\n          _arr3 = [];\n          excludeNodesByField[_n5.data.field] = _arr3;\n        }\n        //NOTE for the entity-building use case need to remove excludes that otherwise\n        // prevent bridge-building.\n        if (_arr3.indexOf(_n5.data.term) < 0) {\n          _arr3.push(_n5.data.term);\n        }\n      }\n\n      var primaryVertices = [];\n      var secondaryVertices = [];\n      for (var fieldName in nodesByField) {\n        primaryVertices.push({\n          'field': fieldName,\n          'include': nodesByField[fieldName],\n          'min_doc_count': parseInt(self.options.exploreControls.minDocCount)\n        });\n      }\n\n      var targetFields = this.options.vertex_fields;\n      if (targetOptions.toFields) {\n        targetFields = targetOptions.toFields;\n      }\n\n      //Identify target fields\n      for (var f in targetFields) {\n        var _fieldName = targetFields[f].name;\n        // Sometimes the target field is disabled from loading new hops so we need to use the last valid figure\n        var hopSize = targetFields[f].hopSize > 0 ? targetFields[f].hopSize : targetFields[f].lastValidHopSize;\n\n        var fieldHop = {\n          'field': _fieldName,\n          'size': hopSize,\n          'min_doc_count': parseInt(self.options.exploreControls.minDocCount)\n        };\n        fieldHop.exclude = excludeNodesByField[_fieldName];\n        secondaryVertices.push(fieldHop);\n      }\n\n      var request = {\n        'controls': self.buildControls(),\n        'vertices': primaryVertices,\n        'connections': {\n          'vertices': secondaryVertices\n        }\n      };\n      self.lastRequest = JSON.stringify(request, null, '\\t');\n      graphExplorer(self.options.indexName, request, function (data) {\n        self.lastResponse = JSON.stringify(data, null, '\\t');\n        var nodes = [];\n        var edges = [];\n\n        //Label fields with a field number for CSS styling\n        for (var _n6 in data.vertices) {\n          var node = data.vertices[_n6];\n          for (var _f in targetFields) {\n            var fieldDef = targetFields[_f];\n            if (node.field == fieldDef.name) {\n              node.color = fieldDef.color;\n              node.icon = fieldDef.icon;\n              node.fieldDef = fieldDef;\n              break;\n            }\n          }\n        }\n\n        // Size the edges based on the maximum weight\n        var minLineSize = 2;\n        var maxLineSize = 10;\n        var maxEdgeWeight = 0.00000001;\n        for (var e in data.connections) {\n          var edge = data.connections[e];\n          maxEdgeWeight = Math.max(maxEdgeWeight, edge.weight);\n        }\n        for (var _e in data.connections) {\n          var _edge = data.connections[_e];\n          edges.push({\n            source: _edge.source,\n            target: _edge.target,\n            doc_count: _edge.doc_count,\n            weight: _edge.weight,\n            width: Math.max(minLineSize, _edge.weight / maxEdgeWeight * maxLineSize)\n          });\n        }\n\n        // Add the new nodes and edges into the existing workspace's graph\n        self.mergeGraph({\n          'nodes': data.vertices,\n          'edges': edges\n        });\n      });\n      //===== End expand graph ========================\n    };\n\n    this.trimExcessNewEdges = function (newNodes, newEdges) {\n      var trimmedEdges = [];\n      var maxNumEdgesToReturn = 5;\n      //Trim here to just the new edges that are most interesting.\n      for (var o in newEdges) {\n        var edge = newEdges[o];\n        var src = newNodes[edge.source];\n        var target = newNodes[edge.target];\n        var srcId = src.field + '..' + src.term;\n        var targetId = target.field + '..' + target.term;\n        var id = this.makeEdgeId(srcId, targetId);\n        var existingSrcNode = self.nodesMap[srcId];\n        var existingTargetNode = self.nodesMap[targetId];\n        if (existingSrcNode != null && existingTargetNode != null) {\n          if (existingSrcNode.parent != undefined && existingTargetNode.parent != undefined) {\n            // both nodes are rolled-up and grouped so this edge would not be a visible\n            // change to the graph - lose it in favour of any other visible ones.\n            continue;\n          }\n        } else {\n          console.log('Error? Missing nodes ' + srcId + ' or ' + targetId, self.nodesMap);\n          continue;\n        }\n\n        var existingEdge = self.edgesMap[id];\n        if (existingEdge) {\n          existingEdge.weight = Math.max(existingEdge.weight, edge.weight);\n          existingEdge.doc_count = Math.max(existingEdge.doc_count, edge.doc_count);\n          continue;\n        } else {\n          trimmedEdges.push(edge);\n        }\n      }\n      if (trimmedEdges.length > maxNumEdgesToReturn) {\n        //trim to only the most interesting ones\n        trimmedEdges.sort(function (a, b) {\n          return b.weight - a.weight;\n        });\n        trimmedEdges = trimmedEdges.splice(0, maxNumEdgesToReturn);\n      }\n      return trimmedEdges;\n    };\n\n    this.getQuery = function (startNodes, loose) {\n      var shoulds = [];\n      var nodes = startNodes;\n      if (!startNodes) {\n        nodes = self.nodes;\n      }\n      for (var bs in nodes) {\n        var node = nodes[bs];\n        if (node.parent == undefined) {\n          shoulds.push(self.buildNodeQuery(node));\n        }\n      }\n      return {\n        'bool': {\n          'should': shoulds,\n          'minimum_should_match': Math.min(shoulds.length, loose ? 1 : 2)\n        }\n      };\n    };\n\n    this.getSelectedOrAllNodes = function () {\n      var startNodes = self.getAllSelectedNodes();\n      if (startNodes.length === 0) {\n        startNodes = self.nodes;\n      }\n      return startNodes;\n    };\n\n    this.getSelectedOrAllTopNodes = function () {\n      return self.getSelectedOrAllNodes().filter(function (node) {\n        return node.parent === undefined;\n      });\n    };\n\n    function addTermToFieldList(map, field, term) {\n      var arr = map[field];\n      if (!arr) {\n        arr = [];\n        map[field] = arr;\n      }\n      arr.push(term);\n    }\n\n    //Add missing links between existing nodes\n    this.fillInGraph = function () {\n      var nodesForLinking = self.getSelectedOrAllTopNodes();\n\n      var maxNewEdges = 10; // Avoid adding too many new edges at once into the graph otherwise disorientating\n      var maxNumVerticesSearchable = 100;\n\n      // Server limitation - we can only search for connections between max 100 vertices at a time.\n      if (nodesForLinking.length > maxNumVerticesSearchable) {\n        //Make a selection of random nodes from the array. Shift the random choices\n        // to the front of the array.\n        for (var i = 0; i < maxNumVerticesSearchable; i++) {\n          var oldNode = nodesForLinking[i];\n          var randomIndex = Math.floor(Math.random() * (nodesForLinking.length - i)) + i;\n          //Swap the node positions of the randomly selected node and i\n          nodesForLinking[i] = nodesForLinking[randomIndex];\n          nodesForLinking[randomIndex] = oldNode;\n        }\n        // Trim to our random selection\n        nodesForLinking = nodesForLinking.slice(0, maxNumVerticesSearchable - 1);\n      }\n\n      // Create our query/aggregation request using the selected nodes.\n      // Filters are named after the index of the node in the nodesForLinking\n      // array. The result bucket describing the relationship between\n      // the first 2 nodes in the array will therefore be labelled \"0|1\"\n      var shoulds = [];\n      var filterMap = {};\n      nodesForLinking.forEach(function (node, nodeNum) {\n        var nodeQuery = self.buildNodeQuery(node);\n        shoulds.push(nodeQuery);\n        filterMap[nodeNum] = nodeQuery;\n      });\n      var searchReq = {\n        \"size\": 0,\n        \"query\": {\n          \"bool\": {\n            // Only match docs that share 2 nodes so can help describe their relationship\n            'minimum_should_match': 2,\n            'should': shoulds\n          }\n        },\n        \"aggs\": {\n          \"matrix\": {\n            \"adjacency_matrix\": {\n              \"separator\": \"|\",\n              \"filters\": filterMap\n            }\n          }\n        }\n      };\n\n      // Search for connections between the selected nodes.\n      searcher(self.options.indexName, searchReq, function (data) {\n\n        var numDocsMatched = data.hits.total;\n        var buckets = data.aggregations.matrix.buckets;\n        var vertices = nodesForLinking.map(function (existingNode) {\n          return {\n            \"field\": existingNode.data.field,\n            \"term\": existingNode.data.term,\n            \"weight\": 1,\n            \"depth\": 0\n          };\n        });\n\n        var connections = [];\n        var maxEdgeWeight = 0;\n        // Turn matrix array of results into a map\n        var keyedBuckets = {};\n        buckets.forEach(function (bucket) {\n          keyedBuckets[bucket.key] = bucket;\n        });\n\n        buckets.forEach(function (bucket) {\n          // We calibrate line thickness based on % of max weight of\n          // all edges (including the edges we may already have in the workspace)\n          var ids = bucket.key.split(\"|\");\n          if (ids.length === 2) {\n            // bucket represents an edge\n            if (self.options.exploreControls.useSignificance) {\n              var t1 = keyedBuckets[ids[0]].doc_count;\n              var t2 = keyedBuckets[ids[1]].doc_count;\n              var t1AndT2 = bucket.doc_count;\n              // Calc the significant_terms score to prioritize selection of interesting links\n              bucket.weight = self.JLHScore(t1AndT2, Math.max(t1, t2), Math.min(t1, t2), numDocsMatched);\n            } else {\n              // prioritize links purely on volume of intersecting docs\n              bucket.weight = bucket.doc_count;\n            }\n            maxEdgeWeight = Math.max(maxEdgeWeight, bucket.weight);\n          }\n        });\n        var backFilledMinLineSize = 2;\n        var backFilledMaxLineSize = 5;\n        buckets.forEach(function (bucket) {\n          if (bucket.doc_count < parseInt(self.options.exploreControls.minDocCount)) {\n            return;\n          }\n          var ids = bucket.key.split(\"|\");\n          if (ids.length == 2) {\n            // Bucket represents an edge\n            var srcNode = nodesForLinking[ids[0]];\n            var targetNode = nodesForLinking[ids[1]];\n            var edgeId = self.makeEdgeId(srcNode.id, targetNode.id);\n            var existingEdge = self.edgesMap[edgeId];\n            if (existingEdge) {\n              // Tweak the doc_count score having just looked it up.\n              existingEdge.doc_count = Math.max(existingEdge.doc_count, bucket.doc_count);\n            } else {\n              connections.push({\n                // source and target values are indexes into the vertices array\n                \"source\": parseInt(ids[0]),\n                \"target\": parseInt(ids[1]),\n                \"weight\": bucket.weight,\n                \"width\": Math.max(backFilledMinLineSize, bucket.weight / maxEdgeWeight * backFilledMaxLineSize),\n                \"doc_count\": bucket.doc_count\n              });\n            }\n          }\n        });\n        // Trim the array of connections so that we don't add too many at once - disorientating for users otherwise\n        if (connections.length > maxNewEdges) {\n          connections = connections.sort(function (a, b) {\n            return b.weight - a.weight;\n          });\n          connections = connections.slice(0, maxNewEdges);\n        }\n\n        // Merge the new edges into the existing workspace's graph.\n        // We reuse the mergeGraph function used to handle the\n        // results of other calls to the server-side Graph API\n        // so must package the results here with that same format\n        // even though we know all the vertices we provide will\n        // be duplicates and ignored.\n        self.mergeGraph({\n          'nodes': vertices,\n          'edges': connections\n        });\n      });\n    };\n\n    // Provide a \"fuzzy find similar\" query that can find similar docs but preferably\n    // not re-iterating the exact terms we already have in the workspace.\n    // We use a free-text search on the index's configured default field (typically '_all')\n    // to drill-down into docs that should be linked but aren't via the exact terms\n    // we have in the workspace\n    this.getLikeThisButNotThisQuery = function (startNodes) {\n      var likeQueries = [];\n\n      var txtsByFieldType = {};\n      startNodes.forEach(function (node) {\n        var txt = txtsByFieldType[node.data.field];\n        if (txt) {\n          txt = txt + ' ' + node.label;\n        } else {\n          txt = node.label;\n        }\n        txtsByFieldType[node.data.field] = txt;\n      });\n      for (var field in txtsByFieldType) {\n        likeQueries.push({\n          'more_like_this': {\n            'like': txtsByFieldType[field],\n            'min_term_freq': 1,\n            'minimum_should_match': '20%',\n            'min_doc_freq': 1,\n            'boost_terms': 2,\n            'max_query_terms': 25\n          }\n        });\n      }\n\n      var excludeNodesByField = {};\n      var allExistingNodes = self.nodes;\n      allExistingNodes.forEach(function (existingNode) {\n        addTermToFieldList(excludeNodesByField, existingNode.data.field, existingNode.data.term);\n      });\n      var blacklistedNodes = self.blacklistedNodes;\n      blacklistedNodes.forEach(function (blacklistedNode) {\n        addTermToFieldList(excludeNodesByField, blacklistedNode.data.field, blacklistedNode.data.term);\n      });\n\n      //Create negative boosting queries to avoid matching what you already have in the workspace.\n      var notExistingNodes = [];\n      Object.keys(excludeNodesByField).forEach(function (fieldName) {\n        var termsQuery = {};\n        termsQuery[fieldName] = excludeNodesByField[fieldName];\n        notExistingNodes.push({\n          'terms': termsQuery\n        });\n      });\n\n      var result = {\n        // Use a boosting query to effectively to request \"similar to these IDS/labels but\n        // preferably not containing these exact IDs\".\n        'boosting': {\n          'negative_boost': 0.0001,\n          'negative': {\n            'bool': {\n              'should': notExistingNodes\n            }\n          },\n          'positive': {\n            'bool': {\n              'should': likeQueries\n            }\n          }\n        }\n      };\n      return result;\n    };\n\n    this.getSelectedIntersections = function (callback) {\n      if (self.selectedNodes.length == 0) {\n        return self.getAllIntersections(callback, self.nodes);\n      }\n      if (self.selectedNodes.length == 1) {\n        var selectedNode = self.selectedNodes[0];\n        var neighbourNodes = self.getNeighbours(selectedNode);\n        neighbourNodes.push(selectedNode);\n        return self.getAllIntersections(callback, neighbourNodes);\n      }\n      return self.getAllIntersections(callback, self.getAllSelectedNodes());\n    };\n\n    this.JLHScore = function (subsetFreq, subsetSize, supersetFreq, supersetSize) {\n      var subsetProbability = subsetFreq / subsetSize;\n      var supersetProbability = supersetFreq / supersetSize;\n\n      var absoluteProbabilityChange = subsetProbability - supersetProbability;\n      if (absoluteProbabilityChange <= 0) {\n        return 0;\n      }\n      var relativeProbabilityChange = subsetProbability / supersetProbability;\n      return absoluteProbabilityChange * relativeProbabilityChange;\n    };\n\n    // Currently unused in the Kibana UI. It was a utility that provided a sorted list\n    // of recommended node merges for a selection of nodes. Top results would be\n    // rare nodes that ALWAYS appear alongside more popular ones e.g. text:9200 always\n    // appears alongside hashtag:elasticsearch so would be offered as a likely candidate\n    // for merging.\n\n    // Determines union/intersection stats for neighbours of a node.\n    // TODO - could move server-side as a graph API function?\n    this.getAllIntersections = function (callback, nodes) {\n      //Ensure these are all top-level nodes only\n      nodes = nodes.filter(function (n) {\n        return n.parent == undefined;\n      });\n\n      var allQueries = nodes.map(function (node) {\n        return self.buildNodeQuery(node);\n      });\n\n      var allQuery = {\n        'bool': {\n          'should': allQueries\n        }\n      };\n      //====================\n      var request = {\n        'query': allQuery,\n        'size': 0,\n        'aggs': {\n          'all': {\n            'global': {}\n          },\n          'sources': {\n            // Could use significant_terms not filters to get stats but\n            // for the fact some of the nodes are groups of terms.\n            'filters': {\n              'filters': {}\n            },\n            'aggs': {\n              'targets': {\n                'filters': {\n                  'filters': {}\n                }\n              }\n            }\n          }\n        }\n      };\n      for (var n in allQueries) {\n        // Add aggs to get intersection stats with root node.\n        request.aggs.sources.filters.filters['bg' + n] = allQueries[n];\n        request.aggs.sources.aggs.targets.filters.filters['fg' + n] = allQueries[n];\n      }\n      var dataForServer = JSON.stringify(request);\n      searcher(self.options.indexName, request, function (data) {\n        var termIntersects = [];\n        var fullDocCounts = [];\n        var allDocCount = data.aggregations.all.doc_count;\n\n        // Gather the background stats for all nodes.\n        for (var _n7 in nodes) {\n          fullDocCounts.push(data.aggregations.sources.buckets['bg' + _n7].doc_count);\n        }\n        for (var _n8 in nodes) {\n          var rootNode = nodes[_n8];\n          var t1 = fullDocCounts[_n8];\n          var baseAgg = data.aggregations.sources.buckets['bg' + _n8].targets.buckets;\n          for (var l in nodes) {\n            var t2 = fullDocCounts[l];\n            var leafNode = nodes[l];\n            if (l == _n8) {\n              continue;\n            }\n            if (t1 > t2) {\n              // We should get the same stats for t2->t1 from the t1->t2 bucket path\n              continue;\n            }\n            if (t1 == t2) {\n              if (rootNode.id > leafNode.id) {\n                // We should get the same stats for t2->t1 from the t1->t2 bucket path\n                continue;\n              }\n            }\n            var t1AndT2 = baseAgg['fg' + l].doc_count;\n            if (t1AndT2 == 0) {\n              continue;\n            }\n            var neighbourNode = nodes[l];\n            var t1Label = rootNode.data.label;\n            if (rootNode.numChildren > 0) {\n              t1Label += '(+' + rootNode.numChildren + ')';\n            }\n            var t2Label = neighbourNode.data.label;\n            if (neighbourNode.numChildren > 0) {\n              t2Label += '(+' + neighbourNode.numChildren + ')';\n            }\n\n            // A straight percentage can be poor if t1==1 (100%) - not too much strength of evidence\n            //  var mergeConfidence=t1AndT2/t1;\n\n            // So using Significance heuristic instead\n            var mergeConfidence = self.JLHScore(t1AndT2, t2, t1, allDocCount);\n\n            var termIntersect = {\n              id1: rootNode.id,\n              id2: neighbourNode.id,\n              term1: t1Label,\n              term2: t2Label,\n              v1: t1,\n              v2: t2,\n              mergeLeftConfidence: t1AndT2 / t1,\n              mergeRightConfidence: t1AndT2 / t2,\n              'mergeConfidence': mergeConfidence,\n              overlap: t1AndT2\n            };\n            termIntersects.push(termIntersect);\n          }\n        }\n        termIntersects.sort(function (a, b) {\n          if (b.mergeConfidence != a.mergeConfidence) {\n            return b.mergeConfidence - a.mergeConfidence;\n          }\n          // If of equal similarity use the size of the overlap as\n          // a measure of magnitude/significance for tie-breaker.\n\n          if (b.overlap != a.overlap) {\n            return b.overlap - a.overlap;\n          }\n          //All other things being equal we now favour where t2 NOT t1 is small.\n          return a.v2 - b.v2;\n        });\n        if (callback) {\n          callback(termIntersects);\n        }\n      });\n    };\n\n    // Internal utility function for calling the Graph API and handling the response\n    // by merging results into existing nodes in this workspace.\n    this.callElasticsearch = function (request) {\n      self.lastRequest = JSON.stringify(request, null, '\\t');\n      graphExplorer(self.options.indexName, request, function (data) {\n        self.lastResponse = JSON.stringify(data, null, '\\t');\n        var nodes = [];\n        var edges = [];\n        //Label the nodes with field number for CSS styling\n        for (var n in data.vertices) {\n          var node = data.vertices[n];\n          for (var f in self.options.vertex_fields) {\n            var fieldDef = self.options.vertex_fields[f];\n            if (node.field == fieldDef.name) {\n              node.color = fieldDef.color;\n              node.icon = fieldDef.icon;\n              node.fieldDef = fieldDef;\n              break;\n            }\n          }\n        }\n\n        //Size the edges depending on weight\n        var minLineSize = 2;\n        var maxLineSize = 10;\n        var maxEdgeWeight = 0.00000001;\n        for (var e in data.connections) {\n          var edge = data.connections[e];\n          maxEdgeWeight = Math.max(maxEdgeWeight, edge.weight);\n        }\n        for (var _e2 in data.connections) {\n          var _edge2 = data.connections[_e2];\n          edges.push({\n            source: _edge2.source,\n            target: _edge2.target,\n            doc_count: _edge2.doc_count,\n            weight: _edge2.weight,\n            width: Math.max(minLineSize, _edge2.weight / maxEdgeWeight * maxLineSize)\n          });\n        }\n\n        self.mergeGraph({\n          'nodes': data.vertices,\n          'edges': edges\n        }, {\n          'labeller': self.options.labeller\n        });\n      });\n    };\n  }\n  //=====================\n\n  // Begin Kibana wrapper\n  return {\n    'createWorkspace': createWorkspace\n  };\n}();",null]}