{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/jobs_list/components/utils.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/jobs_list/components/utils.js","mtime":1567631712052},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadFullJob = loadFullJob;\nexports.isStartable = isStartable;\nexports.isStoppable = isStoppable;\nexports.isClosable = isClosable;\nexports.forceStartDatafeeds = forceStartDatafeeds;\nexports.stopDatafeeds = stopDatafeeds;\nexports.cloneJob = cloneJob;\nexports.closeJobs = closeJobs;\nexports.deleteJobs = deleteJobs;\nexports.filterJobs = filterJobs;\n\nvar _lodash = require('lodash');\n\nvar _notify = require('ui/notify');\n\nvar _messagebar_service = require('plugins/ml/components/messagebar/messagebar_service');\n\nvar _job_service = require('plugins/ml/services/job_service');\n\nvar _ml_api_service = require('plugins/ml/services/ml_api_service');\n\nvar _states = require('plugins/ml/../common/constants/states');\n\nvar _i18n = require('@kbn/i18n');\n\nfunction loadFullJob(jobId) {\n  return new Promise(function (resolve, reject) {\n    _ml_api_service.ml.jobs.jobs(jobId).then(function (jobs) {\n      if (jobs.length) {\n        resolve(jobs[0]);\n      } else {\n        throw new Error('Could not find job ' + jobId);\n      }\n    }).catch(function (error) {\n      reject(error);\n    });\n  });\n} /*\n   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n   * or more contributor license agreements. Licensed under the Elastic License;\n   * you may not use this file except in compliance with the Elastic License.\n   */\n\nfunction isStartable(jobs) {\n  return jobs.some(function (j) {\n    return j.datafeedState === _states.DATAFEED_STATE.STOPPED;\n  });\n}\n\nfunction isStoppable(jobs) {\n  return jobs.some(function (j) {\n    return j.datafeedState === _states.DATAFEED_STATE.STARTED;\n  });\n}\n\nfunction isClosable(jobs) {\n  return jobs.some(function (j) {\n    return j.datafeedState === _states.DATAFEED_STATE.STOPPED && j.jobState !== _states.JOB_STATE.CLOSED;\n  });\n}\n\nfunction forceStartDatafeeds(jobs, start, end) {\n  var finish = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n\n  var datafeedIds = jobs.filter(function (j) {\n    return j.hasDatafeed;\n  }).map(function (j) {\n    return j.datafeedId;\n  });\n  _job_service.mlJobService.forceStartDatafeeds(datafeedIds, start, end).then(function (resp) {\n    showResults(resp, _states.DATAFEED_STATE.STARTED);\n    finish();\n  }).catch(function (error) {\n    _messagebar_service.mlMessageBarService.notify.error(error);\n    _notify.toastNotifications.addDanger(_i18n.i18n.translate('xpack.ml.jobsList.startJobErrorMessage', {\n      defaultMessage: 'Jobs failed to start'\n    }), error);\n    finish();\n  });\n}\n\nfunction stopDatafeeds(jobs) {\n  var finish = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\n  var datafeedIds = jobs.filter(function (j) {\n    return j.hasDatafeed;\n  }).map(function (j) {\n    return j.datafeedId;\n  });\n  _job_service.mlJobService.stopDatafeeds(datafeedIds).then(function (resp) {\n    showResults(resp, _states.DATAFEED_STATE.STOPPED);\n    finish();\n  }).catch(function (error) {\n    _messagebar_service.mlMessageBarService.notify.error(error);\n    _notify.toastNotifications.addDanger(_i18n.i18n.translate('xpack.ml.jobsList.stopJobErrorMessage', {\n      defaultMessage: 'Jobs failed to stop'\n    }), error);\n    finish();\n  });\n}\n\nfunction showResults(resp, action) {\n  var successes = [];\n  var failures = [];\n  for (var d in resp) {\n    if (resp[d][action] === true || resp[d][action] === false && resp[d].error.statusCode === 409 && action === _states.DATAFEED_STATE.STARTED) {\n      successes.push(d);\n    } else {\n      failures.push({\n        id: d,\n        result: resp[d]\n      });\n    }\n  }\n\n  var actionText = '';\n  var actionTextPT = '';\n  if (action === _states.DATAFEED_STATE.STARTED) {\n    actionText = _i18n.i18n.translate('xpack.ml.jobsList.startActionStatusText', {\n      defaultMessage: 'start'\n    });\n    actionTextPT = _i18n.i18n.translate('xpack.ml.jobsList.startedActionStatusText', {\n      defaultMessage: 'started'\n    });\n  } else if (action === _states.DATAFEED_STATE.STOPPED) {\n    actionText = _i18n.i18n.translate('xpack.ml.jobsList.stopActionStatusText', {\n      defaultMessage: 'stop'\n    });\n    actionTextPT = _i18n.i18n.translate('xpack.ml.jobsList.stoppedActionStatusText', {\n      defaultMessage: 'stopped'\n    });\n  } else if (action === _states.DATAFEED_STATE.DELETED) {\n    actionText = _i18n.i18n.translate('xpack.ml.jobsList.deleteActionStatusText', {\n      defaultMessage: 'delete'\n    });\n    actionTextPT = _i18n.i18n.translate('xpack.ml.jobsList.deletedActionStatusText', {\n      defaultMessage: 'deleted'\n    });\n  } else if (action === _states.JOB_STATE.CLOSED) {\n    actionText = _i18n.i18n.translate('xpack.ml.jobsList.closeActionStatusText', {\n      defaultMessage: 'close'\n    });\n    actionTextPT = _i18n.i18n.translate('xpack.ml.jobsList.closedActionStatusText', {\n      defaultMessage: 'closed'\n    });\n  }\n\n  _notify.toastNotifications.addSuccess(_i18n.i18n.translate('xpack.ml.jobsList.actionExecuteSuccessfullyNotificationMessage', {\n    defaultMessage: '{successesJobsCount, plural, one{{successJob}} other{# jobs}} {actionTextPT} successfully',\n    values: {\n      successesJobsCount: successes.length,\n      successJob: successes[0],\n      actionTextPT: actionTextPT\n    }\n  }));\n\n  if (failures.length > 0) {\n    failures.forEach(function (f) {\n      _messagebar_service.mlMessageBarService.notify.error(f.result.error);\n      _notify.toastNotifications.addDanger(_i18n.i18n.translate('xpack.ml.jobsList.actionFailedNotificationMessage', {\n        defaultMessage: '{failureId} failed to {actionText}',\n        values: {\n          failureId: f.id,\n          actionText: actionText\n        }\n      }));\n    });\n  }\n}\n\nfunction cloneJob(jobId) {\n  loadFullJob(jobId).then(function (job) {\n    _job_service.mlJobService.currentJob = job;\n    window.location.href = '#/jobs/new_job';\n  }).catch(function (error) {\n    _messagebar_service.mlMessageBarService.notify.error(error);\n    _notify.toastNotifications.addDanger(_i18n.i18n.translate('xpack.ml.jobsList.cloneJobErrorMessage', {\n      defaultMessage: 'Could not clone {jobId}. Job could not be found',\n      values: { jobId: jobId }\n    }));\n  });\n}\n\nfunction closeJobs(jobs) {\n  var finish = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\n  var jobIds = jobs.map(function (j) {\n    return j.id;\n  });\n  _job_service.mlJobService.closeJobs(jobIds).then(function (resp) {\n    showResults(resp, _states.JOB_STATE.CLOSED);\n    finish();\n  }).catch(function (error) {\n    _messagebar_service.mlMessageBarService.notify.error(error);\n    _notify.toastNotifications.addDanger(_i18n.i18n.translate('xpack.ml.jobsList.closeJobErrorMessage', {\n      defaultMessage: 'Jobs failed to close'\n    }), error);\n    finish();\n  });\n}\n\nfunction deleteJobs(jobs) {\n  var finish = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\n  var jobIds = jobs.map(function (j) {\n    return j.id;\n  });\n  _job_service.mlJobService.deleteJobs(jobIds).then(function (resp) {\n    showResults(resp, _states.JOB_STATE.DELETED);\n    finish();\n  }).catch(function (error) {\n    _messagebar_service.mlMessageBarService.notify.error(error);\n    _notify.toastNotifications.addDanger(_i18n.i18n.translate('xpack.ml.jobsList.deleteJobErrorMessage', {\n      defaultMessage: 'Jobs failed to delete'\n    }), error);\n    finish();\n  });\n}\n\nfunction filterJobs(jobs, clauses) {\n  if (clauses.length === 0) {\n    return jobs;\n  }\n\n  // keep count of the number of matches we make as we're looping over the clauses\n  // we only want to return jobs which match all clauses, i.e. each search term is ANDed\n  var matches = jobs.reduce(function (p, c) {\n    p[c.id] = {\n      job: c,\n      count: 0\n    };\n    return p;\n  }, {});\n\n  clauses.forEach(function (c) {\n    // the search term could be negated with a minus, e.g. -bananas\n    var bool = c.match === 'must';\n    var js = [];\n\n    if (c.type === 'term') {\n      // filter term based clauses, e.g. bananas\n      // match on id, description and memory_status\n      // if the term has been negated, AND the matches\n      if (bool === true) {\n        js = jobs.filter(function (job) {\n          return stringMatch(job.id, c.value) === bool || stringMatch(job.description, c.value) === bool || stringMatch(job.memory_status, c.value) === bool;\n        });\n      } else {\n        js = jobs.filter(function (job) {\n          return stringMatch(job.id, c.value) === bool && stringMatch(job.description, c.value) === bool && stringMatch(job.memory_status, c.value) === bool;\n        });\n      }\n    } else {\n      // filter other clauses, i.e. the toggle group buttons\n      if (Array.isArray(c.value)) {\n        // the groups value is an array of group ids\n        js = jobs.filter(function (job) {\n          return jobProperty(job, c.field).some(function (g) {\n            return c.value.indexOf(g) >= 0;\n          });\n        });\n      } else {\n        js = jobs.filter(function (job) {\n          return jobProperty(job, c.field) === c.value;\n        });\n      }\n    }\n\n    js.forEach(function (j) {\n      return matches[j.id].count++;\n    });\n  });\n\n  // loop through the matches and return only those jobs which have match all the clauses\n  var filteredJobs = [];\n  (0, _lodash.each)(matches, function (m) {\n    if (m.count >= clauses.length) {\n      filteredJobs.push(m.job);\n    }\n  });\n  return filteredJobs;\n}\n\nfunction stringMatch(str, substr) {\n  return typeof str === 'string' && typeof substr === 'string' && str.toLowerCase().match(substr.toLowerCase()) === null === false;\n}\n\nfunction jobProperty(job, prop) {\n  var propMap = {\n    job_state: 'jobState',\n    datafeed_state: 'datafeedState',\n    groups: 'groups'\n  };\n  return job[propMap[prop]];\n}",null]}