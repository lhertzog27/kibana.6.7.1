{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/remote_clusters/public/store/actions/edit_cluster.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/remote_clusters/public/store/actions/edit_cluster.js","mtime":1567631712124},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearEditClusterErrors = exports.stopEditingCluster = exports.startEditingCluster = exports.editCluster = undefined;\n\nvar _i18n = require('@kbn/i18n');\n\nvar _notify = require('ui/notify');\n\nvar _constants = require('../../constants');\n\nvar _load_clusters = require('./load_clusters');\n\nvar _services = require('../../services');\n\nvar _action_types = require('../action_types');\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */\n\nvar editCluster = exports.editCluster = function editCluster(cluster) {\n  return function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(dispatch) {\n      var statusCode, data, _getRouter, history, search, _extractQueryParams, redirectUrl, decodedRedirect;\n\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              dispatch({\n                type: _action_types.EDIT_CLUSTER_SAVE\n              });\n\n              _context.prev = 1;\n              _context.next = 4;\n              return Promise.all([(0, _services.editCluster)(cluster),\n              // Wait at least half a second to avoid a weird flicker of the saving feedback.\n              new Promise(function (resolve) {\n                return setTimeout(resolve, 500);\n              })]);\n\n            case 4:\n              _context.next = 13;\n              break;\n\n            case 6:\n              _context.prev = 6;\n              _context.t0 = _context['catch'](1);\n\n              if (!_context.t0) {\n                _context.next = 12;\n                break;\n              }\n\n              statusCode = _context.t0.statusCode, data = _context.t0.data;\n\n              // Expect an error in the shape provided by Angular's $http service.\n\n              if (!data) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.abrupt('return', dispatch({\n                type: _action_types.EDIT_CLUSTER_FAILURE,\n                payload: {\n                  error: {\n                    message: _i18n.i18n.translate('xpack.remoteClusters.editAction.failedDefaultErrorMessage', {\n                      defaultMessage: 'Request failed with a {statusCode} error. {message}',\n                      values: { statusCode: statusCode, message: data.message }\n                    }),\n                    cause: data.cause\n                  }\n                }\n              }));\n\n            case 12:\n              return _context.abrupt('return', (0, _notify.fatalError)(_context.t0, _i18n.i18n.translate('xpack.remoteClusters.editAction.errorTitle', {\n                defaultMessage: 'Error editing cluster'\n              })));\n\n            case 13:\n\n              dispatch({\n                type: _action_types.EDIT_CLUSTER_SUCCESS\n              });\n\n              _getRouter = (0, _services.getRouter)(), history = _getRouter.history, search = _getRouter.route.location.search;\n              _extractQueryParams = (0, _services.extractQueryParams)(search), redirectUrl = _extractQueryParams.redirect;\n\n\n              if (redirectUrl) {\n                // A toast is only needed if we're leaving the app.\n                _notify.toastNotifications.addSuccess(_i18n.i18n.translate('xpack.remoteClusters.editAction.successTitle', {\n                  defaultMessage: 'Edited remote cluster \\'{name}\\'',\n                  values: { name: cluster.name }\n                }));\n\n                decodedRedirect = decodeURIComponent(redirectUrl);\n\n                (0, _services.redirect)(decodedRedirect + '?cluster=' + cluster.name);\n              } else {\n                // This will open the edited cluster in the detail panel. Note that we're *not* showing a success toast\n                // here, because it would partially obscure the detail panel.\n                history.push({\n                  pathname: _constants.CRUD_APP_BASE_PATH + '/list',\n                  search: '?cluster=' + cluster.name\n                });\n              }\n\n            case 17:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, undefined, [[1, 6]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n\nvar startEditingCluster = exports.startEditingCluster = function startEditingCluster(_ref2) {\n  var clusterName = _ref2.clusterName;\n  return function (dispatch) {\n    dispatch((0, _load_clusters.loadClusters)());\n\n    dispatch({\n      type: _action_types.EDIT_CLUSTER_START,\n      payload: { clusterName: clusterName }\n    });\n  };\n};\n\nvar stopEditingCluster = exports.stopEditingCluster = function stopEditingCluster() {\n  return function (dispatch) {\n    // Load the clusters to refresh the one we just edited.\n    dispatch((0, _load_clusters.loadClusters)());\n\n    dispatch({\n      type: _action_types.EDIT_CLUSTER_STOP\n    });\n  };\n};\n\nvar clearEditClusterErrors = exports.clearEditClusterErrors = function clearEditClusterErrors() {\n  return function (dispatch) {\n    dispatch({\n      type: _action_types.CLEAR_EDIT_CLUSTER_ERRORS\n    });\n  };\n};",null]}