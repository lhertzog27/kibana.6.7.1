{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/common/lib/dataurl.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/common/lib/dataurl.js","mtime":1567631711911},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.imageTypes = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\nexports.parseDataUrl = parseDataUrl;\nexports.isValidDataUrl = isValidDataUrl;\nexports.encode = encode;\n\nvar _base64Js = require('base64-js');\n\nvar _lite = require('mime/lite');\n\nvar _lite2 = _interopRequireDefault(_lite);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar dataurlRegex = /^data:([a-z]+\\/[a-z0-9-+.]+)(;[a-z-]+=[a-z0-9-]+)?(;([a-z0-9]+))?,/;\n\nvar imageTypes = exports.imageTypes = ['image/svg+xml', 'image/jpeg', 'image/png', 'image/gif'];\n\nfunction parseDataUrl(str) {\n  var withData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (typeof str !== 'string') {\n    return;\n  }\n\n  var matches = str.match(dataurlRegex);\n\n  if (!matches) {\n    return;\n  }\n\n  var _matches = _slicedToArray(matches, 5),\n      mimetype = _matches[1],\n      charset = _matches[2],\n      encoding = _matches[4];\n\n  // all types except for svg need to be base64 encoded\n\n\n  var imageTypeIndex = imageTypes.indexOf(matches[1]);\n  if (imageTypeIndex > 0 && encoding !== 'base64') {\n    return;\n  }\n\n  return {\n    mimetype: mimetype,\n    encoding: encoding,\n    charset: charset && charset.split('=')[1],\n    data: !withData ? null : str.split(',')[1],\n    isImage: imageTypeIndex >= 0,\n    extension: _lite2.default.getExtension(mimetype)\n  };\n}\n\nfunction isValidDataUrl(str) {\n  return dataurlRegex.test(str);\n}\n\nfunction encode(data) {\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text/plain';\n\n  // use FileReader if it's available, like in the browser\n  if (FileReader) {\n    return new Promise(function (resolve, reject) {\n      var reader = new FileReader();\n      reader.onloadend = function () {\n        return resolve(reader.result);\n      };\n      reader.onerror = function (err) {\n        return reject(err);\n      };\n      reader.readAsDataURL(data);\n    });\n  }\n\n  // otherwise fall back to fromByteArray\n  // note: Buffer doesn't seem to correctly base64 encode binary data\n  return Promise.resolve('data:' + type + ';base64,' + (0, _base64Js.fromByteArray)(data));\n}",null]}