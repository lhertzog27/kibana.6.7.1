{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/actions/store_actions.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/actions/store_actions.js","mtime":1567631712013},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.REMOVE_TRACKED_LAYER_STATE = exports.ROLLBACK_TO_TRACKED_LAYER_STATE = exports.TRACK_CURRENT_LAYER_STATE = exports.CLEAR_GOTO = exports.SET_GOTO = exports.CLEAR_MOUSE_COORDINATES = exports.SET_MOUSE_COORDINATES = exports.SET_REFRESH_CONFIG = exports.UPDATE_SOURCE_PROP = exports.TOUCH_LAYER = exports.UPDATE_LAYER_STYLE = exports.UPDATE_LAYER_PROP = exports.TRIGGER_REFRESH_TIMER = exports.SET_QUERY = exports.SET_JOINS = exports.UPDATE_SOURCE_DATA_REQUEST = exports.LAYER_DATA_LOAD_ERROR = exports.LAYER_DATA_LOAD_ENDED = exports.LAYER_DATA_LOAD_STARTED = exports.MAP_DESTROYED = exports.MAP_READY = exports.MAP_EXTENT_CHANGED = exports.TOGGLE_LAYER_VISIBLE = exports.REMOVE_LAYER = exports.CLEAR_WAITING_FOR_MAP_READY_LAYER_LIST = exports.ADD_WAITING_FOR_MAP_READY_LAYER = exports.SET_LAYER_ERROR_STATUS = exports.ADD_LAYER = exports.UPDATE_LAYER_ORDER = exports.SET_TRANSIENT_LAYER = exports.SET_SELECTED_LAYER = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar syncDataForAllLayers = function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(getState, dispatch, dataFilters) {\n    var state, layerList, syncs;\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            state = getState();\n            layerList = (0, _map_selectors.getLayerList)(state);\n            syncs = layerList.map(function (layer) {\n              var loadingFunctions = getLayerLoadingCallbacks(dispatch, layer.getId());\n              return layer.syncData(_extends({}, loadingFunctions, { dataFilters: dataFilters }));\n            });\n            _context2.next = 5;\n            return Promise.all(syncs);\n\n          case 5:\n          case 'end':\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n\n  return function syncDataForAllLayers(_x, _x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.trackCurrentLayerState = trackCurrentLayerState;\nexports.rollbackToTrackedLayerStateForSelectedLayer = rollbackToTrackedLayerStateForSelectedLayer;\nexports.removeTrackedLayerStateForSelectedLayer = removeTrackedLayerStateForSelectedLayer;\nexports.replaceLayerList = replaceLayerList;\nexports.addLayer = addLayer;\nexports.toggleLayerVisible = toggleLayerVisible;\nexports.setSelectedLayer = setSelectedLayer;\nexports.removeTransientLayer = removeTransientLayer;\nexports.setTransientLayer = setTransientLayer;\nexports.clearTransientLayerStateAndCloseFlyout = clearTransientLayerStateAndCloseFlyout;\nexports.updateLayerOrder = updateLayerOrder;\nexports.mapReady = mapReady;\nexports.mapDestroyed = mapDestroyed;\nexports.mapExtentChanged = mapExtentChanged;\nexports.setMouseCoordinates = setMouseCoordinates;\nexports.clearMouseCoordinates = clearMouseCoordinates;\nexports.fitToLayerExtent = fitToLayerExtent;\nexports.setGotoWithBounds = setGotoWithBounds;\nexports.setGotoWithCenter = setGotoWithCenter;\nexports.clearGoto = clearGoto;\nexports.startDataLoad = startDataLoad;\nexports.updateSourceDataRequest = updateSourceDataRequest;\nexports.endDataLoad = endDataLoad;\nexports.onDataLoadError = onDataLoadError;\nexports.updateSourceProp = updateSourceProp;\nexports.syncDataForLayer = syncDataForLayer;\nexports.updateLayerLabel = updateLayerLabel;\nexports.updateLayerMinZoom = updateLayerMinZoom;\nexports.updateLayerMaxZoom = updateLayerMaxZoom;\nexports.updateLayerAlpha = updateLayerAlpha;\nexports.removeSelectedLayer = removeSelectedLayer;\nexports.removeLayer = removeLayer;\nexports.setQuery = setQuery;\nexports.setRefreshConfig = setRefreshConfig;\nexports.triggerRefreshTimer = triggerRefreshTimer;\nexports.clearMissingStyleProperties = clearMissingStyleProperties;\nexports.updateLayerStyle = updateLayerStyle;\nexports.updateLayerStyleForSelectedLayer = updateLayerStyleForSelectedLayer;\nexports.setJoinsForLayer = setJoinsForLayer;\n\nvar _turf = require('turf');\n\nvar _turf2 = _interopRequireDefault(_turf);\n\nvar _booleanContains = require('@turf/boolean-contains');\n\nvar _booleanContains2 = _interopRequireDefault(_booleanContains);\n\nvar _map_selectors = require('../selectors/map_selectors');\n\nvar _ui = require('../store/ui');\n\nvar _constants = require('../../common/constants');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */\n\nvar SET_SELECTED_LAYER = exports.SET_SELECTED_LAYER = 'SET_SELECTED_LAYER';\nvar SET_TRANSIENT_LAYER = exports.SET_TRANSIENT_LAYER = 'SET_TRANSIENT_LAYER';\nvar UPDATE_LAYER_ORDER = exports.UPDATE_LAYER_ORDER = 'UPDATE_LAYER_ORDER';\nvar ADD_LAYER = exports.ADD_LAYER = 'ADD_LAYER';\nvar SET_LAYER_ERROR_STATUS = exports.SET_LAYER_ERROR_STATUS = 'SET_LAYER_ERROR_STATUS';\nvar ADD_WAITING_FOR_MAP_READY_LAYER = exports.ADD_WAITING_FOR_MAP_READY_LAYER = 'ADD_WAITING_FOR_MAP_READY_LAYER';\nvar CLEAR_WAITING_FOR_MAP_READY_LAYER_LIST = exports.CLEAR_WAITING_FOR_MAP_READY_LAYER_LIST = 'CLEAR_WAITING_FOR_MAP_READY_LAYER_LIST';\nvar REMOVE_LAYER = exports.REMOVE_LAYER = 'REMOVE_LAYER';\nvar TOGGLE_LAYER_VISIBLE = exports.TOGGLE_LAYER_VISIBLE = 'TOGGLE_LAYER_VISIBLE';\nvar MAP_EXTENT_CHANGED = exports.MAP_EXTENT_CHANGED = 'MAP_EXTENT_CHANGED';\nvar MAP_READY = exports.MAP_READY = 'MAP_READY';\nvar MAP_DESTROYED = exports.MAP_DESTROYED = 'MAP_DESTROYED';\nvar LAYER_DATA_LOAD_STARTED = exports.LAYER_DATA_LOAD_STARTED = 'LAYER_DATA_LOAD_STARTED';\nvar LAYER_DATA_LOAD_ENDED = exports.LAYER_DATA_LOAD_ENDED = 'LAYER_DATA_LOAD_ENDED';\nvar LAYER_DATA_LOAD_ERROR = exports.LAYER_DATA_LOAD_ERROR = 'LAYER_DATA_LOAD_ERROR';\nvar UPDATE_SOURCE_DATA_REQUEST = exports.UPDATE_SOURCE_DATA_REQUEST = 'UPDATE_SOURCE_DATA_REQUEST';\nvar SET_JOINS = exports.SET_JOINS = 'SET_JOINS';\nvar SET_QUERY = exports.SET_QUERY = 'SET_QUERY';\nvar TRIGGER_REFRESH_TIMER = exports.TRIGGER_REFRESH_TIMER = 'TRIGGER_REFRESH_TIMER';\nvar UPDATE_LAYER_PROP = exports.UPDATE_LAYER_PROP = 'UPDATE_LAYER_PROP';\nvar UPDATE_LAYER_STYLE = exports.UPDATE_LAYER_STYLE = 'UPDATE_LAYER_STYLE';\nvar TOUCH_LAYER = exports.TOUCH_LAYER = 'TOUCH_LAYER';\nvar UPDATE_SOURCE_PROP = exports.UPDATE_SOURCE_PROP = 'UPDATE_SOURCE_PROP';\nvar SET_REFRESH_CONFIG = exports.SET_REFRESH_CONFIG = 'SET_REFRESH_CONFIG';\nvar SET_MOUSE_COORDINATES = exports.SET_MOUSE_COORDINATES = 'SET_MOUSE_COORDINATES';\nvar CLEAR_MOUSE_COORDINATES = exports.CLEAR_MOUSE_COORDINATES = 'CLEAR_MOUSE_COORDINATES';\nvar SET_GOTO = exports.SET_GOTO = 'SET_GOTO';\nvar CLEAR_GOTO = exports.CLEAR_GOTO = 'CLEAR_GOTO';\nvar TRACK_CURRENT_LAYER_STATE = exports.TRACK_CURRENT_LAYER_STATE = 'TRACK_CURRENT_LAYER_STATE';\nvar ROLLBACK_TO_TRACKED_LAYER_STATE = exports.ROLLBACK_TO_TRACKED_LAYER_STATE = 'ROLLBACK_TO_TRACKED_LAYER_STATE';\nvar REMOVE_TRACKED_LAYER_STATE = exports.REMOVE_TRACKED_LAYER_STATE = 'REMOVE_TRACKED_LAYER_STATE';\n\nfunction getLayerLoadingCallbacks(dispatch, layerId) {\n  var _this = this;\n\n  return {\n    startLoading: function startLoading(dataId, requestToken, meta) {\n      return dispatch(startDataLoad(layerId, dataId, requestToken, meta));\n    },\n    stopLoading: function stopLoading(dataId, requestToken, data, meta) {\n      return dispatch(endDataLoad(layerId, dataId, requestToken, data, meta));\n    },\n    onLoadError: function onLoadError(dataId, requestToken, errorMessage) {\n      return dispatch(onDataLoadError(layerId, dataId, requestToken, errorMessage));\n    },\n    onRefreshStyle: function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return dispatch({\n                  type: TOUCH_LAYER,\n                  layerId: layerId\n                });\n\n              case 2:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, _this);\n      }));\n\n      function onRefreshStyle() {\n        return _ref.apply(this, arguments);\n      }\n\n      return onRefreshStyle;\n    }(),\n    updateSourceData: function updateSourceData(newData) {\n      dispatch(updateSourceDataRequest(layerId, newData));\n    }\n  };\n}\n\nfunction trackCurrentLayerState(layerId) {\n  return {\n    type: TRACK_CURRENT_LAYER_STATE,\n    layerId: layerId\n  };\n}\n\nfunction rollbackToTrackedLayerStateForSelectedLayer() {\n  var _this2 = this;\n\n  return function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(dispatch, getState) {\n      var layerId;\n      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              layerId = (0, _map_selectors.getSelectedLayerId)(getState());\n              _context3.next = 3;\n              return dispatch({\n                type: ROLLBACK_TO_TRACKED_LAYER_STATE,\n                layerId: layerId\n              });\n\n            case 3:\n              dispatch(syncDataForLayer(layerId));\n\n            case 4:\n            case 'end':\n              return _context3.stop();\n          }\n        }\n      }, _callee3, _this2);\n    }));\n\n    return function (_x4, _x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n}\n\nfunction removeTrackedLayerStateForSelectedLayer() {\n  return function (dispatch, getState) {\n    var layerId = (0, _map_selectors.getSelectedLayerId)(getState());\n    dispatch({\n      type: REMOVE_TRACKED_LAYER_STATE,\n      layerId: layerId\n    });\n  };\n}\n\nfunction replaceLayerList(newLayerList) {\n  return function (dispatch, getState) {\n    (0, _map_selectors.getLayerListRaw)(getState()).forEach(function (_ref4) {\n      var id = _ref4.id;\n\n      dispatch(removeLayer(id));\n    });\n\n    newLayerList.forEach(function (layerDescriptor) {\n      dispatch(addLayer(layerDescriptor));\n    });\n  };\n}\n\nfunction addLayer(layerDescriptor) {\n  return function (dispatch, getState) {\n    var isMapReady = (0, _map_selectors.getMapReady)(getState());\n    if (!isMapReady) {\n      dispatch({\n        type: ADD_WAITING_FOR_MAP_READY_LAYER,\n        layer: layerDescriptor\n      });\n      return;\n    }\n\n    dispatch({\n      type: ADD_LAYER,\n      layer: layerDescriptor\n    });\n    dispatch(syncDataForLayer(layerDescriptor.id));\n  };\n}\n\nfunction setLayerDataLoadErrorStatus(layerId, errorMessage) {\n  return function (dispatch) {\n    dispatch({\n      type: SET_LAYER_ERROR_STATUS,\n      isInErrorState: errorMessage !== null,\n      layerId: layerId,\n      errorMessage: errorMessage\n    });\n  };\n}\n\nfunction toggleLayerVisible(layerId) {\n  var _this3 = this;\n\n  return function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(dispatch, getState) {\n      var layer, makeVisible;\n      return regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              //if the current-state is invisible, we also want to sync data\n              //e.g. if a layer was invisible at start-up, it won't have any data loaded\n              layer = (0, _map_selectors.getLayerList)(getState()).find(function (layer) {\n                return layerId === layer.getId();\n              });\n\n              if (layer) {\n                _context4.next = 3;\n                break;\n              }\n\n              return _context4.abrupt('return');\n\n            case 3:\n              makeVisible = !layer.isVisible();\n              _context4.next = 6;\n              return dispatch({\n                type: TOGGLE_LAYER_VISIBLE,\n                layerId: layerId\n              });\n\n            case 6:\n              if (makeVisible) {\n                dispatch(syncDataForLayer(layerId));\n              }\n\n            case 7:\n            case 'end':\n              return _context4.stop();\n          }\n        }\n      }, _callee4, _this3);\n    }));\n\n    return function (_x6, _x7) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n}\n\nfunction setSelectedLayer(layerId) {\n  var _this4 = this;\n\n  return function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(dispatch, getState) {\n      var oldSelectedLayer;\n      return regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              oldSelectedLayer = (0, _map_selectors.getSelectedLayerId)(getState());\n\n              if (!oldSelectedLayer) {\n                _context5.next = 4;\n                break;\n              }\n\n              _context5.next = 4;\n              return dispatch(rollbackToTrackedLayerStateForSelectedLayer());\n\n            case 4:\n              if (layerId) {\n                dispatch(trackCurrentLayerState(layerId));\n              }\n              dispatch({\n                type: SET_SELECTED_LAYER,\n                selectedLayerId: layerId\n              });\n\n            case 6:\n            case 'end':\n              return _context5.stop();\n          }\n        }\n      }, _callee5, _this4);\n    }));\n\n    return function (_x8, _x9) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n}\n\nfunction removeTransientLayer() {\n  var _this5 = this;\n\n  return function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(dispatch, getState) {\n      var transientLayerId;\n      return regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              transientLayerId = (0, _map_selectors.getTransientLayerId)(getState());\n\n              if (!transientLayerId) {\n                _context6.next = 6;\n                break;\n              }\n\n              _context6.next = 4;\n              return dispatch(removeLayer(transientLayerId));\n\n            case 4:\n              _context6.next = 6;\n              return dispatch(setTransientLayer(null));\n\n            case 6:\n            case 'end':\n              return _context6.stop();\n          }\n        }\n      }, _callee6, _this5);\n    }));\n\n    return function (_x10, _x11) {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n}\n\nfunction setTransientLayer(layerId) {\n  return {\n    type: SET_TRANSIENT_LAYER,\n    transientLayerId: layerId\n  };\n}\n\nfunction clearTransientLayerStateAndCloseFlyout() {\n  var _this6 = this;\n\n  return function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(dispatch) {\n      return regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return dispatch((0, _ui.updateFlyout)(_ui.FLYOUT_STATE.NONE));\n\n            case 2:\n              _context7.next = 4;\n              return dispatch(setSelectedLayer(null));\n\n            case 4:\n              _context7.next = 6;\n              return dispatch(removeTransientLayer());\n\n            case 6:\n            case 'end':\n              return _context7.stop();\n          }\n        }\n      }, _callee7, _this6);\n    }));\n\n    return function (_x12) {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n}\n\nfunction updateLayerOrder(newLayerOrder) {\n  return {\n    type: UPDATE_LAYER_ORDER,\n    newLayerOrder: newLayerOrder\n  };\n}\n\nfunction mapReady() {\n  return function (dispatch, getState) {\n    dispatch({\n      type: MAP_READY\n    });\n\n    (0, _map_selectors.getWaitingForMapReadyLayerListRaw)(getState()).forEach(function (layerDescriptor) {\n      dispatch(addLayer(layerDescriptor));\n    });\n\n    dispatch({\n      type: CLEAR_WAITING_FOR_MAP_READY_LAYER_LIST\n    });\n  };\n}\n\nfunction mapDestroyed() {\n  return {\n    type: MAP_DESTROYED\n  };\n}\n\nfunction mapExtentChanged(newMapConstants) {\n  var _this7 = this;\n\n  return function () {\n    var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(dispatch, getState) {\n      var state, dataFilters, extent, newZoom, buffer, currentZoom, doesBufferContainExtent, bufferGeometry, extentGeometry, scaleFactor, width, height, newDataFilters;\n      return regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              state = getState();\n              dataFilters = (0, _map_selectors.getDataFilters)(state);\n              extent = newMapConstants.extent, newZoom = newMapConstants.zoom;\n              buffer = dataFilters.buffer, currentZoom = dataFilters.zoom;\n\n\n              if (extent) {\n                doesBufferContainExtent = false;\n\n                if (buffer) {\n                  bufferGeometry = _turf2.default.bboxPolygon([buffer.minLon, buffer.minLat, buffer.maxLon, buffer.maxLat]);\n                  extentGeometry = _turf2.default.bboxPolygon([extent.minLon, extent.minLat, extent.maxLon, extent.maxLat]);\n\n\n                  doesBufferContainExtent = (0, _booleanContains2.default)(bufferGeometry, extentGeometry);\n                }\n\n                if (!doesBufferContainExtent || currentZoom !== newZoom) {\n                  scaleFactor = 0.5; // TODO put scale factor in store and fetch with selector\n\n                  width = extent.maxLon - extent.minLon;\n                  height = extent.maxLat - extent.minLat;\n\n                  dataFilters.buffer = {\n                    minLon: extent.minLon - width * scaleFactor,\n                    minLat: extent.minLat - height * scaleFactor,\n                    maxLon: extent.maxLon + width * scaleFactor,\n                    maxLat: extent.maxLat + height * scaleFactor\n                  };\n                }\n              }\n\n              dispatch({\n                type: MAP_EXTENT_CHANGED,\n                mapState: _extends({}, dataFilters, newMapConstants)\n              });\n              newDataFilters = _extends({}, dataFilters, newMapConstants);\n              _context8.next = 9;\n              return syncDataForAllLayers(getState, dispatch, newDataFilters);\n\n            case 9:\n            case 'end':\n              return _context8.stop();\n          }\n        }\n      }, _callee8, _this7);\n    }));\n\n    return function (_x13, _x14) {\n      return _ref9.apply(this, arguments);\n    };\n  }();\n}\n\nfunction setMouseCoordinates(_ref10) {\n  var lat = _ref10.lat,\n      lon = _ref10.lon;\n\n  var safeLon = lon;\n  if (lon > 180) {\n    var overlapWestOfDateLine = lon - 180;\n    safeLon = -180 + overlapWestOfDateLine;\n  } else if (lon < -180) {\n    var overlapEastOfDateLine = Math.abs(lon) - 180;\n    safeLon = 180 - overlapEastOfDateLine;\n  }\n\n  return {\n    type: SET_MOUSE_COORDINATES,\n    lat: lat,\n    lon: safeLon\n  };\n}\n\nfunction clearMouseCoordinates() {\n  return { type: CLEAR_MOUSE_COORDINATES };\n}\n\nfunction fitToLayerExtent(layerId) {\n  return function () {\n    var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(dispatch, getState) {\n      var targetLayer, dataFilters, bounds;\n      return regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              targetLayer = (0, _map_selectors.getLayerList)(getState()).find(function (layer) {\n                return layer.getId() === layerId;\n              });\n\n              if (!targetLayer) {\n                _context9.next = 9;\n                break;\n              }\n\n              dataFilters = (0, _map_selectors.getDataFilters)(getState());\n              _context9.next = 5;\n              return targetLayer.getBounds(dataFilters);\n\n            case 5:\n              bounds = _context9.sent;\n\n              if (!bounds) {\n                _context9.next = 9;\n                break;\n              }\n\n              _context9.next = 9;\n              return dispatch(setGotoWithBounds(bounds));\n\n            case 9:\n            case 'end':\n              return _context9.stop();\n          }\n        }\n      }, _callee9, this);\n    }));\n\n    return function (_x15, _x16) {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n}\n\nfunction setGotoWithBounds(bounds) {\n  return {\n    type: SET_GOTO,\n    bounds: bounds\n  };\n}\n\nfunction setGotoWithCenter(_ref12) {\n  var lat = _ref12.lat,\n      lon = _ref12.lon,\n      zoom = _ref12.zoom;\n\n  return {\n    type: SET_GOTO,\n    center: { lat: lat, lon: lon, zoom: zoom }\n  };\n}\n\nfunction clearGoto() {\n  return { type: CLEAR_GOTO };\n}\n\nfunction startDataLoad(layerId, dataId, requestToken) {\n  var meta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  return {\n    meta: meta,\n    type: LAYER_DATA_LOAD_STARTED,\n    layerId: layerId,\n    dataId: dataId,\n    requestToken: requestToken\n  };\n}\n\nfunction updateSourceDataRequest(layerId, newData) {\n  return {\n    type: UPDATE_SOURCE_DATA_REQUEST,\n    dataId: _constants.SOURCE_DATA_ID_ORIGIN,\n    layerId: layerId,\n    newData: newData\n  };\n}\n\nfunction endDataLoad(layerId, dataId, requestToken, data, meta) {\n  var _this8 = this;\n\n  return function () {\n    var _ref13 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(dispatch) {\n      return regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              dispatch({\n                type: LAYER_DATA_LOAD_ENDED,\n                layerId: layerId,\n                dataId: dataId,\n                data: data,\n                meta: meta,\n                requestToken: requestToken\n              });\n              //Clear any data-load errors when there is a succesful data return.\n              //Co this on end-data-load iso at start-data-load to avoid blipping the error status between true/false.\n              //This avoids jitter in the warning icon of the TOC when the requests continues to return errors.\n              dispatch(setLayerDataLoadErrorStatus(layerId, null));\n\n            case 2:\n            case 'end':\n              return _context10.stop();\n          }\n        }\n      }, _callee10, _this8);\n    }));\n\n    return function (_x18) {\n      return _ref13.apply(this, arguments);\n    };\n  }();\n}\n\nfunction onDataLoadError(layerId, dataId, requestToken, errorMessage) {\n  var _this9 = this;\n\n  return function () {\n    var _ref14 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(dispatch) {\n      return regeneratorRuntime.wrap(function _callee11$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              dispatch({\n                type: LAYER_DATA_LOAD_ERROR,\n                layerId: layerId,\n                dataId: dataId,\n                requestToken: requestToken\n              });\n\n              dispatch(setLayerDataLoadErrorStatus(layerId, errorMessage));\n\n            case 2:\n            case 'end':\n              return _context11.stop();\n          }\n        }\n      }, _callee11, _this9);\n    }));\n\n    return function (_x19) {\n      return _ref14.apply(this, arguments);\n    };\n  }();\n}\n\nfunction updateSourceProp(layerId, propName, value) {\n  var _this10 = this;\n\n  return function () {\n    var _ref15 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(dispatch) {\n      return regeneratorRuntime.wrap(function _callee12$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              dispatch({\n                type: UPDATE_SOURCE_PROP,\n                layerId: layerId,\n                propName: propName,\n                value: value\n              });\n              _context12.next = 3;\n              return dispatch(clearMissingStyleProperties(layerId));\n\n            case 3:\n              dispatch(syncDataForLayer(layerId));\n\n            case 4:\n            case 'end':\n              return _context12.stop();\n          }\n        }\n      }, _callee12, _this10);\n    }));\n\n    return function (_x20) {\n      return _ref15.apply(this, arguments);\n    };\n  }();\n}\n\nfunction syncDataForLayer(layerId) {\n  var _this11 = this;\n\n  return function () {\n    var _ref16 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(dispatch, getState) {\n      var targetLayer, dataFilters, loadingFunctions;\n      return regeneratorRuntime.wrap(function _callee13$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              targetLayer = (0, _map_selectors.getLayerList)(getState()).find(function (layer) {\n                return layer.getId() === layerId;\n              });\n\n              if (!targetLayer) {\n                _context13.next = 6;\n                break;\n              }\n\n              dataFilters = (0, _map_selectors.getDataFilters)(getState());\n              loadingFunctions = getLayerLoadingCallbacks(dispatch, layerId);\n              _context13.next = 6;\n              return targetLayer.syncData(_extends({}, loadingFunctions, {\n                dataFilters: dataFilters\n              }));\n\n            case 6:\n            case 'end':\n              return _context13.stop();\n          }\n        }\n      }, _callee13, _this11);\n    }));\n\n    return function (_x21, _x22) {\n      return _ref16.apply(this, arguments);\n    };\n  }();\n}\n\nfunction updateLayerLabel(id, newLabel) {\n  return {\n    type: UPDATE_LAYER_PROP,\n    id: id,\n    propName: 'label',\n    newValue: newLabel\n  };\n}\n\nfunction updateLayerMinZoom(id, minZoom) {\n  return {\n    type: UPDATE_LAYER_PROP,\n    id: id,\n    propName: 'minZoom',\n    newValue: minZoom\n  };\n}\n\nfunction updateLayerMaxZoom(id, maxZoom) {\n  return {\n    type: UPDATE_LAYER_PROP,\n    id: id,\n    propName: 'maxZoom',\n    newValue: maxZoom\n  };\n}\n\nfunction updateLayerAlpha(id, alpha) {\n  return {\n    type: UPDATE_LAYER_PROP,\n    id: id,\n    propName: 'alpha',\n    newValue: alpha\n  };\n}\n\nfunction removeSelectedLayer() {\n  return function (dispatch, getState) {\n    var state = getState();\n    var layerId = (0, _map_selectors.getSelectedLayerId)(state);\n    dispatch(removeLayer(layerId));\n    dispatch(setSelectedLayer(null));\n  };\n}\n\nfunction removeLayer(id) {\n  return function (dispatch, getState) {\n    var layerGettingRemoved = (0, _map_selectors.getLayerList)(getState()).find(function (layer) {\n      return id === layer.getId();\n    });\n    if (layerGettingRemoved) {\n      layerGettingRemoved.destroy();\n    }\n\n    dispatch({\n      type: REMOVE_LAYER,\n      id: id\n    });\n  };\n}\n\nfunction setQuery(_ref17) {\n  var _this12 = this;\n\n  var query = _ref17.query,\n      timeFilters = _ref17.timeFilters;\n\n  return function () {\n    var _ref18 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(dispatch, getState) {\n      var dataFilters;\n      return regeneratorRuntime.wrap(function _callee14$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              dispatch({\n                type: SET_QUERY,\n                timeFilters: timeFilters,\n                query: _extends({}, query, {\n                  // ensure query changes to trigger re-fetch even when query is the same because \"Refresh\" clicked\n                  queryLastTriggeredAt: new Date().toISOString()\n                })\n              });\n\n              dataFilters = (0, _map_selectors.getDataFilters)(getState());\n              _context14.next = 4;\n              return syncDataForAllLayers(getState, dispatch, dataFilters);\n\n            case 4:\n            case 'end':\n              return _context14.stop();\n          }\n        }\n      }, _callee14, _this12);\n    }));\n\n    return function (_x23, _x24) {\n      return _ref18.apply(this, arguments);\n    };\n  }();\n}\n\nfunction setRefreshConfig(_ref19) {\n  var isPaused = _ref19.isPaused,\n      interval = _ref19.interval;\n\n  return {\n    type: SET_REFRESH_CONFIG,\n    isPaused: isPaused,\n    interval: interval\n  };\n}\n\nfunction triggerRefreshTimer() {\n  var _this13 = this;\n\n  return function () {\n    var _ref20 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(dispatch, getState) {\n      var dataFilters;\n      return regeneratorRuntime.wrap(function _callee15$(_context15) {\n        while (1) {\n          switch (_context15.prev = _context15.next) {\n            case 0:\n              dispatch({\n                type: TRIGGER_REFRESH_TIMER\n              });\n\n              dataFilters = (0, _map_selectors.getDataFilters)(getState());\n              _context15.next = 4;\n              return syncDataForAllLayers(getState, dispatch, dataFilters);\n\n            case 4:\n            case 'end':\n              return _context15.stop();\n          }\n        }\n      }, _callee15, _this13);\n    }));\n\n    return function (_x25, _x26) {\n      return _ref20.apply(this, arguments);\n    };\n  }();\n}\n\nfunction clearMissingStyleProperties(layerId) {\n  var _this14 = this;\n\n  return function () {\n    var _ref21 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(dispatch, getState) {\n      var targetLayer, style, ordinalFields, _style$getDescriptorW, hasChanges, nextStyleDescriptor;\n\n      return regeneratorRuntime.wrap(function _callee16$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              targetLayer = (0, _map_selectors.getLayerList)(getState()).find(function (layer) {\n                return layer.getId() === layerId;\n              });\n\n              if (targetLayer) {\n                _context16.next = 3;\n                break;\n              }\n\n              return _context16.abrupt('return');\n\n            case 3:\n              style = targetLayer.getCurrentStyle();\n\n              if (style) {\n                _context16.next = 6;\n                break;\n              }\n\n              return _context16.abrupt('return');\n\n            case 6:\n              _context16.next = 8;\n              return targetLayer.getOrdinalFields();\n\n            case 8:\n              ordinalFields = _context16.sent;\n              _style$getDescriptorW = style.getDescriptorWithMissingStylePropsRemoved(ordinalFields), hasChanges = _style$getDescriptorW.hasChanges, nextStyleDescriptor = _style$getDescriptorW.nextStyleDescriptor;\n\n              if (hasChanges) {\n                dispatch(updateLayerStyle(layerId, nextStyleDescriptor));\n              }\n\n            case 11:\n            case 'end':\n              return _context16.stop();\n          }\n        }\n      }, _callee16, _this14);\n    }));\n\n    return function (_x27, _x28) {\n      return _ref21.apply(this, arguments);\n    };\n  }();\n}\n\nfunction updateLayerStyle(layerId, styleDescriptor) {\n  return function (dispatch) {\n    dispatch({\n      type: UPDATE_LAYER_STYLE,\n      layerId: layerId,\n      style: _extends({}, styleDescriptor)\n    });\n\n    // Style update may require re-fetch, for example ES search may need to retrieve field used for dynamic styling\n    dispatch(syncDataForLayer(layerId));\n  };\n}\n\nfunction updateLayerStyleForSelectedLayer(styleDescriptor) {\n  return function (dispatch, getState) {\n    var selectedLayerId = (0, _map_selectors.getSelectedLayerId)(getState());\n    if (!selectedLayerId) {\n      return;\n    }\n    dispatch(updateLayerStyle(selectedLayerId, styleDescriptor));\n  };\n}\n\nfunction setJoinsForLayer(layer, joins) {\n  var _this15 = this;\n\n  return function () {\n    var _ref22 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(dispatch) {\n      return regeneratorRuntime.wrap(function _callee17$(_context17) {\n        while (1) {\n          switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.next = 2;\n              return dispatch({\n                type: SET_JOINS,\n                layer: layer,\n                joins: joins\n              });\n\n            case 2:\n              _context17.next = 4;\n              return dispatch(clearMissingStyleProperties(layer.getId()));\n\n            case 4:\n              dispatch(syncDataForLayer(layer.getId()));\n\n            case 5:\n            case 'end':\n              return _context17.stop();\n          }\n        }\n      }, _callee17, _this15);\n    }));\n\n    return function (_x29) {\n      return _ref22.apply(this, arguments);\n    };\n  }();\n}",null]}