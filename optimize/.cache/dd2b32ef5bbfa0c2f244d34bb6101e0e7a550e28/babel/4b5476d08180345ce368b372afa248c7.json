{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/middleware/aeroelastic.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/middleware/aeroelastic.js","mtime":1567631711935},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.aeroelastic = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nvar _recompose = require('recompose');\n\nvar _aeroelastic_kibana = require('../../lib/aeroelastic_kibana');\n\nvar _matrix = require('../../lib/aeroelastic/matrix');\n\nvar _functional = require('../../lib/aeroelastic/functional');\n\nvar _elements = require('../actions/elements');\n\nvar _history = require('../actions/history');\n\nvar _transient = require('../actions/transient');\n\nvar _pages2 = require('../actions/pages');\n\nvar _app = require('../actions/app');\n\nvar _workpad = require('../actions/workpad');\n\nvar _workpad2 = require('../selectors/workpad');\n\nvar aeroelasticConfiguration = {\n  getAdHocChildAnnotationName: 'adHocChildAnnotation',\n  adHocGroupName: 'adHocGroup',\n  alignmentGuideName: 'alignmentGuide',\n  atopZ: 1000,\n  depthSelect: true,\n  devColor: 'magenta',\n  groupName: 'group',\n  groupResize: true,\n  guideDistance: 3,\n  hoverAnnotationName: 'hoverAnnotation',\n  hoverLift: 100,\n  intraGroupManipulation: false,\n  intraGroupSnapOnly: false,\n  minimumElementSize: 2,\n  persistentGroupName: 'persistentGroup',\n  resizeAnnotationConnectorOffset: 0,\n  resizeAnnotationOffset: 0,\n  resizeAnnotationOffsetZ: 0.1, // causes resize markers to be slightly above the shape plane\n  resizeAnnotationSize: 10,\n  resizeConnectorName: 'resizeConnector',\n  resizeHandleName: 'resizeHandle',\n  rotateAnnotationOffset: 12,\n  rotateSnapInPixels: 10,\n  rotationEpsilon: 0.001,\n  rotationHandleName: 'rotationHandle',\n  rotationHandleSize: 14,\n  rotationTooltipName: 'rotationTooltip',\n  shortcuts: false,\n  singleSelect: false,\n  snapConstraint: true,\n  tooltipZ: 1100\n};\n\nvar isGroupId = function isGroupId(id) {\n  return id.startsWith(aeroelasticConfiguration.groupName);\n};\n\nvar pageChangerActions = [_pages2.duplicatePage.toString(), _pages2.addPage.toString(), _pages2.setPage.toString()];\n\n/**\n * elementToShape\n *\n * converts a `kibana-canvas` element to an `aeroelastic` shape.\n *\n * Shape: the layout algorithms need to deal with objects through their geometric properties, excluding other aspects,\n * such as what's inside the element, eg. image or scatter plot. This representation is, at its core, a transform matrix\n * that establishes a new local coordinate system https://drafts.csswg.org/css-transforms/#local-coordinate-system plus a\n * size descriptor. There are two versions of the transform matrix:\n *   - `transformMatrix` is analogous to the SVG https://drafts.csswg.org/css-transforms/#current-transformation-matrix\n *   - `localTransformMatrix` is analogous to the SVG https://drafts.csswg.org/css-transforms/#transformation-matrix\n *\n * Element: it also needs to represent the geometry, primarily because of the need to persist it in `redux` and on the\n * server, and to accept such data from the server. The redux and server representations will need to change as more general\n * projections such as 3D are added. The element also needs to maintain its content, such as an image or a plot.\n *\n * While all elements on the current page also exist as shapes, there are shapes that are not elements: annotations.\n * For example, `rotation_handle`, `border_resize_handle` and `border_connection` are modeled as shapes by the layout\n * library, simply for generality.\n */\nvar elementToShape = function elementToShape(element, i) {\n  var position = element.position;\n  var a = position.width / 2;\n  var b = position.height / 2;\n  var cx = position.left + a;\n  var cy = position.top + b;\n  var z = i; // painter's algo: latest item goes to top\n  // multiplying the angle with -1 as `transform: matrix3d` uses a left-handed coordinate system\n  var angleRadians = -position.angle / 180 * Math.PI;\n  var transformMatrix = _aeroelastic_kibana.aeroelastic.matrix.multiply(_aeroelastic_kibana.aeroelastic.matrix.translate(cx, cy, z), _aeroelastic_kibana.aeroelastic.matrix.rotateZ(angleRadians));\n  var isGroup = isGroupId(element.id);\n  var parent = element.position && element.position.parent || null; // reserved for hierarchical (tree shaped) grouping\n  return {\n    id: element.id,\n    type: isGroup ? 'group' : 'rectangleElement',\n    subtype: isGroup ? 'persistentGroup' : '',\n    parent: parent,\n    transformMatrix: transformMatrix,\n    a: a, // we currently specify half-width, half-height as it leads to\n    b: b // more regular math (like ellipsis radii rather than diameters)\n  };\n};\n\nvar shapeToElement = function shapeToElement(shape) {\n  return {\n    left: shape.transformMatrix[12] - shape.a,\n    top: shape.transformMatrix[13] - shape.b,\n    width: shape.a * 2,\n    height: shape.b * 2,\n    angle: Math.round((0, _matrix.matrixToAngle)(shape.transformMatrix) * 180 / Math.PI),\n    parent: shape.parent || null,\n    type: shape.type === 'group' ? 'group' : 'element'\n  };\n};\n\nvar updateGlobalPositions = function updateGlobalPositions(setMultiplePositions, _ref, unsortedElements) {\n  var shapes = _ref.shapes,\n      gestureEnd = _ref.gestureEnd;\n\n  var ascending = function ascending(a, b) {\n    return a.id < b.id ? -1 : 1;\n  };\n  var relevant = function relevant(s) {\n    return s.type !== 'annotation' && s.subtype !== 'adHocGroup';\n  };\n  var elements = unsortedElements.filter(relevant).sort(ascending);\n  var repositionings = shapes.filter(relevant).sort(ascending).map(function (shape, i) {\n    var element = elements[i];\n    var elemPos = element && element.position;\n    if (elemPos && gestureEnd) {\n      // get existing position information from element\n      var oldProps = {\n        left: elemPos.left,\n        top: elemPos.top,\n        width: elemPos.width,\n        height: elemPos.height,\n        angle: Math.round(elemPos.angle),\n        type: elemPos.type,\n        parent: elemPos.parent || null\n      };\n\n      // cast shape into element-like object to compare\n      var newProps = shapeToElement(shape);\n\n      if (1 / newProps.angle === -Infinity) {\n        newProps.angle = 0;\n      } // recompose.shallowEqual discerns between 0 and -0\n\n      return (0, _recompose.shallowEqual)(oldProps, newProps) ? null : { position: newProps, elementId: shape.id };\n    }\n  }).filter(_functional.identity);\n  if (repositionings.length) {\n    setMultiplePositions(repositionings);\n  }\n};\n\nvar id = function id(element) {\n  return element.id;\n};\n// check for duplication\nvar deduped = function deduped(a) {\n  return a.filter(function (d, i) {\n    return a.indexOf(d) === i;\n  });\n};\nvar idDuplicateCheck = function idDuplicateCheck(groups) {\n  if (deduped(groups.map(function (g) {\n    return g.id;\n  })).length !== groups.length) {\n    throw new Error('Duplicate element encountered');\n  }\n};\n\nvar missingParentCheck = function missingParentCheck(groups) {\n  var idMap = (0, _functional.arrayToMap)(groups.map(function (g) {\n    return g.id;\n  }));\n  groups.forEach(function (g) {\n    if (g.parent && !idMap[g.parent]) {\n      g.parent = null;\n    }\n  });\n};\n\nvar aeroelastic = exports.aeroelastic = function aeroelastic(_ref2) {\n  var dispatch = _ref2.dispatch,\n      getState = _ref2.getState;\n\n  // When aeroelastic updates an element, we need to dispatch actions to notify redux of the changes\n\n  var onChangeCallback = function onChangeCallback(_ref3) {\n    var state = _ref3.state;\n\n    var nextScene = state.currentScene;\n    if (!nextScene.gestureEnd) {\n      return;\n    } // only update redux on gesture end\n    // TODO: check for gestureEnd on element selection\n\n    // read current data out of redux\n    var page = (0, _workpad2.getSelectedPage)(getState());\n    var elements = (0, _workpad2.getNodes)(getState(), page);\n    var selectedElement = (0, _workpad2.getSelectedElement)(getState());\n\n    var shapes = nextScene.shapes;\n    var persistableGroups = shapes.filter(function (s) {\n      return s.subtype === 'persistentGroup';\n    });\n    var persistedGroups = elements.filter(function (e) {\n      return isGroupId(e.id);\n    });\n\n    idDuplicateCheck(persistableGroups);\n    idDuplicateCheck(persistedGroups);\n\n    persistableGroups.forEach(function (g) {\n      if (!persistedGroups.find(function (p) {\n        if (!p.id) {\n          throw new Error('Element has no id');\n        }\n        return p.id === g.id;\n      })) {\n        var partialElement = {\n          id: g.id,\n          filter: undefined,\n          expression: 'shape fill=\"rgba(255,255,255,0)\" | render',\n          position: _extends({}, shapeToElement(g))\n        };\n        dispatch((0, _elements.addElement)(page, partialElement));\n      }\n    });\n\n    var elementsToRemove = persistedGroups.filter(\n    // list elements for removal if they're not in the persistable set, or if there's no longer an associated element\n    // the latter of which shouldn't happen, so it's belts and braces\n    function (p) {\n      return !persistableGroups.find(function (g) {\n        return p.id === g.id;\n      }) || !elements.find(function (e) {\n        return e.position.parent === p.id;\n      });\n    });\n\n    updateGlobalPositions(function (positions) {\n      return dispatch((0, _elements.setMultiplePositions)(positions.map(function (p) {\n        return _extends({}, p, { pageId: page });\n      })));\n    }, nextScene, elements);\n\n    if (elementsToRemove.length) {\n      // remove elements for groups that were ungrouped\n      dispatch((0, _elements.removeElements)(elementsToRemove.map(function (e) {\n        return e.id;\n      }), page));\n    }\n\n    // set the selected element on the global store, if one element is selected\n    var selectedShape = nextScene.selectedPrimaryShapes[0];\n    if (nextScene.selectedShapes.length === 1 && !isGroupId(selectedShape)) {\n      if (selectedShape !== (selectedElement && selectedElement.id)) {\n        dispatch((0, _transient.selectElement)(selectedShape));\n      }\n    } else {\n      // otherwise, clear the selected element state\n      // even for groups - TODO add handling for groups, esp. persistent groups - common styling etc.\n      if (selectedElement) {\n        var shape = shapes.find(function (s) {\n          return s.id === selectedShape;\n        });\n        // don't reset if eg. we're in the middle of converting an ad hoc group into a persistent one\n        if (!shape || shape.subtype !== 'adHocGroup') {\n          dispatch((0, _transient.selectElement)(null));\n        }\n      }\n    }\n  };\n\n  var createStore = function createStore(page) {\n    return _aeroelastic_kibana.aeroelastic.createStore({\n      shapeAdditions: [],\n      primaryUpdate: null,\n      currentScene: { shapes: [] },\n      configuration: aeroelasticConfiguration\n    }, onChangeCallback, page);\n  };\n\n  var populateWithElements = function populateWithElements(page) {\n    var newShapes = (0, _workpad2.getNodes)(getState(), page).map(elementToShape)\n    // filtering to eliminate residual element of a possible group that had been deleted in Redux\n    .filter(function (d, i, a) {\n      return !isGroupId(d.id) || a.find(function (s) {\n        return s.parent === d.id;\n      });\n    });\n    idDuplicateCheck(newShapes);\n    missingParentCheck(newShapes);\n    return _aeroelastic_kibana.aeroelastic.commit(page, 'restateShapesEvent', { newShapes: newShapes }, { silent: true });\n  };\n\n  var selectShape = function selectShape(page, id) {\n    _aeroelastic_kibana.aeroelastic.commit(page, 'shapeSelect', { shapes: [id] });\n  };\n\n  var unselectShape = function unselectShape(page) {\n    _aeroelastic_kibana.aeroelastic.commit(page, 'shapeSelect', { shapes: [] });\n  };\n\n  return function (next) {\n    return function (action) {\n      // get information before the state is changed\n      var prevPage = (0, _workpad2.getSelectedPage)(getState());\n      var prevElements = (0, _workpad2.getNodes)(getState(), prevPage);\n\n      if (action.type === _workpad.setWorkpad.toString()) {\n        var pages = action.payload.pages;\n        _aeroelastic_kibana.aeroelastic.clearStores();\n        // Create the aeroelastic store, which happens once per page creation; disposed on workbook change.\n        // TODO: consider implementing a store removal upon page removal to reclaim a small amount of storage\n        pages.map(function (p) {\n          return p.id;\n        }).forEach(createStore);\n      }\n\n      if (action.type === _history.restoreHistory.toString()) {\n        _aeroelastic_kibana.aeroelastic.clearStores();\n        action.payload.workpad.pages.map(function (p) {\n          return p.id;\n        }).forEach(createStore);\n      }\n\n      if (action.type === _app.appReady.toString()) {\n        var _pages = (0, _workpad2.getPages)(getState());\n        _aeroelastic_kibana.aeroelastic.clearStores();\n        _pages.map(function (p) {\n          return p.id;\n        }).forEach(createStore);\n      }\n\n      var lastPageRemoved = false;\n      if (action.type === _pages2.removePage.toString()) {\n        var preRemoveState = getState();\n        if ((0, _workpad2.getPages)(preRemoveState).length <= 1) {\n          lastPageRemoved = true;\n        }\n\n        _aeroelastic_kibana.aeroelastic.removeStore(action.payload);\n      }\n\n      if (pageChangerActions.indexOf(action.type) >= 0) {\n        if ((0, _workpad2.getSelectedElement)(getState())) {\n          dispatch((0, _transient.selectElement)(null)); // ensure sidebar etc. get updated; will update the layout engine too\n        } else {\n          unselectShape(prevPage); // deselect persistent groups as they're not currently selections in Redux\n        }\n      }\n\n      next(action);\n\n      switch (action.type) {\n        case _app.appReady.toString():\n        case _history.restoreHistory.toString():\n        case _workpad.setWorkpad.toString():\n          // Populate the aeroelastic store, which only happens once per page creation; disposed on workbook change.\n          (0, _workpad2.getPages)(getState()).map(function (p) {\n            return p.id;\n          }).forEach(populateWithElements);\n          break;\n\n        case _pages2.addPage.toString():\n        case _pages2.duplicatePage.toString():\n          var newPage = (0, _workpad2.getSelectedPage)(getState());\n          createStore(newPage);\n          if (action.type === _pages2.duplicatePage.toString()) {\n            dispatch((0, _elements.fetchAllRenderables)());\n          }\n\n          populateWithElements(newPage);\n          break;\n\n        case _pages2.removePage.toString():\n          var postRemoveState = getState();\n          if (lastPageRemoved) {\n            var freshPage = (0, _workpad2.getSelectedPage)(postRemoveState);\n            createStore(freshPage);\n          }\n          break;\n\n        case _transient.selectElement.toString():\n          // without this condition, a mouse release anywhere will trigger it, leading to selection of whatever is\n          // underneath the pointer (maybe nothing) when the mouse is released\n          if (action.payload) {\n            selectShape(prevPage, action.payload);\n          } else {\n            unselectShape(prevPage);\n          }\n\n          break;\n\n        case _elements.removeElements.toString():\n        case _elements.addElement.toString():\n        case _elements.insertNodes.toString():\n        case _elements.elementLayer.toString():\n        case _elements.setMultiplePositions.toString():\n          var page = (0, _workpad2.getSelectedPage)(getState());\n          var elements = (0, _workpad2.getNodes)(getState(), page);\n\n          // TODO: add a better check for elements changing, including their position, ids, etc.\n          var shouldResetState = prevPage !== page || !(0, _recompose.shallowEqual)(prevElements.map(id), elements.map(id));\n          if (shouldResetState) {\n            populateWithElements(page);\n          }\n\n          if (action.type !== _elements.setMultiplePositions.toString() && action.type !== _elements.elementLayer.toString()) {\n            unselectShape(prevPage);\n          }\n\n          break;\n      }\n    };\n  };\n};",null]}