{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/index_lifecycle_management/public/store/selectors/policies.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/index_lifecycle_management/public/store/selectors/policies.js","mtime":1567631711967},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.phaseToES = exports.policyFromES = exports.phaseFromES = exports.isEmptyObject = exports.isNumber = exports.splitSizeAndUnits = exports.getPhaseData = exports.getPhase = exports.getPhases = exports.getSelectedPolicyName = exports.getSaveAsNewPolicy = exports.getPageOfPolicies = exports.getPolicyPager = exports.getTotalPolicies = exports.isPolicyListLoaded = exports.getPolicyPageSize = exports.getPolicyCurrentPage = exports.getPolicySort = exports.getPolicyFilter = exports.getSelectedOriginalPolicyName = exports.getIsSelectedPolicySet = exports.getSelectedPolicy = exports.getIsNewPolicy = exports.getPolicyByName = exports.getPolicies = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nvar _reselect = require('reselect');\n\nvar _eui = require('@elastic/eui');\n\nvar _constants = require('../constants');\n\nvar _defaults = require('../defaults');\n\nvar _services = require('../../services');\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar getPolicies = exports.getPolicies = function getPolicies(state) {\n  return state.policies.policies;\n};\nvar getPolicyByName = exports.getPolicyByName = function getPolicyByName(state, name) {\n  return getPolicies(state).find(function (policy) {\n    return policy.name === name;\n  }) || {};\n};\nvar getIsNewPolicy = exports.getIsNewPolicy = function getIsNewPolicy(state) {\n  return state.policies.selectedPolicy.isNew;\n};\nvar getSelectedPolicy = exports.getSelectedPolicy = function getSelectedPolicy(state) {\n  return state.policies.selectedPolicy;\n};\nvar getIsSelectedPolicySet = exports.getIsSelectedPolicySet = function getIsSelectedPolicySet(state) {\n  return state.policies.selectedPolicySet;\n};\nvar getSelectedOriginalPolicyName = exports.getSelectedOriginalPolicyName = function getSelectedOriginalPolicyName(state) {\n  return state.policies.originalPolicyName;\n};\nvar getPolicyFilter = exports.getPolicyFilter = function getPolicyFilter(state) {\n  return state.policies.filter;\n};\nvar getPolicySort = exports.getPolicySort = function getPolicySort(state) {\n  return state.policies.sort;\n};\nvar getPolicyCurrentPage = exports.getPolicyCurrentPage = function getPolicyCurrentPage(state) {\n  return state.policies.currentPage;\n};\nvar getPolicyPageSize = exports.getPolicyPageSize = function getPolicyPageSize(state) {\n  return state.policies.pageSize;\n};\nvar isPolicyListLoaded = exports.isPolicyListLoaded = function isPolicyListLoaded(state) {\n  return state.policies.isLoaded;\n};\n\nvar getFilteredPolicies = (0, _reselect.createSelector)(getPolicies, getPolicyFilter, function (policies, filter) {\n  return (0, _services.filterItems)(['name'], filter, policies);\n});\nvar getTotalPolicies = exports.getTotalPolicies = (0, _reselect.createSelector)(getFilteredPolicies, function (filteredPolicies) {\n  return filteredPolicies.length;\n});\nvar getPolicyPager = exports.getPolicyPager = (0, _reselect.createSelector)(getPolicyCurrentPage, getPolicyPageSize, getTotalPolicies, function (currentPage, pageSize, totalPolicies) {\n  return new _eui.Pager(totalPolicies, pageSize, currentPage);\n});\nvar getPageOfPolicies = exports.getPageOfPolicies = (0, _reselect.createSelector)(getFilteredPolicies, getPolicySort, getPolicyPager, function (filteredPolicies, sort, pager) {\n  var sortedPolicies = (0, _services.sortTable)(filteredPolicies, sort.sortField, sort.isSortAscending);\n  var firstItemIndex = pager.firstItemIndex,\n      lastItemIndex = pager.lastItemIndex;\n\n  var pagedPolicies = sortedPolicies.slice(firstItemIndex, lastItemIndex + 1);\n  return pagedPolicies;\n});\nvar getSaveAsNewPolicy = exports.getSaveAsNewPolicy = function getSaveAsNewPolicy(state) {\n  return state.policies.selectedPolicy.saveAsNew;\n};\n\nvar getSelectedPolicyName = exports.getSelectedPolicyName = function getSelectedPolicyName(state) {\n  if (!getSaveAsNewPolicy(state)) {\n    return getSelectedOriginalPolicyName(state);\n  }\n  return state.policies.selectedPolicy.name;\n};\n\nvar getPhases = exports.getPhases = function getPhases(state) {\n  return state.policies.selectedPolicy.phases;\n};\nvar getPhase = exports.getPhase = function getPhase(state, phase) {\n  return getPhases(state)[phase];\n};\nvar getPhaseData = exports.getPhaseData = function getPhaseData(state, phase, key) {\n  if (_constants.PHASE_ATTRIBUTES_THAT_ARE_NUMBERS.includes(key)) {\n    return parseInt(getPhase(state, phase)[key]);\n  }\n  return getPhase(state, phase)[key];\n};\n\nvar splitSizeAndUnits = exports.splitSizeAndUnits = function splitSizeAndUnits(field) {\n  var size = void 0;\n  var units = void 0;\n\n  var result = /(\\d+)(\\w+)/.exec(field);\n  if (result) {\n    size = parseInt(result[1]) || 0;\n    units = result[2];\n  }\n\n  return {\n    size: size,\n    units: units\n  };\n};\n\nvar isNumber = exports.isNumber = function isNumber(value) {\n  return typeof value === 'number';\n};\nvar isEmptyObject = exports.isEmptyObject = function isEmptyObject(obj) {\n  return !obj || Object.entries(obj).length === 0 && obj.constructor === Object;\n};\n\nvar phaseFromES = exports.phaseFromES = function phaseFromES(phase, phaseName, defaultEmptyPolicy) {\n  var policy = _extends({}, defaultEmptyPolicy);\n  if (!phase) {\n    return policy;\n  }\n\n  policy[_constants.PHASE_ENABLED] = true;\n\n  if (phase.min_age) {\n    if (phaseName === _constants.PHASE_WARM && phase.min_age === '0ms') {\n      policy[_constants.WARM_PHASE_ON_ROLLOVER] = true;\n    } else {\n      var _splitSizeAndUnits = splitSizeAndUnits(phase.min_age),\n          minAge = _splitSizeAndUnits.size,\n          minAgeUnits = _splitSizeAndUnits.units;\n\n      policy[_constants.PHASE_ROLLOVER_MINIMUM_AGE] = minAge;\n      policy[_constants.PHASE_ROLLOVER_MINIMUM_AGE_UNITS] = minAgeUnits;\n    }\n  }\n  if (phaseName === _constants.PHASE_WARM) {\n    policy[_constants.PHASE_SHRINK_ENABLED] = false;\n    policy[_constants.PHASE_FORCE_MERGE_ENABLED] = false;\n  }\n  if (phase.actions) {\n    var actions = phase.actions;\n\n    if (actions.rollover) {\n      var rollover = actions.rollover;\n      policy[_constants.PHASE_ROLLOVER_ENABLED] = true;\n      if (rollover.max_age) {\n        var _splitSizeAndUnits2 = splitSizeAndUnits(rollover.max_age),\n            maxAge = _splitSizeAndUnits2.size,\n            maxAgeUnits = _splitSizeAndUnits2.units;\n\n        policy[_constants.PHASE_ROLLOVER_MAX_AGE] = maxAge;\n        policy[_constants.PHASE_ROLLOVER_MAX_AGE_UNITS] = maxAgeUnits;\n      }\n      if (rollover.max_size) {\n        var _splitSizeAndUnits3 = splitSizeAndUnits(rollover.max_size),\n            maxSize = _splitSizeAndUnits3.size,\n            maxSizeUnits = _splitSizeAndUnits3.units;\n\n        policy[_constants.PHASE_ROLLOVER_MAX_SIZE_STORED] = maxSize;\n        policy[_constants.PHASE_ROLLOVER_MAX_SIZE_STORED_UNITS] = maxSizeUnits;\n      }\n      if (rollover.max_docs) {\n        policy[_constants.PHASE_ROLLOVER_MAX_DOCUMENTS] = rollover.max_docs;\n      }\n    }\n\n    if (actions.allocate) {\n      var allocate = actions.allocate;\n      if (allocate.require) {\n        Object.entries(allocate.require).forEach(function (entry) {\n          policy[_constants.PHASE_NODE_ATTRS] = entry.join(':');\n        });\n        // checking for null or undefined here\n        if (allocate.number_of_replicas != null) {\n          policy[_constants.PHASE_REPLICA_COUNT] = allocate.number_of_replicas;\n        }\n      }\n    }\n\n    if (actions.forcemerge) {\n      var forcemerge = actions.forcemerge;\n      policy[_constants.PHASE_FORCE_MERGE_ENABLED] = true;\n      policy[_constants.PHASE_FORCE_MERGE_SEGMENTS] = forcemerge.max_num_segments;\n    }\n\n    if (actions.shrink) {\n      policy[_constants.PHASE_PRIMARY_SHARD_COUNT] = actions.shrink.number_of_shards;\n    }\n    if (actions.freeze) {\n      policy[_constants.PHASE_FREEZE_ENABLED] = true;\n    }\n    if (actions.set_priority) {\n      policy[_constants.PHASE_INDEX_PRIORITY] = actions.set_priority.priority;\n    }\n  }\n  return policy;\n};\n\nvar policyFromES = exports.policyFromES = function policyFromES(policy) {\n  var _phases;\n\n  var name = policy.name,\n      phases = policy.policy.phases;\n\n  return {\n    name: name,\n    phases: (_phases = {}, _defineProperty(_phases, _constants.PHASE_HOT, phaseFromES(phases[_constants.PHASE_HOT], _constants.PHASE_HOT, _defaults.defaultEmptyHotPhase)), _defineProperty(_phases, _constants.PHASE_WARM, phaseFromES(phases[_constants.PHASE_WARM], _constants.PHASE_WARM, _defaults.defaultEmptyWarmPhase)), _defineProperty(_phases, _constants.PHASE_COLD, phaseFromES(phases[_constants.PHASE_COLD], _constants.PHASE_COLD, _defaults.defaultEmptyColdPhase)), _defineProperty(_phases, _constants.PHASE_DELETE, phaseFromES(phases[_constants.PHASE_DELETE], _constants.PHASE_DELETE, _defaults.defaultEmptyDeletePhase)), _phases),\n    isNew: false,\n    saveAsNew: false\n  };\n};\n\nvar phaseToES = exports.phaseToES = function phaseToES(phase, originalEsPhase) {\n  var esPhase = _extends({}, originalEsPhase);\n\n  if (!phase[_constants.PHASE_ENABLED]) {\n    return {};\n  }\n  if (isNumber(phase[_constants.PHASE_ROLLOVER_MINIMUM_AGE])) {\n    esPhase.min_age = '' + phase[_constants.PHASE_ROLLOVER_MINIMUM_AGE] + phase[_constants.PHASE_ROLLOVER_MINIMUM_AGE_UNITS];\n  }\n\n  esPhase.actions = esPhase.actions || {};\n\n  if (phase[_constants.PHASE_ROLLOVER_ENABLED]) {\n    esPhase.actions.rollover = {};\n\n    if (isNumber(phase[_constants.PHASE_ROLLOVER_MAX_AGE])) {\n      esPhase.actions.rollover.max_age = '' + phase[_constants.PHASE_ROLLOVER_MAX_AGE] + phase[_constants.PHASE_ROLLOVER_MAX_AGE_UNITS];\n    }\n    if (isNumber(phase[_constants.PHASE_ROLLOVER_MAX_SIZE_STORED])) {\n      esPhase.actions.rollover.max_size = '' + phase[_constants.PHASE_ROLLOVER_MAX_SIZE_STORED] + phase[_constants.PHASE_ROLLOVER_MAX_SIZE_STORED_UNITS];\n    }\n    if (isNumber(phase[_constants.PHASE_ROLLOVER_MAX_DOCUMENTS])) {\n      esPhase.actions.rollover.max_docs = phase[_constants.PHASE_ROLLOVER_MAX_DOCUMENTS];\n    }\n  } else {\n    delete esPhase.actions.rollover;\n  }\n  if (phase[_constants.PHASE_NODE_ATTRS]) {\n    var _phase$PHASE_NODE_ATT = phase[_constants.PHASE_NODE_ATTRS].split(':'),\n        _phase$PHASE_NODE_ATT2 = _slicedToArray(_phase$PHASE_NODE_ATT, 2),\n        name = _phase$PHASE_NODE_ATT2[0],\n        value = _phase$PHASE_NODE_ATT2[1];\n\n    esPhase.actions.allocate = esPhase.actions.allocate || {};\n    esPhase.actions.allocate.require = _defineProperty({}, name, value);\n  } else {\n    if (esPhase.actions.allocate) {\n      delete esPhase.actions.allocate.require;\n    }\n  }\n  if (isNumber(phase[_constants.PHASE_REPLICA_COUNT])) {\n    esPhase.actions.allocate = esPhase.actions.allocate || {};\n    esPhase.actions.allocate.number_of_replicas = phase[_constants.PHASE_REPLICA_COUNT];\n  } else {\n    if (esPhase.actions.allocate) {\n      delete esPhase.actions.allocate.number_of_replicas;\n    }\n  }\n  if (esPhase.actions.allocate && !esPhase.actions.allocate.require && !isNumber(esPhase.actions.allocate.number_of_replicas) && isEmptyObject(esPhase.actions.allocate.include) && isEmptyObject(esPhase.actions.allocate.exclude)) {\n    // remove allocate action if it does not define require or number of nodes\n    // and both include and exclude are empty objects (ES will fail to parse if we don't)\n    delete esPhase.actions.allocate;\n  }\n\n  if (phase[_constants.PHASE_FORCE_MERGE_ENABLED]) {\n    esPhase.actions.forcemerge = {\n      max_num_segments: phase[_constants.PHASE_FORCE_MERGE_SEGMENTS]\n    };\n  } else {\n    delete esPhase.actions.forcemerge;\n  }\n\n  if (phase[_constants.PHASE_SHRINK_ENABLED] && isNumber(phase[_constants.PHASE_PRIMARY_SHARD_COUNT])) {\n    esPhase.actions.shrink = {\n      number_of_shards: phase[_constants.PHASE_PRIMARY_SHARD_COUNT]\n    };\n  } else {\n    delete esPhase.actions.shrink;\n  }\n\n  if (phase[_constants.PHASE_FREEZE_ENABLED]) {\n    esPhase.actions.freeze = {};\n  } else {\n    delete esPhase.actions.freeze;\n  }\n  if (isNumber(phase[_constants.PHASE_INDEX_PRIORITY])) {\n    esPhase.actions.set_priority = {\n      priority: phase[_constants.PHASE_INDEX_PRIORITY]\n    };\n  }\n  return esPhase;\n};",null]}