{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/packages/kbn-es-query/target/kuery/ast/kuery.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/packages/kbn-es-query/target/kuery/ast/kuery.js","mtime":1567666387747},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["\"use strict\";\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }return target;\n};\n\nmodule.exports = function () {\n  \"use strict\";\n\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() {\n      this.constructor = child;\n    }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  function peg$parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n        parser = this,\n        peg$FAILED = {},\n        peg$startRuleFunctions = { start: peg$parsestart, Literal: peg$parseLiteral },\n        peg$startRuleFunction = peg$parsestart,\n        peg$c0 = function peg$c0(query, trailing) {\n      if (trailing.type === 'cursor') {\n        return _extends({}, trailing, {\n          suggestionTypes: ['conjunction']\n        });\n      }\n      if (query !== null) return query;\n      return nodeTypes.function.buildNode('is', '*', '*');\n    },\n        peg$c1 = function peg$c1(left, right) {\n      var cursor = [left, right].find(function (node) {\n        return node.type === 'cursor';\n      });\n      if (cursor) return cursor;\n      return buildFunctionNode('or', [left, right]);\n    },\n        peg$c2 = function peg$c2(left, right) {\n      var cursor = [left, right].find(function (node) {\n        return node.type === 'cursor';\n      });\n      if (cursor) return cursor;\n      return buildFunctionNode('and', [left, right]);\n    },\n        peg$c3 = function peg$c3(query) {\n      if (query.type === 'cursor') return query;\n      return buildFunctionNode('not', [query]);\n    },\n        peg$c4 = \"(\",\n        peg$c5 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n        peg$c6 = \")\",\n        peg$c7 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n        peg$c8 = function peg$c8(query, trailing) {\n      if (trailing.type === 'cursor') {\n        return _extends({}, trailing, {\n          suggestionTypes: ['conjunction']\n        });\n      }\n      return query;\n    },\n        peg$c9 = function peg$c9(field, operator, value) {\n      if (value.type === 'cursor') {\n        return _extends({}, value, {\n          suggestionTypes: ['conjunction']\n        });\n      }\n      var range = buildNamedArgNode(operator, value);\n      return buildFunctionNode('range', [field, range]);\n    },\n        peg$c10 = \":\",\n        peg$c11 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c12 = function peg$c12(field, partial) {\n      if (partial.type === 'cursor') {\n        return _extends({}, partial, {\n          fieldName: field.value,\n          suggestionTypes: ['value', 'conjunction']\n        });\n      }\n      return partial(field);\n    },\n        peg$c13 = function peg$c13(partial) {\n      if (partial.type === 'cursor') {\n        var fieldName = (\"\" + partial.prefix + partial.suffix).trim();\n        return _extends({}, partial, {\n          fieldName: fieldName,\n          suggestionTypes: ['field', 'operator', 'conjunction']\n        });\n      }\n      var field = buildLiteralNode(null);\n      return partial(field);\n    },\n        peg$c14 = function peg$c14(partial, trailing) {\n      if (trailing.type === 'cursor') {\n        return _extends({}, trailing, {\n          suggestionTypes: ['conjunction']\n        });\n      }\n      return partial;\n    },\n        peg$c15 = function peg$c15(partialLeft, partialRight) {\n      var cursor = [partialLeft, partialRight].find(function (node) {\n        return node.type === 'cursor';\n      });\n      if (cursor) {\n        return _extends({}, cursor, {\n          suggestionTypes: ['value']\n        });\n      }\n      return function (field) {\n        return buildFunctionNode('or', [partialLeft(field), partialRight(field)]);\n      };\n    },\n        peg$c16 = function peg$c16(partialLeft, partialRight) {\n      var cursor = [partialLeft, partialRight].find(function (node) {\n        return node.type === 'cursor';\n      });\n      if (cursor) {\n        return _extends({}, cursor, {\n          suggestionTypes: ['value']\n        });\n      }\n      return function (field) {\n        return buildFunctionNode('and', [partialLeft(field), partialRight(field)]);\n      };\n    },\n        peg$c17 = function peg$c17(partial) {\n      if (partial.type === 'cursor') {\n        return _extends({}, list, {\n          suggestionTypes: ['value']\n        });\n      }\n      return function (field) {\n        return buildFunctionNode('not', [partial(field)]);\n      };\n    },\n        peg$c18 = function peg$c18(value) {\n      if (value.type === 'cursor') return value;\n      var isPhrase = buildLiteralNode(true);\n      return function (field) {\n        return buildFunctionNode('is', [field, value, isPhrase]);\n      };\n    },\n        peg$c19 = function peg$c19(value) {\n      if (value.type === 'cursor') return value;\n\n      if (!allowLeadingWildcards && value.type === 'wildcard' && nodeTypes.wildcard.hasLeadingWildcard(value)) {\n        error('Leading wildcards are disabled. See query:allowLeadingWildcards in Advanced Settings.');\n      }\n\n      var isPhrase = buildLiteralNode(false);\n      return function (field) {\n        return buildFunctionNode('is', [field, value, isPhrase]);\n      };\n    },\n        peg$c20 = \"or\",\n        peg$c21 = { type: \"literal\", value: \"or\", description: \"\\\"or\\\"\" },\n        peg$c22 = \"and\",\n        peg$c23 = { type: \"literal\", value: \"and\", description: \"\\\"and\\\"\" },\n        peg$c24 = \"not\",\n        peg$c25 = { type: \"literal\", value: \"not\", description: \"\\\"not\\\"\" },\n        peg$c26 = \"\\\"\",\n        peg$c27 = { type: \"literal\", value: \"\\\"\", description: \"\\\"\\\\\\\"\\\"\" },\n        peg$c28 = function peg$c28(prefix, cursor, suffix) {\n      var _location = location(),\n          start = _location.start,\n          end = _location.end;\n\n      return {\n        type: 'cursor',\n        start: start.offset,\n        end: end.offset - cursor.length,\n        prefix: prefix.join(''),\n        suffix: suffix.join(''),\n        text: text().replace(cursor, '')\n      };\n    },\n        peg$c29 = function peg$c29(chars) {\n      return buildLiteralNode(chars.join(''));\n    },\n        peg$c30 = \"\\\\\",\n        peg$c31 = { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n        peg$c32 = /^[\\\\\"]/,\n        peg$c33 = { type: \"class\", value: \"[\\\\\\\\\\\"]\", description: \"[\\\\\\\\\\\"]\" },\n        peg$c34 = function peg$c34(char) {\n      return char;\n    },\n        peg$c35 = /^[^\"]/,\n        peg$c36 = { type: \"class\", value: \"[^\\\"]\", description: \"[^\\\"]\" },\n        peg$c37 = function peg$c37(chars) {\n      var sequence = chars.join('').trim();\n      if (sequence === 'null') return buildLiteralNode(null);\n      if (sequence === 'true') return buildLiteralNode(true);\n      if (sequence === 'false') return buildLiteralNode(false);\n      if (chars.includes(wildcardSymbol)) return buildWildcardNode(sequence);\n      var number = Number(sequence);\n      var value = isNaN(number) ? sequence : number;\n      return buildLiteralNode(value);\n    },\n        peg$c38 = { type: \"any\", description: \"any character\" },\n        peg$c39 = \"*\",\n        peg$c40 = { type: \"literal\", value: \"*\", description: \"\\\"*\\\"\" },\n        peg$c41 = function peg$c41() {\n      return wildcardSymbol;\n    },\n        peg$c42 = \"\\\\t\",\n        peg$c43 = { type: \"literal\", value: \"\\\\t\", description: \"\\\"\\\\\\\\t\\\"\" },\n        peg$c44 = function peg$c44() {\n      return '\\t';\n    },\n        peg$c45 = \"\\\\r\",\n        peg$c46 = { type: \"literal\", value: \"\\\\r\", description: \"\\\"\\\\\\\\r\\\"\" },\n        peg$c47 = function peg$c47() {\n      return '\\r';\n    },\n        peg$c48 = \"\\\\n\",\n        peg$c49 = { type: \"literal\", value: \"\\\\n\", description: \"\\\"\\\\\\\\n\\\"\" },\n        peg$c50 = function peg$c50() {\n      return '\\n';\n    },\n        peg$c51 = function peg$c51(keyword) {\n      return keyword;\n    },\n        peg$c52 = /^[\\\\():<>\"*]/,\n        peg$c53 = { type: \"class\", value: \"[\\\\\\\\():<>\\\"*]\", description: \"[\\\\\\\\():<>\\\"*]\" },\n        peg$c54 = \"<=\",\n        peg$c55 = { type: \"literal\", value: \"<=\", description: \"\\\"<=\\\"\" },\n        peg$c56 = function peg$c56() {\n      return 'lte';\n    },\n        peg$c57 = \">=\",\n        peg$c58 = { type: \"literal\", value: \">=\", description: \"\\\">=\\\"\" },\n        peg$c59 = function peg$c59() {\n      return 'gte';\n    },\n        peg$c60 = \"<\",\n        peg$c61 = { type: \"literal\", value: \"<\", description: \"\\\"<\\\"\" },\n        peg$c62 = function peg$c62() {\n      return 'lt';\n    },\n        peg$c63 = \">\",\n        peg$c64 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n        peg$c65 = function peg$c65() {\n      return 'gt';\n    },\n        peg$c66 = /^[ \\t\\r\\n]/,\n        peg$c67 = { type: \"class\", value: \"[\\\\ \\\\t\\\\r\\\\n]\", description: \"[\\\\ \\\\t\\\\r\\\\n]\" },\n        peg$c68 = function peg$c68() {\n      return parseCursor;\n    },\n        peg$c69 = \"@kuery-cursor@\",\n        peg$c70 = { type: \"literal\", value: \"@kuery-cursor@\", description: \"\\\"@kuery-cursor@\\\"\" },\n        peg$c71 = function peg$c71() {\n      return cursorSymbol;\n    },\n        peg$currPos = 0,\n        peg$savedPos = 0,\n        peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }],\n        peg$maxFailPos = 0,\n        peg$maxFailExpected = [],\n        peg$silentFails = 0,\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description) {\n      throw peg$buildException(null, [{ type: \"other\", description: description }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos],\n          p,\n          ch;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column,\n          seenCR: details.seenCR\n        };\n\n        while (p < pos) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) {\n              details.line++;\n            }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function (a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) {\n            return ch.charCodeAt(0).toString(16).toUpperCase();\n          }\n\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\x08/g, '\\\\b').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\f/g, '\\\\f').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x80-\\xFF]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          }).replace(/[\\u0100-\\u0FFF]/g, function (ch) {\n            return \"\\\\u0\" + hex(ch);\n          }).replace(/[\\u1000-\\uFFFF]/g, function (ch) {\n            return \"\\\\u\" + hex(ch);\n          });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc,\n            foundDesc,\n            i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(\", \") + \" or \" + expectedDescs[expected.length - 1] : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);\n    }\n\n    function peg$parsestart() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseSpace();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseSpace();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseOrQuery();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseOptionalSpace();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseOrQuery() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseAndQuery();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseOr();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseOrQuery();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c1(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseAndQuery();\n      }\n\n      return s0;\n    }\n\n    function peg$parseAndQuery() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseNotQuery();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseAnd();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseAndQuery();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c2(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseNotQuery();\n      }\n\n      return s0;\n    }\n\n    function peg$parseNotQuery() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parseNot();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseSubQuery();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c3(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseSubQuery();\n      }\n\n      return s0;\n    }\n\n    function peg$parseSubQuery() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c4;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c5);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseSpace();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseSpace();\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseOrQuery();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseOptionalSpace();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c6;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c7);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c8(s3, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseExpression();\n      }\n\n      return s0;\n    }\n\n    function peg$parseExpression() {\n      var s0;\n\n      s0 = peg$parseFieldRangeExpression();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseFieldValueExpression();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseValueExpression();\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseFieldRangeExpression() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parseLiteral();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseSpace();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseSpace();\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseRangeOperator();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parseSpace();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parseSpace();\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseQuotedString();\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseUnquotedLiteral();\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c9(s1, s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseFieldValueExpression() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parseLiteral();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseSpace();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseSpace();\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s3 = peg$c10;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c11);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parseSpace();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parseSpace();\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseListOfValues();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c12(s1, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseValueExpression() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      s1 = peg$parseValue();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c13(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseListOfValues() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c4;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c5);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseSpace();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseSpace();\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseOrListOfValues();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseOptionalSpace();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c6;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c7);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c14(s3, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseValue();\n      }\n\n      return s0;\n    }\n\n    function peg$parseOrListOfValues() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseAndListOfValues();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseOr();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseOrListOfValues();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c15(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseAndListOfValues();\n      }\n\n      return s0;\n    }\n\n    function peg$parseAndListOfValues() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseNotListOfValues();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseAnd();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseAndListOfValues();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c16(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseNotListOfValues();\n      }\n\n      return s0;\n    }\n\n    function peg$parseNotListOfValues() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parseNot();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseListOfValues();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c17(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseListOfValues();\n      }\n\n      return s0;\n    }\n\n    function peg$parseValue() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      s1 = peg$parseQuotedString();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c18(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseUnquotedLiteral();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c19(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseOr() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseSpace();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseSpace();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c20) {\n          s2 = input.substr(peg$currPos, 2);\n          peg$currPos += 2;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c21);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseSpace();\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseSpace();\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseAnd() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseSpace();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseSpace();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c22) {\n          s2 = input.substr(peg$currPos, 3);\n          peg$currPos += 3;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c23);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseSpace();\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseSpace();\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseNot() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c24) {\n        s1 = input.substr(peg$currPos, 3);\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c25);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseSpace();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseSpace();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseLiteral() {\n      var s0;\n\n      s0 = peg$parseQuotedString();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseUnquotedLiteral();\n      }\n\n      return s0;\n    }\n\n    function peg$parseQuotedString() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c26;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c27);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseQuotedCharacter();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseQuotedCharacter();\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseCursor();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parseQuotedCharacter();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parseQuotedCharacter();\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 34) {\n                s5 = peg$c26;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c27);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c28(s2, s3, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s1 = peg$c26;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c27);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parseQuotedCharacter();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseQuotedCharacter();\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 34) {\n              s3 = peg$c26;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c27);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c29(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseQuotedCharacter() {\n      var s0, s1, s2;\n\n      s0 = peg$parseEscapedWhitespace();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s1 = peg$c30;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c31);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          if (peg$c32.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c33);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c34(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$currPos;\n          peg$silentFails++;\n          s2 = peg$parseCursor();\n          peg$silentFails--;\n          if (s2 === peg$FAILED) {\n            s1 = void 0;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            if (peg$c35.test(input.charAt(peg$currPos))) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c36);\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c34(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseUnquotedLiteral() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseUnquotedCharacter();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseUnquotedCharacter();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseCursor();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseUnquotedCharacter();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseUnquotedCharacter();\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c28(s1, s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseUnquotedCharacter();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parseUnquotedCharacter();\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c37(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseUnquotedCharacter() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$parseEscapedWhitespace();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseEscapedSpecialCharacter();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseEscapedKeyword();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseWildcard();\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$currPos;\n              peg$silentFails++;\n              s2 = peg$parseSpecialCharacter();\n              peg$silentFails--;\n              if (s2 === peg$FAILED) {\n                s1 = void 0;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = peg$currPos;\n                peg$silentFails++;\n                s3 = peg$parseKeyword();\n                peg$silentFails--;\n                if (s3 === peg$FAILED) {\n                  s2 = void 0;\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$currPos;\n                  peg$silentFails++;\n                  s4 = peg$parseCursor();\n                  peg$silentFails--;\n                  if (s4 === peg$FAILED) {\n                    s3 = void 0;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                  if (s3 !== peg$FAILED) {\n                    if (input.length > peg$currPos) {\n                      s4 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s4 = peg$FAILED;\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$c38);\n                      }\n                    }\n                    if (s4 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c34(s4);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseWildcard() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s1 = peg$c39;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c40);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c41();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseOptionalSpace() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseSpace();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseSpace();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseCursor();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseSpace();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseSpace();\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c28(s1, s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = [];\n        s1 = peg$parseSpace();\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          s1 = peg$parseSpace();\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseEscapedWhitespace() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c42) {\n        s1 = peg$c42;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c43);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c44();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c45) {\n          s1 = peg$c45;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c46);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c47();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 2) === peg$c48) {\n            s1 = peg$c48;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c49);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c50();\n          }\n          s0 = s1;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseEscapedSpecialCharacter() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c30;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c31);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseSpecialCharacter();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c34(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseEscapedKeyword() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c30;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c31);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c20) {\n          s2 = input.substr(peg$currPos, 2);\n          peg$currPos += 2;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c21);\n          }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c22) {\n            s2 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c23);\n            }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c24) {\n              s2 = input.substr(peg$currPos, 3);\n              peg$currPos += 3;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c25);\n              }\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c51(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseKeyword() {\n      var s0;\n\n      s0 = peg$parseOr();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseAnd();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseNot();\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseSpecialCharacter() {\n      var s0;\n\n      if (peg$c52.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c53);\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseRangeOperator() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c54) {\n        s1 = peg$c54;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c55);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c56();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c57) {\n          s1 = peg$c57;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c58);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c59();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 60) {\n            s1 = peg$c60;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c61);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c62();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 62) {\n              s1 = peg$c63;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c64);\n              }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c65();\n            }\n            s0 = s1;\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseSpace() {\n      var s0;\n\n      if (peg$c66.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c67);\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseCursor() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      peg$savedPos = peg$currPos;\n      s1 = peg$c68();\n      if (s1) {\n        s1 = void 0;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 14) === peg$c69) {\n          s2 = peg$c69;\n          peg$currPos += 14;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c70);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c71();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    var parseCursor = options.parseCursor,\n        cursorSymbol = options.cursorSymbol,\n        _options$allowLeading = options.allowLeadingWildcards,\n        allowLeadingWildcards = _options$allowLeading === undefined ? true : _options$allowLeading,\n        nodeTypes = options.helpers.nodeTypes;\n\n    var buildFunctionNode = nodeTypes.function.buildNodeWithArgumentNodes;\n    var buildLiteralNode = nodeTypes.literal.buildNode;\n    var buildWildcardNode = nodeTypes.wildcard.buildNode;\n    var buildNamedArgNode = nodeTypes.namedArg.buildNode;\n    var wildcardSymbol = nodeTypes.wildcard.wildcardSymbol;\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();",null]}