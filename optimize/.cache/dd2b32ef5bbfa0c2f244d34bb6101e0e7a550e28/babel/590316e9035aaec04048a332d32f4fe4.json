{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/shared/layers/tile_layer.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/shared/layers/tile_layer.js","mtime":1567631712022},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TileLayer = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _layer = require('./layer');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _eui = require('@elastic/eui');\n\nvar _tile_style = require('../layers/styles/tile_style');\n\nvar _constants = require('../../../common/constants');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar TileLayer = exports.TileLayer = function (_AbstractLayer) {\n  _inherits(TileLayer, _AbstractLayer);\n\n  function TileLayer(_ref) {\n    var layerDescriptor = _ref.layerDescriptor,\n        source = _ref.source,\n        style = _ref.style;\n\n    _classCallCheck(this, TileLayer);\n\n    var _this = _possibleConstructorReturn(this, (TileLayer.__proto__ || Object.getPrototypeOf(TileLayer)).call(this, { layerDescriptor: layerDescriptor, source: source, style: style }));\n\n    if (!style) {\n      _this._style = new _tile_style.TileStyle();\n    }\n    return _this;\n  }\n\n  _createClass(TileLayer, [{\n    key: 'syncData',\n    value: function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref2) {\n        var startLoading = _ref2.startLoading,\n            stopLoading = _ref2.stopLoading,\n            onLoadError = _ref2.onLoadError,\n            dataFilters = _ref2.dataFilters;\n        var sourceDataRequest, requestToken, url;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!this.isVisible() || !this.showAtZoomLevel(dataFilters.zoom))) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt('return');\n\n              case 2:\n                sourceDataRequest = this.getSourceDataRequest();\n\n                if (!sourceDataRequest) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt('return');\n\n              case 5:\n                requestToken = Symbol('layer-source-refresh:' + this.getId() + ' - source');\n\n                startLoading(_constants.SOURCE_DATA_ID_ORIGIN, requestToken, dataFilters);\n                _context.prev = 7;\n                _context.next = 10;\n                return this._source.getUrlTemplate();\n\n              case 10:\n                url = _context.sent;\n\n                stopLoading(_constants.SOURCE_DATA_ID_ORIGIN, requestToken, url, {});\n                _context.next = 17;\n                break;\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context['catch'](7);\n\n                onLoadError(_constants.SOURCE_DATA_ID_ORIGIN, requestToken, _context.t0.message);\n\n              case 17:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 14]]);\n      }));\n\n      function syncData(_x) {\n        return _ref3.apply(this, arguments);\n      }\n\n      return syncData;\n    }()\n  }, {\n    key: 'syncLayerWithMB',\n    value: function syncLayerWithMB(mbMap) {\n\n      var source = mbMap.getSource(this.getId());\n      var mbLayerId = this.getId() + '_raster';\n\n      if (!source) {\n        var sourceDataRequest = this.getSourceDataRequest();\n        if (!sourceDataRequest) {\n          //this is possible if the layer was invisible at startup.\n          //the actions will not perform any data=syncing as an optimization when a layer is invisible\n          //when turning the layer back into visible, it's possible the url has not been resovled yet.\n          return;\n        }\n        var url = sourceDataRequest.getData();\n        if (!url) {\n          return;\n        }\n\n        var sourceId = this.getId();\n        mbMap.addSource(sourceId, {\n          type: 'raster',\n          tiles: [url],\n          tileSize: 256,\n          scheme: 'xyz'\n        });\n\n        mbMap.addLayer({\n          id: mbLayerId,\n          type: 'raster',\n          source: sourceId,\n          minzoom: this._descriptor.minZoom,\n          maxzoom: this._descriptor.maxZoom\n        });\n      }\n\n      this._setTileLayerProperties(mbMap, mbLayerId);\n    }\n  }, {\n    key: '_setTileLayerProperties',\n    value: function _setTileLayerProperties(mbMap, mbLayerId) {\n      mbMap.setLayoutProperty(mbLayerId, 'visibility', this.isVisible() ? 'visible' : 'none');\n      mbMap.setLayerZoomRange(mbLayerId, this._descriptor.minZoom, this._descriptor.maxZoom);\n      mbMap.setPaintProperty(mbLayerId, 'raster-opacity', this.getAlpha());\n    }\n  }, {\n    key: 'getLayerTypeIconName',\n    value: function getLayerTypeIconName() {\n      return 'grid';\n    }\n  }, {\n    key: 'getIcon',\n    value: function getIcon() {\n      return _react2.default.createElement(_eui.EuiIcon, {\n        type: this.getLayerTypeIconName()\n      });\n    }\n  }, {\n    key: 'isLayerLoading',\n    value: function isLayerLoading() {\n      return false;\n    }\n  }], [{\n    key: 'createDescriptor',\n    value: function createDescriptor(options) {\n      var tileLayerDescriptor = _get(TileLayer.__proto__ || Object.getPrototypeOf(TileLayer), 'createDescriptor', this).call(this, options);\n      tileLayerDescriptor.type = TileLayer.type;\n      tileLayerDescriptor.alpha = _lodash2.default.get(options, 'alpha', 1);\n      tileLayerDescriptor.style = _tile_style.TileStyle.createDescriptor(tileLayerDescriptor.style.properties);\n      return tileLayerDescriptor;\n    }\n  }]);\n\n  return TileLayer;\n}(_layer.AbstractLayer);\n\nTileLayer.type = \"TILE\";",null]}