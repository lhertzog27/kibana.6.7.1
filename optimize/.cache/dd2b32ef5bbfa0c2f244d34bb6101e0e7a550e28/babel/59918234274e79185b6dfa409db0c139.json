{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/explorer/explorer_charts/explorer_chart_single_metric.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/explorer/explorer_charts/explorer_chart_single_metric.js","mtime":1567631712041},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExplorerChartSingleMetric = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _class, _temp; /*\n                    * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                    * or more contributor license agreements. Licensed under the Elastic License;\n                    * you may not use this file except in compliance with the Elastic License.\n                    */\n\n/*\n * React component for rendering a chart of anomalies in the raw data in\n * the Machine Learning Explorer dashboard.\n */\n\n// don't use something like plugins/ml/../common\n// because it won't work with the jest tests\n\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _date_utils = require('../../util/date_utils');\n\nvar _format_value = require('../../formatters/format_value');\n\nvar _anomaly_utils = require('../../../common/util/anomaly_utils');\n\nvar _chart_utils = require('../../util/chart_utils');\n\nvar _time_buckets = require('ui/time_buckets');\n\nvar _loading_indicator = require('../../components/loading_indicator/loading_indicator');\n\nvar _string_utils = require('../../util/string_utils');\n\nvar _field_format_service = require('../../services/field_format_service');\n\nvar _chart_tooltip_service = require('../../components/chart_tooltip/chart_tooltip_service');\n\nvar _select_severity = require('../../components/controls/select_severity/select_severity');\n\nvar _react3 = require('@kbn/i18n/react');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CONTENT_WRAPPER_HEIGHT = 215;\nvar CONTENT_WRAPPER_CLASS = 'ml-explorer-chart-content-wrapper';\n\nvar ExplorerChartSingleMetric = exports.ExplorerChartSingleMetric = (0, _react3.injectI18n)((_temp = _class = function (_React$Component) {\n  _inherits(ExplorerChartSingleMetric, _React$Component);\n\n  function ExplorerChartSingleMetric() {\n    _classCallCheck(this, ExplorerChartSingleMetric);\n\n    return _possibleConstructorReturn(this, (ExplorerChartSingleMetric.__proto__ || Object.getPrototypeOf(ExplorerChartSingleMetric)).apply(this, arguments));\n  }\n\n  _createClass(ExplorerChartSingleMetric, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.renderChart();\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.renderChart();\n    }\n  }, {\n    key: 'renderChart',\n    value: function renderChart() {\n      var _props = this.props,\n          tooManyBuckets = _props.tooManyBuckets,\n          intl = _props.intl;\n\n\n      var element = this.rootNode;\n      var config = this.props.seriesConfig;\n\n      if (typeof config === 'undefined' || Array.isArray(config.chartData) === false) {\n        // just return so the empty directive renders without an error later on\n        return;\n      }\n\n      var fieldFormat = _field_format_service.mlFieldFormatService.getFieldFormat(config.jobId, config.detectorIndex);\n\n      var vizWidth = 0;\n      var chartHeight = 170;\n\n      // Left margin is adjusted later for longest y-axis label.\n      var margin = { top: 10, right: 0, bottom: 30, left: 60 };\n\n      var lineChartXScale = null;\n      var lineChartYScale = null;\n      var lineChartGroup = void 0;\n      var lineChartValuesLine = null;\n\n      init(config.chartLimits);\n      drawLineChart(config.chartData);\n\n      function init(chartLimits) {\n        var $el = (0, _jquery2.default)('.ml-explorer-chart');\n\n        // Clear any existing elements from the visualization,\n        // then build the svg elements for the chart.\n        var chartElement = _d2.default.select(element).select('.' + CONTENT_WRAPPER_CLASS);\n        chartElement.select('svg').remove();\n\n        var svgWidth = $el.width();\n        var svgHeight = chartHeight + margin.top + margin.bottom;\n\n        var svg = chartElement.append('svg').classed('ml-explorer-chart-svg', true).attr('width', svgWidth).attr('height', svgHeight);\n\n        // Set the size of the left margin according to the width of the largest y axis tick label.\n        lineChartYScale = _d2.default.scale.linear().range([chartHeight, 0]).domain([chartLimits.min, chartLimits.max]).nice();\n\n        var yAxis = _d2.default.svg.axis().scale(lineChartYScale).orient('left').innerTickSize(0).outerTickSize(0).tickPadding(10);\n\n        var maxYAxisLabelWidth = 0;\n        var tempLabelText = svg.append('g').attr('class', 'temp-axis-label tick');\n        tempLabelText.selectAll('text.temp.axis').data(lineChartYScale.ticks()).enter().append('text').text(function (d) {\n          if (fieldFormat !== undefined) {\n            return fieldFormat.convert(d, 'text');\n          } else {\n            return lineChartYScale.tickFormat()(d);\n          }\n        })\n        // Don't use an arrow function since we need access to `this`.\n        .each(function () {\n          maxYAxisLabelWidth = Math.max(this.getBBox().width + yAxis.tickPadding(), maxYAxisLabelWidth);\n        }).remove();\n        _d2.default.select('.temp-axis-label').remove();\n\n        margin.left = Math.max(maxYAxisLabelWidth, 40);\n        vizWidth = svgWidth - margin.left - margin.right;\n\n        // Set the x axis domain to match the request plot range.\n        // This ensures ranges on different charts will match, even when there aren't\n        // data points across the full range, and the selected anomalous region is centred.\n        lineChartXScale = _d2.default.time.scale().range([0, vizWidth]).domain([config.plotEarliest, config.plotLatest]);\n\n        lineChartValuesLine = _d2.default.svg.line().x(function (d) {\n          return lineChartXScale(d.date);\n        }).y(function (d) {\n          return lineChartYScale(d.value);\n        }).defined(function (d) {\n          return d.value !== null;\n        });\n\n        lineChartGroup = svg.append('g').attr('class', 'line-chart').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n      }\n\n      function drawLineChart(data) {\n        // Add border round plot area.\n        lineChartGroup.append('rect').attr('x', 0).attr('y', 0).attr('height', chartHeight).attr('width', vizWidth).style('stroke', '#cccccc').style('fill', 'none').style('stroke-width', 1);\n\n        drawLineChartAxes();\n        drawLineChartHighlightedSpan();\n        drawLineChartPaths(data);\n        (0, _chart_utils.drawLineChartDots)(data, lineChartGroup, lineChartValuesLine);\n        drawLineChartMarkers(data);\n      }\n\n      function drawLineChartAxes() {\n        // Get the scaled date format to use for x axis tick labels.\n        var timeBuckets = new _time_buckets.TimeBuckets();\n        var bounds = { min: (0, _moment2.default)(config.plotEarliest), max: (0, _moment2.default)(config.plotLatest) };\n        timeBuckets.setBounds(bounds);\n        timeBuckets.setInterval('auto');\n        var xAxisTickFormat = timeBuckets.getScaledDateFormat();\n\n        var tickValuesStart = Math.max(config.selectedEarliest, config.plotEarliest);\n        // +1 ms to account for the ms that was substracted for query aggregations.\n        var interval = config.selectedLatest - config.selectedEarliest + 1;\n        var tickValues = (0, _chart_utils.getTickValues)(tickValuesStart, interval, config.plotEarliest, config.plotLatest);\n\n        var xAxis = _d2.default.svg.axis().scale(lineChartXScale).orient('bottom').innerTickSize(-chartHeight).outerTickSize(0).tickPadding(10).tickFormat(function (d) {\n          return (0, _moment2.default)(d).format(xAxisTickFormat);\n        });\n\n        // With tooManyBuckets the chart would end up with no x-axis labels\n        // because the ticks are based on the span of the emphasis section,\n        // and the highlighted area spans the whole chart.\n        if (tooManyBuckets === false) {\n          xAxis.tickValues(tickValues);\n        } else {\n          xAxis.ticks((0, _chart_utils.numTicksForDateFormat)(vizWidth, xAxisTickFormat));\n        }\n\n        var yAxis = _d2.default.svg.axis().scale(lineChartYScale).orient('left').innerTickSize(0).outerTickSize(0).tickPadding(10);\n\n        if (fieldFormat !== undefined) {\n          yAxis.tickFormat(function (d) {\n            return fieldFormat.convert(d, 'text');\n          });\n        }\n\n        var axes = lineChartGroup.append('g');\n\n        var gAxis = axes.append('g').attr('class', 'x axis').attr('transform', 'translate(0,' + chartHeight + ')').call(xAxis);\n\n        axes.append('g').attr('class', 'y axis').call(yAxis);\n\n        if (tooManyBuckets === false) {\n          (0, _chart_utils.removeLabelOverlap)(gAxis, tickValuesStart, interval, vizWidth);\n        }\n      }\n\n      function drawLineChartHighlightedSpan() {\n        // Draws a rectangle which highlights the time span that has been selected for view.\n        // Note depending on the overall time range and the bucket span, the selected time\n        // span may be longer than the range actually being plotted.\n        var rectStart = Math.max(config.selectedEarliest, config.plotEarliest);\n        var rectEnd = Math.min(config.selectedLatest, config.plotLatest);\n        var rectWidth = lineChartXScale(rectEnd) - lineChartXScale(rectStart);\n\n        lineChartGroup.append('rect').attr('class', 'selected-interval').attr('x', lineChartXScale(new Date(rectStart)) + 2).attr('y', 2).attr('rx', 3).attr('ry', 3).attr('width', rectWidth - 4).attr('height', chartHeight - 4);\n      }\n\n      function drawLineChartPaths(data) {\n        lineChartGroup.append('path').attr('class', 'values-line').attr('d', lineChartValuesLine(data));\n      }\n\n      function drawLineChartMarkers(data) {\n        // Render circle markers for the points.\n        // These are used for displaying tooltips on mouseover.\n        // Don't render dots where value=null (data gaps, with no anomalies)\n        // or for multi-bucket anomalies.\n        var dots = lineChartGroup.append('g').attr('class', 'chart-markers').selectAll('.metric-value').data(data.filter(function (d) {\n          return (d.value !== null || typeof d.anomalyScore === 'number') && !(0, _chart_utils.showMultiBucketAnomalyMarker)(d);\n        }));\n\n        // Remove dots that are no longer needed i.e. if number of chart points has decreased.\n        dots.exit().remove();\n        // Create any new dots that are needed i.e. if number of chart points has increased.\n        dots.enter().append('circle').attr('r', _chart_utils.LINE_CHART_ANOMALY_RADIUS)\n        // Don't use an arrow function since we need access to `this`.\n        .on('mouseover', function (d) {\n          showLineChartTooltip(d, this);\n        }).on('mouseout', function () {\n          return _chart_tooltip_service.mlChartTooltipService.hide();\n        });\n\n        // Update all dots to new positions.\n        var threshold = _select_severity.mlSelectSeverityService.initiliazed ? _select_severity.mlSelectSeverityService.state.get('threshold') : _select_severity.SEVERITY_OPTIONS[0];\n        dots.attr('cx', function (d) {\n          return lineChartXScale(d.date);\n        }).attr('cy', function (d) {\n          return lineChartYScale(d.value);\n        }).attr('class', function (d) {\n          var markerClass = 'metric-value';\n          if (_lodash2.default.has(d, 'anomalyScore') && Number(d.anomalyScore) >= threshold.val) {\n            markerClass += ' anomaly-marker ' + (0, _anomaly_utils.getSeverityWithLow)(d.anomalyScore).id;\n          }\n          return markerClass;\n        });\n\n        // Render cross symbols for any multi-bucket anomalies.\n        var multiBucketMarkers = lineChartGroup.select('.chart-markers').selectAll('.multi-bucket').data(data.filter(function (d) {\n          return d.anomalyScore !== null && (0, _chart_utils.showMultiBucketAnomalyMarker)(d) === true;\n        }));\n\n        // Remove multi-bucket markers that are no longer needed\n        multiBucketMarkers.exit().remove();\n\n        // Append the multi-bucket markers and position on chart.\n        multiBucketMarkers.enter().append('path').attr('d', _d2.default.svg.symbol().size(_chart_utils.MULTI_BUCKET_SYMBOL_SIZE).type('cross')).attr('transform', function (d) {\n          return 'translate(' + lineChartXScale(d.date) + ', ' + lineChartYScale(d.value) + ')';\n        }).attr('class', function (d) {\n          return 'anomaly-marker multi-bucket ' + (0, _anomaly_utils.getSeverityWithLow)(d.anomalyScore).id;\n        })\n        // Don't use an arrow function since we need access to `this`.\n        .on('mouseover', function (d) {\n          showLineChartTooltip(d, this);\n        }).on('mouseout', function () {\n          return _chart_tooltip_service.mlChartTooltipService.hide();\n        });\n\n        // Add rectangular markers for any scheduled events.\n        var scheduledEventMarkers = lineChartGroup.select('.chart-markers').selectAll('.scheduled-event-marker').data(data.filter(function (d) {\n          return d.scheduledEvents !== undefined;\n        }));\n\n        // Remove markers that are no longer needed i.e. if number of chart points has decreased.\n        scheduledEventMarkers.exit().remove();\n        // Create any new markers that are needed i.e. if number of chart points has increased.\n        scheduledEventMarkers.enter().append('rect').attr('width', _chart_utils.LINE_CHART_ANOMALY_RADIUS * 2).attr('height', _chart_utils.SCHEDULED_EVENT_SYMBOL_HEIGHT).attr('class', 'scheduled-event-marker').attr('rx', 1).attr('ry', 1);\n\n        // Update all markers to new positions.\n        scheduledEventMarkers.attr('x', function (d) {\n          return lineChartXScale(d.date) - _chart_utils.LINE_CHART_ANOMALY_RADIUS;\n        }).attr('y', function (d) {\n          return lineChartYScale(d.value) - _chart_utils.SCHEDULED_EVENT_SYMBOL_HEIGHT / 2;\n        });\n      }\n\n      function showLineChartTooltip(marker, circle) {\n        // Show the time and metric values in the tooltip.\n        // Uses date, value, upper, lower and anomalyScore (optional) marker properties.\n        var formattedDate = (0, _date_utils.formatHumanReadableDateTime)(marker.date);\n        var contents = formattedDate + '<br/><hr/>';\n\n        if (_lodash2.default.has(marker, 'anomalyScore')) {\n          var score = parseInt(marker.anomalyScore);\n          var displayScore = score > 0 ? score : '< 1';\n          contents += intl.formatMessage({\n            id: 'xpack.ml.explorer.singleMetricChart.anomalyScoreLabel',\n            defaultMessage: 'anomaly score: {displayScore}'\n          }, { displayScore: displayScore });\n\n          if ((0, _chart_utils.showMultiBucketAnomalyTooltip)(marker) === true) {\n            contents += intl.formatMessage({\n              id: 'xpack.ml.explorer.singleMetricChart.multiBucketImpactLabel',\n              defaultMessage: '{br}multi-bucket impact: {multiBucketImpactLabel}'\n            }, {\n              br: '<br />',\n              multiBucketImpactLabel: (0, _anomaly_utils.getMultiBucketImpactLabel)(marker.multiBucketImpact)\n            });\n          }\n\n          // Show actual/typical when available except for rare detectors.\n          // Rare detectors always have 1 as actual and the probability as typical.\n          // Exposing those values in the tooltip with actual/typical labels might irritate users.\n          if (_lodash2.default.has(marker, 'actual') && config.functionDescription !== 'rare') {\n            // Display the record actual in preference to the chart value, which may be\n            // different depending on the aggregation interval of the chart.\n            contents += intl.formatMessage({\n              id: 'xpack.ml.explorer.singleMetricChart.actualLabel',\n              defaultMessage: '{br}actual: {actualValue}'\n            }, {\n              br: '<br />',\n              actualValue: (0, _format_value.formatValue)(marker.actual, config.functionDescription, fieldFormat)\n            });\n            contents += intl.formatMessage({\n              id: 'xpack.ml.explorer.singleMetricChart.typicalLabel',\n              defaultMessage: '{br}typical: {typicalValue}'\n            }, {\n              br: '<br />',\n              typicalValue: (0, _format_value.formatValue)(marker.typical, config.functionDescription, fieldFormat)\n            });\n          } else {\n            contents += intl.formatMessage({\n              id: 'xpack.ml.explorer.singleMetricChart.valueLabel',\n              defaultMessage: '{br}value: {value}'\n            }, {\n              br: '<br />',\n              value: (0, _format_value.formatValue)(marker.value, config.functionDescription, fieldFormat)\n            });\n            if (_lodash2.default.has(marker, 'byFieldName') && _lodash2.default.has(marker, 'numberOfCauses')) {\n              var numberOfCauses = marker.numberOfCauses;\n              var byFieldName = (0, _string_utils.mlEscape)(marker.byFieldName);\n              intl.formatMessage({\n                id: 'xpack.ml.explorer.singleMetricChart.unusualByFieldValuesLabel',\n                defaultMessage: '{br} { numberOfCauses, plural, one {# unusual {byFieldName} value} other {#{plusSign} unusual {byFieldName} values}}'\n              }, {\n                br: '<br />',\n                numberOfCauses: numberOfCauses,\n                byFieldName: byFieldName,\n                // Maximum of 10 causes are stored in the record, so '10' may mean more than 10.\n                plusSign: numberOfCauses < 10 ? '' : '+'\n              });\n            }\n          }\n        } else {\n          contents += intl.formatMessage({\n            id: 'xpack.ml.explorer.singleMetricChart.valueWithoutAnomalyScoreLabel',\n            defaultMessage: 'value: {value}'\n          }, {\n            value: (0, _format_value.formatValue)(marker.value, config.functionDescription, fieldFormat)\n          });\n        }\n\n        if (_lodash2.default.has(marker, 'scheduledEvents')) {\n          contents += '<br/><hr/>' + intl.formatMessage({\n            id: 'xpack.ml.explorer.singleMetricChart.scheduledEventsLabel',\n            defaultMessage: 'Scheduled events:{br}{scheduledEventsValue}'\n          }, {\n            br: '<br />',\n            scheduledEventsValue: marker.scheduledEvents.map(_string_utils.mlEscape).join('<br/>')\n          });\n        }\n\n        _chart_tooltip_service.mlChartTooltipService.show(contents, circle, {\n          x: _chart_utils.LINE_CHART_ANOMALY_RADIUS * 2,\n          y: 0\n        });\n      }\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate() {\n      // Always return true, d3 will take care of appropriate re-rendering.\n      return true;\n    }\n  }, {\n    key: 'setRef',\n    value: function setRef(componentNode) {\n      this.rootNode = componentNode;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var seriesConfig = this.props.seriesConfig;\n\n\n      if (typeof seriesConfig === 'undefined') {\n        // just return so the empty directive renders without an error later on\n        return null;\n      }\n\n      // create a chart loading placeholder\n      var isLoading = seriesConfig.loading;\n\n      return _react2.default.createElement(\n        'div',\n        { className: 'ml-explorer-chart', ref: this.setRef.bind(this) },\n        isLoading && _react2.default.createElement(_loading_indicator.LoadingIndicator, { height: CONTENT_WRAPPER_HEIGHT }),\n        !isLoading && _react2.default.createElement('div', { className: CONTENT_WRAPPER_CLASS })\n      );\n    }\n  }]);\n\n  return ExplorerChartSingleMetric;\n}(_react2.default.Component), _class.propTypes = {\n  tooManyBuckets: _propTypes2.default.bool,\n  seriesConfig: _propTypes2.default.object\n}, _temp));",null]}