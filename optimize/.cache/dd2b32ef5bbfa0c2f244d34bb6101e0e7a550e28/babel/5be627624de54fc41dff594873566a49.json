{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/remote_clusters/public/store/actions/add_cluster.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/remote_clusters/public/store/actions/add_cluster.js","mtime":1567631712124},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearAddClusterErrors = exports.addCluster = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _i18n = require('@kbn/i18n');\n\nvar _notify = require('ui/notify');\n\nvar _constants = require('../../constants');\n\nvar _services = require('../../services');\n\nvar _action_types = require('../action_types');\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */\n\nvar addCluster = exports.addCluster = function addCluster(cluster) {\n  return function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(dispatch) {\n      var newCluster, _ref2, _ref3, statusCode, data, _getRouter, history, search, _extractQueryParams, redirectUrl, decodedRedirect;\n\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              dispatch({\n                type: _action_types.ADD_CLUSTER_START\n              });\n\n              newCluster = void 0;\n              _context.prev = 2;\n              _context.next = 5;\n              return Promise.all([(0, _services.addCluster)(cluster),\n              // Wait at least half a second to avoid a weird flicker of the saving feedback.\n              new Promise(function (resolve) {\n                return setTimeout(resolve, 500);\n              })]);\n\n            case 5:\n              _ref2 = _context.sent;\n              _ref3 = _slicedToArray(_ref2, 1);\n              newCluster = _ref3[0];\n              _context.next = 19;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context['catch'](2);\n\n              if (!_context.t0) {\n                _context.next = 18;\n                break;\n              }\n\n              statusCode = _context.t0.statusCode, data = _context.t0.data;\n\n              // Expect an error in the shape provided by Angular's $http service.\n\n              if (!data) {\n                _context.next = 18;\n                break;\n              }\n\n              if (!((statusCode || data && data.statusCode) === 409)) {\n                _context.next = 17;\n                break;\n              }\n\n              return _context.abrupt('return', dispatch({\n                type: _action_types.ADD_CLUSTER_FAILURE,\n                payload: {\n                  error: {\n                    message: _i18n.i18n.translate('xpack.remoteClusters.addAction.clusterNameAlreadyExistsErrorMessage', {\n                      defaultMessage: 'A cluster with the name \\'{clusterName}\\' already exists.',\n                      values: { clusterName: cluster.name }\n                    })\n                  }\n                }\n              }));\n\n            case 17:\n              return _context.abrupt('return', dispatch({\n                type: _action_types.ADD_CLUSTER_FAILURE,\n                payload: {\n                  error: {\n                    message: _i18n.i18n.translate('xpack.remoteClusters.addAction.failedDefaultErrorMessage', {\n                      defaultMessage: 'Request failed with a {statusCode} error. {message}',\n                      values: { statusCode: statusCode, message: data.message }\n                    }),\n                    cause: data.cause\n                  }\n                }\n              }));\n\n            case 18:\n              return _context.abrupt('return', (0, _notify.fatalError)(_context.t0, _i18n.i18n.translate('xpack.remoteClusters.addAction.errorTitle', {\n                defaultMessage: 'Error adding cluster'\n              })));\n\n            case 19:\n\n              dispatch({\n                type: _action_types.ADD_CLUSTER_SUCCESS,\n                payload: { cluster: newCluster.data }\n              });\n\n              _getRouter = (0, _services.getRouter)(), history = _getRouter.history, search = _getRouter.route.location.search;\n              _extractQueryParams = (0, _services.extractQueryParams)(search), redirectUrl = _extractQueryParams.redirect;\n\n\n              if (redirectUrl) {\n                // A toast is only needed if we're leaving the app.\n                _notify.toastNotifications.addSuccess(_i18n.i18n.translate('xpack.remoteClusters.addAction.successTitle', {\n                  defaultMessage: 'Added remote cluster \\'{name}\\'',\n                  values: { name: cluster.name }\n                }));\n\n                decodedRedirect = decodeURIComponent(redirectUrl);\n\n                (0, _services.redirect)(decodedRedirect + '?cluster=' + cluster.name);\n              } else {\n                // This will open the new job in the detail panel. Note that we're *not* showing a success toast\n                // here, because it would partially obscure the detail panel.\n                history.push({\n                  pathname: _constants.CRUD_APP_BASE_PATH + '/list',\n                  search: '?cluster=' + cluster.name\n                });\n              }\n\n            case 23:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, undefined, [[2, 10]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n\nvar clearAddClusterErrors = exports.clearAddClusterErrors = function clearAddClusterErrors() {\n  return function (dispatch) {\n    dispatch({\n      type: _action_types.CLEAR_ADD_CLUSTER_ERRORS\n    });\n  };\n};",null]}