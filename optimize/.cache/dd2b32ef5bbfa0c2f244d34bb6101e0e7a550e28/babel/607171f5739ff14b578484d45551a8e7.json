{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/services/job_service.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/services/job_service.js","mtime":1567631712062},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mlJobService = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _i18n = require('@kbn/i18n');\n\nvar _parse_interval = require('ui/utils/parse_interval');\n\nvar _ml_api_service = require('./ml_api_service');\n\nvar _messagebar_service = require('../components/messagebar/messagebar_service');\n\nvar _string_utils = require('../util/string_utils');\n\nvar _job_utils = require('../../common/util/job_utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar msgs = _messagebar_service.mlMessageBarService;\nvar jobs = [];\nvar datafeedIds = {};\n\nvar JobService = function () {\n  function JobService() {\n    _classCallCheck(this, JobService);\n\n    this.currentJob = undefined;\n    this.jobs = [];\n\n    // Provide ready access to widely used basic job properties.\n    // Note these get populated on a call to loadJobs.\n    this.basicJobs = {};\n    this.jobDescriptions = {};\n    this.detectorsByJob = {};\n    this.customUrlsByJob = {};\n    this.jobStats = {\n      activeNodes: { label: _i18n.i18n.translate('xpack.ml.jobService.activeMLNodesLabel', {\n          defaultMessage: 'Active ML Nodes'\n        }), value: 0, show: true },\n      total: { label: _i18n.i18n.translate('xpack.ml.jobService.totalJobsLabel', {\n          defaultMessage: 'Total jobs'\n        }), value: 0, show: true },\n      open: { label: _i18n.i18n.translate('xpack.ml.jobService.openJobsLabel', {\n          defaultMessage: 'Open jobs'\n        }), value: 0, show: true },\n      closed: { label: _i18n.i18n.translate('xpack.ml.jobService.closedJobsLabel', {\n          defaultMessage: 'Closed jobs'\n        }), value: 0, show: true },\n      failed: { label: _i18n.i18n.translate('xpack.ml.jobService.failedJobsLabel', {\n          defaultMessage: 'Failed jobs'\n        }), value: 0, show: false },\n      activeDatafeeds: { label: _i18n.i18n.translate('xpack.ml.jobService.activeDatafeedsLabel', {\n          defaultMessage: 'Active datafeeds'\n        }), value: 0, show: true }\n    };\n    this.jobUrls = {};\n  }\n\n  _createClass(JobService, [{\n    key: 'getBlankJob',\n    value: function getBlankJob() {\n      return {\n        job_id: '',\n        description: '',\n        groups: [],\n        analysis_config: {\n          bucket_span: '15m',\n          influencers: [],\n          detectors: []\n        },\n        data_description: {\n          time_field: '',\n          time_format: '', // 'epoch',\n          field_delimiter: '',\n          quote_character: '\"',\n          format: 'delimited'\n        }\n      };\n    }\n  }, {\n    key: 'loadJobs',\n    value: function loadJobs() {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        jobs = [];\n        datafeedIds = {};\n\n        _ml_api_service.ml.getJobs().then(function (resp) {\n          // make deep copy of jobs\n          _angular2.default.copy(resp.jobs, jobs);\n\n          // load jobs stats\n          _ml_api_service.ml.getJobStats().then(function (statsResp) {\n            // merge jobs stats into jobs\n            for (var i = 0; i < jobs.length; i++) {\n              var job = jobs[i];\n              // create empty placeholders for stats and datafeed objects\n              job.data_counts = {};\n              job.model_size_stats = {};\n              job.datafeed_config = {};\n\n              for (var j = 0; j < statsResp.jobs.length; j++) {\n                if (job.job_id === statsResp.jobs[j].job_id) {\n                  var jobStats = _angular2.default.copy(statsResp.jobs[j]);\n\n                  job.state = jobStats.state;\n                  job.data_counts = jobStats.data_counts;\n                  job.model_size_stats = jobStats.model_size_stats;\n                  if (jobStats.node) {\n                    job.node = jobStats.node;\n                  }\n                  if (jobStats.open_time) {\n                    job.open_time = jobStats.open_time;\n                  }\n                }\n              }\n            }\n            _this.loadDatafeeds().then(function (datafeedsResp) {\n              for (var _i = 0; _i < jobs.length; _i++) {\n                for (var _j = 0; _j < datafeedsResp.datafeeds.length; _j++) {\n                  if (jobs[_i].job_id === datafeedsResp.datafeeds[_j].job_id) {\n                    jobs[_i].datafeed_config = datafeedsResp.datafeeds[_j];\n\n                    datafeedIds[jobs[_i].job_id] = datafeedsResp.datafeeds[_j].datafeed_id;\n                  }\n                }\n              }\n              processBasicJobInfo(_this, jobs);\n              _this.jobs = jobs;\n              createJobStats(_this.jobs, _this.jobStats);\n              createJobUrls(_this.jobs, _this.jobUrls);\n              resolve({ jobs: _this.jobs });\n            });\n          }).catch(function (err) {\n            error(err);\n          });\n        }).catch(function (err) {\n          error(err);\n        });\n\n        function error(err) {\n          console.log('jobService error getting list of jobs:', err);\n          msgs.error(_i18n.i18n.translate('xpack.ml.jobService.jobsListCouldNotBeRetrievedErrorMessage', {\n            defaultMessage: 'Jobs list could not be retrieved'\n          }));\n          msgs.error('', err);\n          reject({ jobs: jobs, err: err });\n        }\n      });\n    }\n  }, {\n    key: 'refreshJob',\n    value: function refreshJob(jobId) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        _ml_api_service.ml.getJobs({ jobId: jobId }).then(function (resp) {\n          var newJob = {};\n          if (resp.jobs && resp.jobs.length) {\n            _angular2.default.copy(resp.jobs[0], newJob);\n\n            // load jobs stats\n            _ml_api_service.ml.getJobStats({ jobId: jobId }).then(function (statsResp) {\n              // merge jobs stats into jobs\n              for (var j = 0; j < statsResp.jobs.length; j++) {\n                if (newJob.job_id === statsResp.jobs[j].job_id) {\n                  var statsJob = statsResp.jobs[j];\n                  newJob.state = statsJob.state;\n                  newJob.data_counts = {};\n                  newJob.model_size_stats = {};\n                  _angular2.default.copy(statsJob.data_counts, newJob.data_counts);\n                  _angular2.default.copy(statsJob.model_size_stats, newJob.model_size_stats);\n                  if (newJob.node) {\n                    _angular2.default.copy(statsJob.node, newJob.node);\n                  }\n\n                  if (statsJob.open_time) {\n                    newJob.open_time = statsJob.open_time;\n                  }\n                }\n              }\n\n              // replace the job in the jobs array\n              for (var i = 0; i < jobs.length; i++) {\n                if (jobs[i].job_id === newJob.job_id) {\n                  jobs[i] = newJob;\n                }\n              }\n\n              var datafeedId = _this2.getDatafeedId(jobId);\n\n              _this2.loadDatafeeds(datafeedId).then(function (datafeedsResp) {\n                for (var _i2 = 0; _i2 < jobs.length; _i2++) {\n                  for (var _j2 = 0; _j2 < datafeedsResp.datafeeds.length; _j2++) {\n                    if (jobs[_i2].job_id === datafeedsResp.datafeeds[_j2].job_id) {\n                      jobs[_i2].datafeed_config = datafeedsResp.datafeeds[_j2];\n\n                      datafeedIds[jobs[_i2].job_id] = datafeedsResp.datafeeds[_j2].datafeed_id;\n                    }\n                  }\n                }\n                _this2.jobs = jobs;\n                createJobStats(_this2.jobs, _this2.jobStats);\n                createJobUrls(_this2.jobs, _this2.jobUrls);\n                resolve({ jobs: _this2.jobs });\n              });\n            }).catch(function (err) {\n              error(err);\n            });\n          }\n        }).catch(function (err) {\n          error(err);\n        });\n\n        function error(err) {\n          console.log('JobService error getting list of jobs:', err);\n          msgs.error(_i18n.i18n.translate('xpack.ml.jobService.jobsListCouldNotBeRetrievedErrorMessage', {\n            defaultMessage: 'Jobs list could not be retrieved'\n          }));\n          msgs.error('', err);\n          reject({ jobs: jobs, err: err });\n        }\n      });\n    }\n  }, {\n    key: 'loadDatafeeds',\n    value: function loadDatafeeds(datafeedId) {\n      return new Promise(function (resolve, reject) {\n        var datafeeds = [];\n        var sId = datafeedId !== undefined ? { datafeed_id: datafeedId } : undefined;\n\n        _ml_api_service.ml.getDatafeeds(sId).then(function (resp) {\n          // console.log('loadDatafeeds query response:', resp);\n\n          // make deep copy of datafeeds\n          _angular2.default.copy(resp.datafeeds, datafeeds);\n\n          // load datafeeds stats\n          _ml_api_service.ml.getDatafeedStats().then(function (statsResp) {\n            // merge datafeeds stats into datafeeds\n            for (var i = 0; i < datafeeds.length; i++) {\n              var datafeed = datafeeds[i];\n              for (var j = 0; j < statsResp.datafeeds.length; j++) {\n                if (datafeed.datafeed_id === statsResp.datafeeds[j].datafeed_id) {\n                  datafeed.state = statsResp.datafeeds[j].state;\n                }\n              }\n            }\n            resolve({ datafeeds: datafeeds });\n          }).catch(function (err) {\n            error(err);\n          });\n        }).catch(function (err) {\n          error(err);\n        });\n\n        function error(err) {\n          console.log('loadDatafeeds error getting list of datafeeds:', err);\n          msgs.error(_i18n.i18n.translate('xpack.ml.jobService.datafeedsListCouldNotBeRetrievedErrorMessage', {\n            defaultMessage: 'datafeeds list could not be retrieved'\n          }));\n          msgs.error('', err);\n          reject({ jobs: jobs, err: err });\n        }\n      });\n    }\n  }, {\n    key: 'updateSingleJobDatafeedState',\n    value: function updateSingleJobDatafeedState(jobId) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n\n        var datafeedId = _this3.getDatafeedId(jobId);\n\n        _ml_api_service.ml.getDatafeedStats({ datafeedId: datafeedId }).then(function (resp) {\n          // console.log('updateSingleJobCounts controller query response:', resp);\n          var datafeeds = resp.datafeeds;\n          var state = 'UNKNOWN';\n          if (datafeeds && datafeeds.length) {\n            state = datafeeds[0].state;\n          }\n          resolve(state);\n        }).catch(function (resp) {\n          reject(resp);\n        });\n      });\n    }\n  }, {\n    key: 'saveNewJob',\n    value: function saveNewJob(job) {\n      // run then and catch through the same check\n      function func(resp) {\n        console.log('Response for job query:', resp);\n        var success = checkSaveResponse(resp, job);\n        return { success: success, job: job, resp: resp };\n      }\n\n      // return the promise chain\n      return _ml_api_service.ml.addJob({ jobId: job.job_id, job: job }).then(func).catch(func);\n    }\n  }, {\n    key: 'cloneJob',\n    value: function cloneJob(job) {\n      // create a deep copy of a job object\n      // also remove items from the job which are set by the server and not needed\n      // in the future this formatting could be optional\n      var tempJob = _angular2.default.copy(job);\n\n      // remove all of the items which should not be copied\n      // such as counts, state and times\n      delete tempJob.state;\n      delete tempJob.job_version;\n      delete tempJob.data_counts;\n      delete tempJob.create_time;\n      delete tempJob.finished_time;\n      delete tempJob.last_data_time;\n      delete tempJob.model_size_stats;\n      delete tempJob.node;\n      delete tempJob.average_bucket_processing_time_ms;\n      delete tempJob.model_snapshot_id;\n      delete tempJob.open_time;\n      delete tempJob.established_model_memory;\n      delete tempJob.calendars;\n\n      delete tempJob.analysis_config.use_per_partition_normalization;\n\n      _lodash2.default.each(tempJob.analysis_config.detectors, function (d) {\n        delete d.detector_index;\n      });\n\n      // remove parts of the datafeed config which should not be copied\n      if (tempJob.datafeed_config) {\n        delete tempJob.datafeed_config.datafeed_id;\n        delete tempJob.datafeed_config.job_id;\n        delete tempJob.datafeed_config.state;\n        delete tempJob.datafeed_config.node;\n\n        // remove query_delay if it's between 60s and 120s\n        // the back-end produces a random value between 60 and 120 and so\n        // by deleting it, the back-end will produce a new random value\n        if (tempJob.datafeed_config.query_delay) {\n          var interval = (0, _parse_interval.parseInterval)(tempJob.datafeed_config.query_delay);\n          if (interval !== null) {\n            var queryDelay = interval.asSeconds();\n            if (queryDelay > 60 && queryDelay < 120) {\n              delete tempJob.datafeed_config.query_delay;\n            }\n          }\n        }\n      }\n\n      // when jumping from a wizard to the advanced job creation,\n      // the wizard's created_by information should be stripped.\n      if (tempJob.custom_settings && tempJob.custom_settings.created_by) {\n        delete tempJob.custom_settings.created_by;\n      }\n\n      return tempJob;\n    }\n  }, {\n    key: 'updateJob',\n    value: function updateJob(jobId, job) {\n      // return the promise chain\n      return _ml_api_service.ml.updateJob({ jobId: jobId, job: job }).then(function (resp) {\n        console.log('update job', resp);\n        return { success: true };\n      }).catch(function (err) {\n        msgs.error(_i18n.i18n.translate('xpack.ml.jobService.couldNotUpdateJobErrorMessage', {\n          defaultMessage: 'Could not update job: {jobId}',\n          values: { jobId: jobId }\n        }));\n        console.log('update job', err);\n        return { success: false, message: err.message };\n      });\n    }\n  }, {\n    key: 'validateJob',\n    value: function validateJob(obj) {\n      // return the promise chain\n      return _ml_api_service.ml.validateJob(obj).then(function (messages) {\n        console.log('validate job', messages);\n        return { success: true, messages: messages };\n      }).catch(function (err) {\n        msgs.error(_i18n.i18n.translate('xpack.ml.jobService.jobValidationErrorMessage', {\n          defaultMessage: 'Job Validation Error: {errorMessage}',\n          values: { errorMessage: err.message }\n        }));\n        console.log('validate job', err);\n        return {\n          success: false,\n          messages: [{\n            status: 'error',\n            text: err.message\n          }]\n        };\n      });\n    }\n\n    // find a job based on the id\n\n  }, {\n    key: 'getJob',\n    value: function getJob(jobId) {\n      var job = _lodash2.default.find(jobs, function (j) {\n        return j.job_id === jobId;\n      });\n\n      return job;\n    }\n  }, {\n    key: 'searchPreview',\n    value: function searchPreview(job) {\n      return new Promise(function (resolve, reject) {\n\n        if (job.datafeed_config) {\n\n          // if query is set, add it to the search, otherwise use match_all\n          var query = { 'match_all': {} };\n          if (job.datafeed_config.query) {\n            query = job.datafeed_config.query;\n          }\n\n          // Get bucket span\n          // Get first doc time for datafeed\n          // Create a new query - must user query and must range query.\n          // Time range 'to' first doc time plus < 10 buckets\n\n          // Do a preliminary search to get the date of the earliest doc matching the\n          // query in the datafeed. This will be used to apply a time range criteria\n          // on the datafeed search preview.\n          // This time filter is required for datafeed searches using aggregations to ensure\n          // the search does not create too many buckets (default 10000 max_bucket limit),\n          // but apply it to searches without aggregations too for consistency.\n          _ml_api_service.ml.getTimeFieldRange({\n            index: job.datafeed_config.indices,\n            timeFieldName: job.data_description.time_field,\n            query: query\n          }).then(function (timeRange) {\n            var bucketSpan = (0, _parse_interval.parseInterval)(job.analysis_config.bucket_span);\n            var earliestMs = timeRange.start.epoch;\n            var latestMs = +timeRange.start.epoch + 10 * bucketSpan.asMilliseconds();\n\n            var body = {\n              query: {\n                bool: {\n                  must: [{\n                    range: _defineProperty({}, job.data_description.time_field, {\n                      gte: earliestMs,\n                      lt: latestMs,\n                      format: 'epoch_millis'\n                    })\n                  }, query]\n                }\n              }\n            };\n\n            // if aggs or aggregations is set, add it to the search\n            var aggregations = job.datafeed_config.aggs || job.datafeed_config.aggregations;\n            if (aggregations && Object.keys(aggregations).length) {\n              body.size = 0;\n              body.aggregations = aggregations;\n\n              // add script_fields if present\n              var scriptFields = job.datafeed_config.script_fields;\n              if (scriptFields && Object.keys(scriptFields).length) {\n                body.script_fields = scriptFields;\n              }\n            } else {\n              // if aggregations is not set and retrieveWholeSource is not set, add all of the fields from the job\n              body.size = _job_utils.ML_DATA_PREVIEW_COUNT;\n\n              // add script_fields if present\n              var _scriptFields = job.datafeed_config.script_fields;\n              if (_scriptFields && Object.keys(_scriptFields).length) {\n                body.script_fields = _scriptFields;\n              }\n\n              var fields = {};\n\n              // get fields from detectors\n              if (job.analysis_config.detectors) {\n                _lodash2.default.each(job.analysis_config.detectors, function (dtr) {\n                  if (dtr.by_field_name) {\n                    fields[dtr.by_field_name] = {};\n                  }\n                  if (dtr.field_name) {\n                    fields[dtr.field_name] = {};\n                  }\n                  if (dtr.over_field_name) {\n                    fields[dtr.over_field_name] = {};\n                  }\n                  if (dtr.partition_field_name) {\n                    fields[dtr.partition_field_name] = {};\n                  }\n                });\n              }\n\n              // get fields from influencers\n              if (job.analysis_config.influencers) {\n                _lodash2.default.each(job.analysis_config.influencers, function (inf) {\n                  fields[inf] = {};\n                });\n              }\n\n              // get fields from categorizationFieldName\n              if (job.analysis_config.categorization_field_name) {\n                fields[job.analysis_config.categorization_field_name] = {};\n              }\n\n              // get fields from summary_count_field_name\n              if (job.analysis_config.summary_count_field_name) {\n                fields[job.analysis_config.summary_count_field_name] = {};\n              }\n\n              // get fields from time_field\n              if (job.data_description.time_field) {\n                fields[job.data_description.time_field] = {};\n              }\n\n              // console.log('fields: ', fields);\n              var fieldsList = Object.keys(fields);\n              if (fieldsList.length) {\n                body._source = fieldsList;\n              }\n            }\n\n            var data = {\n              index: job.datafeed_config.indices,\n              body: body\n            };\n\n            _ml_api_service.ml.esSearch(data).then(function (resp) {\n              resolve(resp);\n            }).catch(function (resp) {\n              reject(resp);\n            });\n          }).catch(function (resp) {\n            reject(resp);\n          });\n        }\n      });\n    }\n  }, {\n    key: 'openJob',\n    value: function openJob(jobId) {\n      return _ml_api_service.ml.openJob({ jobId: jobId });\n    }\n  }, {\n    key: 'closeJob',\n    value: function closeJob(jobId) {\n      return _ml_api_service.ml.closeJob({ jobId: jobId });\n    }\n  }, {\n    key: 'saveNewDatafeed',\n    value: function saveNewDatafeed(datafeedConfig, jobId) {\n      var datafeedId = 'datafeed-' + jobId;\n      datafeedConfig.job_id = jobId;\n\n      return _ml_api_service.ml.addDatafeed({\n        datafeedId: datafeedId,\n        datafeedConfig: datafeedConfig\n      });\n    }\n  }, {\n    key: 'updateDatafeed',\n    value: function updateDatafeed(datafeedId, datafeedConfig) {\n      return _ml_api_service.ml.updateDatafeed({ datafeedId: datafeedId, datafeedConfig: datafeedConfig }).then(function (resp) {\n        console.log('update datafeed', resp);\n        return { success: true };\n      }).catch(function (err) {\n        msgs.error(_i18n.i18n.translate('xpack.ml.jobService.couldNotUpdateDatafeedErrorMessage', {\n          defaultMessage: 'Could not update datafeed: {datafeedId}',\n          values: { datafeedId: datafeedId }\n        }));\n        console.log('update datafeed', err);\n        return { success: false, message: err.message };\n      });\n    }\n\n    // start the datafeed for a given job\n    // refresh the job state on start success\n\n  }, {\n    key: 'startDatafeed',\n    value: function startDatafeed(datafeedId, jobId, start, end) {\n      return new Promise(function (resolve, reject) {\n\n        // if the end timestamp is a number, add one ms to it to make it\n        // inclusive of the end of the data\n        if (_lodash2.default.isNumber(end)) {\n          end++;\n        }\n\n        _ml_api_service.ml.startDatafeed({\n          datafeedId: datafeedId,\n          start: start,\n          end: end\n        }).then(function (resp) {\n          resolve(resp);\n        }).catch(function (err) {\n          console.log('jobService error starting datafeed:', err);\n          msgs.error(_i18n.i18n.translate('xpack.ml.jobService.couldNotStartDatafeedErrorMessage', {\n            defaultMessage: 'Could not start datafeed for {jobId}',\n            values: { jobId: jobId }\n          }), err);\n          reject(err);\n        });\n      });\n    }\n\n    // stop the datafeed for a given job\n    // refresh the job state on stop success\n\n  }, {\n    key: 'stopDatafeed',\n    value: function stopDatafeed(datafeedId, jobId) {\n      return new Promise(function (resolve, reject) {\n        _ml_api_service.ml.stopDatafeed({\n          datafeedId: datafeedId\n        }).then(function (resp) {\n          resolve(resp);\n        }).catch(function (err) {\n          console.log('jobService error stopping datafeed:', err);\n          var couldNotStopDatafeedErrorMessage = _i18n.i18n.translate('xpack.ml.jobService.couldNotStopDatafeedErrorMessage', {\n            defaultMessage: 'Could not stop datafeed for {jobId}',\n            values: { jobId: jobId }\n          });\n\n          if (err.statusCode === 500) {\n            msgs.error(couldNotStopDatafeedErrorMessage);\n            msgs.error(_i18n.i18n.translate('xpack.ml.jobService.requestMayHaveTimedOutErrorMessage', {\n              defaultMessage: 'Request may have timed out and may still be running in the background.'\n            }));\n          } else {\n            msgs.error(couldNotStopDatafeedErrorMessage, err);\n          }\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: 'forceStartDatafeeds',\n    value: function forceStartDatafeeds(dIds, start, end) {\n      return _ml_api_service.ml.jobs.forceStartDatafeeds(dIds, start, end);\n    }\n  }, {\n    key: 'stopDatafeeds',\n    value: function stopDatafeeds(dIds) {\n      return _ml_api_service.ml.jobs.stopDatafeeds(dIds);\n    }\n  }, {\n    key: 'deleteJobs',\n    value: function deleteJobs(jIds) {\n      return _ml_api_service.ml.jobs.deleteJobs(jIds);\n    }\n  }, {\n    key: 'closeJobs',\n    value: function closeJobs(jIds) {\n      return _ml_api_service.ml.jobs.closeJobs(jIds);\n    }\n  }, {\n    key: 'validateDetector',\n    value: function validateDetector(detector) {\n      return new Promise(function (resolve, reject) {\n        if (detector) {\n          _ml_api_service.ml.validateDetector({ detector: detector }).then(function (resp) {\n            resolve(resp);\n          }).catch(function (resp) {\n            reject(resp);\n          });\n        } else {\n          reject({});\n        }\n      });\n    }\n  }, {\n    key: 'getDatafeedId',\n    value: function getDatafeedId(jobId) {\n      var datafeedId = datafeedIds[jobId];\n      if (datafeedId === undefined) {\n        datafeedId = 'datafeed-' + jobId;\n      }\n      return datafeedId;\n    }\n  }, {\n    key: 'getDatafeedPreview',\n    value: function getDatafeedPreview(jobId) {\n      var datafeedId = this.getDatafeedId(jobId);\n      return _ml_api_service.ml.datafeedPreview({ datafeedId: datafeedId });\n    }\n\n    // get the list of job group ids as well as how many jobs are in each group\n\n  }, {\n    key: 'getJobGroups',\n    value: function getJobGroups() {\n      var groups = [];\n      var tempGroups = {};\n      this.jobs.forEach(function (job) {\n        if (Array.isArray(job.groups)) {\n          job.groups.forEach(function (group) {\n            if (tempGroups[group] === undefined) {\n              tempGroups[group] = [job];\n            } else {\n              tempGroups[group].push(job);\n            }\n          });\n        }\n      });\n      _lodash2.default.each(tempGroups, function (js, id) {\n        groups.push({ id: id, jobs: js });\n      });\n      return groups;\n    }\n  }, {\n    key: 'createResultsUrl',\n    value: function createResultsUrl(jobIds, from, to, resultsPage) {\n      return _createResultsUrl(jobIds, from, to, resultsPage);\n    }\n  }]);\n\n  return JobService;\n}();\n\n// private function used to check the job saving response\n\n\nfunction checkSaveResponse(resp, origJob) {\n  if (resp) {\n    if (resp.job_id) {\n      if (resp.job_id === origJob.job_id) {\n        console.log('checkSaveResponse(): save successful');\n        return true;\n      }\n    } else {\n      if (resp.errorCode) {\n        console.log('checkSaveResponse(): save failed', resp);\n        return false;\n      }\n    }\n  } else {\n    console.log('checkSaveResponse(): response is empty');\n    return false;\n  }\n}\n\nfunction processBasicJobInfo(localJobService, jobsList) {\n  // Process the list of job data obtained from the jobs endpoint to return\n  // an array of objects containing the basic information (id, description, bucketSpan,\n  // and detectors properties, plus a customUrls key if custom URLs\n  // have been configured for the job) used by various result dashboards in the ml plugin.\n  // The key information is stored in the jobService object for quick access.\n  var processedJobsList = [];\n  var detectorsByJob = {};\n  var customUrlsByJob = {};\n\n  // use cloned copy of jobs list so not to alter the original\n  var jobsListCopy = _lodash2.default.cloneDeep(jobsList);\n\n  _lodash2.default.each(jobsListCopy, function (jobObj) {\n    var analysisConfig = jobObj.analysis_config;\n    var bucketSpan = (0, _parse_interval.parseInterval)(analysisConfig.bucket_span);\n\n    var job = {\n      id: jobObj.job_id,\n      bucketSpanSeconds: bucketSpan.asSeconds()\n    };\n\n    if (_lodash2.default.has(jobObj, 'description') && /^\\s*$/.test(jobObj.description) === false) {\n      job.description = jobObj.description;\n    } else {\n      // Just use the id as the description.\n      job.description = jobObj.job_id;\n    }\n\n    job.detectors = _lodash2.default.get(analysisConfig, 'detectors', []);\n    detectorsByJob[job.id] = job.detectors;\n\n    if (_lodash2.default.has(jobObj, 'custom_settings.custom_urls')) {\n      job.customUrls = [];\n      _lodash2.default.each(jobObj.custom_settings.custom_urls, function (url) {\n        if (_lodash2.default.has(url, 'url_name') && _lodash2.default.has(url, 'url_value') && (0, _string_utils.isWebUrl)(url.url_value)) {\n          // Only make web URLs (i.e. http or https) available in dashboard drilldowns.\n          job.customUrls.push(url);\n        }\n      });\n      // Only add an entry for a job if customUrls have been defined.\n      if (job.customUrls.length > 0) {\n        customUrlsByJob[job.id] = job.customUrls;\n      }\n    }\n\n    localJobService.jobDescriptions[job.id] = job.description;\n    localJobService.basicJobs[job.id] = job;\n    processedJobsList.push(job);\n  });\n\n  localJobService.detectorsByJob = detectorsByJob;\n  localJobService.customUrlsByJob = customUrlsByJob;\n\n  return processedJobsList;\n}\n\n// Loop through the jobs list and create basic stats\n// stats are displayed along the top of the Jobs Management page\nfunction createJobStats(jobsList, jobStats) {\n\n  jobStats.activeNodes.value = 0;\n  jobStats.total.value = 0;\n  jobStats.open.value = 0;\n  jobStats.closed.value = 0;\n  jobStats.failed.value = 0;\n  jobStats.activeDatafeeds.value = 0;\n\n  // object to keep track of nodes being used by jobs\n  var mlNodes = {};\n  var failedJobs = 0;\n\n  _lodash2.default.each(jobsList, function (job) {\n    if (job.state === 'opened') {\n      jobStats.open.value++;\n    } else if (job.state === 'closed') {\n      jobStats.closed.value++;\n    } else if (job.state === 'failed') {\n      failedJobs++;\n    }\n\n    if (job.datafeed_config && job.datafeed_config.state === 'started') {\n      jobStats.activeDatafeeds.value++;\n    }\n\n    if (job.node && job.node.name) {\n      mlNodes[job.node.name] = {};\n    }\n  });\n\n  jobStats.total.value = jobsList.length;\n\n  // // Only show failed jobs if it is non-zero\n  if (failedJobs) {\n    jobStats.failed.value = failedJobs;\n    jobStats.failed.show = true;\n  } else {\n    jobStats.failed.show = false;\n  }\n\n  jobStats.activeNodes.value = Object.keys(mlNodes).length;\n}\n\nfunction createJobUrls(jobsList, jobUrls) {\n  _lodash2.default.each(jobsList, function (job) {\n    if (job.data_counts) {\n      var from = (0, _moment2.default)(job.data_counts.earliest_record_timestamp).toISOString();\n      var to = (0, _moment2.default)(job.data_counts.latest_record_timestamp).toISOString();\n      var path = _createResultsUrl([job.job_id], to, from);\n\n      if (jobUrls[job.job_id]) {\n        jobUrls[job.job_id].url = path;\n      } else {\n        jobUrls[job.job_id] = { url: path };\n      }\n    }\n  });\n}\n\nfunction _createResultsUrl(jobIds, start, end, resultsPage) {\n  var idString = jobIds.map(function (j) {\n    return '\\'' + j + '\\'';\n  }).join(',');\n  var from = (0, _moment2.default)(start).toISOString();\n  var to = (0, _moment2.default)(end).toISOString();\n  var path = '';\n\n  if (resultsPage !== undefined) {\n    path += 'ml#/';\n    path += resultsPage;\n  }\n\n  path += '?_g=(ml:(jobIds:!(' + idString + '))';\n  path += ',refreshInterval:(display:Off,pause:!f,value:0),time:(from:\\'' + from + '\\'';\n  path += ',mode:absolute,to:\\'' + to + '\\'';\n  path += '))&_a=(filters:!(),query:(query_string:(analyze_wildcard:!t,query:\\'*\\')))';\n\n  return path;\n}\n\nvar mlJobService = exports.mlJobService = new JobService();",null]}