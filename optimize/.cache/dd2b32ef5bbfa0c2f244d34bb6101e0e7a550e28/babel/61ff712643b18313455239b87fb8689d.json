{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/table_vis/public/legacy_response_handler.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/table_vis/public/legacy_response_handler.js","mtime":1567631711641},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.legacyTableResponseHandler = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar legacyTableResponseHandler = exports.legacyTableResponseHandler = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(table) {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt('return', { tables: splitTable(table.columns, table.rows, null) });\n\n          case 1:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function legacyTableResponseHandler(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.splitRowsOnColumn = splitRowsOnColumn;\nexports.splitTable = splitTable;\n\nvar _lodash = require('lodash');\n\nvar _agg_config_result = require('ui/vis/agg_config_result');\n\nvar _agg_config_result2 = _interopRequireDefault(_agg_config_result);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; } /*\n                                                                                                                                                                                                                              * Licensed to Elasticsearch B.V. under one or more contributor\n                                                                                                                                                                                                                              * license agreements. See the NOTICE file distributed with\n                                                                                                                                                                                                                              * this work for additional information regarding copyright\n                                                                                                                                                                                                                              * ownership. Elasticsearch B.V. licenses this file to you under\n                                                                                                                                                                                                                              * the Apache License, Version 2.0 (the \"License\"); you may\n                                                                                                                                                                                                                              * not use this file except in compliance with the License.\n                                                                                                                                                                                                                              * You may obtain a copy of the License at\n                                                                                                                                                                                                                              *\n                                                                                                                                                                                                                              *    http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                              *\n                                                                                                                                                                                                                              * Unless required by applicable law or agreed to in writing,\n                                                                                                                                                                                                                              * software distributed under the License is distributed on an\n                                                                                                                                                                                                                              * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                                                                                                                                                                                                                              * KIND, either express or implied.  See the License for the\n                                                                                                                                                                                                                              * specific language governing permissions and limitations\n                                                                                                                                                                                                                              * under the License.\n                                                                                                                                                                                                                              */\n\n/**\n * Takes an array of tabified rows and splits them by column value:\n *\n * const rows = [\n *   { col-1: 'foo', col-2: 'X' },\n *   { col-1: 'bar', col-2: 50 },\n *   { col-1: 'baz', col-2: 'X' },\n * ];\n * const splitRows = splitRowsOnColumn(rows, 'col-2');\n * splitRows.results; // ['X', 50];\n * splitRows.rowsGroupedByResult; // { X: [{ col-1: 'foo' }, { col-1: 'baz' }], 50: [{ col-1: 'bar' }] }\n */\nfunction splitRowsOnColumn(rows, columnId) {\n  var resultsMap = {}; // Used to preserve types, since object keys are always converted to strings.\n  return {\n    rowsGroupedByResult: rows.reduce(function (acc, row) {\n      var splitValue = row[columnId],\n          rest = _objectWithoutProperties(row, [columnId]);\n\n      resultsMap[splitValue] = splitValue;\n      acc[splitValue] = [].concat(_toConsumableArray(acc[splitValue] || []), [rest]);\n      return acc;\n    }, {}),\n    results: Object.values(resultsMap)\n  };\n}\n\nfunction splitTable(columns, rows, $parent) {\n  var splitColumn = columns.find(function (column) {\n    return (0, _lodash.get)(column, 'aggConfig.schema.name') === 'split';\n  });\n\n  if (!splitColumn) {\n    return [{\n      $parent: $parent,\n      columns: columns.map(function (column) {\n        return _extends({ title: column.name }, column);\n      }),\n      rows: rows.map(function (row, rowIndex) {\n        return columns.map(function (column) {\n          var aggConfigResult = new _agg_config_result2.default(column.aggConfig, $parent, row[column.id], row[column.id]);\n          aggConfigResult.rawData = {\n            table: { columns: columns, rows: rows },\n            column: columns.findIndex(function (c) {\n              return c.id === column.id;\n            }),\n            row: rowIndex\n          };\n          return aggConfigResult;\n        });\n      })\n    }];\n  }\n\n  var splitColumnIndex = columns.findIndex(function (column) {\n    return column.id === splitColumn.id;\n  });\n  var splitRows = splitRowsOnColumn(rows, splitColumn.id);\n\n  // Check if there are buckets after the first metric.\n  var firstMetricsColumnIndex = columns.findIndex(function (column) {\n    return (0, _lodash.get)(column, 'aggConfig.type.type') === 'metrics';\n  });\n  var lastBucketsColumnIndex = (0, _lodash.findLastIndex)(columns, function (column) {\n    return (0, _lodash.get)(column, 'aggConfig.type.type') === 'buckets';\n  });\n  var metricsAtAllLevels = firstMetricsColumnIndex < lastBucketsColumnIndex;\n\n  // Calculate metrics:bucket ratio.\n  var numberOfMetrics = columns.filter(function (column) {\n    return (0, _lodash.get)(column, 'aggConfig.type.type') === 'metrics';\n  }).length;\n  var numberOfBuckets = columns.filter(function (column) {\n    return (0, _lodash.get)(column, 'aggConfig.type.type') === 'buckets';\n  }).length;\n  var metricsPerBucket = numberOfMetrics / numberOfBuckets;\n\n  var filteredColumns = columns.filter(function (column, i) {\n    var isSplitColumn = i === splitColumnIndex;\n    var isSplitMetric = metricsAtAllLevels && i > splitColumnIndex && i <= splitColumnIndex + metricsPerBucket;\n    return !isSplitColumn && !isSplitMetric;\n  }).map(function (column) {\n    return _extends({ title: column.name }, column);\n  });\n\n  return splitRows.results.map(function (splitValue) {\n    var $newParent = new _agg_config_result2.default(splitColumn.aggConfig, $parent, splitValue, splitValue);\n    $newParent.rawData = {\n      table: { columns: columns, rows: rows },\n      column: splitColumnIndex,\n      row: -1 // For split buckets, we don't need the actual row for filters, just the provided value.\n    };\n    return {\n      $parent: $newParent,\n      aggConfig: splitColumn.aggConfig,\n      title: splitColumn.aggConfig.fieldFormatter()(splitValue) + ': ' + splitColumn.aggConfig.makeLabel(),\n      key: splitValue,\n      // Recurse with filtered data to continue the search for additional split columns.\n      tables: splitTable(filteredColumns, splitRows.rowsGroupedByResult[splitValue], $newParent)\n    };\n  });\n}",null]}