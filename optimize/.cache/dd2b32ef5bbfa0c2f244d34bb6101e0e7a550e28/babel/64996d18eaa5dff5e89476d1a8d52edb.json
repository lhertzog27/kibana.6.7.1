{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/renderers/plot/plugins/size.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/renderers/plot/plugins/size.js","mtime":1567631711904},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.size = undefined;\n\nvar _lodash = require('lodash');\n\n/*\n * The MIT License\nCopyright (c) 2010, 2011, 2012, 2013 by Juergen Marsch\nCopyright (c) 2015 by Alexander Wunschik\nCopyright (c) 2015 by Stefan Siegl\nCopyright (c) 2015 by Pascal Vervest\nCopyright (c) 2017 by Rashid Khan\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\nThe below is based on the flot bubble plugin, but with all the complex overlay logic stripped\n\n*/\n\nvar pluginName = 'simpleBubble'; /*\n                                  * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                  * or more contributor license agreements. Licensed under the Elastic License;\n                                  * you may not use this file except in compliance with the Elastic License.\n                                  */\n\nvar pluginVersion = '0.1.0';\n\nvar options = {\n  series: {\n    bubbles: {\n      size: {\n        max: 20,\n        min: 2\n      },\n      active: true,\n      show: true,\n      fill: false,\n      drawbubble: drawbubbleDefault\n    }\n  }\n};\n\nfunction drawbubbleDefault(ctx, series, x, y, radius, c) {\n  ctx.fillStyle = c;\n  if (series.bubbles.fill) {\n    ctx.globalAlpha = series.bubbles.fill;\n  }\n  ctx.strokeStyle = c;\n\n  ctx.lineWidth = Math.round(radius / 3);\n  ctx.beginPath();\n\n  ctx.arc(x, y, radius, 0, Math.PI * 2, true);\n  ctx.closePath();\n  if (series.bubbles.fill) {\n    ctx.fill();\n  } else {\n    ctx.stroke();\n  }\n}\n\nfunction init(plot) {\n  plot.hooks.processOptions.push(processOptions);\n\n  function processOptions(plot, options) {\n    if (options.series.bubbles.active) {\n      plot.hooks.drawSeries.push(drawSeries);\n    }\n  }\n\n  function drawSeries(plot, ctx, series) {\n    // Actually need to calculate the min/max for the entire set up here, not on an individual series basis;\n    var allSizes = (0, _lodash.map)((0, _lodash.map)((0, _lodash.flatten)((0, _lodash.map)(plot.getData(), 'data')), 2), 'size');\n    var minPoint = (0, _lodash.min)(allSizes);\n    var maxPoint = (0, _lodash.max)(allSizes);\n\n    if (series.bubbles.show) {\n      var drawPoint = function drawPoint(point) {\n        var x = offset.left + series.xaxis.p2c(point[0]);\n        var y = offset.top + series.yaxis.p2c(point[1]);\n        var size = point[2].size;\n\n        var delta = maxPoint - minPoint;\n        var radius = function () {\n          if (size == null) {\n            return 0;\n          } // If there is no size, draw nothing\n          if (delta === 0) {\n            return series.bubbles.size.min;\n          } // If there is no difference between the min and the max, draw the minimum bubble.\n\n          // Otherwise draw something between the min and max acceptable radius.\n          return (series.bubbles.size.max - series.bubbles.size.min) / delta * (size - minPoint) + series.bubbles.size.min;\n        }();\n\n        var color = series.color === 'function' ? series.color.apply(this, point) : series.color;\n\n        var seriesBubbleDrawFn = series.bubbles.drawbubble;\n        seriesBubbleDrawFn(ctx, series, x, y, radius, color);\n      };\n\n      var offset = plot.getPlotOffset();\n\n      series.data.forEach(function (point) {\n        return drawPoint(point);\n      });\n    }\n  }\n}\n\nvar size = exports.size = {\n  init: init,\n  options: options,\n  name: pluginName,\n  version: pluginVersion\n};",null]}