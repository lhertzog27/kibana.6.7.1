{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/components/context_chart_mask/context_chart_mask.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/components/context_chart_mask/context_chart_mask.js","mtime":1567631712068},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContextChartMask = ContextChartMask;\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _chart_utils = require('../../../util/chart_utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Creates a mask over sections of the context chart and swimlane\n * which fall outside the extent of the selection brush used for zooming.\n */\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nfunction ContextChartMask(contextGroup, data, drawBounds, swimlaneHeight) {\n  this.contextGroup = contextGroup;\n  this.data = data;\n  this.drawBounds = drawBounds;\n  this.swimlaneHeight = swimlaneHeight;\n  this.mask = this.contextGroup.append('g').attr('class', 'mask');\n\n  // Create groups for the left and right sides of the mask.\n  this.leftGroup = this.mask.append('g').attr('class', 'left-mask');\n  this.rightGroup = this.mask.append('g').attr('class', 'right-mask');\n\n  // Create polygons to provide opacity over the left and right sections of the mask.\n  this.leftPolygon = this.leftGroup.append('polygon');\n  this.rightPolygon = this.rightGroup.append('polygon');\n\n  // Create the path elements for the bounded area and values line.\n  if (this.drawBounds === true) {\n    this.leftGroup.append('path').attr('class', 'left area bounds');\n    this.rightGroup.append('path').attr('class', 'right area bounds');\n  }\n  this.leftGroup.append('path').attr('class', 'left values-line');\n  this.rightGroup.append('path').attr('class', 'right values-line');\n\n  this._x = null;\n  this._y = null;\n}\n\nContextChartMask.prototype.style = function (prop, val) {\n  this.leftGroup.style(prop, val);\n  this.rightGroup.style(prop, val);\n  return this;\n};\n\nContextChartMask.prototype.x = function (f) {\n  if (f == null) {\n    return this._x;\n  }\n  this._x = f;\n  return this;\n};\n\nContextChartMask.prototype.y = function (f) {\n  if (f == null) {\n    return this._y;\n  }\n  this._y = f;\n  return this;\n};\n\nContextChartMask.prototype.redraw = function () {\n  var yDomain = this._y.domain();\n  var minY = yDomain[0];\n  var maxY = yDomain[1];\n  var xDomain = this._x.domain();\n  var minX = xDomain[0];\n  var maxX = xDomain[1];\n\n  var that = this;\n\n  var leftData = this.data.filter(function (d) {\n    return d.date < that.from;\n  });\n\n  var rightData = this.data.filter(function (d) {\n    return d.date > that.to;\n  });\n\n  // Render the bounds area and values line.\n  if (this.drawBounds === true) {\n    var boundedArea = _d2.default.svg.area().x(function (d) {\n      return that._x(d.date) || 1;\n    }).y0(function (d) {\n      return that._y(Math.min(maxY, Math.max(d.lower, minY)));\n    }).y1(function (d) {\n      return that._y(Math.max(minY, Math.min(d.upper, maxY)));\n    }).defined(function (d) {\n      return d.lower !== null && d.upper !== null;\n    });\n    this.leftGroup.select('.left.area.bounds').attr('d', boundedArea(leftData));\n    this.rightGroup.select('.right.area.bounds').attr('d', boundedArea(rightData));\n  }\n\n  var valuesLine = _d2.default.svg.line().x(function (d) {\n    return that._x(d.date);\n  }).y(function (d) {\n    return that._y(d.value);\n  }).defined(function (d) {\n    return d.value !== null;\n  });\n\n  this.leftGroup.select('.left.values-line').attr('d', valuesLine(leftData));\n  (0, _chart_utils.drawLineChartDots)(leftData, this.leftGroup, valuesLine, 1);\n\n  this.rightGroup.select('.right.values-line').attr('d', valuesLine(rightData));\n  (0, _chart_utils.drawLineChartDots)(rightData, this.rightGroup, valuesLine, 1);\n\n  // Configure the coordinates of the left and right polygons (which provide opacity).\n  // y extends to the scale min plus the swimlane height.\n  var leftPoly = {\n    l: this._x(minX),\n    t: this._y(minY) + this.swimlaneHeight,\n    r: this._x(this.from),\n    b: 0\n  };\n  var rightPoly = {\n    l: this._x(this.to),\n    t: this._y(minY) + this.swimlaneHeight,\n    r: this._x(maxX),\n    b: 0\n  };\n  this.leftPolygon.attr('points', '' + leftPoly.l + ',' + leftPoly.t + '  ' + leftPoly.r + ',' + leftPoly.t + '  ' + leftPoly.r + ',' + leftPoly.b + '  ' + leftPoly.l + ',' + leftPoly.b);\n  this.rightPolygon.attr('points', '' + rightPoly.l + ',' + rightPoly.t + '  ' + rightPoly.r + ',' + rightPoly.t + '  ' + rightPoly.r + ',' + rightPoly.b + '  ' + rightPoly.l + ',' + rightPoly.b);\n  return this;\n};\n\nContextChartMask.prototype.reveal = function (extent) {\n  this.from = extent[0];\n  this.to = extent[1];\n  this.redraw();\n  return this;\n};",null]}