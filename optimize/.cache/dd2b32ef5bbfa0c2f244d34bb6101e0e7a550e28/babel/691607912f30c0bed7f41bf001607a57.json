{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/explorer/explorer_utils.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/explorer/explorer_utils.js","mtime":1567631712042},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadTopInfluencers = exports.loadDataForCharts = exports.loadAnomaliesTableData = exports.getFilteredTopInfluencers = undefined;\n\nvar getFilteredTopInfluencers = exports.getFilteredTopInfluencers = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(jobIds, earliestMs, latestMs, records, influencers, noInfluencersConfigured) {\n    var recordInfluencersByName, uniqValuesByName, filterInfluencers;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // Filter the Top Influencers list to show just the influencers from\n            // the records in the selected time range.\n            recordInfluencersByName = {};\n\n            // Add the specified influencer(s) to ensure they are used in the filter\n            // even if their influencer score for the selected time range is zero.\n\n            influencers.forEach(function (influencer) {\n              var fieldName = influencer.fieldName;\n              if (recordInfluencersByName[influencer.fieldName] === undefined) {\n                recordInfluencersByName[influencer.fieldName] = [];\n              }\n              recordInfluencersByName[fieldName].push(influencer.fieldValue);\n            });\n\n            // Add the influencers from the top scoring anomalies.\n            records.forEach(function (record) {\n              var influencersByName = record.influencers || [];\n              influencersByName.forEach(function (influencer) {\n                var _recordInfluencersByN;\n\n                var fieldName = influencer.influencer_field_name;\n                var fieldValues = influencer.influencer_field_values;\n                if (recordInfluencersByName[fieldName] === undefined) {\n                  recordInfluencersByName[fieldName] = [];\n                }\n                (_recordInfluencersByN = recordInfluencersByName[fieldName]).push.apply(_recordInfluencersByN, _toConsumableArray(fieldValues));\n              });\n            });\n\n            uniqValuesByName = {};\n\n            Object.keys(recordInfluencersByName).forEach(function (fieldName) {\n              var fieldValues = recordInfluencersByName[fieldName];\n              uniqValuesByName[fieldName] = (0, _lodash.uniq)(fieldValues);\n            });\n\n            filterInfluencers = [];\n\n            Object.keys(uniqValuesByName).forEach(function (fieldName) {\n              // Find record influencers with the same field name as the clicked on cell(s).\n              var matchingFieldName = influencers.find(function (influencer) {\n                return influencer.fieldName === fieldName;\n              });\n\n              if (matchingFieldName !== undefined) {\n                // Filter for the value(s) of the clicked on cell(s).\n                filterInfluencers.push.apply(filterInfluencers, _toConsumableArray(influencers));\n              } else {\n                // For other field names, add values from all records.\n                uniqValuesByName[fieldName].forEach(function (fieldValue) {\n                  filterInfluencers.push({ fieldName: fieldName, fieldValue: fieldValue });\n                });\n              }\n            });\n\n            _context.next = 9;\n            return loadTopInfluencers(jobIds, earliestMs, latestMs, filterInfluencers, noInfluencersConfigured);\n\n          case 9:\n            return _context.abrupt('return', _context.sent);\n\n          case 10:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function getFilteredTopInfluencers(_x, _x2, _x3, _x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar loadAnomaliesTableData = exports.loadAnomaliesTableData = function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(selectedCells, selectedJobs, dateFormatTz, interval, bounds, fieldName) {\n    var jobIds, influencers, timeRange;\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            jobIds = selectedCells !== null && selectedCells.viewByFieldName === _explorer_constants.VIEW_BY_JOB_LABEL ? selectedCells.lanes : selectedJobs.map(function (d) {\n              return d.id;\n            });\n            influencers = getSelectionInfluencers(selectedCells, fieldName);\n            timeRange = getSelectionTimeRange(selectedCells, interval, bounds);\n            return _context2.abrupt('return', new Promise(function (resolve, reject) {\n              _ml_api_service.ml.results.getAnomaliesTableData(jobIds, [], influencers, _select_interval.mlSelectIntervalService.state.get('interval').val, _select_severity.mlSelectSeverityService.state.get('threshold').val, timeRange.earliestMs, timeRange.latestMs, dateFormatTz, _search.ANOMALIES_TABLE_DEFAULT_QUERY_SIZE, _explorer_constants.MAX_CATEGORY_EXAMPLES).then(function (resp) {\n                var anomalies = resp.anomalies;\n                var detectorsByJob = _job_service.mlJobService.detectorsByJob;\n                anomalies.forEach(function (anomaly) {\n                  // Add a detector property to each anomaly.\n                  // Default to functionDescription if no description available.\n                  // TODO - when job_service is moved server_side, move this to server endpoint.\n                  var jobId = anomaly.jobId;\n                  var detector = (0, _lodash.get)(detectorsByJob, [jobId, anomaly.detectorIndex]);\n                  anomaly.detector = (0, _lodash.get)(detector, ['detector_description'], anomaly.source.function_description);\n\n                  // For detectors with rules, add a property with the rule count.\n                  if (detector !== undefined && detector.custom_rules !== undefined) {\n                    anomaly.rulesLength = detector.custom_rules.length;\n                  }\n\n                  // Add properties used for building the links menu.\n                  // TODO - when job_service is moved server_side, move this to server endpoint.\n                  anomaly.isTimeSeriesViewDetector = (0, _job_utils.isTimeSeriesViewDetector)(_job_service.mlJobService.getJob(jobId), anomaly.detectorIndex);\n                  if (_job_service.mlJobService.customUrlsByJob[jobId] !== undefined) {\n                    anomaly.customUrls = _job_service.mlJobService.customUrlsByJob[jobId];\n                  }\n                });\n\n                resolve({\n                  anomalies: anomalies,\n                  interval: resp.interval,\n                  examplesByJobId: resp.examplesByJobId,\n                  showViewSeriesLink: true,\n                  jobIds: jobIds\n                });\n              }).catch(function (resp) {\n                console.log('Explorer - error loading data for anomalies table:', resp);\n                reject();\n              });\n            }));\n\n          case 4:\n          case 'end':\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n\n  return function loadAnomaliesTableData(_x8, _x9, _x10, _x11, _x12, _x13) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n// track the request to be able to ignore out of date requests\n// and avoid race conditions ending up with the wrong charts.\n\n\nvar loadDataForCharts = exports.loadDataForCharts = function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(jobIds, earliestMs, latestMs) {\n    var influencers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    var selectedCells = arguments[4];\n    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt('return', new Promise(function (resolve) {\n              // Just skip doing the request when this function\n              // is called without the minimum required data.\n              if (selectedCells === null && influencers.length === 0) {\n                resolve([]);\n              }\n\n              var newRequestCount = ++requestCount;\n              requestCount = newRequestCount;\n\n              // Load the top anomalies (by record_score) which will be displayed in the charts.\n              _results_service.mlResultsService.getRecordsForInfluencer(jobIds, influencers, 0, earliestMs, latestMs, 500).then(function (resp) {\n                // Ignore this response if it's returned by an out of date promise\n                if (newRequestCount < requestCount) {\n                  resolve(undefined);\n                }\n\n                if (selectedCells !== null && Object.keys(selectedCells).length > 0) {\n                  console.log('Explorer anomaly charts data set:', resp.records);\n                  resolve(resp.records);\n                }\n\n                resolve(undefined);\n              });\n            }));\n\n          case 1:\n          case 'end':\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this);\n  }));\n\n  return function loadDataForCharts(_x15, _x16, _x17) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar loadTopInfluencers = exports.loadTopInfluencers = function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(selectedJobIds, earliestMs, latestMs) {\n    var influencers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    var noInfluencersConfigured = arguments[4];\n    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt('return', new Promise(function (resolve) {\n              if (noInfluencersConfigured !== true) {\n                _results_service.mlResultsService.getTopInfluencers(selectedJobIds, earliestMs, latestMs, _explorer_constants.MAX_INFLUENCER_FIELD_VALUES, influencers).then(function (resp) {\n                  // TODO - sort the influencers keys so that the partition field(s) are first.\n                  console.log('Explorer top influencers data set:', resp.influencers);\n                  resolve(resp.influencers);\n                });\n              } else {\n                resolve({});\n              }\n            }));\n\n          case 1:\n          case 'end':\n            return _context4.stop();\n        }\n      }\n    }, _callee4, this);\n  }));\n\n  return function loadTopInfluencers(_x19, _x20, _x21) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.createJobs = createJobs;\nexports.getClearedSelectedAnomaliesState = getClearedSelectedAnomaliesState;\nexports.getDefaultViewBySwimlaneData = getDefaultViewBySwimlaneData;\nexports.mapScopeToProps = mapScopeToProps;\nexports.selectedJobsHaveInfluencers = selectedJobsHaveInfluencers;\nexports.getFieldsByJob = getFieldsByJob;\nexports.getSelectionTimeRange = getSelectionTimeRange;\nexports.getSelectionInfluencers = getSelectionInfluencers;\nexports.getViewBySwimlaneOptions = getViewBySwimlaneOptions;\nexports.processOverallResults = processOverallResults;\nexports.processViewByResults = processViewByResults;\nexports.loadAnnotationsTableData = loadAnnotationsTableData;\n\nvar _lodash = require('lodash');\n\nvar _parse_interval = require('ui/utils/parse_interval');\n\nvar _job_utils = require('../../common/util/job_utils');\n\nvar _ml_api_service = require('../services/ml_api_service');\n\nvar _job_service = require('../services/job_service');\n\nvar _results_service = require('plugins/ml/services/results_service');\n\nvar _select_interval = require('../components/controls/select_interval/select_interval');\n\nvar _select_severity = require('../components/controls/select_severity/select_severity');\n\nvar _explorer_constants = require('./explorer_constants');\n\nvar _search = require('../../common/constants/search');\n\nvar _i18n = require('@kbn/i18n');\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */\n\n/*\n * utils for Anomaly Explorer.\n */\n\nvar mlAnnotationsEnabled = _chrome2.default.getInjected('mlAnnotationsEnabled', false);\n\n// create new job objects based on standard job config objects\n// new job objects just contain job id, bucket span in seconds and a selected flag.\nfunction createJobs(jobs) {\n  return jobs.map(function (job) {\n    var bucketSpan = (0, _parse_interval.parseInterval)(job.analysis_config.bucket_span);\n    return { id: job.job_id, selected: false, bucketSpanSeconds: bucketSpan.asSeconds() };\n  });\n}\n\nfunction getClearedSelectedAnomaliesState() {\n  return {\n    anomalyChartRecords: [],\n    selectedCells: null,\n    viewByLoadedForTimeFormatted: null\n  };\n}\n\nfunction getDefaultViewBySwimlaneData() {\n  return {\n    fieldName: '',\n    laneLabels: [],\n    points: [],\n    interval: 3600\n  };\n}\n\nfunction mapScopeToProps(scope) {\n  return {\n    appStateHandler: scope.appStateHandler,\n    dateFormatTz: scope.dateFormatTz,\n    mlJobSelectService: scope.mlJobSelectService,\n    MlTimeBuckets: scope.MlTimeBuckets\n  };\n}\n\nfunction selectedJobsHaveInfluencers() {\n  var selectedJobs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var hasInfluencers = false;\n  selectedJobs.forEach(function (selectedJob) {\n    var job = _job_service.mlJobService.getJob(selectedJob.id);\n    var influencers = [];\n    if (job !== undefined) {\n      influencers = job.analysis_config.influencers || [];\n    }\n    hasInfluencers = hasInfluencers || influencers.length > 0;\n  });\n  return hasInfluencers;\n}\n\nfunction getFieldsByJob() {\n  return _job_service.mlJobService.jobs.reduce(function (reducedFieldsByJob, job) {\n    // Add the list of distinct by, over, partition and influencer fields for each job.\n    var analysisConfig = job.analysis_config;\n    var influencers = analysisConfig.influencers || [];\n    var fieldsForJob = (analysisConfig.detectors || []).reduce(function (reducedfieldsForJob, detector) {\n      if (detector.partition_field_name !== undefined) {\n        reducedfieldsForJob.push(detector.partition_field_name);\n      }\n      if (detector.over_field_name !== undefined) {\n        reducedfieldsForJob.push(detector.over_field_name);\n      }\n      // For jobs with by and over fields, don't add the 'by' field as this\n      // field will only be added to the top-level fields for record type results\n      // if it also an influencer over the bucket.\n      if (detector.by_field_name !== undefined && detector.over_field_name === undefined) {\n        reducedfieldsForJob.push(detector.by_field_name);\n      }\n      return reducedfieldsForJob;\n    }, []).concat(influencers);\n\n    reducedFieldsByJob[job.job_id] = (0, _lodash.uniq)(fieldsForJob);\n    reducedFieldsByJob['*'] = (0, _lodash.union)(reducedFieldsByJob['*'], reducedFieldsByJob[job.job_id]);\n    return reducedFieldsByJob;\n  }, { '*': [] });\n}\n\nfunction getSelectionTimeRange(selectedCells, interval, bounds) {\n  // Returns the time range of the cell(s) currently selected in the swimlane.\n  // If no cell(s) are currently selected, returns the dashboard time range.\n  var earliestMs = bounds.min.valueOf();\n  var latestMs = bounds.max.valueOf();\n\n  if (selectedCells !== null && selectedCells.times !== undefined) {\n    // time property of the cell data is an array, with the elements being\n    // the start times of the first and last cell selected.\n    earliestMs = selectedCells.times[0] !== undefined ? selectedCells.times[0] * 1000 : bounds.min.valueOf();\n    latestMs = bounds.max.valueOf();\n    if (selectedCells.times[1] !== undefined) {\n      // Subtract 1 ms so search does not include start of next bucket.\n      latestMs = (selectedCells.times[1] + interval) * 1000 - 1;\n    }\n  }\n\n  return { earliestMs: earliestMs, latestMs: latestMs };\n}\n\nfunction getSelectionInfluencers(selectedCells, fieldName) {\n  if (selectedCells !== null && selectedCells.viewByFieldName !== undefined && selectedCells.viewByFieldName !== _explorer_constants.VIEW_BY_JOB_LABEL) {\n    return selectedCells.lanes.map(function (laneLabel) {\n      return { fieldName: fieldName, fieldValue: laneLabel };\n    });\n  }\n\n  return [];\n}\n\n// Obtain the list of 'View by' fields per job and swimlaneViewByFieldName\nfunction getViewBySwimlaneOptions(selectedJobs, currentSwimlaneViewByFieldName) {\n  var selectedJobIds = selectedJobs.map(function (d) {\n    return d.id;\n  });\n\n  // Unique influencers for the selected job(s).\n  var viewByOptions = (0, _lodash.chain)(_job_service.mlJobService.jobs.reduce(function (reducedViewByOptions, job) {\n    if (selectedJobIds.some(function (jobId) {\n      return jobId === job.job_id;\n    })) {\n      return reducedViewByOptions.concat(job.analysis_config.influencers || []);\n    }\n    return reducedViewByOptions;\n  }, [])).uniq().sortBy(function (fieldName) {\n    return fieldName.toLowerCase();\n  }).value();\n\n  viewByOptions.push(_explorer_constants.VIEW_BY_JOB_LABEL);\n  var viewBySwimlaneOptions = viewByOptions;\n\n  var swimlaneViewByFieldName = undefined;\n\n  if (viewBySwimlaneOptions.indexOf(currentSwimlaneViewByFieldName) !== -1) {\n    // Set the swimlane viewBy to that stored in the state (URL) if set.\n    // This means we reset it to the current state because it was set by the listener\n    // on initialization.\n    swimlaneViewByFieldName = currentSwimlaneViewByFieldName;\n  } else {\n    if (selectedJobIds.length > 1) {\n      // If more than one job selected, default to job ID.\n      swimlaneViewByFieldName = _explorer_constants.VIEW_BY_JOB_LABEL;\n    } else {\n      // For a single job, default to the first partition, over,\n      // by or influencer field of the first selected job.\n      var firstSelectedJob = _job_service.mlJobService.jobs.find(function (job) {\n        return job.job_id === selectedJobIds[0];\n      });\n\n      var firstJobInfluencers = firstSelectedJob.analysis_config.influencers || [];\n      firstSelectedJob.analysis_config.detectors.forEach(function (detector) {\n        if (detector.partition_field_name !== undefined && firstJobInfluencers.indexOf(detector.partition_field_name) !== -1) {\n          swimlaneViewByFieldName = detector.partition_field_name;\n          return false;\n        }\n\n        if (detector.over_field_name !== undefined && firstJobInfluencers.indexOf(detector.over_field_name) !== -1) {\n          swimlaneViewByFieldName = detector.over_field_name;\n          return false;\n        }\n\n        // For jobs with by and over fields, don't add the 'by' field as this\n        // field will only be added to the top-level fields for record type results\n        // if it also an influencer over the bucket.\n        if (detector.by_field_name !== undefined && detector.over_field_name === undefined && firstJobInfluencers.indexOf(detector.by_field_name) !== -1) {\n          swimlaneViewByFieldName = detector.by_field_name;\n          return false;\n        }\n      });\n\n      if (swimlaneViewByFieldName === undefined) {\n        if (firstJobInfluencers.length > 0) {\n          swimlaneViewByFieldName = firstJobInfluencers[0];\n        } else {\n          // No influencers for first selected job - set to first available option.\n          swimlaneViewByFieldName = viewBySwimlaneOptions.length > 0 ? viewBySwimlaneOptions[0] : undefined;\n        }\n      }\n    }\n  }\n\n  return {\n    swimlaneViewByFieldName: swimlaneViewByFieldName,\n    viewBySwimlaneOptions: viewBySwimlaneOptions\n  };\n}\n\nfunction processOverallResults(scoresByTime, searchBounds, interval) {\n  var overallLabel = _i18n.i18n.translate('xpack.ml.explorer.overallLabel', { defaultMessage: 'Overall' });\n  var dataset = {\n    laneLabels: [overallLabel],\n    points: [],\n    interval: interval,\n    earliest: searchBounds.min.valueOf() / 1000,\n    latest: searchBounds.max.valueOf() / 1000\n  };\n\n  if (Object.keys(scoresByTime).length > 0) {\n    // Store the earliest and latest times of the data returned by the ES aggregations,\n    // These will be used for calculating the earliest and latest times for the swimlane charts.\n    (0, _lodash.each)(scoresByTime, function (score, timeMs) {\n      var time = timeMs / 1000;\n      dataset.points.push({\n        laneLabel: overallLabel,\n        time: time,\n        value: score\n      });\n\n      dataset.earliest = Math.min(time, dataset.earliest);\n      dataset.latest = Math.max(time + dataset.interval, dataset.latest);\n    });\n  }\n\n  return dataset;\n}\n\nfunction processViewByResults(scoresByInfluencerAndTime, sortedLaneValues, overallSwimlaneData, swimlaneViewByFieldName, interval) {\n  // Processes the scores for the 'view by' swimlane.\n  // Sorts the lanes according to the supplied array of lane\n  // values in the order in which they should be displayed,\n  // or pass an empty array to sort lanes according to max score over all time.\n  var dataset = {\n    fieldName: swimlaneViewByFieldName,\n    points: [],\n    interval: interval\n  };\n\n  // Set the earliest and latest to be the same as the overall swimlane.\n  dataset.earliest = overallSwimlaneData.earliest;\n  dataset.latest = overallSwimlaneData.latest;\n\n  var laneLabels = [];\n  var maxScoreByLaneLabel = {};\n\n  (0, _lodash.each)(scoresByInfluencerAndTime, function (influencerData, influencerFieldValue) {\n    laneLabels.push(influencerFieldValue);\n    maxScoreByLaneLabel[influencerFieldValue] = 0;\n\n    (0, _lodash.each)(influencerData, function (anomalyScore, timeMs) {\n      var time = timeMs / 1000;\n      dataset.points.push({\n        laneLabel: influencerFieldValue,\n        time: time,\n        value: anomalyScore\n      });\n      maxScoreByLaneLabel[influencerFieldValue] = Math.max(maxScoreByLaneLabel[influencerFieldValue], anomalyScore);\n    });\n  });\n\n  var sortValuesLength = sortedLaneValues.length;\n  if (sortValuesLength === 0) {\n    // Sort lanes in descending order of max score.\n    // Note the keys in scoresByInfluencerAndTime received from the ES request\n    // are not guaranteed to be sorted by score if they can be parsed as numbers\n    // (e.g. if viewing by HTTP response code).\n    dataset.laneLabels = laneLabels.sort(function (a, b) {\n      return maxScoreByLaneLabel[b] - maxScoreByLaneLabel[a];\n    });\n  } else {\n    // Sort lanes according to supplied order\n    // e.g. when a cell in the overall swimlane has been selected.\n    // Find the index of each lane label from the actual data set,\n    // rather than using sortedLaneValues as-is, just in case they differ.\n    dataset.laneLabels = laneLabels.sort(function (a, b) {\n      var aIndex = sortedLaneValues.indexOf(a);\n      var bIndex = sortedLaneValues.indexOf(b);\n      aIndex = aIndex > -1 ? aIndex : sortValuesLength;\n      bIndex = bIndex > -1 ? bIndex : sortValuesLength;\n      return aIndex - bIndex;\n    });\n  }\n\n  return dataset;\n}\n\nfunction loadAnnotationsTableData(selectedCells, selectedJobs, interval, bounds) {\n  var jobIds = selectedCells !== null && selectedCells.viewByFieldName === _explorer_constants.VIEW_BY_JOB_LABEL ? selectedCells.lanes : selectedJobs.map(function (d) {\n    return d.id;\n  });\n  var timeRange = getSelectionTimeRange(selectedCells, interval, bounds);\n\n  if (mlAnnotationsEnabled === false) {\n    return Promise.resolve([]);\n  }\n\n  return new Promise(function (resolve) {\n    _ml_api_service.ml.annotations.getAnnotations({\n      jobIds: jobIds,\n      earliestMs: timeRange.earliestMs,\n      latestMs: timeRange.latestMs,\n      maxAnnotations: _search.ANNOTATIONS_TABLE_DEFAULT_QUERY_SIZE\n    }).then(function (resp) {\n      if (resp.error !== undefined || resp.annotations === undefined) {\n        return resolve([]);\n      }\n\n      var annotationsData = [];\n      jobIds.forEach(function (jobId) {\n        var jobAnnotations = resp.annotations[jobId];\n        if (jobAnnotations !== undefined) {\n          annotationsData.push.apply(annotationsData, _toConsumableArray(jobAnnotations));\n        }\n      });\n\n      return resolve(annotationsData.sort(function (a, b) {\n        return a.timestamp - b.timestamp;\n      }).map(function (d, i) {\n        d.key = String.fromCharCode(65 + i);\n        return d;\n      }));\n    }).catch(function (resp) {\n      console.log('Error loading list of annotations for jobs list:', resp);\n      // Silently fail and just return an empty array for annotations to not break the UI.\n      return resolve([]);\n    });\n  });\n}\n\nvar requestCount = 0;",null]}