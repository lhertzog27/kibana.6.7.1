{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/datavisualizer/datavisualizer_controller.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/datavisualizer/datavisualizer_controller.js","mtime":1567631712037},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\n/*\n  * Angular controller for the Machine Learning data visualizer which allows the user\n  * to explore the data in the fields in an index pattern prior to creating a job.\n  */\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _risonNode = require('rison-node');\n\nvar _risonNode2 = _interopRequireDefault(_risonNode);\n\nrequire('plugins/ml/components/form_filter_input');\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _routes = require('ui/routes');\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nvar _esQuery = require('@kbn/es-query');\n\nvar _notify = require('ui/notify');\n\nvar _field_types = require('plugins/ml/../common/constants/field_types');\n\nvar _field_types_utils = require('plugins/ml/util/field_types_utils');\n\nvar _ml_time_buckets = require('plugins/ml/util/ml_time_buckets');\n\nvar _check_license = require('plugins/ml/license/check_license');\n\nvar _check_privilege = require('plugins/ml/privilege/check_privilege');\n\nvar _new_job_utils = require('plugins/ml/jobs/new_job/utils/new_job_utils');\n\nvar _index_utils = require('plugins/ml/util/index_utils');\n\nvar _check_ml_nodes = require('plugins/ml/ml_nodes_check/check_ml_nodes');\n\nvar _ml_api_service = require('plugins/ml/services/ml_api_service');\n\nvar _datavisualizer = require('./datavisualizer.html');\n\nvar _datavisualizer2 = _interopRequireDefault(_datavisualizer);\n\nvar _timefilter = require('ui/timefilter');\n\nvar _modules = require('ui/modules');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_routes2.default.when('/jobs/new_job/datavisualizer', {\n  template: _datavisualizer2.default,\n  resolve: {\n    CheckLicense: _check_license.checkBasicLicense,\n    privileges: _check_privilege.checkGetJobsPrivilege,\n    indexPattern: _index_utils.loadCurrentIndexPattern,\n    savedSearch: _index_utils.loadCurrentSavedSearch,\n    checkMlNodesAvailable: _check_ml_nodes.checkMlNodesAvailable\n  }\n});\n\nvar _module = _modules.uiModules.get('apps/ml');\n\n_module.controller('MlDataVisualizerViewFields', function ($scope, $timeout, $window, Private, AppState, config, i18n) {\n\n  _timefilter.timefilter.enableTimeRangeSelector();\n  _timefilter.timefilter.enableAutoRefreshSelector();\n\n  var createSearchItems = Private(_new_job_utils.SearchItemsProvider);\n\n  var _createSearchItems = createSearchItems(),\n      indexPattern = _createSearchItems.indexPattern,\n      query = _createSearchItems.query;\n\n  (0, _index_utils.timeBasedIndexCheck)(indexPattern, true);\n\n  // List of system fields we don't want to display.\n  // TODO - are we happy to ignore these fields?\n  var OMIT_FIELDS = ['_source', '_type', '_index', '_id', '_version', '_score'];\n\n  $scope.metricCards = [];\n  $scope.totalMetricFieldCount = 0;\n  $scope.populatedMetricFieldCount = 0;\n  $scope.showAllMetrics = false;\n  $scope.fieldCards = [];\n  $scope.totalNonMetricFieldCount = 0;\n  $scope.populatedNonMetricFieldCount = 0;\n  $scope.ML_JOB_FIELD_TYPES = _field_types.ML_JOB_FIELD_TYPES;\n  $scope.showAllFields = false;\n  $scope.filterFieldType = '*';\n  $scope.urlBasePath = _chrome2.default.getBasePath();\n  $scope.appState = new AppState();\n\n  $scope.indexPattern = indexPattern;\n  $scope.earliest = _timefilter.timefilter.getActiveBounds().min.valueOf();\n  $scope.latest = _timefilter.timefilter.getActiveBounds().max.valueOf();\n\n  $scope.metricFilterIcon = 0;\n  $scope.metricFieldFilter = '';\n  $scope.fieldFilterIcon = 0;\n  $scope.fieldFilter = '';\n  $scope.recognizerResults = {\n    count: 0,\n    onChange: function onChange() {\n      $scope.$applyAsync();\n    }\n  };\n\n  $scope.showSidebar = (0, _check_license.isFullLicense)();\n\n  // Check for a saved query in the AppState or via a savedSearchId in the URL.\n  // TODO - add in support for lucene queries with filters and Kuery.\n  $scope.searchQueryText = '';\n  var queryBarQry = $scope.appState.query !== undefined ? $scope.appState.query : query;\n  if (queryBarQry.language === 'lucene') {\n    $scope.searchQueryText = _lodash2.default.get(queryBarQry, 'query', '');\n  } else {\n    _notify.toastNotifications.addWarning({\n      title: i18n('xpack.ml.datavisualizer.languageSyntaxNotSupportedWarningTitle', {\n        defaultMessage: '{language} syntax not supported',\n        values: {\n          language: queryBarQry.language !== undefined ? queryBarQry.language : ''\n        }\n      }),\n      text: i18n('xpack.ml.datavisualizer.languageSyntaxNotSupportedWarningDescription', {\n        defaultMessage: 'The Data Visualizer currently only supports queries using the lucene query syntax.'\n      })\n    });\n  }\n\n  $scope.searchQuery = buildSearchQuery();\n\n  $scope.samplerShardSize = $scope.appState.samplerShardSize ? $scope.appState.samplerShardSize : 5000; // -1 indicates no sampling.\n\n  var MlTimeBuckets = Private(_ml_time_buckets.IntervalHelperProvider);\n\n  var metricFieldRegexp = void 0;\n  var metricFieldFilterTimeout = void 0;\n  var fieldRegexp = void 0;\n  var fieldFilterTimeout = void 0;\n\n  // Obtain the list of non metric field types which appear in the index pattern.\n  var indexedFieldTypes = [];\n  _lodash2.default.each(indexPattern.fields, function (field) {\n    if (!field.scripted) {\n      var dataVisualizerType = (0, _field_types_utils.kbnTypeToMLJobType)(field);\n      if (dataVisualizerType !== undefined) {\n        indexedFieldTypes.push(dataVisualizerType);\n      }\n    }\n  });\n  indexedFieldTypes = _lodash2.default.chain(indexedFieldTypes).unique().without(_field_types.ML_JOB_FIELD_TYPES.NUMBER).value();\n  $scope.indexedFieldTypes = indexedFieldTypes.sort();\n\n  // Refresh the data when the time range is altered.\n  $scope.$listenAndDigestAsync(_timefilter.timefilter, 'fetch', function () {\n    $scope.earliest = _timefilter.timefilter.getActiveBounds().min.valueOf();\n    $scope.latest = _timefilter.timefilter.getActiveBounds().max.valueOf();\n    loadOverallStats();\n  });\n\n  $scope.submitSearchQuery = function () {\n    $scope.searchQuery = buildSearchQuery();\n    saveAppState();\n    loadOverallStats();\n  };\n\n  $scope.samplerShardSizeChanged = function () {\n    saveAppState();\n    loadOverallStats();\n  };\n\n  $scope.toggleAllMetrics = function () {\n    $scope.showAllMetrics = !$scope.showAllMetrics;\n    createMetricCards();\n  };\n\n  $scope.toggleAllFields = function () {\n    $scope.showAllFields = !$scope.showAllFields;\n    createNonMetricCards();\n  };\n\n  $scope.filterFieldTypeChanged = function (fieldType) {\n    $scope.filterFieldType = fieldType;\n    createNonMetricCards();\n  };\n\n  $scope.metricFieldFilterChanged = function () {\n    // Clear the previous filter timeout.\n    if (metricFieldFilterTimeout !== undefined) {\n      $timeout.cancel(metricFieldFilterTimeout);\n    }\n\n    // Create a timeout to recreate the metric configurations based on the filter.\n    // A timeout of 1.5s is used as the user may still be in the process of typing the filter\n    // when this function is first called.\n    metricFieldFilterTimeout = $timeout(function () {\n      if ($scope.metricFieldFilter && $scope.metricFieldFilter !== '') {\n        metricFieldRegexp = new RegExp('(' + $scope.metricFieldFilter + ')', 'gi');\n      } else {\n        metricFieldRegexp = undefined;\n      }\n\n      createMetricCards();\n      metricFieldFilterTimeout = undefined;\n    }, 1500);\n\n    // Display the spinner icon after 250ms of typing.\n    // The spinner is a nice way of showing that something is\n    // happening as we're stalling for the user to stop typing.\n    $timeout(function () {\n      $scope.metricFilterIcon = 1;\n    }, 250);\n  };\n\n  $scope.clearMetricFilter = function () {\n    $scope.metricFieldFilter = '';\n    metricFieldRegexp = undefined;\n    createMetricCards();\n  };\n\n  $scope.fieldFilterChanged = function () {\n    // Clear the previous filter timeout.\n    if (fieldFilterTimeout !== undefined) {\n      $timeout.cancel(fieldFilterTimeout);\n    }\n\n    // Create a timeout to recreate the non-metric field configurations based on the filter.\n    // A timeout of 1.5s is used as the user may still be in the process of typing the filter\n    // when this function is first called.\n    fieldFilterTimeout = $timeout(function () {\n      if ($scope.fieldFilter && $scope.fieldFilter !== '') {\n        fieldRegexp = new RegExp('(' + $scope.fieldFilter + ')', 'gi');\n      } else {\n        fieldRegexp = undefined;\n      }\n\n      createNonMetricCards();\n      fieldFilterTimeout = undefined;\n    }, 1500);\n\n    // Display the spinner icon after 250ms of typing.\n    // the spinner is a nice way of showing that something is\n    // happening as we're stalling for the user to stop trying.\n    $timeout(function () {\n      $scope.fieldFilterIcon = 1;\n    }, 250);\n  };\n\n  $scope.clearFieldFilter = function () {\n    $scope.fieldFilter = '';\n    fieldRegexp = undefined;\n    createNonMetricCards();\n  };\n\n  $scope.createJob = function () {\n    // TODO - allow the user to select metrics and fields and use\n    // the selection to open the appropriate job wizard (single, multi-metric etc).\n    // For now just open the Advanced wizard, passing in the index pattern ID.\n    var _a = _risonNode2.default.encode({\n      query: {\n        language: 'lucene',\n        query: $scope.searchQueryText\n      }\n    });\n\n    var path = $scope.urlBasePath + '/app/ml#/jobs/new_job/advanced?index=' + $scope.indexPattern + '&_a=' + _a;\n    $window.open(path, '_self');\n  };\n\n  function buildSearchQuery() {\n    var searchQuery = (0, _esQuery.luceneStringToDsl)($scope.searchQueryText);\n    var queryStringOptions = config.get('query:queryString:options');\n    (0, _esQuery.decorateQuery)(searchQuery, queryStringOptions);\n    return searchQuery;\n  }\n\n  function saveAppState() {\n    $scope.appState.query = {\n      language: 'lucene',\n      query: $scope.searchQueryText\n    };\n    $scope.appState.samplerShardSize = $scope.samplerShardSize;\n    $scope.appState.save();\n  }\n\n  function createMetricCards() {\n    $scope.metricCards.length = 0;\n\n    var aggregatableExistsFields = $scope.overallStats.aggregatableExistsFields || [];\n\n    var allMetricFields = [];\n    if (metricFieldRegexp === undefined) {\n      allMetricFields = _lodash2.default.filter(indexPattern.fields, function (f) {\n        return f.type === _field_types.KBN_FIELD_TYPES.NUMBER && !_lodash2.default.contains(OMIT_FIELDS, f.displayName);\n      });\n    } else {\n      allMetricFields = _lodash2.default.filter(indexPattern.fields, function (f) {\n        return f.type === _field_types.KBN_FIELD_TYPES.NUMBER && !_lodash2.default.contains(OMIT_FIELDS, f.displayName) && f.displayName.match(metricFieldRegexp);\n      });\n    }\n\n    var metricExistsFields = _lodash2.default.filter(allMetricFields, function (f) {\n      return _lodash2.default.find(aggregatableExistsFields, { fieldName: f.displayName });\n    });\n\n    var metricCards = [];\n\n    // Add a config for 'document count', identified by no field name if index is timeseries based\n    if (indexPattern.timeFieldName !== undefined) {\n      metricCards.push({\n        type: _field_types.ML_JOB_FIELD_TYPES.NUMBER,\n        existsInDocs: true,\n        loading: true\n      });\n    } else {\n      // disable timeRangeSelector and remove sidebar if index not timeseries based\n      _timefilter.timefilter.disableTimeRangeSelector();\n      $scope.showSidebar = false;\n    }\n\n    // Add on 1 for the document count card.\n    // TODO - remove the '+1' if document count goes in its own section.\n    $scope.totalMetricFieldCount = allMetricFields.length + 1;\n    $scope.populatedMetricFieldCount = metricExistsFields.length + 1;\n    if ($scope.totalMetricFieldCount === $scope.populatedMetricFieldCount) {\n      $scope.showAllMetrics = true;\n    }\n\n    var aggregatableFields = $scope.overallStats.aggregatableExistsFields;\n    if ($scope.showAllMetrics === true) {\n      aggregatableFields = aggregatableFields.concat($scope.overallStats.aggregatableNotExistsFields);\n    }\n\n    var metricFields = $scope.showAllMetrics ? allMetricFields : metricExistsFields;\n    _lodash2.default.each(metricFields, function (field) {\n      var fieldData = _lodash2.default.find(aggregatableFields, { fieldName: field.displayName });\n\n      var card = _extends({}, fieldData, {\n        fieldFormat: field.format,\n        type: _field_types.ML_JOB_FIELD_TYPES.NUMBER,\n        loading: true\n      });\n\n      metricCards.push(card);\n    });\n\n    $scope.metricCards = metricCards;\n    loadMetricFieldStats();\n  }\n\n  function createNonMetricCards() {\n    $scope.fieldCards.length = 0;\n\n    var allNonMetricFields = [];\n    if ($scope.filterFieldType === '*') {\n      allNonMetricFields = _lodash2.default.filter(indexPattern.fields, function (f) {\n        return f.type !== _field_types.KBN_FIELD_TYPES.NUMBER && !_lodash2.default.contains(OMIT_FIELDS, f.displayName);\n      });\n    } else {\n      if ($scope.filterFieldType === _field_types.ML_JOB_FIELD_TYPES.TEXT || $scope.filterFieldType === _field_types.ML_JOB_FIELD_TYPES.KEYWORD) {\n        var aggregatableCheck = $scope.filterFieldType === _field_types.ML_JOB_FIELD_TYPES.KEYWORD ? true : false;\n        allNonMetricFields = _lodash2.default.filter(indexPattern.fields, function (f) {\n          return !_lodash2.default.contains(OMIT_FIELDS, f.displayName) && f.type === _field_types.KBN_FIELD_TYPES.STRING && f.aggregatable === aggregatableCheck;\n        });\n      } else {\n        allNonMetricFields = _lodash2.default.filter(indexPattern.fields, function (f) {\n          return !_lodash2.default.contains(OMIT_FIELDS, f.displayName) && f.type === $scope.filterFieldType;\n        });\n      }\n    }\n\n    // If a field filter has been entered, perform another filter on the entered regexp.\n    if (fieldRegexp !== undefined) {\n      allNonMetricFields = _lodash2.default.filter(allNonMetricFields, function (f) {\n        return f.displayName.match(fieldRegexp);\n      });\n    }\n\n    $scope.totalNonMetricFieldCount = allNonMetricFields.length;\n\n    // Obtain the list of all non-metric fields which appear in documents\n    // (aggregatable or not aggregatable).\n    var populatedNonMetricFields = []; // Kibana index pattern non metric fields.\n    var nonMetricFieldData = []; // Basic non metric field data loaded from requesting overall stats.\n    var populatedNonMetricFieldCount = 0;\n    _lodash2.default.each(allNonMetricFields, function (f) {\n      var checkAggregatableField = _lodash2.default.find($scope.overallStats.aggregatableExistsFields, { fieldName: f.displayName });\n      if (checkAggregatableField !== undefined) {\n        populatedNonMetricFields.push(f);\n        nonMetricFieldData.push(checkAggregatableField);\n        populatedNonMetricFieldCount++;\n      } else {\n        var checkNonAggregatableField = _lodash2.default.find($scope.overallStats.nonAggregatableExistsFields, { fieldName: f.displayName });\n        if (checkNonAggregatableField !== undefined) {\n          populatedNonMetricFields.push(f);\n          nonMetricFieldData.push(checkNonAggregatableField);\n          populatedNonMetricFieldCount++;\n        }\n      }\n    });\n\n    $scope.populatedNonMetricFieldCount = populatedNonMetricFieldCount;\n    if ($scope.totalNonMetricFieldCount === $scope.populatedNonMetricFieldCount) {\n      $scope.showAllFields = true;\n    }\n\n    var nonMetricFieldsToShow = $scope.showAllFields === true ? allNonMetricFields : populatedNonMetricFields;\n\n    // Combine the field data obtained from Elasticsearch into a single array.\n    if ($scope.showAllFields === true) {\n      nonMetricFieldData = nonMetricFieldData.concat($scope.overallStats.aggregatableNotExistsFields, $scope.overallStats.nonAggregatableNotExistsFields);\n    }\n\n    var fieldCards = [];\n\n    _lodash2.default.each(nonMetricFieldsToShow, function (field) {\n      var fieldData = _lodash2.default.find(nonMetricFieldData, { fieldName: field.displayName });\n\n      var card = _extends({}, fieldData, {\n        fieldFormat: field.format,\n        aggregatable: field.aggregatable,\n        scripted: field.scripted,\n        loading: fieldData.existsInDocs\n      });\n\n      // Map the field type from the Kibana index pattern to the field type\n      // used in the data visualizer.\n      var dataVisualizerType = (0, _field_types_utils.kbnTypeToMLJobType)(field);\n      if (dataVisualizerType !== undefined) {\n        card.type = dataVisualizerType;\n      } else {\n        // Add a flag to indicate that this is one of the 'other' Kibana\n        // field types that do not yet have a specific card type.\n        card.type = field.type;\n        card.isUnsupportedType = true;\n      }\n\n      fieldCards.push(card);\n    });\n\n    $scope.fieldCards = _lodash2.default.sortBy(fieldCards, 'fieldName');\n    loadNonMetricFieldStats();\n  }\n\n  function loadMetricFieldStats() {\n    // Only request data for fields that exist in documents.\n    var numberFields = _lodash2.default.filter($scope.metricCards, { existsInDocs: true });\n\n    // Pass the field name, type and cardinality in the request.\n    // Top values will be obtained on a sample if cardinality > 100000.\n    numberFields = _lodash2.default.map(numberFields, function (card) {\n      var props = { fieldName: card.fieldName, type: card.type };\n      if (_lodash2.default.has(card, ['stats', 'cardinality'])) {\n        props.cardinality = card.stats.cardinality;\n      }\n      return props;\n    });\n\n    // Obtain the interval to use for date histogram aggregations\n    // (such as the document count chart). Aim for 75 bars.\n    var buckets = new MlTimeBuckets();\n    var bounds = _timefilter.timefilter.getActiveBounds();\n    var BAR_TARGET = 75;\n    buckets.setInterval('auto');\n    buckets.setBounds(bounds);\n    buckets.setBarTarget(BAR_TARGET);\n    var aggInterval = buckets.getInterval();\n\n    _ml_api_service.ml.getVisualizerFieldStats({\n      indexPatternTitle: indexPattern.title,\n      query: $scope.searchQuery,\n      timeFieldName: indexPattern.timeFieldName,\n      earliest: $scope.earliest,\n      latest: $scope.latest,\n      samplerShardSize: $scope.samplerShardSize,\n      interval: aggInterval.expression,\n      fields: numberFields\n    }).then(function (resp) {\n      // Add the metric stats to the existing stats in the corresponding card. [ {documentCounts:...}, {fieldName: ..} ]\n      _lodash2.default.each($scope.metricCards, function (card) {\n        if (card.fieldName !== undefined) {\n          card.stats = _extends({}, card.stats, _lodash2.default.find(resp, { fieldName: card.fieldName }));\n        } else {\n          // Document count card.\n          card.stats = _lodash2.default.find(resp, function (stats) {\n            return stats.fieldName === undefined;\n          });\n        }\n\n        card.loading = false;\n      });\n\n      // Clear the filter spinner if it's running.\n      $scope.metricFilterIcon = 0;\n    }).catch(function (err) {\n      // TODO - display error in cards saying data could not be loaded.\n      console.log('DataVisualizer - error getting stats for metric cards from elasticsearch:', err);\n      if (err.statusCode === 500) {\n        _notify.notify.error(i18n('xpack.ml.datavisualizer.metricInternalServerErrorTitle', {\n          defaultMessage: 'Error loading data for metrics in index {index}. {message}. ' + 'The request may have timed out. Try using a smaller sample size or narrowing the time range.',\n          values: {\n            index: indexPattern.title,\n            message: err.message\n          }\n        }), { lifetime: 30000 });\n      } else {\n        _notify.notify.error(i18n('xpack.ml.datavisualizer.loadingMetricDataErrorTitle', {\n          defaultMessage: 'Error loading data for metrics in index {index}. {message}',\n          values: {\n            index: indexPattern.title,\n            message: err.message\n          }\n        }), { lifetime: 30000 });\n      }\n    }).then(function () {\n      $scope.$applyAsync();\n    });\n  }\n\n  function loadNonMetricFieldStats() {\n    // Only request data for fields that exist in documents.\n    var fields = _lodash2.default.filter($scope.fieldCards, { existsInDocs: true });\n\n    // Pass the field name, type and cardinality in the request.\n    // Top values will be obtained on a sample if cardinality > 100000.\n    fields = _lodash2.default.map(fields, function (card) {\n      var props = { fieldName: card.fieldName, type: card.type };\n      if (_lodash2.default.has(card, ['stats', 'cardinality'])) {\n        props.cardinality = card.stats.cardinality;\n      }\n      return props;\n    });\n\n    if (fields.length > 0) {\n\n      _ml_api_service.ml.getVisualizerFieldStats({\n        indexPatternTitle: indexPattern.title,\n        query: $scope.searchQuery,\n        fields: fields,\n        timeFieldName: indexPattern.timeFieldName,\n        earliest: $scope.earliest,\n        latest: $scope.latest,\n        samplerShardSize: $scope.samplerShardSize,\n        maxExamples: 10\n      }).then(function (resp) {\n        // Add the metric stats to the existing stats in the corresponding card.\n        _lodash2.default.each($scope.fieldCards, function (card) {\n          card.stats = _extends({}, card.stats, _lodash2.default.find(resp, { fieldName: card.fieldName }));\n          card.loading = false;\n        });\n\n        // Clear the filter spinner if it's running.\n        $scope.fieldFilterIcon = 0;\n      }).catch(function (err) {\n        // TODO - display error in cards saying data could not be loaded.\n        console.log('DataVisualizer - error getting non metric field stats from elasticsearch:', err);\n        if (err.statusCode === 500) {\n          _notify.notify.error(i18n('xpack.ml.datavisualizer.fieldsInternalServerErrorTitle', {\n            defaultMessage: 'Error loading data for fields in index {index}. {message}. ' + 'The request may have timed out. Try using a smaller sample size or narrowing the time range.',\n            values: {\n              index: indexPattern.title,\n              message: err.message\n            }\n          }), { lifetime: 30000 });\n        } else {\n          _notify.notify.error(i18n('xpack.ml.datavisualizer.loadingFieldsDataErrorTitle', {\n            defaultMessage: 'Error loading data for fields in index {index}. {message}',\n            values: {\n              index: indexPattern.title,\n              message: err.message\n            }\n          }), { lifetime: 30000 });\n        }\n      }).then(function () {\n        $scope.$applyAsync();\n      });\n    } else {\n      $scope.fieldFilterIcon = 0;\n    }\n  }\n\n  function loadOverallStats() {\n    var aggregatableFields = [];\n    var nonAggregatableFields = [];\n    _lodash2.default.each(indexPattern.fields, function (field) {\n      if (OMIT_FIELDS.indexOf(field.displayName) === -1) {\n        if (field.aggregatable === true) {\n          aggregatableFields.push(field.displayName);\n        } else {\n          nonAggregatableFields.push(field.displayName);\n        }\n      }\n    });\n\n    // Need to find:\n    // 1. List of aggregatable fields that do exist in docs\n    // 2. List of aggregatable fields that do not exist in docs\n    // 3. List of non-aggregatable fields that do exist in docs.\n    // 4. List of non-aggregatable fields that do not exist in docs.\n    _ml_api_service.ml.getVisualizerOverallStats({\n      indexPatternTitle: indexPattern.title,\n      query: $scope.searchQuery,\n      timeFieldName: indexPattern.timeFieldName,\n      samplerShardSize: $scope.samplerShardSize,\n      earliest: $scope.earliest,\n      latest: $scope.latest,\n      aggregatableFields: aggregatableFields,\n      nonAggregatableFields: nonAggregatableFields\n    }).then(function (resp) {\n      $scope.overallStats = resp;\n      createMetricCards();\n      createNonMetricCards();\n    }).catch(function (err) {\n      // TODO - display error in cards saying data could not be loaded.\n      console.log('DataVisualizer - error getting overall stats from elasticsearch:', err);\n      if (err.statusCode === 500) {\n        _notify.notify.error(i18n('xpack.ml.datavisualizer.overallFieldsInternalServerErrorTitle', {\n          defaultMessage: 'Error loading data for fields in index {index}. {message}. ' + 'The request may have timed out. Try using a smaller sample size or narrowing the time range.',\n          values: {\n            index: indexPattern.title,\n            message: err.message\n          }\n        }), { lifetime: 30000 });\n      } else {\n        _notify.notify.error(i18n('xpack.ml.datavisualizer.loadingOverallFieldsDataErrorTitle', {\n          defaultMessage: 'Error loading data for fields in index {index}. {message}',\n          values: {\n            index: indexPattern.title,\n            message: err.message\n          }\n        }), { lifetime: 30000 });\n      }\n\n      $scope.$applyAsync();\n    });\n  }\n\n  loadOverallStats();\n});",null]}