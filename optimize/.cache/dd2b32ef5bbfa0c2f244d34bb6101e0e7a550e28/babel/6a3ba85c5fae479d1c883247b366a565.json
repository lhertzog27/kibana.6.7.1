{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/components/utils/prepopulate_job_settings.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/components/utils/prepopulate_job_settings.js","mtime":1567631712057},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.preLoadJob = preLoadJob;\nexports.jobSettingsFromJob = jobSettingsFromJob;\n\nvar _job_service = require('plugins/ml/services/job_service');\n\nvar _app_state_settings = require('plugins/ml/jobs/new_job/simple/components/utils/app_state_settings');\n\nvar _general = require('plugins/ml/jobs/new_job/simple/components/constants/general');\n\nfunction preLoadJob($scope, appState) {\n  var job = _job_service.mlJobService.currentJob;\n  _job_service.mlJobService.currentJob = undefined;\n  if (job !== undefined) {\n    var mlJobSettings = jobSettingsFromJob(job, $scope.ui.aggTypeOptions);\n    (0, _app_state_settings.populateAppStateSettings)({ mlJobSettings: mlJobSettings }, $scope);\n    $scope.setFullTimeRange().then(function () {\n      return $scope.loadVis();\n    }).catch(function () {\n      return $scope.loadVis();\n    });\n  } else {\n    // populate the fields with any settings from the URL\n    (0, _app_state_settings.populateAppStateSettings)(appState, $scope);\n  }\n} /*\n   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n   * or more contributor license agreements. Licensed under the Elastic License;\n   * you may not use this file except in compliance with the Elastic License.\n   */\n\nfunction jobSettingsFromJob(job, aggTypeOptions) {\n  if (job.custom_settings === undefined) {\n    return {};\n  }\n\n  function getKibanaAggName(mlAggName) {\n    var agg = aggTypeOptions.find(function (a) {\n      return a.mlName === mlAggName;\n    });\n    return agg ? agg.mlName : undefined;\n  }\n\n  var jobSettings = {};\n\n  var dtrs = job.analysis_config.detectors;\n\n  if (job.custom_settings.created_by === _general.WIZARD_TYPE.SINGLE_METRIC) {\n    // single metric\n    var d = dtrs[0];\n    var func = d.function;\n\n    // distinct_count jobs in single metric wizard use a particular aggregation where\n    // the detector function is replaced as non_zero_count.\n    // here we look for this exact situation and switch the function back to distinct_count\n    if (func === 'non_zero_count' && job.analysis_config.summary_count_field_name !== undefined && job.analysis_config.summary_count_field_name.match(/^dc_.+/)) {\n      func = 'distinct_count';\n    }\n\n    var field = { agg: getKibanaAggName(func) };\n    if (d.field_name) {\n      field.fieldName = d.field_name;\n    } else if (func === 'distinct_count' && job.analysis_config.summary_count_field_name !== undefined) {\n      var fieldMatch = job.analysis_config.summary_count_field_name.match(/^dc_(.+)/);\n      if (fieldMatch[1] !== undefined) {\n        field.fieldName = fieldMatch[1];\n      }\n    }\n\n    jobSettings.fields = [field];\n  } else if (job.custom_settings.created_by === _general.WIZARD_TYPE.MULTI_METRIC) {\n    // multi metric\n    var splitField = '';\n\n    jobSettings.fields = dtrs.map(function (d) {\n      if (d.partition_field_name) {\n        splitField = d.partition_field_name;\n      }\n\n      var field = { agg: getKibanaAggName(d.function) };\n      if (d.field_name) {\n        field.fieldName = d.field_name;\n      }\n      return field;\n    });\n\n    if (splitField !== '') {\n      jobSettings.split = splitField;\n    }\n  } else if (job.custom_settings.created_by === _general.WIZARD_TYPE.POPULATION) {\n    var overField = '';\n    var splitFields = {};\n\n    jobSettings.fields = dtrs.map(function (d) {\n      // population\n      if (d.over_field_name) {\n        overField = d.over_field_name;\n      }\n\n      var field = { agg: getKibanaAggName(d.function) };\n      if (d.field_name) {\n        field.fieldName = d.field_name;\n      }\n\n      if (d.by_field_name) {\n        field.split = d.by_field_name;\n      }\n\n      return field;\n    });\n\n    if (overField !== '') {\n      jobSettings.population = overField;\n    }\n\n    var numberOfSplits = Object.keys(splitFields).length;\n\n    if (numberOfSplits > 0) {\n      if (numberOfSplits > 1) {\n        // multiple splits, population or advanced job\n        for (var f in splitFields) {\n          if (splitFields.hasOwnProperty(f)) {\n            var i = splitFields[f];\n            jobSettings.fields[i] = f;\n          }\n        }\n      } else {\n        jobSettings.split = Object.keys(splitFields)[0];\n      }\n    }\n  }\n\n  jobSettings.bucketSpan = job.analysis_config.bucket_span;\n  if (job.analysis_limits && job.analysis_limits.model_memory_limit) {\n    jobSettings.modelMemoryLimit = job.analysis_limits.model_memory_limit;\n  }\n\n  if (job.description !== '') {\n    jobSettings.description = job.description;\n  }\n\n  if (job.groups !== undefined && job.groups.length) {\n    jobSettings.groups = job.groups;\n  }\n\n  if (job.analysis_config && job.analysis_config.influencers) {\n    jobSettings.influencers = job.analysis_config.influencers;\n  }\n\n  jobSettings.resultsIndexName = job.results_index_name;\n\n  return jobSettings;\n}",null]}