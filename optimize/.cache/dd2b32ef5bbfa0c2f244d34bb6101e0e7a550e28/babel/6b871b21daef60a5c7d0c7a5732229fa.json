{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/util/ml_calc_auto_interval.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/util/ml_calc_auto_interval.js","mtime":1567631712071},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TimeBucketsCalcAutoIntervalProvider = TimeBucketsCalcAutoIntervalProvider;\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar d = _moment2.default.duration; /*\n                                    * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                    * or more contributor license agreements. Licensed under the Elastic License;\n                                    * you may not use this file except in compliance with the Elastic License.\n                                    */\n\n// Based on Kibana ui/time_buckets/calc_auto_interval.js but with\n// a few modifications:\n//   - edit to the near rule, so that it returns either the\n//    upper or lower rule bound, depending on which is closest to the\n//    supplied target.\n//   - edit to the lessThan rule so that the interval returned gives\n//     fewer buckets than the supplied target.\n//   - edits to the list of roundingRules to align better with the\n//    Ml job bucket span options.\n\nfunction TimeBucketsCalcAutoIntervalProvider() {\n\n  // Note there is a current issue with Kibana (Kibana issue #9184)\n  // which means we can't round to, for example, 2 week or 3 week buckets,\n  // so there is a large gap between the 1 week and 1 month rule.\n  var roundingRules = [[d(500, 'ms'), d(100, 'ms')], [d(5, 'second'), d(1, 'second')], [d(10, 'second'), d(5, 'second')], [d(15, 'second'), d(10, 'second')], [d(30, 'second'), d(15, 'second')], [d(1, 'minute'), d(30, 'second')], [d(5, 'minute'), d(1, 'minute')], [d(10, 'minute'), d(5, 'minute')], [d(15, 'minute'), d(10, 'minute')], [d(30, 'minute'), d(10, 'minute')], [d(1, 'hour'), d(30, 'minute')], [d(2, 'hour'), d(1, 'hour')], [d(4, 'hour'), d(2, 'hour')], [d(6, 'hour'), d(4, 'hour')], [d(8, 'hour'), d(6, 'hour')], [d(12, 'hour'), d(8, 'hour')], [d(24, 'hour'), d(12, 'hour')], [d(2, 'd'), d(1, 'd')], [d(4, 'd'), d(2, 'd')], [d(1, 'week'), d(4, 'd')],\n  //[ d(2, 'week'), d(1, 'week') ],\n  //[ d(1, 'month'), d(2, 'week') ],\n  [d(1, 'month'), d(1, 'week')], [d(1, 'year'), d(1, 'month')], [Infinity, d(1, 'year')]];\n\n  var revRoundingRules = roundingRules.slice(0).reverse();\n\n  function find(rules, check, last) {\n    function pick(buckets, duration) {\n      var target = duration / buckets;\n      var lastResp = void 0;\n\n      for (var i = 0; i < rules.length; i++) {\n        var rule = rules[i];\n        var resp = check(rule[0], rule[1], target);\n\n        if (resp == null) {\n          if (!last) {\n            continue;\n          }\n          if (lastResp) {\n            return lastResp;\n          }\n          break;\n        }\n\n        if (!last) {\n          return resp;\n        }\n        lastResp = resp;\n      }\n\n      // fallback to just a number of milliseconds, ensure ms is >= 1\n      var ms = Math.max(Math.floor(target), 1);\n      return _moment2.default.duration(ms, 'ms');\n    }\n\n    return function (buckets, duration) {\n      var interval = pick(buckets, duration);\n      if (interval) {\n        return _moment2.default.duration(interval._data);\n      }\n    };\n  }\n\n  return {\n    near: find(revRoundingRules, function near(upperBound, lowerBound, target) {\n      // upperBound - first duration in rule\n      // lowerBound - second duration in rule\n      // target - target interval in milliseconds.\n      if (upperBound > target) {\n        if (upperBound === Infinity) {\n          return lowerBound;\n        }\n\n        var boundMs = upperBound.asMilliseconds();\n        var intervalMs = lowerBound.asMilliseconds();\n        var retInterval = Math.abs(boundMs - target) <= Math.abs(intervalMs) ? upperBound : lowerBound;\n        return retInterval;\n      }\n    }, true),\n\n    lessThan: find(revRoundingRules, function (upperBound, lowerBound, target) {\n      // upperBound - first duration in rule\n      // lowerBound - second duration in rule\n      // target - target interval in milliseconds. Must not return intervals less than this duration.\n      if (lowerBound < target) {\n        return upperBound !== Infinity ? upperBound : lowerBound;\n      }\n    }),\n\n    atLeast: find(revRoundingRules, function atLeast(upperBound, lowerBound, target) {\n      // Unmodified from Kibana ui/time_buckets/calc_auto_interval.js.\n      if (lowerBound <= target) {\n        return lowerBound;\n      }\n    })\n  };\n}",null]}