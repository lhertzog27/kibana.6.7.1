{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/util/chart_utils.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/util/chart_utils.js","mtime":1567631712070},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SCHEDULED_EVENT_SYMBOL_HEIGHT = exports.MULTI_BUCKET_SYMBOL_SIZE = exports.LINE_CHART_ANOMALY_RADIUS = undefined;\nexports.chartLimits = chartLimits;\nexports.drawLineChartDots = drawLineChartDots;\nexports.filterAxisLabels = filterAxisLabels;\nexports.getChartType = getChartType;\nexports.getExploreSeriesLink = getExploreSeriesLink;\nexports.showMultiBucketAnomalyMarker = showMultiBucketAnomalyMarker;\nexports.showMultiBucketAnomalyTooltip = showMultiBucketAnomalyTooltip;\nexports.numTicks = numTicks;\nexports.numTicksForDateFormat = numTicksForDateFormat;\nexports.getTickValues = getTickValues;\nexports.isLabelLengthAboveThreshold = isLabelLengthAboveThreshold;\nexports.getXTransform = getXTransform;\nexports.removeLabelOverlap = removeLabelOverlap;\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _string_utils = require('../util/string_utils');\n\nvar _multi_bucket_impact = require('../../common/constants/multi_bucket_impact');\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _risonNode = require('rison-node');\n\nvar _risonNode2 = _interopRequireDefault(_risonNode);\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _timefilter = require('ui/timefilter');\n\nvar _explorer_constants = require('../explorer/explorer_constants');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nvar LINE_CHART_ANOMALY_RADIUS = exports.LINE_CHART_ANOMALY_RADIUS = 7;\nvar MULTI_BUCKET_SYMBOL_SIZE = exports.MULTI_BUCKET_SYMBOL_SIZE = 100; // In square pixels for use with d3 symbol.size\nvar SCHEDULED_EVENT_SYMBOL_HEIGHT = exports.SCHEDULED_EVENT_SYMBOL_HEIGHT = 5;\n\nvar MAX_LABEL_WIDTH = 100;\n\nfunction chartLimits() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var domain = _d2.default.extent(data, function (d) {\n    var metricValue = d.value;\n    if (metricValue === null && d.anomalyScore !== undefined && d.actual !== undefined) {\n      // If an anomaly coincides with a gap in the data, use the anomaly actual value.\n      metricValue = Array.isArray(d.actual) ? d.actual[0] : d.actual;\n    }\n    return metricValue;\n  });\n  var limits = { max: domain[1], min: domain[0] };\n\n  if (limits.max === limits.min) {\n    limits.max = _d2.default.max(data, function (d) {\n      if (d.typical) {\n        return Math.max(d.value, d.typical);\n      } else {\n        // If analysis with by and over field, and more than one cause,\n        // there will be no actual and typical value.\n        // TODO - produce a better visual for population analyses.\n        return d.value;\n      }\n    });\n    limits.min = _d2.default.min(data, function (d) {\n      if (d.typical) {\n        return Math.min(d.value, d.typical);\n      } else {\n        // If analysis with by and over field, and more than one cause,\n        // there will be no actual and typical value.\n        // TODO - produce a better visual for population analyses.\n        return d.value;\n      }\n    });\n  }\n\n  // add padding of 5% of the difference between max and min\n  // if we ended up with the same value for both of them\n  if (limits.max === limits.min) {\n    var padding = limits.max * 0.05;\n    limits.max += padding;\n    limits.min -= padding;\n  }\n\n  return limits;\n}\n\nfunction drawLineChartDots(data, lineChartGroup, lineChartValuesLine) {\n  var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.5;\n\n  // We need to do this because when creating a line for a chart which has data gaps,\n  // if there are single datapoints without any valid data before and after them,\n  // the lines created by using d3...defined() do not contain these data points.\n  // So this function adds additional circle elements to display the single\n  // datapoints in additional to the line created for the chart.\n\n  // first reduce the dataset to data points\n  // where the previous and next one don't contain any data\n  var dotsData = data.reduce(function (p, c, i) {\n    var previous = data[i - 1];\n    var next = data[i + 1];\n    if ((typeof previous === 'undefined' || previous && previous.value === null) && c.value !== null && (typeof next === 'undefined' || next && next.value === null)) {\n      p.push(c);\n    }\n    return p;\n  }, []);\n\n  // check if `g.values-dots` already exists, if not create it\n  // in both cases assign the element to `dotGroup`\n  var dotGroup = lineChartGroup.select('.values-dots').empty() ? lineChartGroup.append('g').classed('values-dots', true) : lineChartGroup.select('.values-dots');\n\n  // use d3's enter/update/exit pattern to render the dots\n  var dots = dotGroup.selectAll('circle').data(dotsData);\n\n  dots.enter().append('circle').attr('r', radius);\n\n  dots.attr('cx', lineChartValuesLine.x()).attr('cy', lineChartValuesLine.y());\n\n  dots.exit().remove();\n}\n\n// this replicates Kibana's filterAxisLabels() behavior\n// which can be found in ui/vislib/lib/axis/axis_labels.js\n// axis labels which overflow the chart's boundaries will be removed\nfunction filterAxisLabels(selection, chartWidth) {\n  if (selection === undefined || selection.selectAll === undefined) {\n    throw new Error('Missing selection parameter');\n  }\n\n  selection.selectAll('.tick text')\n  // don't refactor this to an arrow function because\n  // we depend on using `this` here.\n  .text(function () {\n    var parent = _d2.default.select(this.parentNode);\n    var labelWidth = parent.node().getBBox().width;\n    var labelXPos = _d2.default.transform(parent.attr('transform')).translate[0];\n    var minThreshold = labelXPos - labelWidth / 2;\n    var maxThreshold = labelXPos + labelWidth / 2;\n    if (minThreshold >= 0 && maxThreshold <= chartWidth) {\n      return this.textContent;\n    } else {\n      parent.remove();\n    }\n  });\n}\n\n// feature flags for chart types\nvar EVENT_DISTRIBUTION_ENABLED = true;\nvar POPULATION_DISTRIBUTION_ENABLED = true;\n\n// get the chart type based on its configuration\nfunction getChartType(config) {\n  if (EVENT_DISTRIBUTION_ENABLED && config.functionDescription === 'rare' && config.entityFields.some(function (f) {\n    return f.fieldType === 'over';\n  }) === false) {\n    return _explorer_constants.CHART_TYPE.EVENT_DISTRIBUTION;\n  } else if (POPULATION_DISTRIBUTION_ENABLED && config.functionDescription !== 'rare' && config.entityFields.some(function (f) {\n    return f.fieldType === 'over';\n  })) {\n    return _explorer_constants.CHART_TYPE.POPULATION_DISTRIBUTION;\n  }\n\n  return _explorer_constants.CHART_TYPE.SINGLE_METRIC;\n}\n\nfunction getExploreSeriesLink(series) {\n  // Open the Single Metric dashboard over the same overall bounds and\n  // zoomed in to the same time as the current chart.\n  var bounds = _timefilter.timefilter.getActiveBounds();\n  var from = bounds.min.toISOString(); // e.g. 2016-02-08T16:00:00.000Z\n  var to = bounds.max.toISOString();\n\n  var zoomFrom = (0, _moment2.default)(series.plotEarliest).toISOString();\n  var zoomTo = (0, _moment2.default)(series.plotLatest).toISOString();\n\n  // Pass the detector index and entity fields (i.e. by, over, partition fields)\n  // to identify the particular series to view.\n  // Initially pass them in the mlTimeSeriesExplorer part of the AppState.\n  // TODO - do we want to pass the entities via the filter?\n  var entityCondition = {};\n  series.entityFields.forEach(function (entity) {\n    entityCondition[entity.fieldName] = entity.fieldValue;\n  });\n\n  // Use rison to build the URL .\n  var _g = _risonNode2.default.encode({\n    ml: {\n      jobIds: [series.jobId]\n    },\n    refreshInterval: {\n      display: 'Off',\n      pause: false,\n      value: 0\n    },\n    time: {\n      from: from,\n      to: to,\n      mode: 'absolute'\n    }\n  });\n\n  var _a = _risonNode2.default.encode({\n    mlTimeSeriesExplorer: {\n      zoom: {\n        from: zoomFrom,\n        to: zoomTo\n      },\n      detectorIndex: series.detectorIndex,\n      entities: entityCondition\n    },\n    filters: [],\n    query: {\n      query_string: {\n        analyze_wildcard: true,\n        query: '*'\n      }\n    }\n  });\n\n  return _chrome2.default.getBasePath() + '/app/ml#/timeseriesexplorer?_g=' + _g + '&_a=' + encodeURIComponent(_a);\n}\n\nfunction showMultiBucketAnomalyMarker(point) {\n  // TODO - test threshold with real use cases\n  return point.multiBucketImpact !== undefined && point.multiBucketImpact >= _multi_bucket_impact.MULTI_BUCKET_IMPACT.MEDIUM;\n}\n\nfunction showMultiBucketAnomalyTooltip(point) {\n  // TODO - test threshold with real use cases\n  return point.multiBucketImpact !== undefined && point.multiBucketImpact >= _multi_bucket_impact.MULTI_BUCKET_IMPACT.LOW;\n}\n\nfunction numTicks(axisWidth) {\n  return axisWidth / MAX_LABEL_WIDTH;\n}\n\nfunction numTicksForDateFormat(axisWidth, dateFormat) {\n  // Allow 1.75 times the width of a formatted date per tick for padding.\n  var tickWidth = (0, _string_utils.calculateTextWidth)((0, _moment2.default)().format(dateFormat), false);\n  return axisWidth / (1.75 * tickWidth);\n}\n\nvar TICK_DIRECTION = {\n  NEXT: 'next',\n  PREVIOUS: 'previous'\n};\n\n// Based on a fixed starting timestamp and an interval, get tick values within\n// the bounds of earliest and latest. This is useful for the Anomaly Explorer Charts\n// to align axis ticks with the gray area resembling the swimlane cell selection.\nfunction getTickValues(startTimeMs, tickInterval, earliest, latest) {\n  // A tickInterval equal or smaller than 0 would trigger a call stack exception,\n  // so we're trying to catch that before it happens.\n  if (tickInterval <= 0) {\n    throw Error('tickInterval must be larger than 0.');\n  }\n\n  var tickValues = [startTimeMs];\n\n  function addTicks(ts, operator) {\n    var newTick = void 0;\n    var addAnotherTick = void 0;\n\n    switch (operator) {\n      case TICK_DIRECTION.PREVIOUS:\n        newTick = ts - tickInterval;\n        addAnotherTick = newTick >= earliest;\n        break;\n      case TICK_DIRECTION.NEXT:\n        newTick = ts + tickInterval;\n        addAnotherTick = newTick <= latest;\n        break;\n    }\n\n    if (addAnotherTick) {\n      tickValues.push(newTick);\n      addTicks(newTick, operator);\n    }\n  }\n\n  addTicks(startTimeMs, TICK_DIRECTION.PREVIOUS);\n  addTicks(startTimeMs, TICK_DIRECTION.NEXT);\n\n  tickValues.sort();\n\n  return tickValues;\n}\n\nvar LABEL_WRAP_THRESHOLD = 60;\n\n// Checks if the string length of a chart label (detector description\n// and entity fields) is above LABEL_WRAP_THRESHOLD.\nfunction isLabelLengthAboveThreshold(_ref) {\n  var detectorLabel = _ref.detectorLabel,\n      entityFields = _ref.entityFields;\n\n  var labelLength = detectorLabel.length + entityFields.map(function (d) {\n    return d.fieldName + ' ' + d.fieldValue;\n  }).join(' ').length;\n  return labelLength > LABEL_WRAP_THRESHOLD;\n}\n\n// To get xTransform it would be nicer to use d3.transform, but that doesn't play well with JSDOM.\n// So this uses a regex variant because we definitely want test coverage for the label removal.\n// Once JSDOM supports SVGAnimatedTransformList we can use this simpler inline version:\n// const xTransform = d3.transform(tick.attr('transform')).translate[0];\nfunction getXTransform(t) {\n  var regexResult = /translate\\(\\s*([^\\s,)]+)([ ,]([^\\s,)]+))?\\)/.exec(t);\n  if (Array.isArray(regexResult) && regexResult.length >= 2) {\n    return Number(regexResult[1]);\n  }\n\n  // fall back to NaN if regex didn't return any results.\n  return NaN;\n}\n\n// This removes overlapping x-axis labels by starting off from a specific label\n// that is required/wanted to show up. The code then traverses to both sides along the axis\n// and decides which labels to keep or remove. All vertical tick lines will be kept visible,\n// but those which still have their text label will be emphasized using the ml-tick-emphasis class.\nfunction removeLabelOverlap(axis, startTimeMs, tickInterval, width) {\n  // Put emphasis on all tick lines, will again de-emphasize the\n  // ones where we remove the label in the next steps.\n  axis.selectAll('g.tick').select('line').classed('ml-tick-emphasis', true);\n\n  function getNeighborTickFactory(operator) {\n    return function (ts) {\n      switch (operator) {\n        case TICK_DIRECTION.PREVIOUS:\n          return ts - tickInterval;\n        case TICK_DIRECTION.NEXT:\n          return ts + tickInterval;\n      }\n    };\n  }\n\n  function getTickDataFactory(operator) {\n    var getNeighborTick = getNeighborTickFactory(operator);\n    var fn = function fn(ts) {\n      var filteredTicks = axis.selectAll('.tick').filter(function (d) {\n        return d === ts;\n      });\n\n      if (filteredTicks.length === 0 || filteredTicks[0].length === 0) {\n        return false;\n      }\n\n      var tick = _d2.default.selectAll(filteredTicks[0]);\n      var textNode = tick.select('text').node();\n\n      if (textNode === null) {\n        return fn(getNeighborTick(ts));\n      }\n\n      var tickWidth = textNode.getBBox().width;\n      var padding = 15;\n      var xTransform = getXTransform(tick.attr('transform'));\n      var xMinOffset = xTransform - (tickWidth / 2 + padding);\n      var xMaxOffset = xTransform + (tickWidth / 2 + padding);\n\n      return {\n        tick: tick,\n        ts: ts,\n        xMinOffset: xMinOffset,\n        xMaxOffset: xMaxOffset\n      };\n    };\n    return fn;\n  }\n\n  function checkTicks(ts, operator) {\n    var getTickData = getTickDataFactory(operator);\n    var currentTickData = getTickData(ts);\n\n    if (currentTickData === false) {\n      return;\n    }\n\n    var getNeighborTick = getNeighborTickFactory(operator);\n    var newTickData = getTickData(getNeighborTick(ts));\n\n    if (newTickData !== false) {\n      if (newTickData.xMinOffset < 0 || newTickData.xMaxOffset > width || newTickData.xMaxOffset > currentTickData.xMinOffset && operator === TICK_DIRECTION.PREVIOUS || newTickData.xMinOffset < currentTickData.xMaxOffset && operator === TICK_DIRECTION.NEXT) {\n        newTickData.tick.select('text').remove();\n        newTickData.tick.select('line').classed('ml-tick-emphasis', false);\n        checkTicks(currentTickData.ts, operator);\n      } else {\n        checkTicks(newTickData.ts, operator);\n      }\n    }\n  }\n\n  checkTicks(startTimeMs, TICK_DIRECTION.PREVIOUS);\n  checkTicks(startTimeMs, TICK_DIRECTION.NEXT);\n}",null]}