{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/agg_types/buckets/date_histogram.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/agg_types/buckets/date_histogram.js","mtime":1567631711697},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dateHistogramBucketAgg = undefined;\n\nvar _jstimezonedetect = require('jstimezonedetect');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _chrome = require('../../chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nrequire('../../filters/field_type');\n\nrequire('../../validate_date_interval');\n\nvar _bucket_agg_type = require('./_bucket_agg_type');\n\nvar _time_buckets = require('../../time_buckets');\n\nvar _date_histogram = require('./create_filter/date_histogram');\n\nvar _interval_options = require('./_interval_options');\n\nvar _time_interval = require('../controls/time_interval.html');\n\nvar _time_interval2 = _interopRequireDefault(_time_interval);\n\nvar _timefilter = require('../../timefilter');\n\nvar _drop_partials = require('../controls/drop_partials.html');\n\nvar _drop_partials2 = _interopRequireDefault(_drop_partials);\n\nvar _i18n = require('@kbn/i18n');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar config = _chrome2.default.getUiSettingsClient();\nvar detectedTimezone = _jstimezonedetect.jstz.determine().name();\nvar tzOffset = (0, _moment2.default)().format('Z');\n\nfunction getInterval(agg) {\n  var interval = _lodash2.default.get(agg, ['params', 'interval']);\n  if (interval && interval.val === 'custom') {\n    return _lodash2.default.get(agg, ['params', 'customInterval']);\n  }\n  return interval;\n}\n\nfunction setBounds(agg, force) {\n  if (agg.buckets._alreadySet && !force) return;\n  agg.buckets._alreadySet = true;\n  var bounds = agg.params.timeRange ? _timefilter.timefilter.calculateBounds(agg.params.timeRange) : null;\n  agg.buckets.setBounds(agg.fieldIsTimeField() && bounds);\n}\n\nvar dateHistogramBucketAgg = exports.dateHistogramBucketAgg = new _bucket_agg_type.BucketAggType({\n  name: 'date_histogram',\n  title: _i18n.i18n.translate('common.ui.aggTypes.buckets.dateHistogramTitle', {\n    defaultMessage: 'Date Histogram'\n  }),\n  ordered: {\n    date: true\n  },\n  makeLabel: function makeLabel(agg) {\n    var output = this.params.write(agg);\n    var field = agg.getFieldDisplayName();\n    return _i18n.i18n.translate('common.ui.aggTypes.buckets.dateHistogramLabel', {\n      defaultMessage: '{fieldName} per {intervalDescription}',\n      values: {\n        fieldName: field,\n        intervalDescription: output.metricScaleText || output.bucketInterval.description\n      }\n    });\n  },\n  createFilter: _date_histogram.createFilterDateHistogram,\n  decorateAggConfig: function decorateAggConfig() {\n    var buckets = void 0;\n    return {\n      buckets: {\n        configurable: true,\n        get: function get() {\n          if (buckets) return buckets;\n\n          buckets = new _time_buckets.TimeBuckets();\n          buckets.setInterval(getInterval(this));\n          setBounds(this);\n\n          return buckets;\n        }\n      }\n    };\n  },\n  getFormat: function getFormat(agg) {\n    return agg.buckets.getScaledDateFormatter();\n  },\n  params: [{\n    name: 'field',\n    type: 'field',\n    filterFieldTypes: 'date',\n    default: function _default(agg) {\n      return agg.getIndexPattern().timeFieldName;\n    },\n    onChange: function onChange(agg) {\n      if (_lodash2.default.get(agg, 'params.interval.val') === 'auto' && !agg.fieldIsTimeField()) {\n        delete agg.params.interval;\n      }\n\n      setBounds(agg, true);\n    }\n  }, {\n    name: 'timeRange',\n    default: null,\n    write: _lodash2.default.noop\n  }, {\n    name: 'useNormalizedEsInterval',\n    default: true,\n    write: _lodash2.default.noop\n  }, {\n    name: 'interval',\n    type: 'optioned',\n    deserialize: function deserialize(state) {\n      var interval = _lodash2.default.find(_interval_options.intervalOptions, { val: state });\n      return interval || _lodash2.default.find(_interval_options.intervalOptions, function (option) {\n        // For upgrading from 4.0.x to 4.1.x - intervals are now stored as 'y' instead of 'year',\n        // but this maps the old values to the new values\n        return Number(_moment2.default.duration(1, state)) === Number(_moment2.default.duration(1, option.val));\n      });\n    },\n    default: 'auto',\n    options: _interval_options.intervalOptions,\n    editor: _time_interval2.default,\n    modifyAggConfigOnSearchRequestStart: function modifyAggConfigOnSearchRequestStart(agg) {\n      setBounds(agg, true);\n    },\n    write: function write(agg, output, aggs) {\n      setBounds(agg, true);\n      agg.buckets.setInterval(getInterval(agg));\n      var useNormalizedEsInterval = agg.params.useNormalizedEsInterval;\n\n      var interval = agg.buckets.getInterval(useNormalizedEsInterval);\n      output.bucketInterval = interval;\n      output.params.interval = interval.expression;\n\n      var scaleMetrics = interval.scaled && interval.scale < 1;\n      if (scaleMetrics && aggs) {\n        var all = _lodash2.default.every(aggs.bySchemaGroup.metrics, function (agg) {\n          return agg.type && agg.type.isScalable();\n        });\n        if (all) {\n          output.metricScale = interval.scale;\n          output.metricScaleText = interval.preScaled.description;\n        }\n      }\n    }\n  }, {\n    name: 'time_zone',\n    default: undefined,\n    // We don't ever want this parameter to be serialized out (when saving or to URLs)\n    // since we do all the logic handling it \"on the fly\" in the `write` method, to prevent\n    // time_zones being persisted into saved_objects\n    serialize: function serialize() {\n      return undefined;\n    },\n    write: function write(agg, output) {\n      // If a time_zone has been set explicitly always prefer this.\n      var tz = agg.params.time_zone;\n      if (!tz && agg.params.field) {\n        // If a field has been configured check the index pattern's typeMeta if a date_histogram on that\n        // field requires a specific time_zone\n        tz = _lodash2.default.get(agg.getIndexPattern(), ['typeMeta', 'aggs', 'date_histogram', agg.params.field.name, 'time_zone']);\n      }\n      if (!tz) {\n        // If the index pattern typeMeta data, didn't had a time zone assigned for the selected field use the configured tz\n        var isDefaultTimezone = config.isDefault('dateFormat:tz');\n        tz = isDefaultTimezone ? detectedTimezone || tzOffset : config.get('dateFormat:tz');\n      }\n      output.params.time_zone = tz;\n    }\n  }, {\n    name: 'drop_partials',\n    default: false,\n    write: _lodash2.default.noop,\n    editor: _drop_partials2.default\n  }, {\n    name: 'customInterval',\n    default: '2h',\n    write: _lodash2.default.noop\n  }, {\n    name: 'format'\n  }, {\n    name: 'min_doc_count',\n    default: 1\n  }, {\n    name: 'extended_bounds',\n    default: {},\n    write: function write(agg, output) {\n      var val = agg.params.extended_bounds;\n\n      if (val.min != null || val.max != null) {\n        output.params.extended_bounds = {\n          min: (0, _moment2.default)(val.min).valueOf(),\n          max: (0, _moment2.default)(val.max).valueOf()\n        };\n\n        return;\n      }\n    }\n  }]\n});",null]}