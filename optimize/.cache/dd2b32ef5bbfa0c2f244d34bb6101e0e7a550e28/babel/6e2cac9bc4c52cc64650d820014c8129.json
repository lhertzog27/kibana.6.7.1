{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/functions/common/ply.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/functions/common/ply.js","mtime":1567631711898},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ply = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\nvar _lodash = require('lodash');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction combineColumns(arrayOfColumnsArrays) {\n  return arrayOfColumnsArrays.reduce(function (resultingColumns, columns) {\n    if (columns) {\n      columns.forEach(function (column) {\n        if (resultingColumns.find(function (resultingColumn) {\n          return resultingColumn.name === column.name;\n        })) {\n          return;\n        } else {\n          resultingColumns.push(column);\n        }\n      });\n    }\n\n    return resultingColumns;\n  }, []);\n}\n\n// This handles merging the tables produced by multiple expressions run on a single member of the `by` split.\n// Thus all tables must be the same length, although their columns do not need to be the same, we will handle combining the columns\nfunction combineAcross(datatableArray) {\n  var _datatableArray = _slicedToArray(datatableArray, 1),\n      referenceTable = _datatableArray[0];\n\n  var targetRowLength = referenceTable.rows.length;\n\n  // Sanity check\n  datatableArray.forEach(function (datatable) {\n    if (datatable.rows.length !== targetRowLength) {\n      throw new Error('All expressions must return the same number of rows');\n    }\n  });\n\n  // Merge columns and rows.\n  var arrayOfRowsArrays = (0, _lodash.map)(datatableArray, 'rows');\n  var rows = [];\n  for (var i = 0; i < targetRowLength; i++) {\n    var rowsAcross = (0, _lodash.map)(arrayOfRowsArrays, i);\n\n    // The reason for the Object.assign is that rowsAcross is an array\n    // and those rows need to be applied as arguments to Object.assign\n    rows.push(Object.assign.apply(Object, [{}].concat(_toConsumableArray(rowsAcross))));\n  }\n\n  var columns = combineColumns((0, _lodash.map)(datatableArray, 'columns'));\n\n  return {\n    type: 'datatable',\n    rows: rows,\n    columns: columns\n  };\n}\n\nvar ply = exports.ply = function ply() {\n  return {\n    name: 'ply',\n    type: 'datatable',\n    help: 'Subdivide a datatable and pass the resulting tables into an expression, then merge the output',\n    context: {\n      types: ['datatable']\n    },\n    args: {\n      by: {\n        types: ['string'],\n        help: 'The column to subdivide on',\n        multi: true\n      },\n      expression: {\n        types: ['datatable'],\n        resolve: false,\n        multi: true,\n        aliases: ['fn', 'function'],\n        help: 'An expression to pass each resulting data table into. Tips: \\n' + ' Expressions must return a datatable. Use `as` to turn literals into datatables.\\n' + ' Multiple expressions must return the same number of rows.' + ' If you need to return a differing row count, pipe into another instance of ply.\\n' + ' If multiple expressions return the same columns, the last one wins.'\n      }\n      // In the future it may make sense to add things like shape, or tooltip values, but I think what we have is good for now\n      // The way the function below is written you can add as many arbitrary named args as you want.\n    },\n    fn: function fn(context, args) {\n      if (!args) {\n        return context;\n      }\n      var byColumns = void 0;\n      var originalDatatables = void 0;\n\n      if (args.by) {\n        byColumns = args.by.map(function (by) {\n          var column = context.columns.find(function (column) {\n            return column.name === by;\n          });\n          if (!column) {\n            throw new Error('Column not found: \\'' + by + '\\'');\n          }\n          return column;\n        });\n        var keyedDatatables = (0, _lodash.groupBy)(context.rows, function (row) {\n          return JSON.stringify((0, _lodash.pick)(row, args.by));\n        });\n        originalDatatables = Object.values(keyedDatatables).map(function (rows) {\n          return _extends({}, context, {\n            rows: rows\n          });\n        });\n      } else {\n        originalDatatables = [context];\n      }\n\n      var datatablePromises = originalDatatables.map(function (originalDatatable) {\n        var expressionResultPromises = [];\n\n        if (args.expression) {\n          expressionResultPromises = args.expression.map(function (expression) {\n            return expression(originalDatatable);\n          });\n        } else {\n          expressionResultPromises.push(Promise.resolve(originalDatatable));\n        }\n\n        return Promise.all(expressionResultPromises).then(combineAcross);\n      });\n\n      return Promise.all(datatablePromises).then(function (newDatatables) {\n        // Here we're just merging each for the by splits, so it doesn't actually matter if the rows are the same length\n        var columns = combineColumns([byColumns].concat((0, _lodash.map)(newDatatables, 'columns')));\n        var rows = (0, _lodash.flatten)(newDatatables.map(function (dt, i) {\n          var byColumnValues = (0, _lodash.pick)(originalDatatables[i].rows[0], args.by);\n          return dt.rows.map(function (row) {\n            return _extends({}, byColumnValues, row);\n          });\n        }));\n\n        return {\n          type: 'datatable',\n          rows: rows,\n          columns: columns\n        };\n      });\n    }\n  };\n};",null]}