{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/packages/kbn-interpreter/target/common/interpreter/interpret.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/packages/kbn-interpreter/target/common/interpreter/interpret.js","mtime":1567666389487},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nexports.interpreterProvider = interpreterProvider;\n\nvar _lodash = require('lodash.clone');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _lodash3 = require('lodash');\n\nvar _get_type = require('../lib/get_type');\n\nvar _ast = require('../lib/ast');\n\nvar _get_by_alias = require('../lib/get_by_alias');\n\nvar _cast = require('./cast');\n\nvar _create_error = require('./create_error');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nfunction interpreterProvider(config) {\n  var interpret = function () {\n    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(node) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return _regenerator2.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.t0 = (0, _get_type.getType)(node);\n              _context.next = _context.t0 === 'expression' ? 3 : _context.t0 === 'string' ? 4 : _context.t0 === 'number' ? 4 : _context.t0 === 'null' ? 4 : _context.t0 === 'boolean' ? 4 : 5;\n              break;\n\n            case 3:\n              return _context.abrupt('return', invokeChain(node.chain, context));\n\n            case 4:\n              return _context.abrupt('return', node);\n\n            case 5:\n              throw new Error('Unknown AST object: ' + JSON.stringify(node));\n\n            case 6:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    return function interpret(_x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  var invokeChain = function () {\n    var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(chainArr, context) {\n      var chain, link, fnName, fnArgs, fnDef, _ref3, resolvedArgs, newContext;\n\n      return _regenerator2.default.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (chainArr.length) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt('return', Promise.resolve(context));\n\n            case 2:\n              chain = (0, _lodash2.default)(chainArr);\n              link = chain.shift(); // Every thing in the chain will always be a function right?\n\n              fnName = link.function, fnArgs = link.arguments;\n              fnDef = (0, _get_by_alias.getByAlias)(functions, fnName);\n\n              if (fnDef) {\n                _context2.next = 8;\n                break;\n              }\n\n              return _context2.abrupt('return', (0, _create_error.createError)({ message: 'Function ' + fnName + ' could not be found.' }));\n\n            case 8:\n              _context2.prev = 8;\n              _context2.next = 11;\n              return resolveArgs(fnDef, context, fnArgs);\n\n            case 11:\n              _ref3 = _context2.sent;\n              resolvedArgs = _ref3.resolvedArgs;\n              _context2.next = 15;\n              return invokeFunction(fnDef, context, resolvedArgs);\n\n            case 15:\n              newContext = _context2.sent;\n\n              if (!((0, _get_type.getType)(newContext) === 'error')) {\n                _context2.next = 18;\n                break;\n              }\n\n              return _context2.abrupt('return', newContext);\n\n            case 18:\n              _context2.next = 20;\n              return invokeChain(chain, newContext);\n\n            case 20:\n              return _context2.abrupt('return', _context2.sent);\n\n            case 23:\n              _context2.prev = 23;\n              _context2.t0 = _context2['catch'](8);\n\n              // Everything that throws from a function will hit this\n              // The interpreter should *never* fail. It should always return a `{type: error}` on failure\n              _context2.t0.message = '[' + fnName + '] > ' + _context2.t0.message;\n              return _context2.abrupt('return', (0, _create_error.createError)(_context2.t0));\n\n            case 27:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this, [[8, 23]]);\n    }));\n\n    return function invokeChain(_x3, _x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var invokeFunction = function () {\n    var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(fnDef, context, args) {\n      var acceptableContext, fnOutput, returnType, expectedType, type;\n      return _regenerator2.default.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              // Check function input.\n              acceptableContext = cast(context, fnDef.context.types);\n              _context3.next = 3;\n              return fnDef.fn(acceptableContext, args, handlers);\n\n            case 3:\n              fnOutput = _context3.sent;\n\n              // Validate that the function returned the type it said it would.\n              // This isn't really required, but it keeps function developers honest.\n              returnType = (0, _get_type.getType)(fnOutput);\n              expectedType = fnDef.type;\n\n              if (!(expectedType && returnType !== expectedType)) {\n                _context3.next = 8;\n                break;\n              }\n\n              throw new Error('Function \\'' + fnDef.name + '\\' should return \\'' + expectedType + '\\',' + (' actually returned \\'' + returnType + '\\''));\n\n            case 8:\n\n              // Validate the function output against the type definition's validate function\n              type = handlers.types[fnDef.type];\n\n              if (!(type && type.validate)) {\n                _context3.next = 17;\n                break;\n              }\n\n              _context3.prev = 10;\n\n              type.validate(fnOutput);\n              _context3.next = 17;\n              break;\n\n            case 14:\n              _context3.prev = 14;\n              _context3.t0 = _context3['catch'](10);\n              throw new Error('Output of \\'' + fnDef.name + '\\' is not a valid type \\'' + fnDef.type + '\\': ' + _context3.t0);\n\n            case 17:\n              return _context3.abrupt('return', fnOutput);\n\n            case 18:\n            case 'end':\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this, [[10, 14]]);\n    }));\n\n    return function invokeFunction(_x5, _x6, _x7) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  // Processes the multi-valued AST argument values into arguments that can be passed to the function\n\n\n  var resolveArgs = function () {\n    var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(fnDef, context, argAsts) {\n      var _this = this;\n\n      var argDefs, dealiasedArgAsts, argAstsWithDefaults, resolveArgFns, argNames, resolvedArgValues, resolvedMultiArgs, resolvedArgs;\n      return _regenerator2.default.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              argDefs = fnDef.args;\n\n              // Use the non-alias name from the argument definition\n\n              dealiasedArgAsts = (0, _lodash3.reduce)(argAsts, function (argAsts, argAst, argName) {\n                var argDef = (0, _get_by_alias.getByAlias)(argDefs, argName);\n                // TODO: Implement a system to allow for undeclared arguments\n                if (!argDef) {\n                  throw new Error('Unknown argument \\'' + argName + '\\' passed to function \\'' + fnDef.name + '\\'');\n                }\n\n                argAsts[argDef.name] = (argAsts[argDef.name] || []).concat(argAst);\n                return argAsts;\n              }, {});\n\n              // Check for missing required arguments\n\n              (0, _lodash3.each)(argDefs, function (argDef) {\n                var aliases = argDef.aliases,\n                    argDefault = argDef.default,\n                    argName = argDef.name,\n                    required = argDef.required;\n\n                if (typeof argDefault === 'undefined' && required && typeof dealiasedArgAsts[argName] === 'undefined') {\n                  if (aliases.length === 0) {\n                    throw new Error(fnDef.name + ' requires an argument');\n                  } else {\n                    var errorArg = argName === '_' ? aliases[0] : argName; // use an alias if _ is the missing arg\n                    throw new Error(fnDef.name + ' requires an \"' + errorArg + '\" argument');\n                  }\n                }\n              });\n\n              // Fill in default values from argument definition\n              argAstsWithDefaults = (0, _lodash3.reduce)(argDefs, function (argAsts, argDef, argName) {\n                if (typeof argAsts[argName] === 'undefined' && typeof argDef.default !== 'undefined') {\n                  argAsts[argName] = [(0, _ast.fromExpression)(argDef.default, 'argument')];\n                }\n\n                return argAsts;\n              }, dealiasedArgAsts);\n\n              // Create the functions to resolve the argument ASTs into values\n              // These are what are passed to the actual functions if you opt out of resolving\n\n              resolveArgFns = (0, _lodash3.mapValues)(argAstsWithDefaults, function (argAsts, argName) {\n                return argAsts.map(function (argAst) {\n                  return (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {\n                    var ctx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : context;\n                    var newContext;\n                    return _regenerator2.default.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            _context4.next = 2;\n                            return interpret(argAst, ctx);\n\n                          case 2:\n                            newContext = _context4.sent;\n\n                            if (!((0, _get_type.getType)(newContext) === 'error')) {\n                              _context4.next = 5;\n                              break;\n                            }\n\n                            throw newContext.error;\n\n                          case 5:\n                            return _context4.abrupt('return', cast(newContext, argDefs[argName].types));\n\n                          case 6:\n                          case 'end':\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4, _this);\n                  }));\n                });\n              });\n              argNames = (0, _lodash3.keys)(resolveArgFns);\n\n              // Actually resolve unless the argument definition says not to\n\n              _context5.next = 8;\n              return Promise.all(argNames.map(function (argName) {\n                var interpretFns = resolveArgFns[argName];\n                if (!argDefs[argName].resolve) return interpretFns;\n                return Promise.all(interpretFns.map(function (fn) {\n                  return fn();\n                }));\n              }));\n\n            case 8:\n              resolvedArgValues = _context5.sent;\n              resolvedMultiArgs = (0, _lodash3.zipObject)(argNames, resolvedArgValues);\n\n              // Just return the last unless the argument definition allows multiple\n\n              resolvedArgs = (0, _lodash3.mapValues)(resolvedMultiArgs, function (argValues, argName) {\n                if (argDefs[argName].multi) return argValues;\n                return (0, _lodash3.last)(argValues);\n              });\n\n              // Return an object here because the arguments themselves might actually have a 'then'\n              // function which would be treated as a promise\n\n              return _context5.abrupt('return', { resolvedArgs: resolvedArgs });\n\n            case 12:\n            case 'end':\n              return _context5.stop();\n          }\n        }\n      }, _callee5, this);\n    }));\n\n    return function resolveArgs(_x8, _x9, _x10) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n\n  var functions = config.functions,\n      types = config.types;\n\n  var handlers = (0, _extends3.default)({}, config.handlers, { types: types });\n  var cast = (0, _cast.castProvider)(types);\n\n  return interpret;\n} /*\n   * Licensed to Elasticsearch B.V. under one or more contributor\n   * license agreements. See the NOTICE file distributed with\n   * this work for additional information regarding copyright\n   * ownership. Elasticsearch B.V. licenses this file to you under\n   * the Apache License, Version 2.0 (the \"License\"); you may\n   * not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *    http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing,\n   * software distributed under the License is distributed on an\n   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n   * KIND, either express or implied.  See the License for the\n   * specific language governing permissions and limitations\n   * under the License.\n   */",null]}