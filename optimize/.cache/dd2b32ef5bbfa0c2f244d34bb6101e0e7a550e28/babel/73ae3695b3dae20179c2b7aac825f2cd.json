{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/renderers/progress/index.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/renderers/progress/index.js","mtime":1567631711904},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.progress = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\nvar _get_id = require('../../../public/lib/get_id');\n\nvar _shapes = require('./shapes');\n\nvar progress = exports.progress = function progress() {\n  return {\n    name: 'progress',\n    displayName: 'Progress',\n    help: 'Reveal a percentage of an element',\n    reuseDomNode: true,\n    render: function render(domNode, config, handlers) {\n      var shape = config.shape,\n          value = config.value,\n          max = config.max,\n          valueColor = config.valueColor,\n          barColor = config.barColor,\n          valueWeight = config.valueWeight,\n          barWeight = config.barWeight,\n          label = config.label,\n          font = config.font;\n\n      var percent = value / max;\n      var shapeDef = _shapes.shapes[shape];\n      var offset = Math.max(valueWeight, barWeight);\n\n      if (shapeDef) {\n        var parser = new DOMParser();\n\n        var _parser$parseFromStri = parser.parseFromString(_shapes.shapes[shape], 'image/svg+xml').getElementsByTagName('svg'),\n            _parser$parseFromStri2 = _slicedToArray(_parser$parseFromStri, 1),\n            shapeSvg = _parser$parseFromStri2[0];\n\n        var initialViewBox = shapeSvg.getAttribute('viewBox').split(' ').map(function (v) {\n          return parseInt(v, 10);\n        });\n\n        var _initialViewBox = _slicedToArray(initialViewBox, 4),\n            minX = _initialViewBox[0],\n            minY = _initialViewBox[1],\n            width = _initialViewBox[2],\n            height = _initialViewBox[3];\n\n        if (shape !== 'horizontalBar') {\n          minX -= offset / 2;\n          width += offset;\n        }\n\n        if (shape === 'semicircle') {\n          minY -= offset / 2;\n          height += offset / 2;\n        } else if (shape !== 'verticalBar') {\n          minY -= offset / 2;\n          height += offset;\n        }\n\n        shapeSvg.setAttribute('className', 'canvasProgress');\n\n        var svgId = (0, _get_id.getId)('svg');\n        shapeSvg.id = svgId;\n\n        var _shapeSvg$getElements = shapeSvg.getElementsByTagName('path'),\n            _shapeSvg$getElements2 = _slicedToArray(_shapeSvg$getElements, 1),\n            bar = _shapeSvg$getElements2[0];\n\n        bar.setAttribute('className', 'canvasProgress__background');\n        bar.setAttribute('fill', 'none');\n        bar.setAttribute('stroke', barColor);\n        bar.setAttribute('stroke-width', barWeight + 'px');\n\n        var _value = bar.cloneNode(true);\n        _value.setAttribute('className', 'canvasProgress__value');\n        _value.setAttribute('stroke', valueColor);\n        _value.setAttribute('stroke-width', valueWeight + 'px');\n\n        var length = _value.getTotalLength();\n        var to = length * (1 - percent);\n        _value.setAttribute('stroke-dasharray', length);\n        _value.setAttribute('stroke-dashoffset', Math.max(0, to));\n\n        shapeSvg.appendChild(_value);\n\n        var _shapeSvg$getElements3 = shapeSvg.getElementsByTagName('text'),\n            _shapeSvg$getElements4 = _slicedToArray(_shapeSvg$getElements3, 1),\n            text = _shapeSvg$getElements4[0];\n\n        if (label && text) {\n          text.textContent = label;\n          text.setAttribute('className', 'canvasProgress__label');\n\n          if (shape === 'horizontalPill') {\n            text.setAttribute('x', parseInt(text.getAttribute('x'), 10) + offset / 2);\n          }\n          if (shape === 'verticalPill') {\n            text.setAttribute('y', parseInt(text.getAttribute('y'), 10) - offset / 2);\n          }\n\n          Object.assign(text.style, font.spec);\n          shapeSvg.appendChild(text);\n          domNode.appendChild(shapeSvg);\n\n          var _text$getBBox = text.getBBox(),\n              labelWidth = _text$getBBox.width,\n              labelHeight = _text$getBBox.height;\n\n          if (shape === 'horizontalBar' || shape === 'horizontalPill') {\n            text.setAttribute('x', parseInt(text.getAttribute('x'), 10));\n            width += labelWidth;\n          }\n          if (shape === 'verticalBar' || shape === 'verticalPill') {\n            if (labelWidth > width) {\n              minX = -labelWidth / 2;\n              width = labelWidth;\n            }\n            minY -= labelHeight;\n            height += labelHeight;\n          }\n        }\n\n        shapeSvg.setAttribute('viewBox', [minX, minY, width, height].join(' '));\n        shapeSvg.setAttribute('width', domNode.offsetWidth);\n        shapeSvg.setAttribute('height', domNode.offsetHeight);\n\n        if (domNode.firstChild) {\n          domNode.removeChild(domNode.firstChild);\n        }\n        domNode.appendChild(shapeSvg);\n\n        handlers.onResize(function () {\n          shapeSvg.setAttribute('width', domNode.offsetWidth);\n          shapeSvg.setAttribute('height', domNode.offsetHeight);\n        });\n      }\n\n      handlers.done();\n    }\n  };\n};",null]}