{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/renderers/time_filter/components/pretty_duration/lib/format_duration.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/renderers/time_filter/components/pretty_duration/lib/format_duration.js","mtime":1567631711906},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatDuration = formatDuration;\n\nvar _datemath = require('@elastic/datemath');\n\nvar _datemath2 = _interopRequireDefault(_datemath);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _quick_ranges = require('./quick_ranges');\n\nvar _time_units = require('./time_units');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nvar lookupByRange = {};\n_quick_ranges.quickRanges.forEach(function (frame) {\n  lookupByRange[frame.from + ' to ' + frame.to] = frame;\n});\n\nfunction formatTime(time) {\n  var roundUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (_moment2.default.isMoment(time)) {\n    return time.format('lll');\n  } else {\n    if (time === 'now') {\n      return 'now';\n    } else {\n      var tryParse = _datemath2.default.parse(time, { roundUp: roundUp });\n      return _moment2.default.isMoment(tryParse) ? '~ ' + tryParse.fromNow() : time;\n    }\n  }\n}\n\nfunction cantLookup(from, to) {\n  return formatTime(from) + ' to ' + formatTime(to);\n}\n\nfunction formatDuration(from, to) {\n  var text = void 0;\n  // If both parts are date math, try to look up a reasonable string\n  if (from && to && !_moment2.default.isMoment(from) && !_moment2.default.isMoment(to)) {\n    var tryLookup = lookupByRange[from.toString() + ' to ' + to.toString()];\n    if (tryLookup) {\n      return tryLookup.display;\n    } else {\n      var fromParts = from.toString().split('-');\n      if (to.toString() === 'now' && fromParts[0] === 'now' && fromParts[1]) {\n        var rounded = fromParts[1].split('/');\n        text = 'Last ' + rounded[0];\n        if (rounded[1]) {\n          text = text + ' rounded to the ' + _time_units.timeUnits[rounded[1]];\n        }\n\n        return text;\n      } else {\n        return cantLookup(from, to);\n      }\n    }\n    // If at least one part is a moment, try to make pretty strings by parsing date math\n  } else {\n    return cantLookup(from, to);\n  }\n}",null]}