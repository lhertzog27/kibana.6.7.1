{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/monitoring/public/lib/elasticsearch_settings/start_checks.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/monitoring/public/lib/elasticsearch_settings/start_checks.js","mtime":1567631712098},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/*\n * NOTE: This returns a promise, thus the async. Typically there is no need to\n * await the return value since the function internals updates the controller's\n * model its their own.\n */\nvar startChecks = exports.startChecks = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(checkers, updateModel) {\n    var _this = this;\n\n    var runCheck, _checkers;\n\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            runCheck = function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(currentChecker) {\n                var _ref3, found, reason, error, errorReason;\n\n                return regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        updateModel({ checkMessage: currentChecker.getMessage() });\n\n                        _context.next = 3;\n                        return currentChecker.executeCheck();\n\n                      case 3:\n                        _ref3 = _context.sent;\n                        found = _ref3.found;\n                        reason = _ref3.reason;\n                        error = _ref3.error;\n                        errorReason = _ref3.errorReason;\n\n                        if (!error) {\n                          _context.next = 14;\n                          break;\n                        }\n\n                        updateModel({ errors: errorReason });\n\n                        if (!currentChecker.hasNext()) {\n                          _context.next = 12;\n                          break;\n                        }\n\n                        return _context.abrupt(\"return\", runCheck(currentChecker.getNext()));\n\n                      case 12:\n                        _context.next = 20;\n                        break;\n\n                      case 14:\n                        if (!found) {\n                          _context.next = 18;\n                          break;\n                        }\n\n                        return _context.abrupt(\"return\", updateModel({\n                          reason: reason,\n                          isLoading: false,\n                          checkMessage: null\n                        }));\n\n                      case 18:\n                        if (!currentChecker.hasNext()) {\n                          _context.next = 20;\n                          break;\n                        }\n\n                        return _context.abrupt(\"return\", runCheck(currentChecker.getNext()));\n\n                      case 20:\n\n                        // dead end\n                        updateModel({\n                          reason: null,\n                          isLoading: false,\n                          checkMessage: null\n                        });\n\n                      case 21:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, _this);\n              }));\n\n              return function runCheck(_x3) {\n                return _ref2.apply(this, arguments);\n              };\n            }();\n\n            _checkers = mapCheckers(checkers);\n            return _context2.abrupt(\"return\", runCheck(_checkers[0]));\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n\n  return function startChecks(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\n// call setNext on all the N-1 checkers to link them to the next checker\nvar mapCheckers = function mapCheckers(_checkers) {\n  return _checkers.map(function (current, checkerIndex) {\n    var next = _checkers[checkerIndex + 1];\n    if (next !== undefined) {\n      current.setNext(next);\n    }\n\n    return current;\n  });\n};",null]}