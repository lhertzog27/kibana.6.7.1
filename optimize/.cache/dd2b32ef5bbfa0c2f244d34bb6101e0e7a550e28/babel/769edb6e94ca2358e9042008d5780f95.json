{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/renderers/shape/index.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/canvas_plugin_src/renderers/shape/index.js","mtime":1567631711905},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shape = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\nvar _shapes = require('./shapes');\n\nvar shape = exports.shape = function shape() {\n  return {\n    name: 'shape',\n    displayName: 'Shape',\n    help: 'Render an shape',\n    reuseDomNode: true,\n    render: function render(domNode, config, handlers) {\n      var shape = config.shape,\n          fill = config.fill,\n          border = config.border,\n          borderWidth = config.borderWidth,\n          maintainAspect = config.maintainAspect;\n\n      var parser = new DOMParser();\n\n      var _parser$parseFromStri = parser.parseFromString(_shapes.shapes[shape], 'image/svg+xml').getElementsByTagName('svg'),\n          _parser$parseFromStri2 = _slicedToArray(_parser$parseFromStri, 1),\n          shapeSvg = _parser$parseFromStri2[0];\n\n      var shapeContent = shapeSvg.firstElementChild;\n\n      if (fill) {\n        shapeContent.setAttribute('fill', fill);\n      }\n      if (border) {\n        shapeContent.setAttribute('stroke', border);\n      }\n      var strokeWidth = Math.max(borderWidth, 0);\n      shapeContent.setAttribute('stroke-width', strokeWidth);\n      shapeContent.setAttribute('stroke-miterlimit', 999);\n      shapeContent.setAttribute('vector-effect', 'non-scaling-stroke');\n\n      shapeSvg.setAttribute('preserveAspectRatio', maintainAspect ? 'xMidYMid meet' : 'none');\n      shapeSvg.setAttribute('overflow', 'visible');\n\n      var initialViewBox = shapeSvg.getAttribute('viewBox').split(' ').map(function (v) {\n        return parseInt(v, 10);\n      });\n\n      var draw = function draw() {\n        var width = domNode.offsetWidth;\n        var height = domNode.offsetHeight;\n\n        // adjust viewBox based on border width\n\n        var _initialViewBox = _slicedToArray(initialViewBox, 4),\n            minX = _initialViewBox[0],\n            minY = _initialViewBox[1],\n            shapeWidth = _initialViewBox[2],\n            shapeHeight = _initialViewBox[3];\n\n        var borderOffset = strokeWidth;\n\n        if (width) {\n          var xOffset = shapeWidth / width * borderOffset;\n          minX -= xOffset;\n          shapeWidth += xOffset * 2;\n        } else {\n          shapeWidth = 0;\n        }\n\n        if (height) {\n          var yOffset = shapeHeight / height * borderOffset;\n          minY -= yOffset;\n          shapeHeight += yOffset * 2;\n        } else {\n          shapeHeight = 0;\n        }\n\n        shapeSvg.setAttribute('width', width);\n        shapeSvg.setAttribute('height', height);\n        shapeSvg.setAttribute('viewBox', [minX, minY, shapeWidth, shapeHeight].join(' '));\n\n        var oldShape = domNode.firstElementChild;\n        if (oldShape) {\n          domNode.removeChild(oldShape);\n        }\n\n        domNode.appendChild(shapeSvg);\n      };\n\n      draw();\n      handlers.done();\n      handlers.onResize(draw); // debouncing avoided for fluidity\n    }\n  };\n};",null]}