{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/elasticsearch_geo_utils.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/elasticsearch_geo_utils.js","mtime":1567631712017},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /*\n                                                                                                                                                                                                                                                                               * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                               * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                               * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                               */\n\nexports.hitsToGeoJson = hitsToGeoJson;\nexports.geoPointToGeometry = geoPointToGeometry;\nexports.makeGeohashGridPolygon = makeGeohashGridPolygon;\nexports.geoShapeToGeometry = geoShapeToGeometry;\nexports.createExtentFilter = createExtentFilter;\nexports.convertMapExtentToPolygon = convertMapExtentToPolygon;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _i18n = require('@kbn/i18n');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Converts Elasticsearch search results into GeoJson FeatureCollection\n *\n * @param {array} hits Elasticsearch search response hits array\n * @param {function} flattenHit Method to flatten hits._source and hits.fields into properties object.\n *   Should just be IndexPattern.flattenHit but wanted to avoid coupling this method to IndexPattern.\n * @param {string} geoFieldName Geometry field name\n * @param {string} geoFieldType Geometry field type [\"geo_point\", \"geo_shape\"]\n * @returns {number}\n */\nfunction hitsToGeoJson(hits, flattenHit, geoFieldName, geoFieldType) {\n  var features = [];\n  hits.forEach(function (hit) {\n    var properties = flattenHit(hit);\n\n    var geometries = void 0;\n    if (geoFieldType === 'geo_point') {\n      geometries = geoPointToGeometry(properties[geoFieldName]);\n    } else if (geoFieldType === 'geo_shape') {\n      geometries = geoShapeToGeometry(properties[geoFieldName]);\n    } else {\n      var errorMessage = _i18n.i18n.translate('xpack.maps.elasticsearch_geo_utils.unsupportedFieldTypeErrorMessage', {\n        defaultMessage: 'Unsupported field type, expected: geo_shape or geo_point, you provided: {geoFieldType}',\n        values: { geoFieldType: geoFieldType }\n      });\n      throw new Error(errorMessage);\n    }\n\n    // don't include geometry field value in properties\n    delete properties[geoFieldName];\n\n    return geometries.map(function (geometry) {\n      features.push({\n        type: 'Feature',\n        geometry: geometry,\n        properties: properties\n      });\n    });\n  });\n\n  return {\n    type: 'FeatureCollection',\n    features: features\n  };\n}\n\nfunction pointGeometryFactory(lat, lon) {\n  return {\n    type: 'Point',\n    coordinates: [lon, lat]\n  };\n}\n\nfunction geoPointToGeometry(value) {\n  if (!value) {\n    return [];\n  }\n\n  if (typeof value === 'string') {\n    var commaSplit = value.split(',');\n    if (commaSplit.length === 1) {\n      var errorMessage = _i18n.i18n.translate('xpack.maps.elasticsearch_geo_utils.geohashIsUnsupportedErrorMessage', {\n        defaultMessage: 'Unable to convert to geojson, geohash not supported'\n      });\n\n      throw new Error(errorMessage);\n    }\n    // Geo-point expressed as a string with the format: \"lat,lon\".\n    var lat = parseFloat(commaSplit[0]);\n    var lon = parseFloat(commaSplit[1]);\n    return [pointGeometryFactory(lat, lon)];\n  }\n\n  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && _lodash2.default.has(value, 'lat') && _lodash2.default.has(value, 'lon')) {\n    // Geo-point expressed as an object with the format: { lon, lat }\n    return [pointGeometryFactory(value.lat, value.lon)];\n  }\n\n  if (!Array.isArray(value)) {\n    var _errorMessage = _i18n.i18n.translate('xpack.maps.elasticsearch_geo_utils.unsupportedGeoPointValueErrorMessage', {\n      defaultMessage: 'Unsupported geo_point value: {geoPointValue}',\n      values: {\n        geoPointValue: value\n      }\n    });\n    throw new Error(_errorMessage);\n  }\n\n  if (value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number') {\n    // Geo-point expressed as an array with the format: [lon, lat]\n    var _lat = value[1];\n    var _lon = value[0];\n    return [pointGeometryFactory(_lat, _lon)];\n  }\n\n  // Geo-point expressed as an array of values\n  return value.reduce(function (points, itemInValueArray) {\n    return points.concat(geoPointToGeometry(itemInValueArray));\n  }, []);\n}\n\nfunction makeGeohashGridPolygon(geohashGridFeature) {\n  var esBbox = geohashGridFeature.properties.geohash_meta.rectangle;\n  return {\n    type: 'Polygon',\n    coordinates: [[[esBbox[0][1], esBbox[0][0]], [esBbox[1][1], esBbox[1][0]], [esBbox[2][1], esBbox[2][0]], [esBbox[3][1], esBbox[3][0]], [esBbox[0][1], esBbox[0][0]]]]\n  };\n}\n\nfunction geoShapeToGeometry(value) {\n  if (!value) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    // value expressed as an array of values\n    return value.reduce(function (shapes, itemInValueArray) {\n      return shapes.concat(geoShapeToGeometry(itemInValueArray));\n    }, []);\n  }\n\n  // TODO handle case where value is WKT and convert to geojson\n  if (typeof value === 'string') {\n    var errorMessage = _i18n.i18n.translate('xpack.maps.elasticsearch_geo_utils.wktIsUnsupportedErrorMessage', {\n      defaultMessage: 'Unable to convert WKT to geojson, not supported'\n    });\n    throw new Error(errorMessage);\n  }\n\n  var geoJson = _lodash2.default.cloneDeep(value);\n\n  // https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-shape.html#input-structure\n  // For some unknown compatibility nightmarish reason, Elasticsearch types are not capitalized the same as geojson types\n  // For example: 'LineString' geojson type is 'linestring' in elasticsearch\n  // Convert feature types to geojson spec values\n  switch (geoJson.type) {\n    case 'point':\n      geoJson.type = 'Point';\n      break;\n    case 'linestring':\n      geoJson.type = 'LineString';\n      break;\n    case 'polygon':\n      geoJson.type = 'Polygon';\n      break;\n    case 'multipoint':\n      geoJson.type = 'MultiPoint';\n      break;\n    case 'multilinestring':\n      geoJson.type = 'MultiLineString';\n      break;\n    case 'multipolygon':\n      geoJson.type = 'MultiPolygon';\n      break;\n    case 'geometrycollection':\n      geoJson.type = 'GeometryCollection';\n      break;\n    case 'envelope':\n    case 'circle':\n      // TODO handle envelope and circle geometry types which exist in elasticsearch but not in geojson\n      throw new Error('Unable to convert ' + geoJson.type + ' geometry to geojson, not supported');\n  }\n\n  return [geoJson];\n}\n\nvar POLYGON_COORDINATES_EXTERIOR_INDEX = 0;\nvar TOP_LEFT_INDEX = 0;\nvar BOTTOM_RIGHT_INDEX = 2;\n\nfunction createExtentFilter(mapExtent, geoFieldName, geoFieldType) {\n  var safePolygon = convertMapExtentToPolygon(mapExtent);\n\n  if (geoFieldType === 'geo_point') {\n    var verticies = safePolygon.coordinates[POLYGON_COORDINATES_EXTERIOR_INDEX];\n    return {\n      geo_bounding_box: _defineProperty({}, geoFieldName, {\n        top_left: verticies[TOP_LEFT_INDEX],\n        bottom_right: verticies[BOTTOM_RIGHT_INDEX]\n      })\n    };\n  } else if (geoFieldType === 'geo_shape') {\n    return {\n      geo_shape: _defineProperty({}, geoFieldName, {\n        shape: safePolygon,\n        relation: 'INTERSECTS'\n      })\n    };\n  } else {\n    var errorMessage = _i18n.i18n.translate('xpack.maps.elasticsearch_geo_utils.unsupportedGeoFieldTypeErrorMessage', {\n      defaultMessage: 'Unsupported field type, expected: geo_shape or geo_point, you provided: {geoFieldType}',\n      values: { geoFieldType: geoFieldType }\n    });\n    throw new Error(errorMessage);\n  }\n}\n\nfunction formatEnvelopeAsPolygon(_ref) {\n  var maxLat = _ref.maxLat,\n      maxLon = _ref.maxLon,\n      minLat = _ref.minLat,\n      minLon = _ref.minLon;\n\n  // GeoJSON mandates that the outer polygon must be counterclockwise to avoid ambiguous polygons\n  // when the shape crosses the dateline\n  var left = minLon;\n  var right = maxLon;\n  var top = maxLat > 90 ? 90 : maxLat;\n  var bottom = minLat < -90 ? -90 : minLat;\n  var topLeft = [left, top];\n  var bottomLeft = [left, bottom];\n  var bottomRight = [right, bottom];\n  var topRight = [right, top];\n  return {\n    'type': 'polygon',\n    'coordinates': [[topLeft, bottomLeft, bottomRight, topRight, topLeft]]\n  };\n}\n\n/*\n * Convert map bounds to polygon\n */\nfunction convertMapExtentToPolygon(_ref2) {\n  var maxLat = _ref2.maxLat,\n      maxLon = _ref2.maxLon,\n      minLat = _ref2.minLat,\n      minLon = _ref2.minLon;\n\n  var lonDelta = maxLon - minLon;\n  if (lonDelta >= 360) {\n    return formatEnvelopeAsPolygon({\n      maxLat: maxLat,\n      maxLon: 180,\n      minLat: minLat,\n      minLon: -180\n    });\n  }\n\n  if (maxLon > 180) {\n    // bounds cross dateline east to west\n    var overlapWestOfDateLine = maxLon - 180;\n    return formatEnvelopeAsPolygon({\n      maxLat: maxLat,\n      maxLon: -180 + overlapWestOfDateLine,\n      minLat: minLat,\n      minLon: minLon\n    });\n  }\n\n  if (minLon < -180) {\n    // bounds cross dateline west to east\n    var overlapEastOfDateLine = Math.abs(minLon) - 180;\n    return formatEnvelopeAsPolygon({\n      maxLat: maxLat,\n      maxLon: maxLon,\n      minLat: minLat,\n      minLon: 180 - overlapEastOfDateLine\n    });\n  }\n\n  return formatEnvelopeAsPolygon({ maxLat: maxLat, maxLon: maxLon, minLat: minLat, minLon: minLon });\n}",null]}