{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/console/public/src/sense_editor/row_parser.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/console/public/src/sense_editor/row_parser.js","mtime":1567631691128},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar MODE = {\n  REQUEST_START: 2,\n  IN_REQUEST: 4,\n  MULTI_DOC_CUR_DOC_END: 8,\n  REQUEST_END: 16,\n  BETWEEN_REQUESTS: 32\n\n};\n\nfunction RowParser(editor) {\n  var defaultEditor = editor;\n\n  this.getRowParseMode = function (row) {\n    if (row === null || typeof row === 'undefined') {\n      row = editor.getCursorPosition().row;\n    }\n\n    var session = editor.getSession();\n    if (row >= session.getLength() || row < 0) {\n      return MODE.BETWEEN_REQUESTS;\n    }\n    var mode = session.getState(row);\n    if (!mode) {\n      return MODE.BETWEEN_REQUESTS;\n    } // shouldn't really happen\n\n    if (mode !== 'start') {\n      return MODE.IN_REQUEST;\n    }\n    var line = (session.getLine(row) || '').trim();\n    if (!line || line[0] === '#') {\n      return MODE.BETWEEN_REQUESTS;\n    } // empty line or a comment waiting for a new req to start\n\n    if (line.indexOf('}', line.length - 1) >= 0) {\n      // check for a multi doc request (must start a new json doc immediately after this one end.\n      row++;\n      if (row < session.getLength()) {\n        line = (session.getLine(row) || '').trim();\n        if (line.indexOf('{') === 0) {\n          // next line is another doc in a multi doc\n          return MODE.MULTI_DOC_CUR_DOC_END | MODE.IN_REQUEST;\n        }\n      }\n      return MODE.REQUEST_END | MODE.MULTI_DOC_CUR_DOC_END; // end of request\n    }\n\n    // check for single line requests\n    row++;\n    if (row >= session.getLength()) {\n      return MODE.REQUEST_START | MODE.REQUEST_END;\n    }\n    line = (session.getLine(row) || '').trim();\n    if (line.indexOf('{') !== 0) {\n      // next line is another request\n      return MODE.REQUEST_START | MODE.REQUEST_END;\n    }\n\n    return MODE.REQUEST_START;\n  };\n\n  this.rowPredicate = function (row, editor, value) {\n    var mode = this.getRowParseMode(row, editor);\n    return (mode & value) > 0;\n  };\n\n  this.isEndRequestRow = function (row, _e) {\n    var editor = _e || defaultEditor;\n    return this.rowPredicate(row, editor, MODE.REQUEST_END);\n  };\n\n  this.isRequestEdge = function (row, _e) {\n    var editor = _e || defaultEditor;\n    return this.rowPredicate(row, editor, MODE.REQUEST_END | MODE.REQUEST_START);\n  };\n\n  this.isStartRequestRow = function (row, _e) {\n    var editor = _e || defaultEditor;\n    return this.rowPredicate(row, editor, MODE.REQUEST_START);\n  };\n\n  this.isInBetweenRequestsRow = function (row, _e) {\n    var editor = _e || defaultEditor;\n    return this.rowPredicate(row, editor, MODE.BETWEEN_REQUESTS);\n  };\n\n  this.isInRequestsRow = function (row, _e) {\n    var editor = _e || defaultEditor;\n    return this.rowPredicate(row, editor, MODE.IN_REQUEST);\n  };\n\n  this.isMultiDocDocEndRow = function (row, _e) {\n    var editor = _e || defaultEditor;\n    return this.rowPredicate(row, editor, MODE.MULTI_DOC_CUR_DOC_END);\n  };\n\n  this.isEmptyToken = function (tokenOrTokenIter) {\n    var token = tokenOrTokenIter && tokenOrTokenIter.getCurrentToken ? tokenOrTokenIter.getCurrentToken() : tokenOrTokenIter;\n    return !token || token.type === 'whitespace';\n  };\n\n  this.isUrlOrMethodToken = function (tokenOrTokenIter) {\n    var t = tokenOrTokenIter.getCurrentToken ? tokenOrTokenIter.getCurrentToken() : tokenOrTokenIter;\n    return t && t.type && (t.type === 'method' || t.type.indexOf('url') === 0);\n  };\n\n  this.nextNonEmptyToken = function (tokenIter) {\n    var t = tokenIter.stepForward();\n    while (t && this.isEmptyToken(t)) {\n      t = tokenIter.stepForward();\n    }return t;\n  };\n\n  this.prevNonEmptyToken = function (tokenIter) {\n    var t = tokenIter.stepBackward();\n    // empty rows return null token.\n    while ((t || tokenIter.getCurrentTokenRow() > 0) && this.isEmptyToken(t)) {\n      t = tokenIter.stepBackward();\n    }return t;\n  };\n}\n\nRowParser.prototype.MODE = MODE;\n\nexports.default = RowParser;\nmodule.exports = exports['default'];",null]}