{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/graph/public/app.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/graph/public/app.js","mtime":1567631711958},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nrequire('ace');\n\nvar _risonNode = require('rison-node');\n\nvar _risonNode2 = _interopRequireDefault(_risonNode);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nrequire('uiExports/fieldFormats');\n\nrequire('uiExports/savedObjectTypes');\n\nrequire('ui/autoload/all');\n\nrequire('ui/directives/saved_object_finder');\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _modules = require('ui/modules');\n\nvar _routes = require('ui/routes');\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nvar _notify = require('ui/notify');\n\nvar _index_patterns = require('ui/index_patterns/index_patterns');\n\nvar _saved_objects = require('ui/saved_objects');\n\nvar _kibana_parsed_url = require('ui/url/kibana_parsed_url');\n\nvar _xpack_info = require('plugins/xpack_main/services/xpack_info');\n\nvar _index = require('./templates/index.html');\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _react3 = require('@kbn/i18n/react');\n\nrequire('./angular-venn-simple.js');\n\nvar _graphClientWorkspace = require('./graphClientWorkspace.js');\n\nvar _graphClientWorkspace2 = _interopRequireDefault(_graphClientWorkspace);\n\nvar _utils = require('./utils.js');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _saved_workspaces = require('./services/saved_workspaces');\n\nvar _style_choices = require('./style_choices');\n\nvar _outlink_encoders = require('./services/outlink_encoders');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import the uiExports that we want to \"use\"\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nvar app = _modules.uiModules.get('app/graph');\n\nfunction checkLicense(Private, Promise, kbnBaseUrl) {\n  var xpackInfo = Private(_xpack_info.XPackInfoProvider);\n  var licenseAllowsToShowThisPage = xpackInfo.get('features.graph.showAppLink') && xpackInfo.get('features.graph.enableAppLink');\n  if (!licenseAllowsToShowThisPage) {\n    var message = xpackInfo.get('features.graph.message');\n    var newUrl = (0, _notify.addAppRedirectMessageToUrl)(_chrome2.default.addBasePath(kbnBaseUrl), message);\n    window.location.href = newUrl;\n    return Promise.halt();\n  }\n\n  return Promise.resolve();\n}\n\napp.directive('focusOn', function () {\n  return function (scope, elem, attr) {\n    scope.$on(attr.focusOn, function () {\n      elem[0].focus();\n    });\n  };\n});\n\nif (_routes2.default.enable) {\n  _routes2.default.enable();\n}\n\n_routes2.default.when('/home', {\n  template: _index2.default,\n  resolve: {\n    //Copied from example found in wizard.js ( Kibana TODO - can't\n    // IndexPatternsProvider abstract these implementation details better?)\n    indexPatterns: function indexPatterns(Private) {\n      var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);\n\n      return savedObjectsClient.find({\n        type: 'index-pattern',\n        fields: ['title', 'type'],\n        perPage: 10000\n      }).then(function (response) {\n        return response.savedObjects;\n      });\n    },\n    GetIndexPatternProvider: function GetIndexPatternProvider(Private) {\n      return Private(_index_patterns.IndexPatternsProvider);\n    },\n    SavedWorkspacesProvider: function SavedWorkspacesProvider(Private) {\n      return Private(_saved_workspaces.SavedWorkspacesProvider);\n    },\n    CheckLicense: checkLicense\n  }\n}).when('/workspace/:id', {\n  template: _index2.default,\n  resolve: {\n    savedWorkspace: function savedWorkspace(savedGraphWorkspaces, courier, $route, i18n) {\n      return savedGraphWorkspaces.get($route.current.params.id).catch(function () {\n        _notify.toastNotifications.addDanger(i18n('xpack.graph.missingWorkspaceErrorMessage', {\n          defaultMessage: 'Missing workspace'\n        }));\n      });\n    },\n    //Copied from example found in wizard.js ( Kibana TODO - can't\n    // IndexPatternsProvider abstract these implementation details better?)\n    indexPatterns: function indexPatterns(Private) {\n      var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);\n\n      return savedObjectsClient.find({\n        type: 'index-pattern',\n        fields: ['title', 'type'],\n        perPage: 10000\n      }).then(function (response) {\n        return response.savedObjects;\n      });\n    },\n    GetIndexPatternProvider: function GetIndexPatternProvider(Private) {\n      return Private(_index_patterns.IndexPatternsProvider);\n    },\n    SavedWorkspacesProvider: function SavedWorkspacesProvider(Private) {\n      return Private(_saved_workspaces.SavedWorkspacesProvider);\n    },\n    CheckLicense: checkLicense\n  }\n}).otherwise({\n  redirectTo: '/home'\n});\n\n//========  Controller for basic UI ==================\napp.controller('graphuiPlugin', function ($scope, $route, $interval, $http, kbnUrl, Private, Promise, confirmModal, kbnBaseUrl, i18n) {\n\n  function handleSuccess(data) {\n    return checkLicense(Private, Promise, kbnBaseUrl).then(function () {\n      return data;\n    });\n  }\n\n  function handleError(err) {\n    return checkLicense(Private, Promise, kbnBaseUrl).then(function () {\n      return _notify.notify.error(err);\n    });\n  }\n\n  $scope.title = 'Graph';\n  $scope.spymode = 'request';\n\n  $scope.iconChoices = _style_choices.iconChoices;\n  $scope.drillDownIconChoices = _style_choices.drillDownIconChoices;\n  $scope.colors = _style_choices.colorChoices;\n  $scope.iconChoicesByClass = _style_choices.iconChoicesByClass;\n\n  $scope.outlinkEncoders = (0, _outlink_encoders.getOutlinkEncoders)(i18n);\n\n  $scope.fields = [];\n  $scope.canEditDrillDownUrls = _chrome2.default.getInjected('canEditDrillDownUrls');\n\n  $scope.graphSavePolicy = _chrome2.default.getInjected('graphSavePolicy');\n  $scope.allSavingDisabled = $scope.graphSavePolicy === 'none';\n  $scope.searchTerm = '';\n\n  //So scope properties can be used consistently with ng-model\n  $scope.grr = $scope;\n\n  //Updates styling on all nodes in the UI that use this field\n  $scope.applyColor = function (fieldDef, color) {\n    fieldDef.color = color;\n    if ($scope.workspace) {\n      $scope.workspace.nodes.forEach(function (node) {\n        if (node.data.field === fieldDef.name) {\n          node.color = color;\n        }\n      });\n    }\n  };\n\n  //Updates styling on all nodes in the UI that use this field\n  $scope.applyIcon = function (fieldDef, icon) {\n    fieldDef.icon = icon;\n    if ($scope.workspace) {\n      $scope.workspace.nodes.forEach(function (node) {\n        if (node.data.field === fieldDef.name) {\n          node.icon = icon;\n        }\n      });\n    }\n  };\n\n  $scope.toggleDrillDownIcon = function (urlTemplate, icon) {\n    urlTemplate.icon === icon ? urlTemplate.icon = null : urlTemplate.icon = icon;\n  };\n\n  $scope.openSavedWorkspace = function (savedWorkspace) {\n    kbnUrl.change('/workspace/{{id}}', { id: savedWorkspace.id });\n  };\n\n  $scope.nodeClick = function (n, $event) {\n\n    //Selection logic - shift key+click helps selects multiple nodes\n    // Without the shift key we deselect all prior selections (perhaps not\n    // a great idea for touch devices with no concept of shift key)\n    if (!$event.shiftKey) {\n      var prevSelection = n.isSelected;\n      $scope.workspace.selectNone();\n      n.isSelected = prevSelection;\n    }\n\n    if ($scope.workspace.toggleNodeSelection(n)) {\n      $scope.selectSelected(n);\n    } else {\n      $scope.detail = null;\n    }\n  };\n\n  //A live response field is one that is both selected and actively enabled for returning in responses\n  // We call this function to refresh the array whenever there is a change in the conditions.\n  $scope.updateLiveResponseFields = function () {\n    $scope.liveResponseFields = $scope.selectedFields.filter(function (fieldDef) {\n      return fieldDef.hopSize > 0 && fieldDef.selected;\n    });\n  };\n\n  $scope.selectedFieldConfigHopSizeChanged = function () {\n    // Only vertex fields with hop size > 0 are deemed \"live\"\n    // so when there is a change we re-evaluate the list of live fields\n    $scope.updateLiveResponseFields();\n  };\n\n  $scope.hideAllConfigPanels = function () {\n    $scope.selectedFieldConfig = null;\n    $scope.kbnTopNav.close();\n  };\n\n  $scope.setAllFieldStatesToDefault = function () {\n    $scope.selectedFields = [];\n    $scope.basicModeSelectedSingleField = null;\n    $scope.liveResponseFields = [];\n\n    // Default field state is not selected\n    $scope.allFields.forEach(function (fieldDef) {\n      fieldDef.selected = false;\n    });\n  };\n\n  $scope.addFieldToSelection = function () {\n    $scope.selectedField.selected = true;\n    if ($scope.selectedFields.indexOf($scope.selectedField) < 0) {\n      $scope.selectedFields.push($scope.selectedField);\n    }\n    $scope.updateLiveResponseFields();\n    //Force load of the config panel for the field\n    $scope.clickVertexFieldIcon($scope.selectedField);\n  };\n\n  $scope.clickVertexFieldIcon = function (field, $event) {\n    // Shift click is a fast way to toggle if the field is active or not.\n    if ($event && field) {\n      if ($event.shiftKey) {\n        if (field.hopSize === 0) {\n          field.hopSize = field.lastValidHopSize ? field.lastValidHopSize : 5;\n        } else {\n          field.lastValidHopSize = field.hopSize;\n          field.hopSize = 0;\n        }\n        $scope.updateLiveResponseFields();\n        return;\n      }\n    }\n\n    // Check if user is toggling off an already-open config panel for the current field\n    if ($scope.kbnTopNav.currentKey === 'fieldConfig' && field === $scope.selectedFieldConfig) {\n      $scope.hideAllConfigPanels();\n      return;\n    }\n    $scope.hideAllConfigPanels();\n    $scope.selectedFieldConfig = field;\n    $scope.kbnTopNav.currentKey = 'fieldConfig';\n  };\n\n  function canWipeWorkspace(yesFn, noFn) {\n    if ($scope.selectedFields.length === 0 && $scope.workspace === null) {\n      yesFn();\n      return;\n    }\n    var confirmModalOptions = {\n      onConfirm: yesFn,\n      onCancel: noFn,\n      confirmButtonText: i18n('xpack.graph.clearWorkspace.confirmButtonLabel', {\n        defaultMessage: 'Clear workspace'\n      })\n    };\n    confirmModal(i18n('xpack.graph.clearWorkspace.confirmText', {\n      defaultMessage: 'This will clear the workspace - are you sure?'\n    }), confirmModalOptions);\n  }\n\n  $scope.uiSelectIndex = function () {\n    canWipeWorkspace(function () {\n      $scope.indexSelected($scope.proposedIndex);\n    }, function () {\n      $scope.proposedIndex = $scope.selectedIndex;\n    });\n  };\n\n  $scope.indexSelected = function (selectedIndex, postInitHandler) {\n    $scope.clearWorkspace();\n    $scope.allFields = [];\n    $scope.selectedFields = [];\n    $scope.basicModeSelectedSingleField = null;\n    $scope.selectedField = null;\n    $scope.selectedFieldConfig = null;\n    $scope.selectedIndex = selectedIndex;\n    $scope.proposedIndex = selectedIndex;\n\n    var promise = $route.current.locals.GetIndexPatternProvider.get(selectedIndex.id);\n    promise.then(handleSuccess).then(function (indexPattern) {\n      var patternFields = indexPattern.getNonScriptedFields();\n      var blockedFieldNames = ['_id', '_index', '_score', '_source', '_type'];\n      patternFields.forEach(function (field, index) {\n        if (blockedFieldNames.indexOf(field.name) >= 0) {\n          return;\n        }\n        var graphFieldDef = {\n          'name': field.name\n        };\n        $scope.allFields.push(graphFieldDef);\n        graphFieldDef.hopSize = 5; //Default the number of results returned per hop\n        graphFieldDef.lastValidHopSize = graphFieldDef.hopSize;\n        graphFieldDef.icon = $scope.iconChoices[0];\n        for (var i = 0; i < $scope.iconChoices.length; i++) {\n          var icon = $scope.iconChoices[i];\n          for (var p = 0; p < icon.patterns.length; p++) {\n            var pattern = icon.patterns[p];\n            if (pattern.test(graphFieldDef.name)) {\n              graphFieldDef.icon = icon;\n              break;\n            }\n          }\n        }\n        graphFieldDef.color = $scope.colors[index % $scope.colors.length];\n      });\n      $scope.setAllFieldStatesToDefault();\n\n      $scope.allFields.sort(function (a, b) {\n        // TODO - should we use \"popularity\" setting from index pattern definition?\n        // What is its intended use? Couldn't see it on the patternField objects\n        if (a.name < b.name) {\n          return -1;\n        } else if (a.name > b.name) {\n          return 1;\n        }\n        return 0;\n      });\n      $scope.filteredFields = $scope.allFields;\n      if ($scope.allFields.length > 0) {\n        $scope.selectedField = $scope.allFields[0];\n      }\n\n      if (postInitHandler) {\n        postInitHandler();\n      }\n    }, handleError);\n  };\n\n  $scope.clickEdge = function (edge) {\n    if (edge.inferred) {\n      $scope.setDetail({ 'inferredEdge': edge });\n    } else {\n      $scope.workspace.getAllIntersections($scope.handleMergeCandidatesCallback, [edge.topSrc, edge.topTarget]);\n    }\n  };\n\n  // Replacement function for graphClientWorkspace's comms so\n  // that it works with Kibana.\n  function callNodeProxy(indexName, query, responseHandler) {\n    var request = {\n      index: indexName,\n      query: query\n    };\n    return $http.post('../api/graph/graphExplore', request).then(function (resp) {\n      if (resp.data.resp.timed_out) {\n        _notify.toastNotifications.addWarning(i18n('xpack.graph.exploreGraph.timedOutWarningText', {\n          defaultMessage: 'Exploration timed out'\n        }));\n      }\n      responseHandler(resp.data.resp);\n    }).catch(handleError);\n  }\n\n  //Helper function for the graphClientWorkspace to perform a query\n  var callSearchNodeProxy = function callSearchNodeProxy(indexName, query, responseHandler) {\n    var request = {\n      index: indexName,\n      body: query\n    };\n    $http.post('../api/graph/searchProxy', request).then(function (resp) {\n      responseHandler(resp.data.resp);\n    }).catch(handleError);\n  };\n\n  $scope.submit = function () {\n    $scope.hideAllConfigPanels();\n    initWorkspaceIfRequired();\n    var numHops = 2;\n    if ($scope.searchTerm.startsWith('{')) {\n      try {\n        var query = JSON.parse($scope.searchTerm);\n        if (query.vertices) {\n          // Is a graph explore request\n          $scope.workspace.callElasticsearch(query);\n        } else {\n          // Is a regular query DSL query\n          $scope.workspace.search(query, $scope.liveResponseFields, numHops);\n        }\n      } catch (err) {\n        handleError(err);\n      }\n      return;\n    }\n    $scope.workspace.simpleSearch($scope.searchTerm, $scope.liveResponseFields, numHops);\n  };\n\n  $scope.clearWorkspace = function () {\n    $scope.workspace = null;\n    $scope.detail = null;\n    if ($scope.kbnTopNav) {\n      $scope.kbnTopNav.close();\n    }\n  };\n\n  $scope.toggleShowAdvancedFieldsConfig = function () {\n    if ($scope.kbnTopNav.currentKey !== 'fields') {\n      $scope.kbnTopNav.close();\n      $scope.kbnTopNav.currentKey = 'fields';\n      //Default the selected field\n      $scope.selectedField = null;\n      $scope.filteredFields = $scope.allFields.filter(function (fieldDef) {\n        return !fieldDef.selected;\n      });\n      if ($scope.filteredFields.length > 0) {\n        $scope.selectedField = $scope.filteredFields[0];\n      }\n    } else {\n      $scope.hideAllConfigPanels();\n    }\n  };\n\n  $scope.removeVertexFieldSelection = function () {\n    $scope.selectedFieldConfig.selected = false;\n    // Find and remove field from array (important not to just make a new filtered array because\n    // this array instance is shared with $scope.workspace)\n    var i = $scope.selectedFields.indexOf($scope.selectedFieldConfig);\n    if (i !== -1) {\n      $scope.selectedFields.splice(i, 1);\n    }\n    $scope.updateLiveResponseFields();\n    $scope.hideAllConfigPanels();\n  };\n\n  $scope.selectSelected = function (node) {\n    $scope.detail = {\n      latestNodeSelection: node\n    };\n    return $scope.selectedSelectedVertex = node;\n  };\n\n  $scope.isSelectedSelected = function (node) {\n    return $scope.selectedSelectedVertex === node;\n  };\n\n  $scope.filterFieldsKeyDown = function () {\n    var lcFilter = $scope.fieldNamesFilterString.toLowerCase();\n    $scope.filteredFields = $scope.allFields.filter(function (fieldDef) {\n      return !fieldDef.selected && (!lcFilter || lcFilter === '' || fieldDef.name.toLowerCase().indexOf(lcFilter) >= 0);\n    });\n  };\n\n  //== Drill-down functionality ==\n  var defaultKibanaQuery = ',query:(query_string:(analyze_wildcard:!t,query:\\'*\\'))';\n  var drillDownRegex = /\\{\\{gquery\\}\\}/;\n\n  $scope.checkForKibanaUrl = function () {\n    $scope.suggestTemplateFix = $scope.newUrlTemplate.url === $scope.lastPastedURL && $scope.newUrlTemplate.url.indexOf(defaultKibanaQuery) > 0;\n  };\n\n  $scope.replaceKibanaUrlParam = function () {\n    $scope.newUrlTemplate.url = $scope.newUrlTemplate.url.replace(defaultKibanaQuery, ',query:{{gquery}}');\n    $scope.lastPastedURL = null;\n    $scope.checkForKibanaUrl();\n  };\n\n  $scope.rejectKibanaUrlSuggestion = function () {\n    $scope.lastPastedURL = null;\n    $scope.checkForKibanaUrl();\n  };\n\n  function detectKibanaUrlPaste(url) {\n    $scope.lastPastedURL = url;\n    $scope.checkForKibanaUrl();\n  }\n\n  $scope.handleUrlTemplatePaste = function ($event) {\n    window.setTimeout(function () {\n      detectKibanaUrlPaste(angular.element($event.currentTarget).val());\n      $scope.$digest();\n    }, 0);\n  };\n\n  $scope.resetNewUrlTemplate = function () {\n    $scope.newUrlTemplate = {\n      url: null,\n      description: null,\n      encoder: $scope.outlinkEncoders[0]\n    };\n  };\n\n  $scope.editUrlTemplate = function (urlTemplate) {\n    Object.assign($scope.newUrlTemplate, urlTemplate, { templateBeingEdited: urlTemplate });\n  };\n\n  $scope.saveUrlTemplate = function () {\n    var found = $scope.newUrlTemplate.url.search(drillDownRegex) > -1;\n    if (!found) {\n      _notify.toastNotifications.addWarning({\n        title: i18n('xpack.graph.settings.drillDowns.invalidUrlWarningTitle', {\n          defaultMessage: 'Invalid URL'\n        }),\n        text: i18n('xpack.graph.settings.drillDowns.invalidUrlWarningText', {\n          defaultMessage: 'The URL must contain a {placeholder} string',\n          values: {\n            placeholder: '{{gquery}}'\n          }\n        })\n      });\n      return;\n    }\n    if ($scope.newUrlTemplate.templateBeingEdited) {\n\n      if ($scope.urlTemplates.indexOf($scope.newUrlTemplate.templateBeingEdited) >= 0) {\n        //patch any existing object\n        Object.assign($scope.newUrlTemplate.templateBeingEdited, $scope.newUrlTemplate);\n        return;\n      }\n    }\n    $scope.urlTemplates.push($scope.newUrlTemplate);\n    $scope.resetNewUrlTemplate();\n  };\n\n  $scope.removeUrlTemplate = function (urlTemplate) {\n    var i = $scope.urlTemplates.indexOf(urlTemplate);\n    if (i != -1) {\n      confirmModal(i18n('xpack.graph.settings.drillDowns.removeConfirmText', {\n        defaultMessage: 'Remove \"{urlTemplateDesciption}\" drill-down?',\n        values: { urlTemplateDesciption: urlTemplate.description }\n      }), {\n        onConfirm: function onConfirm() {\n          return $scope.urlTemplates.splice(i, 1);\n        },\n        confirmButtonText: i18n('xpack.graph.settings.drillDowns.removeConfirmButtonLabel', {\n          defaultMessage: 'Remove drill-down'\n        })\n      });\n    }\n  };\n\n  $scope.openUrlTemplate = function (template) {\n    var url = template.url;\n    var newUrl = url.replace(drillDownRegex, template.encoder.encode($scope.workspace));\n    window.open(newUrl, '_blank');\n  };\n\n  //============================\n\n  $scope.resetWorkspace = function () {\n    $scope.clearWorkspace();\n    $scope.userHasConfirmedSaveWorkspaceData = false;\n    $scope.selectedIndex = null;\n    $scope.proposedIndex = null;\n    $scope.detail = null;\n    $scope.selectedSelectedVertex = null;\n    $scope.selectedField = null;\n    $scope.description = null;\n    $scope.allFields = [];\n    $scope.urlTemplates = [];\n    $scope.resetNewUrlTemplate();\n\n    $scope.fieldNamesFilterString = null;\n    $scope.filteredFields = [];\n\n    $scope.selectedFields = [];\n    $scope.configPanel = 'settings';\n    $scope.liveResponseFields = [];\n\n    $scope.exploreControls = {\n      useSignificance: true,\n      sampleSize: 2000,\n      timeoutMillis: 5000,\n      sampleDiversityField: null,\n      maxValuesPerDoc: 1,\n      minDocCount: 3\n    };\n  };\n\n  function initWorkspaceIfRequired() {\n    if ($scope.workspace) {\n      return;\n    }\n    var options = {\n      indexName: $scope.selectedIndex.attributes.title,\n      vertex_fields: $scope.selectedFields,\n      // Here we have the opportunity to look up labels for nodes...\n      nodeLabeller: function nodeLabeller() {\n        //   console.log(newNodes);\n      },\n      changeHandler: function changeHandler() {\n        //Allows DOM to update with graph layout changes.\n        $scope.$apply();\n      },\n      graphExploreProxy: callNodeProxy,\n      searchProxy: callSearchNodeProxy,\n      exploreControls: $scope.exploreControls\n    };\n    $scope.workspace = _graphClientWorkspace2.default.createWorkspace(options);\n    $scope.detail = null;\n\n    if ($scope.urlTemplates.length === 0) {\n      // url templates specified by users can include the `{{gquery}}` tag and\n      // will have the elasticsearch query for the graph nodes injected there\n      var tag = '{{gquery}}';\n\n      var kUrl = new _kibana_parsed_url.KibanaParsedUrl({\n        appId: 'kibana',\n        basePath: _chrome2.default.getBasePath(),\n        appPath: '/discover'\n      });\n\n      kUrl.addQueryParameter('_a', _risonNode2.default.encode({\n        columns: ['_source'],\n        index: $scope.selectedIndex.id,\n        interval: 'auto',\n        query: tag,\n        sort: ['_score', 'desc']\n      }));\n\n      var discoverUrl = kUrl.getRootRelativePath()\n      // replace the URI encoded version of the tag with the unescaped version\n      // so it can be found with String.replace, regexp, etc.\n      .replace(encodeURIComponent(tag), tag);\n\n      $scope.urlTemplates.push({\n        url: discoverUrl,\n        description: i18n('xpack.graph.settings.drillDowns.defaultUrlTemplateTitle', {\n          defaultMessage: 'Raw documents'\n        }),\n        encoder: $scope.outlinkEncoders[0]\n      });\n    }\n  }\n\n  $scope.indices = $route.current.locals.indexPatterns.filter(function (indexPattern) {\n    return !indexPattern.get('type');\n  });\n\n  $scope.setDetail = function (data) {\n    $scope.detail = data;\n  };\n\n  $scope.performMerge = function (parentId, childId) {\n    var found = true;\n    while (found) {\n      found = false;\n      for (var i in $scope.detail.mergeCandidates) {\n        var mc = $scope.detail.mergeCandidates[i];\n        if (mc.id1 === childId || mc.id2 === childId) {\n          $scope.detail.mergeCandidates.splice(i, 1);\n          found = true;\n          break;\n        }\n      }\n    }\n    $scope.workspace.mergeIds(parentId, childId);\n    $scope.detail = null;\n  };\n\n  $scope.handleMergeCandidatesCallback = function (termIntersects) {\n    $scope.detail = {\n      'mergeCandidates': _utils2.default.getMergeSuggestionObjects(termIntersects)\n    };\n  };\n\n  // Zoom functions for the SVG-based graph\n  var redraw = function redraw() {\n    _d2.default.select('#svgRootGroup').attr('transform', 'translate(' + _d2.default.event.translate + ')' + 'scale(' + _d2.default.event.scale + ')').attr('style', 'stroke-width: ' + 1 / _d2.default.event.scale);\n    //To make scale-dependent features possible....\n    if ($scope.zoomLevel !== _d2.default.event.scale) {\n      $scope.zoomLevel = _d2.default.event.scale;\n      $scope.$apply();\n    }\n  };\n\n  //initialize all the state\n  $scope.resetWorkspace();\n\n  var blockScroll = function blockScroll() {\n    _d2.default.event.preventDefault();\n  };\n  _d2.default.select('#graphSvg').on('mousewheel', blockScroll).on('DOMMouseScroll', blockScroll).call(_d2.default.behavior.zoom().on('zoom', redraw));\n\n  var managementUrl = _chrome2.default.getNavLinkById('kibana:management').url;\n  var url = managementUrl + '/kibana/indices';\n\n  if ($scope.indices.length === 0) {\n    _notify.toastNotifications.addWarning({\n      title: i18n('xpack.graph.noDataSourceNotificationMessageTitle', {\n        defaultMessage: 'No data source'\n      }),\n      text: _react2.default.createElement(\n        'p',\n        null,\n        _react2.default.createElement(_react3.FormattedMessage, {\n          id: 'xpack.graph.noDataSourceNotificationMessageText',\n          defaultMessage: 'Go to {managementIndexPatternsLink} and create an index pattern',\n          values: {\n            managementIndexPatternsLink: _react2.default.createElement(\n              'a',\n              { href: url },\n              _react2.default.createElement(_react3.FormattedMessage, {\n                id: 'xpack.graph.noDataSourceNotificationMessageText.managementIndexPatternLinkText',\n                defaultMessage: 'Management > Index Patterns'\n              })\n            )\n          }\n        })\n      )\n    });\n  }\n\n  // ===== Menubar configuration =========\n  $scope.topNavMenu = [];\n  $scope.topNavMenu.push({\n    key: 'new',\n    label: i18n('xpack.graph.topNavMenu.newWorkspaceLabel', {\n      defaultMessage: 'New'\n    }),\n    description: i18n('xpack.graph.topNavMenu.newWorkspaceAriaLabel', {\n      defaultMessage: 'New Workspace'\n    }),\n    tooltip: i18n('xpack.graph.topNavMenu.newWorkspaceTooltip', {\n      defaultMessage: 'Create a new workspace'\n    }),\n    run: function run() {\n      canWipeWorkspace(function () {\n        kbnUrl.change('/home', {});\n      });\n    }\n  });\n  if (!$scope.allSavingDisabled) {\n    $scope.topNavMenu.push({\n      key: 'save',\n      label: i18n('xpack.graph.topNavMenu.saveWorkspace.enabledLabel', {\n        defaultMessage: 'Save'\n      }),\n      description: i18n('xpack.graph.topNavMenu.saveWorkspace.enabledAriaLabel', {\n        defaultMessage: 'Save Workspace'\n      }),\n      tooltip: i18n('xpack.graph.topNavMenu.saveWorkspace.enabledTooltip', {\n        defaultMessage: 'Save this workspace'\n      }),\n      disableButton: function disableButton() {\n        return $scope.selectedFields.length === 0;\n      },\n      template: require('./templates/save_workspace.html')\n    });\n  } else {\n    $scope.topNavMenu.push({\n      key: 'save',\n      label: i18n('xpack.graph.topNavMenu.saveWorkspace.disabledLabel', {\n        defaultMessage: 'Save'\n      }),\n      description: i18n('xpack.graph.topNavMenu.saveWorkspace.disabledAriaLabel', {\n        defaultMessage: 'Save Workspace'\n      }),\n      tooltip: i18n('xpack.graph.topNavMenu.saveWorkspace.disabledTooltip', {\n        defaultMessage: 'No changes to saved workspaces are permitted by the current save policy'\n      }),\n      disableButton: true\n    });\n  }\n  $scope.topNavMenu.push({\n    key: 'open',\n    label: i18n('xpack.graph.topNavMenu.loadWorkspaceLabel', {\n      defaultMessage: 'Open'\n    }),\n    description: i18n('xpack.graph.topNavMenu.loadWorkspaceAriaLabel', {\n      defaultMessage: 'Load Saved Workspace'\n    }),\n    tooltip: i18n('xpack.graph.topNavMenu.loadWorkspaceTooltip', {\n      defaultMessage: 'Load a saved workspace'\n    }),\n    template: require('./templates/load_workspace.html')\n  });\n  if (!$scope.allSavingDisabled) {\n    $scope.topNavMenu.push({\n      key: 'delete',\n      disableButton: function disableButton() {\n        return $route.current.locals === undefined || $route.current.locals.savedWorkspace === undefined;\n      },\n      label: i18n('xpack.graph.topNavMenu.deleteWorkspace.enabledLabel', {\n        defaultMessage: 'Delete'\n      }),\n      description: i18n('xpack.graph.topNavMenu.deleteWorkspace.enabledAriaLabel', {\n        defaultMessage: 'Delete Saved Workspace'\n      }),\n      tooltip: i18n('xpack.graph.topNavMenu.deleteWorkspace.enabledAriaTooltip', {\n        defaultMessage: 'Delete this workspace'\n      }),\n      run: function run() {\n        var title = $route.current.locals.savedWorkspace.title;\n        function doDelete() {\n          $route.current.locals.SavedWorkspacesProvider.delete($route.current.locals.savedWorkspace.id);\n          kbnUrl.change('/home', {});\n\n          _notify.toastNotifications.addSuccess(i18n('xpack.graph.topNavMenu.deleteWorkspaceNotification', {\n            defaultMessage: 'Deleted \\'{workspaceTitle}\\'',\n            values: { workspaceTitle: title }\n          }));\n        }\n        var confirmModalOptions = {\n          onConfirm: doDelete,\n          confirmButtonText: i18n('xpack.graph.topNavMenu.deleteWorkspace.confirmButtonLabel', {\n            defaultMessage: 'Delete workspace'\n          })\n        };\n        confirmModal(i18n('xpack.graph.topNavMenu.deleteWorkspace.confirmText', {\n          defaultMessage: 'Are you sure you want to delete the workspace {title} ?',\n          values: { title: title }\n        }), confirmModalOptions);\n      }\n    });\n  } else {\n    $scope.topNavMenu.push({\n      key: 'delete',\n      disableButton: true,\n      label: i18n('xpack.graph.topNavMenu.deleteWorkspace.disabledLabel', {\n        defaultMessage: 'Delete'\n      }),\n      description: i18n('xpack.graph.topNavMenu.deleteWorkspace.disabledAriaLabel', {\n        defaultMessage: 'Delete Saved Workspace'\n      }),\n      tooltip: i18n('xpack.graph.topNavMenu.deleteWorkspace.disabledTooltip', {\n        defaultMessage: 'No changes to saved workspaces are permitted by the current save policy'\n      })\n    });\n  }\n  $scope.topNavMenu.push({\n    key: 'settings',\n    disableButton: function disableButton() {\n      return $scope.selectedIndex === null;\n    },\n    label: i18n('xpack.graph.topNavMenu.settingsLabel', {\n      defaultMessage: 'Settings'\n    }),\n    description: i18n('xpack.graph.topNavMenu.settingsAriaLabel', {\n      defaultMessage: 'Settings'\n    }),\n    template: require('./templates/settings.html')\n  });\n\n  // Deal with situation of request to open saved workspace\n  if ($route.current.locals.savedWorkspace) {\n\n    var wsObj = JSON.parse($route.current.locals.savedWorkspace.wsState);\n    $scope.savedWorkspace = $route.current.locals.savedWorkspace;\n    $scope.description = $route.current.locals.savedWorkspace.description;\n\n    // Load any saved drill-down templates\n    wsObj.urlTemplates.forEach(function (urlTemplate) {\n      var encoder = $scope.outlinkEncoders.find(function (outlinkEncoder) {\n        return outlinkEncoder.id === urlTemplate.encoderID;\n      });\n      if (encoder) {\n        var template = {\n          url: urlTemplate.url,\n          description: urlTemplate.description,\n          encoder: encoder\n        };\n        if (urlTemplate.iconClass) {\n          template.icon = _style_choices.drillDownIconChoicesByClass[urlTemplate.iconClass];\n        }\n        $scope.urlTemplates.push(template);\n      }\n    });\n\n    //Lookup the saved index pattern title\n    var savedObjectIndexPattern = null;\n    $scope.indices.forEach(function (savedObject) {\n      // wsObj.indexPattern is the title string of an indexPattern which\n      // we attempt here to look up in the list of currently saved objects\n      // that contain index pattern definitions\n      if (savedObject.attributes.title === wsObj.indexPattern) {\n        savedObjectIndexPattern = savedObject;\n      }\n    });\n    if (!savedObjectIndexPattern) {\n      _notify.toastNotifications.addDanger(i18n('xpack.graph.loadWorkspace.missingIndexPatternErrorMessage', {\n        defaultMessage: 'Missing index pattern {indexPattern}',\n        values: { indexPattern: wsObj.indexPattern }\n      }));\n      return;\n    }\n\n    $scope.indexSelected(savedObjectIndexPattern, function () {\n      Object.assign($scope.exploreControls, wsObj.exploreControls);\n\n      if ($scope.exploreControls.sampleDiversityField) {\n        $scope.exploreControls.sampleDiversityField = $scope.allFields.find(function (field) {\n          return $scope.exploreControls.sampleDiversityField.name === field.name;\n        });\n      }\n\n      for (var i in wsObj.selectedFields) {\n        var savedField = wsObj.selectedFields[i];\n        for (var f in $scope.allFields) {\n          var field = $scope.allFields[f];\n          if (savedField.name === field.name) {\n            field.hopSize = savedField.hopSize;\n            field.lastValidHopSize = savedField.lastValidHopSize;\n            field.color = savedField.color;\n            field.icon = $scope.iconChoicesByClass[savedField.iconClass];\n            field.selected = true;\n            $scope.selectedFields.push(field);\n            break;\n          }\n        }\n        //TODO what if field name no longer exists as part of the index-pattern definition?\n      }\n\n      $scope.updateLiveResponseFields();\n      initWorkspaceIfRequired();\n      var graph = {\n        nodes: [],\n        edges: []\n      };\n      for (var _i in wsObj.vertices) {\n        var vertex = wsObj.vertices[_i]; // eslint-disable-line no-var\n        var node = {\n          field: vertex.field,\n          term: vertex.term,\n          label: vertex.label,\n          color: vertex.color,\n          icon: $scope.allFields.filter(function (fieldDef) {\n            return vertex.field === fieldDef.name;\n          })[0].icon,\n          data: {}\n        };\n        graph.nodes.push(node);\n      }\n      for (var _i2 in wsObj.blacklist) {\n        var vertex = wsObj.vertices[_i2]; // eslint-disable-line no-var\n        var fieldDef = $scope.allFields.filter(function (fieldDef) {\n          return vertex.field === fieldDef.name;\n        })[0];\n        if (fieldDef) {\n          var _node = {\n            field: vertex.field,\n            term: vertex.term,\n            label: vertex.label,\n            color: vertex.color,\n            icon: fieldDef.icon,\n            data: {\n              field: vertex.field,\n              term: vertex.term\n            }\n          };\n          $scope.workspace.blacklistedNodes.push(_node);\n        }\n      }\n      for (var _i3 in wsObj.links) {\n        var link = wsObj.links[_i3];\n        graph.edges.push({\n          source: link.source,\n          target: link.target,\n          inferred: link.inferred,\n          label: link.label,\n          term: vertex.term,\n          width: link.width,\n          weight: link.weight\n        });\n      }\n\n      $scope.workspace.mergeGraph(graph);\n\n      // Wire up parents and children\n      for (var _i4 in wsObj.vertices) {\n        var _vertex = wsObj.vertices[_i4];\n        var vId = $scope.workspace.makeNodeId(_vertex.field, _vertex.term);\n        var visNode = $scope.workspace.nodesMap[vId];\n        // Default the positions.\n        visNode.x = _vertex.x;\n        visNode.y = _vertex.y;\n        if (_vertex.parent !== null) {\n          var parentSavedObj = graph.nodes[_vertex.parent];\n          var parentId = $scope.workspace.makeNodeId(parentSavedObj.field, parentSavedObj.term);\n          visNode.parent = $scope.workspace.nodesMap[parentId];\n        }\n      }\n      $scope.workspace.runLayout();\n\n      // Allow URLs to include a user-defined text query\n      if ($route.current.params.query) {\n        $scope.searchTerm = $route.current.params.query;\n        $scope.submit();\n      }\n    });\n  } else {\n    $route.current.locals.SavedWorkspacesProvider.get().then(function (newWorkspace) {\n      $scope.savedWorkspace = newWorkspace;\n    });\n  }\n\n  $scope.saveWorkspace = function () {\n    if ($scope.allSavingDisabled) {\n      // It should not be possible to navigate to this function if allSavingDisabled is set\n      // but adding check here as a safeguard.\n      _notify.toastNotifications.addWarning(i18n('xpack.graph.saveWorkspace.disabledWarning', { defaultMessage: 'Saving is disabled' }));\n      return;\n    }\n    initWorkspaceIfRequired();\n    var canSaveData = $scope.graphSavePolicy === 'configAndData' || $scope.graphSavePolicy === 'configAndDataWithConsent' && $scope.userHasConfirmedSaveWorkspaceData;\n\n    var blacklist = [];\n    var vertices = [];\n    var links = [];\n    if (canSaveData) {\n      blacklist = $scope.workspace.blacklistedNodes.map(function (node) {\n        return {\n          x: node.x,\n          y: node.y,\n          field: node.data.field,\n          term: node.data.term,\n          label: node.label,\n          color: node.color,\n          parent: null,\n          weight: node.weight,\n          size: node.scaledSize\n        };\n      });\n      vertices = $scope.workspace.nodes.map(function (node) {\n        return {\n          x: node.x,\n          y: node.y,\n          field: node.data.field,\n          term: node.data.term,\n          label: node.label,\n          color: node.color,\n          parent: node.parent ? $scope.workspace.nodes.indexOf(node.parent) : null,\n          weight: node.weight,\n          size: node.scaledSize\n        };\n      });\n      links = $scope.workspace.edges.map(function (edge) {\n        return {\n          'weight': edge.weight,\n          'width': edge.width,\n          'inferred': edge.inferred,\n          'label': edge.label,\n          'source': $scope.workspace.nodes.indexOf(edge.source),\n          'target': $scope.workspace.nodes.indexOf(edge.target)\n        };\n      });\n    }\n\n    var urlTemplates = $scope.urlTemplates.map(function (template) {\n      var result = {\n        'url': template.url,\n        'description': template.description,\n        'encoderID': template.encoder.id\n      };\n      if (template.icon) {\n        result.iconClass = template.icon.class;\n      }\n      return result;\n    });\n\n    $scope.savedWorkspace.wsState = JSON.stringify({\n      'indexPattern': $scope.selectedIndex.attributes.title,\n      'selectedFields': $scope.selectedFields.map(function (field) {\n        return {\n          'name': field.name,\n          'lastValidHopSize': field.lastValidHopSize,\n          'color': field.color,\n          'iconClass': field.icon.class,\n          'hopSize': field.hopSize\n        };\n      }),\n      blacklist: blacklist,\n      vertices: vertices,\n      links: links,\n      urlTemplates: urlTemplates,\n      exploreControls: $scope.exploreControls\n    });\n    $scope.savedWorkspace.numVertices = vertices.length;\n    $scope.savedWorkspace.numLinks = links.length;\n    $scope.savedWorkspace.description = $scope.description;\n\n    $scope.savedWorkspace.save().then(function (id) {\n      $scope.kbnTopNav.close('save');\n      $scope.userHasConfirmedSaveWorkspaceData = false; //reset flag\n      if (id) {\n        var title = i18n('xpack.graph.saveWorkspace.successNotificationTitle', {\n          defaultMessage: 'Saved \"{workspaceTitle}\"',\n          values: { workspaceTitle: $scope.savedWorkspace.title }\n        });\n        var text = void 0;\n        if (!canSaveData && $scope.workspace.nodes.length > 0) {\n          text = i18n('xpack.graph.saveWorkspace.successNotification.noDataSavedText', {\n            defaultMessage: 'The configuration was saved, but the data was not saved'\n          });\n        }\n\n        _notify.toastNotifications.addSuccess({\n          title: title,\n          text: text,\n          'data-test-subj': 'saveGraphSuccess'\n        });\n        if ($scope.savedWorkspace.id === $route.current.params.id) return;\n        $scope.openSavedWorkspace($scope.savedWorkspace);\n      }\n    }, _notify.fatalError);\n  };\n});\n//End controller",null]}