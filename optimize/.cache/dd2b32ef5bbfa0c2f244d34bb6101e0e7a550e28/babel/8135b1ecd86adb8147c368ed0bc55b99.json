{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/courier/search_strategy/search_strategy_registry.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/courier/search_strategy/search_strategy_registry.js","mtime":1567631711715},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSearchStategyForIndexPattern = exports.assignSearchRequestsToSearchStrategies = exports.addSearchStrategy = undefined;\n\nvar _no_op_search_strategy = require('./no_op_search_strategy');\n\nvar searchStrategies = []; /*\n                            * Licensed to Elasticsearch B.V. under one or more contributor\n                            * license agreements. See the NOTICE file distributed with\n                            * this work for additional information regarding copyright\n                            * ownership. Elasticsearch B.V. licenses this file to you under\n                            * the Apache License, Version 2.0 (the \"License\"); you may\n                            * not use this file except in compliance with the License.\n                            * You may obtain a copy of the License at\n                            *\n                            *    http://www.apache.org/licenses/LICENSE-2.0\n                            *\n                            * Unless required by applicable law or agreed to in writing,\n                            * software distributed under the License is distributed on an\n                            * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                            * KIND, either express or implied.  See the License for the\n                            * specific language governing permissions and limitations\n                            * under the License.\n                            */\n\nvar addSearchStrategy = exports.addSearchStrategy = function addSearchStrategy(searchStrategy) {\n  if (searchStrategies.includes(searchStrategy)) {\n    return;\n  }\n\n  searchStrategies.push(searchStrategy);\n};\n\nvar getSearchStrategyByViability = function getSearchStrategyByViability(indexPattern) {\n  return searchStrategies.find(function (searchStrategy) {\n    return searchStrategy.isViable(indexPattern);\n  });\n};\n\nvar getSearchStrategyById = function getSearchStrategyById(searchStrategyId) {\n  return searchStrategies.find(function (searchStrategy) {\n    return searchStrategy.id === searchStrategyId;\n  });\n};\n\nvar getSearchStrategyForSearchRequest = function getSearchStrategyForSearchRequest(searchRequest) {\n  // Allow the searchSource to declare the correct strategy with which to execute its searches.\n  var preferredSearchStrategyId = searchRequest.source.getPreferredSearchStrategyId();\n  if (preferredSearchStrategyId != null) {\n    return getSearchStrategyById(preferredSearchStrategyId);\n  }\n\n  // Otherwise try to match it to a strategy.\n  var indexPattern = searchRequest.source.getField('index');\n  var viableSearchStrategy = getSearchStrategyByViability(indexPattern);\n\n  if (viableSearchStrategy) {\n    return viableSearchStrategy;\n  }\n\n  // This search strategy automatically rejects with an error.\n  return _no_op_search_strategy.noOpSearchStrategy;\n};\n\n/**\n * Build a structure like this:\n *\n *   [{\n *     searchStrategy: rollupSearchStrategy,\n *     searchRequests: []<SearchRequest>,\n *   }, {\n *     searchStrategy: defaultSearchStrategy,\n *     searchRequests: []<SearchRequest>,\n *   }]\n *\n * We use an array of objects to preserve the order of the search requests, which we use to\n * deterministically associate each response with the originating request.\n */\nvar assignSearchRequestsToSearchStrategies = exports.assignSearchRequestsToSearchStrategies = function assignSearchRequestsToSearchStrategies(searchRequests) {\n  var searchStrategiesWithRequests = [];\n  var searchStrategyById = {};\n\n  searchRequests.forEach(function (searchRequest) {\n    var matchingSearchStrategy = getSearchStrategyForSearchRequest(searchRequest);\n    var id = matchingSearchStrategy.id;\n\n    var searchStrategyWithRequest = searchStrategyById[id];\n\n    // Create the data structure if we don't already have it.\n    if (!searchStrategyWithRequest) {\n      searchStrategyWithRequest = {\n        searchStrategy: matchingSearchStrategy,\n        searchRequests: []\n      };\n\n      searchStrategyById[id] = searchStrategyWithRequest;\n      searchStrategiesWithRequests.push(searchStrategyWithRequest);\n    }\n\n    searchStrategyWithRequest.searchRequests.push(searchRequest);\n  });\n\n  return searchStrategiesWithRequests;\n};\n\nvar hasSearchStategyForIndexPattern = exports.hasSearchStategyForIndexPattern = function hasSearchStategyForIndexPattern(indexPattern) {\n  return Boolean(getSearchStrategyByViability(indexPattern));\n};",null]}