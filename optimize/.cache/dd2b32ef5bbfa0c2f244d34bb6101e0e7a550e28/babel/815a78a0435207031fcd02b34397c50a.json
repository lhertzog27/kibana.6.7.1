{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/aeroelastic/layout_functions.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/aeroelastic/layout_functions.js","mtime":1567631711932},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNextScene = exports.getAnnotatedShapes = exports.getRotationAnnotations = exports.getGroupedSelectedShapeIds = exports.getGroupedSelectedPrimaryShapeIds = exports.getGroupedSelectedShapes = exports.getGroupAction = exports.getConstrainedShapesWithPreexistingAnnotations = exports.getSnappedShapes = exports.getHoverAnnotations = exports.getAdHocChildrenAnnotations = exports.getAlignmentGuideAnnotations = exports.getDraggedPrimaryShape = exports.getNextShapes = exports.getTransformIntents = exports.getResizeManipulator = exports.getSelectedPrimaryShapeIds = exports.getSelectedShapes = exports.getSelectionState = exports.getSelectedShapesPrev = exports.primaryUpdate = exports.getCursor = exports.getGrouping = exports.getHoveredShape = exports.getHoveredShapes = exports.getShapes = exports.configuration = exports.getScene = exports.getRotationTooltipAnnotation = exports.cascadeProperties = exports.applyLocalTransforms = exports.getSelectedShapeObjects = exports.getDirectSelect = exports.getRestateShapesEvent = exports.getMouseTransformGesture = exports.getMouseTransformState = exports.getMouseTransformGesturePrev = exports.getAlterSnapGesture = exports.getFocusedShape = exports.draggingShape = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nexports.resizeAnnotationsFunction = resizeAnnotationsFunction;\n\nvar _get_id = require('./../../lib/get_id');\n\nvar _geometry = require('./geometry');\n\nvar _matrix = require('./matrix');\n\nvar _matrix2d = require('./matrix2d');\n\nvar _functional = require('./functional');\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar resizeVertexTuples = [[-1, -1, 315], [1, -1, 45], [1, 1, 135], [-1, 1, 225], // corners\n[0, -1, 0], [1, 0, 90], [0, 1, 180], [-1, 0, 270]];\n\nvar connectorVertices = [[[-1, -1], [0, -1]], [[0, -1], [1, -1]], [[1, -1], [1, 0]], [[1, 0], [1, 1]], [[1, 1], [0, 1]], [[0, 1], [-1, 1]], [[-1, 1], [-1, 0]], [[-1, 0], [-1, -1]]];\n\nvar resizeMultiplierHorizontal = { left: -1, center: 0, right: 1 };\nvar resizeMultiplierVertical = { top: -1, center: 0, bottom: 1 };\n\nvar xNames = { '-1': 'left', '0': 'center', '1': 'right' };\nvar yNames = { '-1': 'top', '0': 'center', '1': 'bottom' };\n\nvar bidirectionalCursors = {\n  '0': 'ns-resize',\n  '45': 'nesw-resize',\n  '90': 'ew-resize',\n  '135': 'nwse-resize',\n  '180': 'ns-resize',\n  '225': 'nesw-resize',\n  '270': 'ew-resize',\n  '315': 'nwse-resize'\n};\n\n// returns the currently dragged shape, or a falsey value otherwise\nvar draggingShape = exports.draggingShape = function draggingShape(_ref, hoveredShape, down, mouseDowned) {\n  var draggedShape = _ref.draggedShape,\n      shapes = _ref.shapes;\n\n  var dragInProgress = down && shapes.reduce(function (prev, next) {\n    return prev || draggedShape && next.id === draggedShape.id;\n  }, false);\n  var result = dragInProgress && draggedShape || down && mouseDowned && hoveredShape;\n  return result;\n};\n\n// the currently dragged shape is considered in-focus; if no dragging is going on, then the hovered shape\nvar getFocusedShape = exports.getFocusedShape = function getFocusedShape(draggedShape, hoveredShape) {\n  return draggedShape || hoveredShape;\n}; // focusedShapes has updated position etc. information while focusedShape may have stale position\n\nvar getAlterSnapGesture = exports.getAlterSnapGesture = function getAlterSnapGesture(metaHeld) {\n  return metaHeld ? ['relax'] : [];\n};\n\nvar initialTransformTuple = {\n  deltaX: 0,\n  deltaY: 0,\n  transform: null,\n  cumulativeTransform: null\n};\n\nvar getMouseTransformGesturePrev = exports.getMouseTransformGesturePrev = function getMouseTransformGesturePrev(_ref2) {\n  var mouseTransformState = _ref2.mouseTransformState;\n  return mouseTransformState || initialTransformTuple;\n};\n\nvar getMouseTransformState = exports.getMouseTransformState = function getMouseTransformState(prev, dragging, _ref3) {\n  var x0 = _ref3.x0,\n      y0 = _ref3.y0,\n      x1 = _ref3.x1,\n      y1 = _ref3.y1;\n\n  if (dragging) {\n    var deltaX = x1 - x0;\n    var deltaY = y1 - y0;\n    var transform = (0, _matrix.translate)(deltaX - prev.deltaX, deltaY - prev.deltaY, 0);\n    var cumulativeTransform = (0, _matrix.translate)(deltaX, deltaY, 0);\n    return {\n      deltaX: deltaX,\n      deltaY: deltaY,\n      transform: transform,\n      cumulativeTransform: cumulativeTransform\n    };\n  } else {\n    return initialTransformTuple;\n  }\n};\n\nvar getMouseTransformGesture = exports.getMouseTransformGesture = function getMouseTransformGesture(tuple) {\n  return [tuple].filter(function (tpl) {\n    return tpl.transform;\n  }).map(function (_ref4) {\n    var transform = _ref4.transform,\n        cumulativeTransform = _ref4.cumulativeTransform;\n    return { transform: transform, cumulativeTransform: cumulativeTransform };\n  });\n};\n\nvar getRestateShapesEvent = exports.getRestateShapesEvent = function getRestateShapesEvent(action) {\n  if (!action || action.type !== 'restateShapesEvent') {\n    return null;\n  }\n  var shapes = action.payload.newShapes;\n  var local = function local(shape) {\n    if (!shape.parent) {\n      return shape.transformMatrix;\n    }\n    return (0, _matrix.multiply)((0, _matrix.invert)(shapes.find(function (s) {\n      return s.id === shape.parent;\n    }).transformMatrix), shape.transformMatrix);\n  };\n  var newShapes = shapes.map(function (s) {\n    return _extends({}, s, { localTransformMatrix: local(s) });\n  });\n  return { newShapes: newShapes, uid: action.payload.uid };\n}; // is selected, as otherwise selection is driven by gestures and knowledge of element positions\n\nvar getDirectSelect = exports.getDirectSelect = function getDirectSelect(action) {\n  return action && action.type === 'shapeSelect' ? action.payload : null;\n};\n\nvar getSelectedShapeObjects = exports.getSelectedShapeObjects = function getSelectedShapeObjects(scene) {\n  return scene.selectedShapeObjects || [];\n}; // returns true if the shape is not a child of one of the shapes\n\n// fixme put it into geometry.js\n// broken.\n// is the composition of the baseline (previously absorbed transforms) and the cumulative (ie. ongoing interaction)\nvar reselectShapes = function reselectShapes(allShapes, shapes) {\n  return shapes.map(function (id) {\n    return allShapes.find(function (shape) {\n      return shape.id === id;\n    });\n  });\n};\n\nvar contentShape = function contentShape(allShapes) {\n  return function (shape) {\n    return shape.type === 'annotation' ? contentShape(allShapes)(allShapes.find(function (s) {\n      return s.id === shape.parent;\n    })) : shape;\n  };\n};\n\nvar getContentShapes = function getContentShapes(allShapes, shapes) {\n  // fixme no need to export, why doesn't linter or highlighter complain?\n  var idMap = (0, _functional.arrayToMap)(allShapes.map(function (shape) {\n    return shape.id;\n  }));\n  return shapes.filter(function (shape) {\n    return idMap[shape.id];\n  }).map(contentShape(allShapes));\n};\n\nvar primaryShape = function primaryShape(shape) {\n  return shape.type === 'annotation' ? shape.parent : shape.id;\n};\n\nvar rotationManipulation = function rotationManipulation(config) {\n  return function (_ref5) {\n    var shape = _ref5.shape,\n        directShape = _ref5.directShape,\n        _ref5$cursorPosition = _ref5.cursorPosition,\n        x = _ref5$cursorPosition.x,\n        y = _ref5$cursorPosition.y,\n        alterSnapGesture = _ref5.alterSnapGesture;\n\n    // rotate around a Z-parallel line going through the shape center (ie. around the center)\n    if (!shape || !directShape) {\n      return { transforms: [], shapes: [] };\n    }\n    var center = shape.transformMatrix;\n    var centerPosition = (0, _matrix.mvMultiply)(center, _matrix.ORIGIN);\n    var vector = (0, _matrix.mvMultiply)((0, _matrix.multiply)(center, directShape.localTransformMatrix), _matrix.ORIGIN);\n    var oldAngle = Math.atan2(centerPosition[1] - vector[1], centerPosition[0] - vector[0]);\n    var newAngle = Math.atan2(centerPosition[1] - y, centerPosition[0] - x);\n    var closest45deg = Math.round(newAngle / (Math.PI / 12)) * Math.PI / 12;\n    var radius = Math.sqrt(Math.pow(centerPosition[0] - x, 2) + Math.pow(centerPosition[1] - y, 2));\n    var closest45degPosition = [Math.cos(closest45deg) * radius, Math.sin(closest45deg) * radius];\n    var pixelDifference = Math.sqrt(Math.pow(closest45degPosition[0] - (centerPosition[0] - x), 2) + Math.pow(closest45degPosition[1] - (centerPosition[1] - y), 2));\n    var relaxed = alterSnapGesture.indexOf('relax') !== -1;\n    var newSnappedAngle = pixelDifference < config.rotateSnapInPixels && !relaxed ? closest45deg : newAngle;\n    var result = (0, _matrix.rotateZ)(oldAngle - newSnappedAngle);\n    return { transforms: [result], shapes: [shape.id] };\n  };\n};\n\nvar minimumSize = function minimumSize(min, _ref6, vector) {\n  var a = _ref6.a,\n      b = _ref6.b,\n      baseAB = _ref6.baseAB;\n\n  // don't allow an element size of less than the minimumElementSize\n  // todo switch to matrix algebra\n  return [Math.max(baseAB ? min - baseAB[0] : min - a, vector[0]), Math.max(baseAB ? min - baseAB[1] : min - b, vector[1])];\n};\n\nvar centeredResizeManipulation = function centeredResizeManipulation(config) {\n  return function (_ref7) {\n    var gesture = _ref7.gesture,\n        shape = _ref7.shape,\n        directShape = _ref7.directShape;\n\n    var transform = gesture.cumulativeTransform;\n    // scaling such that the center remains in place (ie. the other side of the shape can grow/shrink)\n    if (!shape || !directShape) {\n      return { transforms: [], shapes: [] };\n    }\n    // transform the incoming `transform` so that resizing is aligned with shape orientation\n    var vector = (0, _matrix.mvMultiply)((0, _matrix.multiply)((0, _matrix.invert)((0, _matrix.compositeComponent)(shape.localTransformMatrix)), // rid the translate component\n    transform), _matrix.ORIGIN);\n    var orientationMask = [resizeMultiplierHorizontal[directShape.horizontalPosition], resizeMultiplierVertical[directShape.verticalPosition], 0];\n    var orientedVector = (0, _matrix2d.componentProduct)(vector, orientationMask);\n    var cappedOrientedVector = minimumSize(config.minimumElementSize, shape, orientedVector);\n    return {\n      cumulativeTransforms: [],\n      cumulativeSizes: [gesture.sizes || _matrix2d.translate.apply(undefined, _toConsumableArray(cappedOrientedVector))],\n      shapes: [shape.id]\n    };\n  };\n};\n\nvar asymmetricResizeManipulation = function asymmetricResizeManipulation(config) {\n  return function (_ref8) {\n    var gesture = _ref8.gesture,\n        shape = _ref8.shape,\n        directShape = _ref8.directShape;\n\n    var transform = gesture.cumulativeTransform;\n    // scaling such that the center remains in place (ie. the other side of the shape can grow/shrink)\n    if (!shape || !directShape) {\n      return { transforms: [], shapes: [] };\n    }\n    // transform the incoming `transform` so that resizing is aligned with shape orientation\n    var composite = (0, _matrix.compositeComponent)(shape.localTransformMatrix);\n    var inv = (0, _matrix.invert)(composite); // rid the translate component\n    var vector = (0, _matrix.mvMultiply)((0, _matrix.multiply)(inv, transform), _matrix.ORIGIN);\n    var orientationMask = [resizeMultiplierHorizontal[directShape.horizontalPosition] / 2, resizeMultiplierVertical[directShape.verticalPosition] / 2, 0];\n    var orientedVector = (0, _matrix2d.componentProduct)(vector, orientationMask);\n    var cappedOrientedVector = minimumSize(config.minimumElementSize, shape, orientedVector);\n\n    var antiRotatedVector = (0, _matrix.mvMultiply)((0, _matrix.multiply)(composite, (0, _matrix.scale)(resizeMultiplierHorizontal[directShape.horizontalPosition], resizeMultiplierVertical[directShape.verticalPosition], 1), (0, _matrix.translate)(cappedOrientedVector[0], cappedOrientedVector[1], 0)), _matrix.ORIGIN);\n    var sizeMatrix = gesture.sizes || _matrix2d.translate.apply(undefined, _toConsumableArray(cappedOrientedVector));\n    return {\n      cumulativeTransforms: [(0, _matrix.translate)(antiRotatedVector[0], antiRotatedVector[1], 0)],\n      cumulativeSizes: [sizeMatrix],\n      shapes: [shape.id]\n    };\n  };\n};\n\nvar directShapeTranslateManipulation = function directShapeTranslateManipulation(cumulativeTransforms, directShapes) {\n  var shapes = directShapes.map(function (shape) {\n    return shape.type !== 'annotation' && shape.id;\n  }).filter(_functional.identity);\n  return [{ cumulativeTransforms: cumulativeTransforms, shapes: shapes }];\n};\n\nvar rotationAnnotationManipulation = function rotationAnnotationManipulation(config, directTransforms, directShapes, allShapes, cursorPosition, alterSnapGesture) {\n  var shapeIds = directShapes.map(function (shape) {\n    return shape.type === 'annotation' && shape.subtype === config.rotationHandleName && shape.parent;\n  });\n  var shapes = shapeIds.map(function (id) {\n    return id && allShapes.find(function (shape) {\n      return shape.id === id;\n    });\n  });\n  var tuples = (0, _functional.flatten)(shapes.map(function (shape, i) {\n    return directTransforms.map(function (transform) {\n      return {\n        transform: transform,\n        shape: shape,\n        directShape: directShapes[i],\n        cursorPosition: cursorPosition,\n        alterSnapGesture: alterSnapGesture\n      };\n    });\n  }));\n  return tuples.map(rotationManipulation(config));\n};\n\nvar resizeAnnotationManipulation = function resizeAnnotationManipulation(config, transformGestures, directShapes, allShapes, manipulator) {\n  var shapeIds = directShapes.map(function (shape) {\n    return shape.type === 'annotation' && shape.subtype === config.resizeHandleName && shape.parent;\n  });\n  var shapes = shapeIds.map(function (id) {\n    return id && allShapes.find(function (shape) {\n      return shape.id === id;\n    });\n  });\n  var tuples = (0, _functional.flatten)(shapes.map(function (shape, i) {\n    return transformGestures.map(function (gesture) {\n      return { gesture: gesture, shape: shape, directShape: directShapes[i] };\n    });\n  }));\n  return tuples.map(manipulator);\n};\n\nvar fromScreen = function fromScreen(currentTransform) {\n  return function (transform) {\n    var isTranslate = transform[12] !== 0 || transform[13] !== 0;\n    if (isTranslate) {\n      var composite = (0, _matrix.compositeComponent)(currentTransform);\n      var inverse = (0, _matrix.invert)(composite);\n      var result = (0, _matrix.translateComponent)((0, _matrix.multiply)(inverse, transform));\n      return result;\n    } else {\n      return transform;\n    }\n  };\n};\n\nvar shapeApplyLocalTransforms = function shapeApplyLocalTransforms(intents) {\n  return function (shape) {\n    var transformIntents = (0, _functional.flatten)(intents.map(function (intent) {\n      return intent.transforms && intent.transforms.length && intent.shapes.find(function (id) {\n        return id === shape.id;\n      }) && intent.transforms.map(fromScreen(shape.localTransformMatrix));\n    }).filter(_functional.identity));\n    var sizeIntents = (0, _functional.flatten)(intents.map(function (intent) {\n      return intent.sizes && intent.sizes.length && intent.shapes.find(function (id) {\n        return id === shape.id;\n      }) && intent.sizes;\n    }).filter(_functional.identity));\n    var cumulativeTransformIntents = (0, _functional.flatten)(intents.map(function (intent) {\n      return intent.cumulativeTransforms && intent.cumulativeTransforms.length && intent.shapes.find(function (id) {\n        return id === shape.id;\n      }) && intent.cumulativeTransforms.map(fromScreen(shape.localTransformMatrix));\n    }).filter(_functional.identity));\n    var cumulativeSizeIntents = (0, _functional.flatten)(intents.map(function (intent) {\n      return intent.cumulativeSizes && intent.cumulativeSizes.length && intent.shapes.find(function (id) {\n        return id === shape.id;\n      }) && intent.cumulativeSizes;\n    }).filter(_functional.identity));\n\n    var baselineLocalTransformMatrix = _matrix.multiply.apply(undefined, [shape.baselineLocalTransformMatrix || shape.localTransformMatrix].concat(_toConsumableArray(transformIntents)));\n    var cumulativeTransformIntentMatrix = _matrix.multiply.apply(undefined, _toConsumableArray(cumulativeTransformIntents));\n    var baselineSizeMatrix = _matrix2d.multiply.apply(undefined, _toConsumableArray(sizeIntents)) || _matrix2d.UNITMATRIX;\n    var localTransformMatrix = cumulativeTransformIntents.length ? (0, _matrix.multiply)(baselineLocalTransformMatrix, cumulativeTransformIntentMatrix) : baselineLocalTransformMatrix;\n\n    var cumulativeSizeIntentMatrix = _matrix2d.multiply.apply(undefined, _toConsumableArray(cumulativeSizeIntents));\n    var sizeVector = (0, _matrix2d.mvMultiply)(cumulativeSizeIntents.length ? (0, _matrix2d.multiply)(baselineSizeMatrix, cumulativeSizeIntentMatrix) : baselineSizeMatrix, shape.baseAB ? [].concat(_toConsumableArray(shape.baseAB), [1]) : [shape.a, shape.b, 1]);\n\n    // Absorb changes if the gesture has ended\n    var absorbChanges = !transformIntents.length && !sizeIntents.length && !cumulativeTransformIntents.length && !cumulativeSizeIntents.length;\n\n    return _extends({}, shape, {\n      // apply transforms:\n      baselineLocalTransformMatrix: absorbChanges ? null : baselineLocalTransformMatrix,\n      baselineSizeMatrix: absorbChanges ? null : baselineSizeMatrix,\n      localTransformMatrix: absorbChanges ? shape.localTransformMatrix : localTransformMatrix,\n      a: absorbChanges ? shape.a : sizeVector[0],\n      b: absorbChanges ? shape.b : sizeVector[1],\n      baseAB: absorbChanges ? null : shape.baseAB || [shape.a, shape.b]\n    });\n  };\n};\n\nvar applyLocalTransforms = exports.applyLocalTransforms = function applyLocalTransforms(shapes, transformIntents) {\n  return shapes.map(shapeApplyLocalTransforms(transformIntents));\n};\n\nvar getUpstreamTransforms = function getUpstreamTransforms(shapes, shape) {\n  return shape.parent ? getUpstreamTransforms(shapes, shapes.find(function (s) {\n    return s.id === shape.parent;\n  })).concat([shape.localTransformMatrix]) : [shape.localTransformMatrix];\n};\n\nvar getUpstreams = function getUpstreams(shapes, shape) {\n  return shape.parent ? getUpstreams(shapes, shapes.find(function (s) {\n    return s.id === shape.parent;\n  })).concat([shape]) : [shape];\n};\n\nvar snappedA = function snappedA(shape) {\n  return shape.a + (shape.snapResizeVector ? shape.snapResizeVector[0] : 0);\n};\nvar snappedB = function snappedB(shape) {\n  return shape.b + (shape.snapResizeVector ? shape.snapResizeVector[1] : 0);\n};\n\nvar cascadeUnsnappedTransforms = function cascadeUnsnappedTransforms(shapes, shape) {\n  if (!shape.parent) {\n    return shape.localTransformMatrix;\n  } // boost for common case of toplevel shape\n  var upstreams = getUpstreams(shapes, shape);\n  var upstreamTransforms = upstreams.map(function (s) {\n    return s.localTransformMatrix;\n  });\n  var cascadedTransforms = (0, _matrix.reduceTransforms)(upstreamTransforms);\n  return cascadedTransforms;\n};\n\nvar cascadeTransforms = function cascadeTransforms(shapes, shape) {\n  var cascade = function cascade(s) {\n    return s.snapDeltaMatrix ? (0, _matrix.multiply)(s.localTransformMatrix, s.snapDeltaMatrix) : s.localTransformMatrix;\n  };\n  if (!shape.parent) {\n    return cascade(shape);\n  } // boost for common case of toplevel shape\n  var upstreams = getUpstreams(shapes, shape);\n  var upstreamTransforms = upstreams.map(cascade);\n  var cascadedTransforms = (0, _matrix.reduceTransforms)(upstreamTransforms);\n  return cascadedTransforms;\n};\n\nvar shapeCascadeProperties = function shapeCascadeProperties(shapes) {\n  return function (shape) {\n    return _extends({}, shape, {\n      transformMatrix: cascadeTransforms(shapes, shape),\n      width: 2 * snappedA(shape),\n      height: 2 * snappedB(shape)\n    });\n  };\n};\n\nvar cascadeProperties = exports.cascadeProperties = function cascadeProperties(shapes) {\n  return shapes.map(shapeCascadeProperties(shapes));\n};\n\nvar alignmentGuides = function alignmentGuides(config, shapes, guidedShapes, draggedShape) {\n  var result = {};\n  var counter = 0;\n  var extremeHorizontal = resizeMultiplierHorizontal[draggedShape.horizontalPosition];\n  var extremeVertical = resizeMultiplierVertical[draggedShape.verticalPosition];\n  // todo replace for loops with [].map calls; DRY it up, break out parts; several of which to move to geometry.js\n  // todo switch to informative variable names\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = guidedShapes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var d = _step.value;\n\n      if (d.type === 'annotation') {\n        continue;\n      } // fixme avoid this by not letting annotations get in here\n      // key points of the dragged shape bounding box\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = shapes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var referenceShape = _step2.value;\n\n          if (referenceShape.type === 'annotation') {\n            continue;\n          } // fixme avoid this by not letting annotations get in here\n          if (!config.intraGroupManipulation && referenceShape.parent) {\n            continue;\n          } // for now, don't snap to grouped elements fixme could snap, but make sure transform is gloabl\n          if (config.intraGroupSnapOnly && d.parent !== referenceShape.parent && d.parent !== referenceShape.id /* allow parent */\n          ) {\n              continue;\n            }\n          var s = d.id === referenceShape.id ? _extends({}, d, {\n            localTransformMatrix: d.baselineLocalTransformMatrix || d.localTransformMatrix,\n            a: d.baseAB ? d.baseAB[0] : d.a,\n            b: d.baseAB ? d.baseAB[1] : d.b\n          }) : referenceShape;\n          // key points of the stationery shape\n          for (var k = -1; k < 2; k++) {\n            for (var l = -1; l < 2; l++) {\n              if (k && !l || !k && l) {\n                continue;\n              } // don't worry about midpoints of the edges, only the center\n              if (draggedShape.subtype === config.resizeHandleName && !(extremeHorizontal === k && extremeVertical === l || // moved corner\n              // moved midpoint on horizontal border\n              extremeHorizontal === 0 && k !== 0 && extremeVertical === l ||\n              // moved midpoint on vertical border\n              extremeVertical === 0 && l !== 0 && extremeHorizontal === k)) {\n                continue;\n              }\n              var D = (0, _geometry.landmarkPoint)(d.a, d.b, cascadeUnsnappedTransforms(shapes, d), k, l);\n              for (var m = -1; m < 2; m++) {\n                for (var n = -1; n < 2; n++) {\n                  if (m && !n || !m && n) {\n                    continue;\n                  } // don't worry about midpoints of the edges, only the center\n                  var S = (0, _geometry.landmarkPoint)(s.a, s.b, cascadeUnsnappedTransforms(shapes, s), m, n);\n                  for (var dim = 0; dim < 2; dim++) {\n                    var orthogonalDimension = 1 - dim;\n                    var dd = D[dim];\n                    var ss = S[dim];\n                    var key = k + '|' + l + '|' + dim;\n                    var signedDistance = dd - ss;\n                    var distance = Math.abs(signedDistance);\n                    var currentClosest = result[key];\n                    if (Math.round(distance) <= config.guideDistance && (!currentClosest || distance <= currentClosest.distance)) {\n                      var orthogonalValues = [D[orthogonalDimension], S[orthogonalDimension]].concat(_toConsumableArray(currentClosest ? [currentClosest.lowPoint, currentClosest.highPoint] : []));\n                      var lowPoint = Math.min.apply(Math, _toConsumableArray(orthogonalValues));\n                      var highPoint = Math.max.apply(Math, _toConsumableArray(orthogonalValues));\n                      var midPoint = (lowPoint + highPoint) / 2;\n                      var radius = midPoint - lowPoint;\n                      result[key] = {\n                        id: counter++,\n                        localTransformMatrix: (0, _matrix.translate)(dim ? midPoint : ss, dim ? ss : midPoint, config.atopZ),\n                        a: dim ? radius : 0.5,\n                        b: dim ? 0.5 : radius,\n                        lowPoint: lowPoint,\n                        highPoint: highPoint,\n                        distance: distance,\n                        signedDistance: signedDistance,\n                        dimension: dim ? 'vertical' : 'horizontal',\n                        constrained: d.id,\n                        constrainer: s.id\n                      };\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return Object.values(result);\n};\n\nvar isHorizontal = function isHorizontal(constraint) {\n  return constraint.dimension === 'horizontal';\n};\nvar isVertical = function isVertical(constraint) {\n  return constraint.dimension === 'vertical';\n};\n\nvar closestConstraint = function closestConstraint() {\n  var prev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { distance: Infinity };\n  var next = arguments[1];\n  return next.distance < prev.distance ? { constraint: next, distance: next.distance } : prev;\n};\n\nvar directionalConstraint = function directionalConstraint(constraints, filterFun) {\n  var directionalConstraints = constraints.filter(filterFun);\n  var closest = directionalConstraints.reduce(closestConstraint, undefined);\n  return closest && closest.constraint;\n};\n\nvar rotationAnnotation = function rotationAnnotation(config, shapes, selectedShapes, shape, i) {\n  var foundShape = shapes.find(function (s) {\n    return shape.id === s.id;\n  });\n  if (!foundShape) {\n    return false;\n  }\n\n  if (foundShape.type === 'annotation') {\n    return rotationAnnotation(config, shapes, selectedShapes, shapes.find(function (s) {\n      return foundShape.parent === s.id;\n    }), i);\n  }\n  var b = snappedB(foundShape);\n  var centerTop = (0, _matrix.translate)(0, -b, 0);\n  var pixelOffset = (0, _matrix.translate)(0, -config.rotateAnnotationOffset, config.atopZ);\n  var transform = (0, _matrix.multiply)(centerTop, pixelOffset);\n  return {\n    id: config.rotationHandleName + '_' + i,\n    type: 'annotation',\n    subtype: config.rotationHandleName,\n    interactive: true,\n    parent: foundShape.id,\n    localTransformMatrix: transform,\n    a: config.rotationHandleSize,\n    b: config.rotationHandleSize\n  };\n};\n\nvar getRotationTooltipAnnotation = exports.getRotationTooltipAnnotation = function getRotationTooltipAnnotation(config, proper, shape, intents, cursorPosition) {\n  return shape && shape.subtype === config.rotationHandleName ? [{\n    id: config.rotationTooltipName + '_' + proper.id,\n    type: 'annotation',\n    subtype: config.rotationTooltipName,\n    interactive: false,\n    parent: null,\n    localTransformMatrix: (0, _matrix.translate)(cursorPosition.x, cursorPosition.y, config.tooltipZ),\n    a: 0,\n    b: 0,\n    text: String(Math.round((0, _matrix.matrixToAngle)(proper.transformMatrix) / Math.PI * 180))\n  }] : [];\n};\n\nvar resizePointAnnotations = function resizePointAnnotations(config, parent, a, b) {\n  return function (_ref9) {\n    var _ref10 = _slicedToArray(_ref9, 3),\n        x = _ref10[0],\n        y = _ref10[1],\n        cursorAngle = _ref10[2];\n\n    var markerPlace = (0, _matrix.translate)(x * a, y * b, config.resizeAnnotationOffsetZ);\n    var pixelOffset = (0, _matrix.translate)(-x * config.resizeAnnotationOffset, -y * config.resizeAnnotationOffset, config.atopZ + 10);\n    var transform = (0, _matrix.multiply)(markerPlace, pixelOffset);\n    var xName = xNames[x];\n    var yName = yNames[y];\n    return {\n      id: [config.resizeHandleName, xName, yName, parent].join('_'),\n      type: 'annotation',\n      subtype: config.resizeHandleName,\n      horizontalPosition: xName,\n      verticalPosition: yName,\n      cursorAngle: cursorAngle,\n      interactive: true,\n      parent: parent.id,\n      localTransformMatrix: transform,\n      backgroundColor: 'rgb(0,255,0,1)',\n      a: config.resizeAnnotationSize,\n      b: config.resizeAnnotationSize\n    };\n  };\n};\n\nvar resizeEdgeAnnotations = function resizeEdgeAnnotations(config, parent, a, b) {\n  return function (_ref11) {\n    var _ref12 = _slicedToArray(_ref11, 2),\n        _ref12$ = _slicedToArray(_ref12[0], 2),\n        x0 = _ref12$[0],\n        y0 = _ref12$[1],\n        _ref12$2 = _slicedToArray(_ref12[1], 2),\n        x1 = _ref12$2[0],\n        y1 = _ref12$2[1];\n\n    var x = a * (0, _functional.mean)(x0, x1);\n    var y = b * (0, _functional.mean)(y0, y1);\n    var markerPlace = (0, _matrix.translate)(x, y, config.atopZ - 10);\n    var transform = markerPlace; // no offset etc. at the moment\n    var horizontal = y0 === y1;\n    var length = horizontal ? a * Math.abs(x1 - x0) : b * Math.abs(y1 - y0);\n    var sectionHalfLength = Math.max(0, length / 2 - config.resizeAnnotationConnectorOffset);\n    var width = 0.5;\n    return {\n      id: [config.resizeConnectorName, xNames[x0], yNames[y0], xNames[x1], yNames[y1], parent].join('_'),\n      type: 'annotation',\n      subtype: config.resizeConnectorName,\n      interactive: true,\n      parent: parent.id,\n      localTransformMatrix: transform,\n      backgroundColor: config.devColor,\n      a: horizontal ? sectionHalfLength : width,\n      b: horizontal ? width : sectionHalfLength\n    };\n  };\n};\n\nvar groupedShape = function groupedShape(properShape) {\n  return function (shape) {\n    return shape.parent === properShape.id;\n  };\n};\nvar magic = function magic(config, shape, shapes) {\n  var epsilon = config.rotationEpsilon;\n  var integralOf = Math.PI * 2;\n  var isIntegerMultiple = function isIntegerMultiple(s) {\n    var zRotation = (0, _matrix.matrixToAngle)(s.localTransformMatrix);\n    var ratio = zRotation / integralOf;\n    return Math.abs(Math.round(ratio) - ratio) < epsilon;\n  };\n\n  function recurse(s) {\n    return shapes.filter(groupedShape(s)).every(resizableChild);\n  }\n\n  function resizableChild(s) {\n    return isIntegerMultiple(s) && recurse(s);\n  }\n\n  return recurse(shape);\n};\n\nfunction resizeAnnotation(config, shapes, selectedShapes, shape) {\n  var foundShape = shapes.find(function (s) {\n    return shape.id === s.id;\n  });\n  var properShape = foundShape && (foundShape.subtype === config.resizeHandleName ? shapes.find(function (s) {\n    return shape.parent === s.id;\n  }) : foundShape);\n  if (!foundShape) {\n    return [];\n  }\n\n  if (foundShape.subtype === config.resizeHandleName) {\n    // preserve any interactive annotation when handling\n    var result = foundShape.interactive ? resizeAnnotationsFunction(config, {\n      shapes: shapes,\n      selectedShapes: [shapes.find(function (s) {\n        return shape.parent === s.id;\n      })]\n    }) : [];\n    return result;\n  }\n  if (foundShape.type === 'annotation') {\n    return resizeAnnotation(config, shapes, selectedShapes, shapes.find(function (s) {\n      return foundShape.parent === s.id;\n    }));\n  }\n\n  // fixme left active: snap wobble. right active: opposite side wobble.\n  var a = snappedA(properShape);\n  var b = snappedB(properShape);\n  var allowResize = properShape.type !== 'group' || config.groupResize && magic(config, properShape, shapes.filter(function (s) {\n    return s.type !== 'annotation';\n  }));\n  var resizeVertices = allowResize ? resizeVertexTuples : [];\n  var resizePoints = resizeVertices.map(resizePointAnnotations(config, shape, a, b));\n  var connectors = connectorVertices.map(resizeEdgeAnnotations(config, shape, a, b));\n  return [].concat(_toConsumableArray(resizePoints), _toConsumableArray(connectors));\n}\n\nfunction resizeAnnotationsFunction(config, _ref13) {\n  var shapes = _ref13.shapes,\n      selectedShapes = _ref13.selectedShapes;\n\n  var shapesToAnnotate = selectedShapes;\n  return (0, _functional.flatten)(shapesToAnnotate.map(function (shape) {\n    return resizeAnnotation(config, shapes, selectedShapes, shape);\n  }).filter(_functional.identity));\n}\n\nvar crystallizeConstraint = function crystallizeConstraint(shape) {\n  var result = _extends({}, shape);\n  if (shape.snapDeltaMatrix) {\n    result.localTransformMatrix = (0, _matrix.multiply)(shape.localTransformMatrix, shape.snapDeltaMatrix);\n    result.snapDeltaMatrix = null;\n  }\n  if (shape.snapResizeVector) {\n    result.a = snappedA(shape);\n    result.b = snappedB(shape);\n    result.snapResizeVector = null;\n  }\n  return result;\n};\n\nvar translateShapeSnap = function translateShapeSnap(horizontalConstraint, verticalConstraint, draggedElement) {\n  return function (shape) {\n    var constrainedX = horizontalConstraint && horizontalConstraint.constrained === shape.id;\n    var constrainedY = verticalConstraint && verticalConstraint.constrained === shape.id;\n    var snapOffsetX = constrainedX ? -horizontalConstraint.signedDistance : 0;\n    var snapOffsetY = constrainedY ? -verticalConstraint.signedDistance : 0;\n    if (constrainedX || constrainedY) {\n      if (!snapOffsetX && !snapOffsetY) {\n        return shape;\n      }\n      var snapOffset = (0, _matrix.translateComponent)((0, _matrix.multiply)((0, _matrix.rotateZ)((0, _matrix.matrixToAngle)(draggedElement.localTransformMatrix)), (0, _matrix.translate)(snapOffsetX, snapOffsetY, 0)));\n      return _extends({}, shape, {\n        snapDeltaMatrix: snapOffset\n      });\n    } else if (shape.snapDeltaMatrix || shape.snapResizeVector) {\n      return crystallizeConstraint(shape);\n    } else {\n      return shape;\n    }\n  };\n};\n\nvar resizeShapeSnap = function resizeShapeSnap(horizontalConstraint, verticalConstraint, draggedElement, symmetric, horizontalPosition, verticalPosition) {\n  return function (shape) {\n    var constrainedShape = draggedElement && shape.id === draggedElement.id;\n    var constrainedX = horizontalConstraint && horizontalConstraint.constrained === shape.id;\n    var constrainedY = verticalConstraint && verticalConstraint.constrained === shape.id;\n    var snapOffsetX = constrainedX ? horizontalConstraint.signedDistance : 0;\n    var snapOffsetY = constrainedY ? -verticalConstraint.signedDistance : 0;\n    if (constrainedX || constrainedY) {\n      var multiplier = symmetric ? 1 : 0.5;\n      var angle = (0, _matrix.matrixToAngle)(draggedElement.localTransformMatrix);\n      var horizontalSign = -resizeMultiplierHorizontal[horizontalPosition]; // fixme unify sign\n      var verticalSign = resizeMultiplierVertical[verticalPosition];\n      // todo turn it into matrix algebra via matrix2d.js\n      var sin = Math.sin(angle);\n      var cos = Math.cos(angle);\n      var snapOffsetA = horizontalSign * (cos * snapOffsetX - sin * snapOffsetY);\n      var snapOffsetB = verticalSign * (sin * snapOffsetX + cos * snapOffsetY);\n      var snapTranslateOffset = (0, _matrix.translateComponent)((0, _matrix.multiply)((0, _matrix.rotateZ)(angle), (0, _matrix.translate)((1 - multiplier) * -snapOffsetX, (1 - multiplier) * snapOffsetY, 0)));\n      var snapSizeOffset = [multiplier * snapOffsetA, multiplier * snapOffsetB];\n      return _extends({}, shape, {\n        snapDeltaMatrix: snapTranslateOffset,\n        snapResizeVector: snapSizeOffset\n      });\n    } else if (constrainedShape) {\n      return _extends({}, shape, {\n        snapDeltaMatrix: null,\n        snapResizeVector: null\n      });\n    } else {\n      return crystallizeConstraint(shape);\n    }\n  };\n};\n\nvar extend = function extend(_ref14, _ref15, _ref16) {\n  var _ref19 = _slicedToArray(_ref14, 2),\n      _ref19$ = _slicedToArray(_ref19[0], 2),\n      xMin = _ref19$[0],\n      yMin = _ref19$[1],\n      _ref19$2 = _slicedToArray(_ref19[1], 2),\n      xMax = _ref19$2[0],\n      yMax = _ref19$2[1];\n\n  var _ref18 = _slicedToArray(_ref15, 2),\n      x0 = _ref18[0],\n      y0 = _ref18[1];\n\n  var _ref17 = _slicedToArray(_ref16, 2),\n      x1 = _ref17[0],\n      y1 = _ref17[1];\n\n  return [[Math.min(xMin, x0, x1), Math.min(yMin, y0, y1)], [Math.max(xMax, x0, x1), Math.max(yMax, y0, y1)]];\n};\n\nvar cornerVertices = [[-1, -1], [1, -1], [-1, 1], [1, 1]];\n\nvar getAABB = function getAABB(shapes) {\n  return shapes.reduce(function (prevOuter, shape) {\n    var shapeBounds = cornerVertices.reduce(function (prevInner, xyVertex) {\n      var cornerPoint = (0, _matrix.normalize)((0, _matrix.mvMultiply)(shape.transformMatrix, [shape.a * xyVertex[0], shape.b * xyVertex[1], 0, 1]));\n      return extend(prevInner, cornerPoint, cornerPoint);\n    }, prevOuter);\n    return extend.apply(undefined, [prevOuter].concat(_toConsumableArray(shapeBounds)));\n  }, [[Infinity, Infinity], [-Infinity, -Infinity]]);\n};\n\nvar projectAABB = function projectAABB(_ref20) {\n  var _ref21 = _slicedToArray(_ref20, 2),\n      _ref21$ = _slicedToArray(_ref21[0], 2),\n      xMin = _ref21$[0],\n      yMin = _ref21$[1],\n      _ref21$2 = _slicedToArray(_ref21[1], 2),\n      xMax = _ref21$2[0],\n      yMax = _ref21$2[1];\n\n  var a = (xMax - xMin) / 2;\n  var b = (yMax - yMin) / 2;\n  var xTranslate = xMin + a;\n  var yTranslate = yMin + b;\n  var zTranslate = 0; // todo fix hack that ensures that grouped elements continue to be selectable\n  var localTransformMatrix = (0, _matrix.translate)(xTranslate, yTranslate, zTranslate);\n  var rigTransform = (0, _matrix.translate)(-xTranslate, -yTranslate, -zTranslate);\n  return { a: a, b: b, localTransformMatrix: localTransformMatrix, rigTransform: rigTransform };\n};\n\nvar dissolveGroups = function dissolveGroups(groupsToDissolve, shapes, selectedShapes) {\n  return {\n    shapes: shapes.filter(function (s) {\n      return !groupsToDissolve.find(function (g) {\n        return s.id === g.id;\n      });\n    }).map(function (shape) {\n      var preexistingGroupParent = groupsToDissolve.find(function (groupShape) {\n        return groupShape.id === shape.parent;\n      });\n      // if linked, dissociate from ad hoc group parent\n      return preexistingGroupParent ? _extends({}, shape, {\n        parent: null,\n        localTransformMatrix: (0, _matrix.multiply)(\n        // pulling preexistingGroupParent from `shapes` to get fresh matrices\n        shapes.find(function (s) {\n          return s.id === preexistingGroupParent.id;\n        }).localTransformMatrix, // reinstate the group offset onto the child\n        shape.localTransformMatrix)\n      }) : shape;\n    }),\n    selectedShapes: selectedShapes\n  };\n};\n\nvar hasNoParentWithin = function hasNoParentWithin(shapes) {\n  return function (shape) {\n    return !shapes.some(function (g) {\n      return shape.parent === g.id;\n    });\n  };\n};\n\nvar asYetUngroupedShapes = function asYetUngroupedShapes(preexistingAdHocGroups, selectedShapes) {\n  return selectedShapes.filter(hasNoParentWithin(preexistingAdHocGroups));\n};\n\nvar idMatch = function idMatch(shape) {\n  return function (s) {\n    return s.id === shape.id;\n  };\n};\n\nvar idsMatch = function idsMatch(selectedShapes) {\n  return function (shape) {\n    return selectedShapes.find(idMatch(shape));\n  };\n};\n\nvar axisAlignedBoundingBoxShape = function axisAlignedBoundingBoxShape(config, shapesToBox) {\n  var axisAlignedBoundingBox = getAABB(shapesToBox);\n\n  var _projectAABB = projectAABB(axisAlignedBoundingBox),\n      a = _projectAABB.a,\n      b = _projectAABB.b,\n      localTransformMatrix = _projectAABB.localTransformMatrix,\n      rigTransform = _projectAABB.rigTransform;\n\n  var id = (0, _get_id.getId)(config.groupName);\n  var aabbShape = {\n    id: id,\n    type: config.groupName,\n    subtype: config.adHocGroupName,\n    a: a,\n    b: b,\n    localTransformMatrix: localTransformMatrix,\n    rigTransform: rigTransform,\n    parent: null\n  };\n  return aabbShape;\n};\n\nvar resetChild = function resetChild(s) {\n  if (s.childBaseAB) {\n    s.childBaseAB = null;\n    s.baseLocalTransformMatrix = null;\n  }\n};\n\nvar childScaler = function childScaler(_ref22, baseAB) {\n  var a = _ref22.a,\n      b = _ref22.b;\n\n  // a scaler of 0, encountered when element is shrunk to zero size, would result in a non-invertible transform matrix\n  var epsilon = 1e-6;\n  var groupScaleX = Math.max(a / baseAB[0], epsilon);\n  var groupScaleY = Math.max(b / baseAB[1], epsilon);\n  var groupScale = (0, _matrix.scale)(groupScaleX, groupScaleY, 1);\n  return groupScale;\n};\n\nvar resizeChild = function resizeChild(groupScale) {\n  return function (s) {\n    var childBaseAB = s.childBaseAB || [s.a, s.b];\n    var impliedScale = _matrix.scale.apply(undefined, _toConsumableArray(childBaseAB).concat([1]));\n    var inverseImpliedScale = (0, _matrix.invert)(impliedScale);\n    var baseLocalTransformMatrix = s.baseLocalTransformMatrix || s.localTransformMatrix;\n    var normalizedBaseLocalTransformMatrix = (0, _matrix.multiply)(baseLocalTransformMatrix, impliedScale);\n    var T = (0, _matrix.multiply)(groupScale, normalizedBaseLocalTransformMatrix);\n    var backScaler = groupScale.map(function (d) {\n      return Math.abs(d);\n    });\n    var inverseBackScaler = (0, _matrix.invert)(backScaler);\n    var abTuple = (0, _matrix.mvMultiply)((0, _matrix.multiply)(backScaler, impliedScale), [1, 1, 1, 1]);\n    s.localTransformMatrix = (0, _matrix.multiply)(T, (0, _matrix.multiply)(inverseImpliedScale, inverseBackScaler));\n    s.a = abTuple[0];\n    s.b = abTuple[1];\n    s.childBaseAB = childBaseAB;\n    s.baseLocalTransformMatrix = baseLocalTransformMatrix;\n  };\n};\n\nvar resizeGroup = function resizeGroup(shapes, rootElement) {\n  var idMap = {};\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = shapes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var shape = _step3.value;\n\n      idMap[shape.id] = shape;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  var depths = {};\n  var ancestorsLength = function ancestorsLength(shape) {\n    return shape.parent ? ancestorsLength(idMap[shape.parent]) + 1 : 0;\n  };\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = shapes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var _shape = _step4.value;\n\n      depths[_shape.id] = ancestorsLength(_shape);\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  var resizedParents = _defineProperty({}, rootElement.id, rootElement);\n  var sortedShapes = shapes.slice().sort(function (a, b) {\n    return depths[a.id] - depths[b.id];\n  });\n  var parentResized = function parentResized(s) {\n    return Boolean(s.childBaseAB || s.baseAB);\n  };\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = sortedShapes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var _shape2 = _step5.value;\n\n      var parent = resizedParents[_shape2.parent];\n      if (parent) {\n        resizedParents[_shape2.id] = _shape2;\n        if (parentResized(parent)) {\n          resizeChild(childScaler(parent, parent.childBaseAB || parent.baseAB))(_shape2);\n        } else {\n          resetChild(_shape2);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  return sortedShapes;\n};\n\nvar getLeafs = function getLeafs(descendCondition, allShapes, shapes) {\n  return (0, _functional.removeDuplicates)(function (s) {\n    return s.id;\n  }, (0, _functional.flatten)(shapes.map(function (shape) {\n    return descendCondition(shape) ? allShapes.filter(function (s) {\n      return s.parent === shape.id;\n    }) : shape;\n  })));\n};\n\nvar preserveCurrentGroups = function preserveCurrentGroups(shapes, selectedShapes) {\n  return { shapes: shapes, selectedShapes: selectedShapes };\n};\n\nvar getScene = exports.getScene = function getScene(state) {\n  return state.currentScene;\n};\n\nvar configuration = exports.configuration = function configuration(state) {\n  return state.configuration;\n};\n\nvar getShapes = exports.getShapes = function getShapes(scene) {\n  return scene.shapes;\n};\n\nvar getHoveredShapes = exports.getHoveredShapes = function getHoveredShapes(config, shapes, cursorPosition) {\n  return (0, _geometry.shapesAt)(shapes.filter(\n  // second AND term excludes intra-group element hover (and therefore drag & drop), todo: remove this current limitation\n  function (s) {\n    return (s.type !== 'annotation' || s.interactive) && (config.intraGroupManipulation || !s.parent || s.type === 'annotation');\n  }), cursorPosition);\n};\n\nvar getHoveredShape = exports.getHoveredShape = function getHoveredShape(hoveredShapes) {\n  return hoveredShapes.length ? hoveredShapes[0] : null;\n};\n\nvar singleSelect = function singleSelect(prev, config, hoveredShapes, metaHeld, uid) {\n  // cycle from top ie. from zero after the cursor position changed ie. !sameLocation\n  var down = true; // this function won't be called otherwise\n  var depthIndex = config.depthSelect && metaHeld ? (prev.depthIndex + (down && !prev.down ? 1 : 0)) % hoveredShapes.length : 0;\n  return {\n    shapes: hoveredShapes.length ? [hoveredShapes[depthIndex]] : [],\n    uid: uid,\n    depthIndex: hoveredShapes.length ? depthIndex : 0,\n    down: down\n  };\n};\n\nvar multiSelect = function multiSelect(prev, config, hoveredShapes, metaHeld, uid, selectedShapeObjects) {\n  var shapes = hoveredShapes.length > 0 ? (0, _functional.disjunctiveUnion)(function (shape) {\n    return shape.id;\n  }, selectedShapeObjects, hoveredShapes.slice(0, 1)) // ie. depthIndex of 0, if any\n  : [];\n  return {\n    shapes: shapes,\n    uid: uid,\n    depthIndex: 0,\n    down: false\n  };\n};\n\nvar getGrouping = exports.getGrouping = function getGrouping(config, shapes, selectedShapes, groupAction) {\n  var childOfGroup = function childOfGroup(shape) {\n    return shape.parent && shape.parent.startsWith(config.groupName);\n  };\n  var isAdHocGroup = function isAdHocGroup(shape) {\n    return shape.type === config.groupName && shape.subtype === config.adHocGroupName;\n  };\n  var preexistingAdHocGroups = shapes.filter(isAdHocGroup);\n  var matcher = idsMatch(selectedShapes);\n  var selectedFn = function selectedFn(shape) {\n    return matcher(shape) && shape.type !== 'annotation';\n  };\n  var freshSelectedShapes = shapes.filter(selectedFn);\n  var freshNonSelectedShapes = shapes.filter((0, _functional.not)(selectedFn));\n  var isGroup = function isGroup(shape) {\n    return shape.type === config.groupName;\n  };\n  var isOrBelongsToGroup = function isOrBelongsToGroup(shape) {\n    return isGroup(shape) || childOfGroup(shape);\n  };\n  var someSelectedShapesAreGrouped = selectedShapes.some(isOrBelongsToGroup);\n  var selectionOutsideGroup = !someSelectedShapesAreGrouped;\n\n  if (groupAction === 'group') {\n    var selectedAdHocGroupsToPersist = selectedShapes.filter(function (s) {\n      return s.subtype === config.adHocGroupName;\n    });\n    return {\n      shapes: shapes.map(function (s) {\n        return s.subtype === config.adHocGroupName ? _extends({}, s, { subtype: config.persistentGroupName }) : s;\n      }),\n      selectedShapes: selectedShapes.filter(function (selected) {\n        return selected.subtype !== config.adHocGroupName;\n      }).concat(selectedAdHocGroupsToPersist.map(function (shape) {\n        return _extends({}, shape, {\n          subtype: config.persistentGroupName\n        });\n      }))\n    };\n  }\n\n  if (groupAction === 'ungroup') {\n    return dissolveGroups(selectedShapes.filter(function (s) {\n      return s.subtype === config.persistentGroupName;\n    }), shapes, asYetUngroupedShapes(preexistingAdHocGroups, freshSelectedShapes));\n  }\n\n  // ad hoc groups must dissolve if 1. the user clicks away, 2. has a selection that's not the group, or 3. selected something else\n  if (preexistingAdHocGroups.length && selectionOutsideGroup) {\n    // asYetUngroupedShapes will trivially be the empty set if case 1 is realized: user clicks aside -> selectedShapes === []\n    // return preserveCurrentGroups(shapes, selectedShapes);\n    return dissolveGroups(preexistingAdHocGroups, shapes, asYetUngroupedShapes(preexistingAdHocGroups, freshSelectedShapes));\n  }\n\n  // preserve the current selection if the sole ad hoc group is being manipulated\n  var elements = getContentShapes(shapes, selectedShapes);\n  if (elements.length === 1 && elements[0].type === 'group') {\n    return config.groupResize ? {\n      shapes: [].concat(_toConsumableArray(resizeGroup(shapes.filter(function (s) {\n        return s.type !== 'annotation';\n      }), elements[0])), _toConsumableArray(shapes.filter(function (s) {\n        return s.type === 'annotation';\n      }))),\n      selectedShapes: selectedShapes\n    } : preserveCurrentGroups(shapes, selectedShapes);\n  }\n  // group items or extend group bounding box (if enabled)\n  if (selectedShapes.length < 2) {\n    // resize the group if needed (ad-hoc group resize is manipulated)\n    return preserveCurrentGroups(shapes, selectedShapes);\n  } else {\n    // group together the multiple items\n    var group = axisAlignedBoundingBoxShape(config, freshSelectedShapes);\n    var selectedLeafShapes = getLeafs(function (shape) {\n      return shape.subtype === config.adHocGroupName;\n    }, shapes, freshSelectedShapes);\n    var parentedSelectedShapes = selectedLeafShapes.map(function (shape) {\n      return _extends({}, shape, {\n        parent: group.id,\n        localTransformMatrix: (0, _matrix.multiply)(group.rigTransform, shape.transformMatrix)\n      });\n    });\n    var nonGroupGraphConstituent = function nonGroupGraphConstituent(s) {\n      return s.subtype !== config.adHocGroupName && !parentedSelectedShapes.find(function (ss) {\n        return s.id === ss.id;\n      });\n    };\n    var dissociateFromParentIfAny = function dissociateFromParentIfAny(s) {\n      return s.parent && s.parent.startsWith(config.groupName) && preexistingAdHocGroups.find(function (ahg) {\n        return ahg.id === s.parent;\n      }) ? _extends({}, s, { parent: null }) : s;\n    };\n    var allTerminalShapes = parentedSelectedShapes.concat(freshNonSelectedShapes.filter(nonGroupGraphConstituent).map(dissociateFromParentIfAny));\n    return {\n      shapes: allTerminalShapes.concat([group]),\n      selectedShapes: [group]\n    };\n  }\n};\n\nvar getCursor = exports.getCursor = function getCursor(config, shape, draggedPrimaryShape) {\n  if (!shape) {\n    return 'auto';\n  }\n  switch (shape.subtype) {\n    case config.rotationHandleName:\n      return 'crosshair';\n    case config.resizeHandleName:\n      var angle = ((0, _matrix.matrixToAngle)(shape.transformMatrix) * 180 / Math.PI + 360) % 360;\n      var screenProjectedAngle = angle + shape.cursorAngle;\n      var discretizedAngle = (Math.round(screenProjectedAngle / 45) * 45 + 360) % 360;\n      return bidirectionalCursors[discretizedAngle];\n    default:\n      return draggedPrimaryShape ? 'grabbing' : 'grab';\n  }\n};\n\n/**\n * Selectors directly from a state object\n */\nvar primaryUpdate = exports.primaryUpdate = function primaryUpdate(state) {\n  return state.primaryUpdate;\n};\n\nvar getSelectedShapesPrev = exports.getSelectedShapesPrev = function getSelectedShapesPrev(scene) {\n  return scene.selectionState || {\n    shapes: [],\n    uid: null,\n    depthIndex: 0,\n    down: false\n  };\n};\n\nvar getSelectionState = exports.getSelectionState = function getSelectionState(prev, config, selectedShapeObjects, hoveredShapes, _ref23, metaHeld, multiselect, directSelect, allShapes) {\n  var down = _ref23.down,\n      uid = _ref23.uid;\n\n  var uidUnchanged = uid === prev.uid;\n  var mouseButtonUp = !down;\n  var updateFromDirectSelect = directSelect && directSelect.shapes && !(0, _functional.shallowEqual)(directSelect.shapes, selectedShapeObjects.map(function (shape) {\n    return shape.id;\n  }));\n  if (updateFromDirectSelect) {\n    return {\n      shapes: reselectShapes(allShapes, directSelect.shapes),\n      uid: directSelect.uid,\n      depthIndex: prev.depthIndex,\n      down: prev.down\n    };\n  }\n  if (selectedShapeObjects) {\n    prev.shapes = selectedShapeObjects.slice();\n  }\n  // take action on mouse down only, and if the uid changed (except with directSelect), ie. bail otherwise\n  if (mouseButtonUp || uidUnchanged && !directSelect) {\n    return _extends({}, prev, { down: down, uid: uid, metaHeld: metaHeld });\n  }\n  var selectFunction = config.singleSelect || !multiselect ? singleSelect : multiSelect;\n  return selectFunction(prev, config, hoveredShapes, metaHeld, uid, selectedShapeObjects);\n};\n\nvar getSelectedShapes = exports.getSelectedShapes = function getSelectedShapes(selectionTuple) {\n  return selectionTuple.shapes;\n};\n\nvar getSelectedPrimaryShapeIds = exports.getSelectedPrimaryShapeIds = function getSelectedPrimaryShapeIds(shapes) {\n  return shapes.map(primaryShape);\n};\n\nvar getResizeManipulator = exports.getResizeManipulator = function getResizeManipulator(config, toggle) {\n  return (toggle ? centeredResizeManipulation : asymmetricResizeManipulation)(config);\n};\n\nvar getTransformIntents = exports.getTransformIntents = function getTransformIntents(config, transformGestures, directShapes, shapes, cursorPosition, alterSnapGesture, manipulator) {\n  return [].concat(_toConsumableArray(directShapeTranslateManipulation(transformGestures.map(function (g) {\n    return g.cumulativeTransform;\n  }), directShapes)), _toConsumableArray(rotationAnnotationManipulation(config, transformGestures.map(function (g) {\n    return g.transform;\n  }), directShapes, shapes, cursorPosition, alterSnapGesture)), _toConsumableArray(resizeAnnotationManipulation(config, transformGestures, directShapes, shapes, manipulator)));\n};\n\nvar getNextShapes = exports.getNextShapes = function getNextShapes(preexistingShapes, restated) {\n  if (restated && restated.newShapes) {\n    return restated.newShapes;\n  }\n\n  // this is the per-shape model update at the current PoC level\n  return preexistingShapes;\n};\n\nvar getDraggedPrimaryShape = exports.getDraggedPrimaryShape = function getDraggedPrimaryShape(shapes, draggedShape) {\n  return draggedShape && shapes.find(function (shape) {\n    return shape.id === primaryShape(draggedShape);\n  });\n};\n\nvar getAlignmentGuideAnnotations = exports.getAlignmentGuideAnnotations = function getAlignmentGuideAnnotations(config, shapes, draggedPrimaryShape, draggedShape) {\n  var guidedShapes = draggedPrimaryShape ? [shapes.find(function (s) {\n    return s.id === draggedPrimaryShape.id;\n  })].filter(_functional.identity) : [];\n  return guidedShapes.length ? alignmentGuides(config, shapes, guidedShapes, draggedShape).map(function (shape) {\n    return _extends({}, shape, {\n      id: config.alignmentGuideName + '_' + shape.id,\n      type: 'annotation',\n      subtype: config.alignmentGuideName,\n      interactive: false,\n      backgroundColor: 'magenta',\n      parent: null\n    });\n  }) : [];\n};\n\nvar borderAnnotation = function borderAnnotation(subtype, lift) {\n  return function (shape) {\n    return _extends({}, shape, {\n      id: subtype + '_' + shape.id,\n      type: 'annotation',\n      subtype: subtype,\n      interactive: false,\n      localTransformMatrix: (0, _matrix.multiply)(shape.localTransformMatrix, (0, _matrix.translate)(0, 0, lift)),\n      parent: shape.parent\n    });\n  };\n};\n\nvar getAdHocChildrenAnnotations = exports.getAdHocChildrenAnnotations = function getAdHocChildrenAnnotations(config, _ref24) {\n  var shapes = _ref24.shapes;\n\n  var adHocGroups = shapes.filter(function (s) {\n    return s.subtype === config.adHocGroupName;\n  });\n  return shapes.filter(function (s) {\n    return s.type !== 'annotation' && s.parent && adHocGroups.find(function (p) {\n      return p.id === s.parent;\n    });\n  }).map(borderAnnotation(config.getAdHocChildAnnotationName, config.hoverLift));\n};\n\nvar getHoverAnnotations = exports.getHoverAnnotations = function getHoverAnnotations(config, shape, selectedPrimaryShapeIds, draggedShape) {\n  return shape && shape.type !== 'annotation' && selectedPrimaryShapeIds.indexOf(shape.id) === -1 && !draggedShape ? [borderAnnotation(config.hoverAnnotationName, config.hoverLift)(shape)] : [];\n};\n\nvar getSnappedShapes = exports.getSnappedShapes = function getSnappedShapes(config, shapes, draggedShape, draggedElement, alignmentGuideAnnotations, alterSnapGesture, symmetricManipulation) {\n  var contentShapes = shapes.filter(function (shape) {\n    return shape.type !== 'annotation';\n  });\n  var subtype = draggedShape && draggedShape.subtype;\n  // snapping doesn't come into play if there's no dragging, or it's not a resize drag or translate drag on a\n  // leaf element or a group element:\n  if (subtype && [config.resizeHandleName, config.adHocGroupName, config.persistentGroupName].indexOf(subtype) === -1) {\n    return contentShapes;\n  }\n  var constraints = alignmentGuideAnnotations; // fixme split concept of snap constraints and their annotations\n  var relaxed = alterSnapGesture.indexOf('relax') !== -1;\n  var constrained = config.snapConstraint && !relaxed;\n  var horizontalConstraint = constrained && directionalConstraint(constraints, isHorizontal);\n  var verticalConstraint = constrained && directionalConstraint(constraints, isVertical);\n  var snapper = subtype === config.resizeHandleName ? resizeShapeSnap(horizontalConstraint, verticalConstraint, draggedElement, symmetricManipulation, draggedShape.horizontalPosition, draggedShape.verticalPosition) : translateShapeSnap(horizontalConstraint, verticalConstraint, draggedElement); // leaf element or ad-hoc group\n  return contentShapes.map(snapper);\n};\n\nvar getConstrainedShapesWithPreexistingAnnotations = exports.getConstrainedShapesWithPreexistingAnnotations = function getConstrainedShapesWithPreexistingAnnotations(snapped, transformed) {\n  return snapped.concat(transformed.filter(function (s) {\n    return s.type === 'annotation';\n  }));\n};\n\nvar getGroupAction = exports.getGroupAction = function getGroupAction(action, mouseIsDown) {\n  var event = action && action.event;\n  return !mouseIsDown && (event === 'group' || event === 'ungroup') ? event : null;\n};\n\nvar getGroupedSelectedShapes = exports.getGroupedSelectedShapes = function getGroupedSelectedShapes(_ref25) {\n  var selectedShapes = _ref25.selectedShapes;\n  return selectedShapes;\n};\n\nvar getGroupedSelectedPrimaryShapeIds = exports.getGroupedSelectedPrimaryShapeIds = function getGroupedSelectedPrimaryShapeIds(selectedShapes) {\n  return selectedShapes.map(primaryShape);\n};\n\nvar getGroupedSelectedShapeIds = exports.getGroupedSelectedShapeIds = function getGroupedSelectedShapeIds(selectedShapes) {\n  return selectedShapes.map(function (shape) {\n    return shape.id;\n  });\n};\n\nvar getRotationAnnotations = exports.getRotationAnnotations = function getRotationAnnotations(config, _ref26) {\n  var shapes = _ref26.shapes,\n      selectedShapes = _ref26.selectedShapes;\n\n  var shapesToAnnotate = selectedShapes;\n  return shapesToAnnotate.map(function (shape, i) {\n    return rotationAnnotation(config, shapes, selectedShapes, shape, i);\n  }).filter(_functional.identity);\n};\n\nvar getAnnotatedShapes = exports.getAnnotatedShapes = function getAnnotatedShapes(_ref27, alignmentGuideAnnotations, hoverAnnotations, rotationAnnotations, resizeAnnotations, rotationTooltipAnnotation, adHocChildrenAnnotations) {\n  var shapes = _ref27.shapes;\n\n  // fixme update it to a simple concatenator, no need for enlisting the now pretty long subtype list\n  var annotations = [].concat(alignmentGuideAnnotations, hoverAnnotations, rotationAnnotations, resizeAnnotations, rotationTooltipAnnotation, adHocChildrenAnnotations);\n  // remove preexisting annotations\n  var contentShapes = shapes.filter(function (shape) {\n    return shape.type !== 'annotation';\n  });\n  return contentShapes.concat(annotations); // add current annotations\n}; // collection of shapes themselves\n\nvar getNextScene = exports.getNextScene = function getNextScene(config, hoveredShape, selectedShapeIds, selectedPrimaryShapes, shapes, gestureEnd, draggedShape, cursor, selectionState, mouseTransformState, selectedShapes) {\n  var selectedLeafShapes = getLeafs(function (shape) {\n    return shape.type === config.groupName;\n  }, shapes, selectionState.shapes.map(function (s) {\n    return s.type === 'annotation' ? shapes.find(function (ss) {\n      return ss.id === s.parent;\n    }) : s;\n  }).filter(_functional.identity)).filter(function (shape) {\n    return shape.type !== 'annotation';\n  }).map(function (s) {\n    return s.id;\n  });\n  return {\n    configuration: config,\n    hoveredShape: hoveredShape,\n    selectedShapes: selectedShapeIds,\n    selectedLeafShapes: selectedLeafShapes,\n    selectedPrimaryShapes: selectedPrimaryShapes,\n    shapes: shapes,\n    gestureEnd: gestureEnd,\n    draggedShape: draggedShape,\n    cursor: cursor,\n    selectionState: selectionState,\n    mouseTransformState: mouseTransformState,\n    selectedShapeObjects: selectedShapes\n  };\n};",null]}