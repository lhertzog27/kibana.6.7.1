{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/rollup/public/search/rollup_search_strategy.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/rollup/public/search/rollup_search_strategy.js","mtime":1567631712292},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rollupSearchStrategy = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar serializeAllFetchParams = function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fetchParams, searchRequests) {\n    var searchRequestsWithFetchParams, failedSearchRequests, serializedFetchParams;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            searchRequestsWithFetchParams = [];\n            failedSearchRequests = [];\n\n            // Gather the fetch param responses from all the successful requests.\n\n            fetchParams.forEach(function (result, index) {\n              if (result.resolved) {\n                searchRequestsWithFetchParams.push(result.resolved);\n              } else {\n                var searchRequest = searchRequests[index];\n\n                searchRequest.handleFailure(result.rejected);\n                failedSearchRequests.push(searchRequest);\n              }\n            });\n\n            serializedFetchParams = serializeFetchParams(searchRequestsWithFetchParams);\n            return _context.abrupt('return', {\n              serializedFetchParams: serializedFetchParams,\n              failedSearchRequests: failedSearchRequests\n            });\n\n          case 5:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function serializeAllFetchParams(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar _kfetch = require('ui/kfetch');\n\nvar _courier = require('ui/courier');\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                           */\n\nfunction getAllFetchParams(searchRequests, Promise) {\n  return Promise.map(searchRequests, function (searchRequest) {\n    return Promise.try(searchRequest.getFetchParams, void 0, searchRequest).then(function (fetchParams) {\n      return searchRequest.fetchParams = fetchParams;\n    }).then(function (value) {\n      return { resolved: value };\n    }).catch(function (error) {\n      return { rejected: error };\n    });\n  });\n}\n\nfunction serializeFetchParams(searchRequestsWithFetchParams) {\n  return JSON.stringify(searchRequestsWithFetchParams.map(function (searchRequestWithFetchParams) {\n    var indexPattern = searchRequestWithFetchParams.index.title || searchRequestWithFetchParams.index;\n    var _searchRequestWithFet = searchRequestWithFetchParams.body,\n        size = _searchRequestWithFet.size,\n        aggs = _searchRequestWithFet.aggs,\n        _query = _searchRequestWithFet.query;\n\n\n    var query = {\n      'size': size,\n      'aggregations': aggs,\n      'query': _query\n    };\n\n    return { index: indexPattern, query: query };\n  }));\n}\n\n// Rollup search always returns 0 hits, but visualizations expect search responses\n// to return hits > 0, otherwise they do not render. We fake the number of hits here\n// by counting the number of aggregation buckets/values returned by rollup search.\nfunction shimHitsInFetchResponse(response) {\n  return response.map(function (result) {\n    var buckets = result.aggregations ? Object.keys(result.aggregations).reduce(function (allBuckets, agg) {\n      return allBuckets.concat(result.aggregations[agg].buckets || [result.aggregations[agg].value] || []);\n    }, []) : [];\n    return buckets && buckets.length ? _extends({}, result, {\n      hits: _extends({}, result.hits, {\n        total: buckets.length\n      })\n    }) : result;\n  });\n}\n\nvar rollupSearchStrategy = exports.rollupSearchStrategy = {\n  id: 'rollup',\n\n  search: function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {\n      var searchRequests = _ref2.searchRequests,\n          Promise = _ref2.Promise;\n\n      var allFetchParams, _ref4, serializedFetchParams, failedSearchRequests, _kfetchAbortable, fetching, abort;\n\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return getAllFetchParams(searchRequests, Promise);\n\n            case 2:\n              allFetchParams = _context2.sent;\n              _context2.next = 5;\n              return serializeAllFetchParams(allFetchParams, searchRequests);\n\n            case 5:\n              _ref4 = _context2.sent;\n              serializedFetchParams = _ref4.serializedFetchParams;\n              failedSearchRequests = _ref4.failedSearchRequests;\n              _kfetchAbortable = (0, _kfetch.kfetchAbortable)({\n                pathname: '../api/rollup/search',\n                method: 'POST',\n                body: serializedFetchParams\n              }), fetching = _kfetchAbortable.fetching, abort = _kfetchAbortable.abort;\n              return _context2.abrupt('return', {\n                searching: new Promise(function (resolve, reject) {\n                  fetching.then(function (result) {\n                    resolve(shimHitsInFetchResponse(result));\n                  }).catch(function (error) {\n                    var _error$body = error.body,\n                        statusText = _error$body.statusText,\n                        title = _error$body.error,\n                        message = _error$body.message,\n                        url = error.res.url;\n\n                    // Format kfetch error as a SearchError.\n\n                    var searchError = new _courier.SearchError({\n                      status: statusText,\n                      title: title,\n                      message: 'Rollup search error: ' + message,\n                      path: url,\n                      type: (0, _courier.getSearchErrorType)({ message: message })\n                    });\n\n                    reject(searchError);\n                  });\n                }),\n                abort: abort,\n                failedSearchRequests: failedSearchRequests\n              });\n\n            case 10:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, _callee2, undefined);\n    }));\n\n    function search(_x3) {\n      return _ref3.apply(this, arguments);\n    }\n\n    return search;\n  }(),\n\n  isViable: function isViable(indexPattern) {\n    if (!indexPattern) {\n      return false;\n    }\n\n    return indexPattern.type === 'rollup';\n  }\n};",null]}