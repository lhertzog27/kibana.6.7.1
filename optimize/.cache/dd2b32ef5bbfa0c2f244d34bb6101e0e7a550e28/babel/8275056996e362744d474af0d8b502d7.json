{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/notify/notifier.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/notify/notifier.js","mtime":1567631711745},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Notifier = Notifier;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _metadata = require('../metadata');\n\nvar _lib = require('./lib');\n\nrequire('../render_directive');\n\nvar _i18n = require('@kbn/i18n');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar notifs = []; /*\n                  * Licensed to Elasticsearch B.V. under one or more contributor\n                  * license agreements. See the NOTICE file distributed with\n                  * this work for additional information regarding copyright\n                  * ownership. Elasticsearch B.V. licenses this file to you under\n                  * the Apache License, Version 2.0 (the \"License\"); you may\n                  * not use this file except in compliance with the License.\n                  * You may obtain a copy of the License at\n                  *\n                  *    http://www.apache.org/licenses/LICENSE-2.0\n                  *\n                  * Unless required by applicable law or agreed to in writing,\n                  * software distributed under the License is distributed on an\n                  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                  * KIND, either express or implied.  See the License for the\n                  * specific language governing permissions and limitations\n                  * under the License.\n                  */\n\nvar version = _metadata.metadata.version,\n    buildNum = _metadata.metadata.buildNum;\n\n\nfunction closeNotif(notif) {\n  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lodash2.default.noop;\n  var key = arguments[2];\n\n  return function () {\n    // this === notif\n    var i = notifs.indexOf(notif);\n    if (i !== -1) notifs.splice(i, 1);\n\n    cancelTimer(notif);\n    cb(key);\n  };\n}\n\nfunction cancelTimer(notif) {\n  if (notif.timerId) {\n    Notifier.config.clearInterval(notif.timerId);\n    notif.timerId = undefined;\n  }\n}\n\nfunction timerCanceler(notif) {\n  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lodash2.default.noop;\n  var key = arguments[2];\n\n  return function cancelNotifTimer() {\n    cancelTimer(notif);\n    cb(key);\n  };\n}\n\n/**\n * Initiates a timer to update _timeRemaining_ on the notif at second\n * intervals and clears the notif once the notif _lifetime_ has been reached.\n */\nfunction startNotifTimer(notif, cb) {\n  var interval = 1000;\n\n  if (notif.lifetime === Infinity || notif.lifetime === 0) {\n    return;\n  }\n\n  notif.timeRemaining = Math.floor(notif.lifetime / interval);\n\n  notif.timerId = Notifier.config.setInterval(function () {\n    notif.timeRemaining -= 1;\n\n    if (notif.timeRemaining <= 0) {\n      closeNotif(notif, cb, 'ignore')();\n    }\n  }, interval, notif.timeRemaining);\n\n  notif.cancelTimer = timerCanceler(notif, cb);\n}\n\nfunction restartNotifTimer(notif, cb) {\n  cancelTimer(notif);\n  startNotifTimer(notif, cb);\n}\n\nvar typeToButtonClassMap = {\n  danger: 'kuiButton--danger', // NOTE: `error` type is internally named as `danger`\n  info: 'kuiButton--secondary'\n};\nvar typeToAlertClassMap = {\n  danger: 'kbnToast--danger',\n  info: 'kbnToast--info'\n};\n\nfunction add(notif, cb) {\n  _lodash2.default.set(notif, 'info.version', version);\n  _lodash2.default.set(notif, 'info.buildNum', buildNum);\n\n  notif.clear = closeNotif(notif);\n\n  if (notif.actions) {\n    notif.actions.forEach(function (action) {\n      notif[action] = closeNotif(notif, cb, action);\n    });\n  } else if (notif.customActions) {\n    // wrap all of the custom functions in a close\n    notif.customActions = notif.customActions.map(function (action) {\n      return {\n        key: action.text,\n        dataTestSubj: action.dataTestSubj,\n        callback: closeNotif(notif, action.callback, action.text),\n        getButtonClass: function getButtonClass() {\n          var buttonTypeClass = typeToButtonClassMap[notif.type];\n          return '' + buttonTypeClass;\n        }\n      };\n    });\n  }\n\n  notif.count = (notif.count || 0) + 1;\n\n  notif.isTimed = function isTimed() {\n    return notif.timerId ? true : false;\n  };\n\n  // decorate the notification with helper functions for the template\n  notif.getButtonClass = function () {\n    return '' + typeToButtonClassMap[notif.type];\n  };\n  notif.getAlertClassStack = function () {\n    return 'kbnToast kbnToast-isStack ' + typeToAlertClassMap[notif.type];\n  };\n  notif.getIconClass = function () {\n    return 'fa fa-' + notif.icon;\n  };\n  notif.getToastMessageClass = function () {\n    return 'kbnToast__message';\n  };\n  notif.getAlertClass = function () {\n    return 'kbnToast ' + typeToAlertClassMap[notif.type];\n  };\n  notif.getButtonGroupClass = function () {\n    return 'kbnToast__controls';\n  };\n\n  var dup = null;\n  if (notif.content) {\n    dup = _lodash2.default.find(notifs, function (item) {\n      return item.content === notif.content && item.lifetime === notif.lifetime;\n    });\n  }\n\n  if (dup) {\n    dup.count += 1;\n    dup.stacks = _lodash2.default.union(dup.stacks, [notif.stack]);\n\n    restartNotifTimer(dup, cb);\n\n    return dup;\n  }\n\n  startNotifTimer(notif, cb);\n\n  notif.stacks = [notif.stack];\n  notifs.push(notif);\n  return notif;\n}\n\nNotifier.prototype.add = add;\n\n/**\n * Functionality to check that\n */\nfunction Notifier(opts) {\n  var self = this;\n  opts = opts || {};\n\n  // label type thing to say where notifications came from\n  self.from = opts.location;\n\n  var notificationLevels = ['error'];\n\n  notificationLevels.forEach(function (m) {\n    self[m] = _lodash2.default.bind(self[m], self);\n  });\n}\n\nNotifier.config = {\n  bannerLifetime: 3000000,\n  errorLifetime: 300000,\n  infoLifetime: 5000,\n  setInterval: window.setInterval,\n  clearInterval: window.clearInterval\n};\n\nNotifier.applyConfig = function (config) {\n  _lodash2.default.merge(Notifier.config, config);\n};\n\n// simply a pointer to the global notif list\nNotifier.prototype._notifs = notifs;\n\nvar overridableOptions = ['lifetime', 'icon'];\n\n/**\n * Alert the user of an error that occured\n * @param  {Error|String} err\n * @param  {Function} cb\n */\nNotifier.prototype.error = function (err, opts, cb) {\n  if (_lodash2.default.isFunction(opts)) {\n    cb = opts;\n    opts = {};\n  }\n\n  var config = _lodash2.default.assign({\n    type: 'danger',\n    content: (0, _lib.formatMsg)(err, this.from),\n    icon: 'warning',\n    title: _i18n.i18n.translate('common.ui.notify.toaster.errorTitle', {\n      defaultMessage: 'Error'\n    }),\n    lifetime: Notifier.config.errorLifetime,\n    actions: ['report', 'accept'],\n    stack: (0, _lib.formatStack)(err)\n  }, _lodash2.default.pick(opts, overridableOptions));\n\n  return add(config, cb);\n};",null]}