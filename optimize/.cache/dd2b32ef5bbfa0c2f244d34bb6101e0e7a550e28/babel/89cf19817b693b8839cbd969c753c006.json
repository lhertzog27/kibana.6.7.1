{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/history_provider.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/history_provider.js","mtime":1567631711933},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.historyProvider = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nvar _lzString = require('lz-string');\n\nvar _lzString2 = _interopRequireDefault(_lzString);\n\nvar _history = require('history');\n\nvar _historyExtra = require('history-extra');\n\nvar _historyExtra2 = _interopRequireDefault(_historyExtra);\n\nvar _get_window = require('./get_window');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction wrapHistoryInstance(history) {\n  var historyState = {\n    onChange: [],\n    prevLocation: {},\n    changeUnlisten: null\n  };\n\n  var locationFormat = function locationFormat(location, action, parser) {\n    return {\n      pathname: location.pathname,\n      hash: location.hash,\n      state: parser(location.state),\n      action: action.toLowerCase()\n    };\n  };\n\n  var wrappedHistory = {\n    undo: function undo() {\n      history.goBack();\n    },\n    redo: function redo() {\n      history.goForward();\n    },\n    go: function go(idx) {\n      history.go(idx);\n    },\n    parse: function parse(payload) {\n      try {\n        var stateJSON = _lzString2.default.decompress(payload);\n        return JSON.parse(stateJSON);\n      } catch (e) {\n        return null;\n      }\n    },\n    encode: function encode(state) {\n      try {\n        var stateJSON = JSON.stringify(state);\n        return _lzString2.default.compress(stateJSON);\n      } catch (e) {\n        throw new Error('Could not encode state: ', e.message);\n      }\n    },\n    getLocation: function getLocation() {\n      var location = history.location;\n      return _extends({}, location, {\n        state: this.parse(location.state)\n      });\n    },\n    getPath: function getPath(path) {\n      if (path != null) {\n        return (0, _history.createPath)((0, _history.parsePath)(path));\n      }\n      return (0, _history.createPath)(this.getLocation());\n    },\n    getFullPath: function getFullPath(path) {\n      if (path != null) {\n        return history.createHref((0, _history.parsePath)(path));\n      }\n      return history.createHref(this.getLocation());\n    },\n    push: function push(state, path) {\n      history.push(path || this.getPath(), this.encode(state));\n    },\n    replace: function replace(state, path) {\n      history.replace(path || this.getPath(), this.encode(state));\n    },\n    onChange: function onChange(fn) {\n      // if no handler fn passed, do nothing\n      if (fn == null) {\n        return;\n      }\n\n      // push onChange function onto listener stack and return a function to remove it\n      var pushedIndex = historyState.onChange.push(fn) - 1;\n      return function () {\n        // only allow the unlisten function to be called once\n        var called = false;\n        return function () {\n          if (called) {\n            return;\n          }\n          historyState.onChange.splice(pushedIndex, 1);\n          called = true;\n        };\n      }();\n    },\n    resetOnChange: function resetOnChange() {\n      // splice to clear the onChange array, and remove listener for each fn\n      historyState.onChange.splice(0);\n    },\n\n\n    get historyInstance() {\n      // getter to get access to the underlying history instance\n      return history;\n    }\n  };\n\n  // track the initial history location and create update listener\n  historyState.prevLocation = wrappedHistory.getLocation();\n  historyState.changeUnlisten = history.listen(function (location, action) {\n    var prevLocation = historyState.prevLocation;\n\n    var locationObj = locationFormat(location, action, wrappedHistory.parse);\n    var prevLocationObj = locationFormat(prevLocation, action, wrappedHistory.parse);\n\n    // execute all listeners\n    historyState.onChange.forEach(function (fn) {\n      return fn.call(null, locationObj, prevLocationObj);\n    });\n\n    // track the updated location\n    historyState.prevLocation = wrappedHistory.getLocation();\n  });\n\n  return wrappedHistory;\n}\n\nvar instances = new WeakMap();\n\nvar getHistoryInstance = function getHistoryInstance(win) {\n  // if no window object, use memory module\n  if (typeof win === 'undefined' || !win.history) {\n    return (0, _history.createMemoryHistory)();\n  }\n  return (0, _historyExtra2.default)();\n};\n\nvar historyProvider = exports.historyProvider = function historyProvider() {\n  var win = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _get_window.getWindow)();\n\n  // return cached instance if one exists\n  var instance = instances.get(win);\n  if (instance) {\n    return instance;\n  }\n\n  // create and cache wrapped history instance\n  var historyInstance = getHistoryInstance(win);\n  var wrappedInstance = wrapHistoryInstance(historyInstance);\n  instances.set(win, wrappedInstance);\n\n  return wrappedInstance;\n};",null]}