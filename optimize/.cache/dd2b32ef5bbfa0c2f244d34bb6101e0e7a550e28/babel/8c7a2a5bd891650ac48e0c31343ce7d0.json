{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/services/results_service.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/services/results_service.js","mtime":1567631712063},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mlResultsService = undefined;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _job_utils = require('../../common/util/job_utils');\n\nvar _string_utils = require('../util/string_utils');\n\nvar _index_patterns = require('../../common/constants/index_patterns');\n\nvar _ml_api_service = require('../services/ml_api_service');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /*\n                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                   */\n\n// Service for carrying out Elasticsearch queries to obtain data for the\n// Ml Results dashboards.\n\n// import d3 from 'd3';\n\n// Obtains the maximum bucket anomaly scores by job ID and time.\n// Pass an empty array or ['*'] to search over all job IDs.\n// Returned response contains a results property, with a key for job\n// which has results for the specified time range.\nfunction getScoresByBucket(jobIds, earliestMs, latestMs, interval, maxResults) {\n  return new Promise(function (resolve, reject) {\n    var obj = {\n      success: true,\n      results: {}\n    };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Adds criteria for the time range plus any specified job IDs.\n    var boolCriteria = [{\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }];\n\n    if (jobIds && jobIds.length > 0 && !(jobIds.length === 1 && jobIds[0] === '*')) {\n      var jobIdFilterStr = '';\n      _lodash2.default.each(jobIds, function (jobId, i) {\n        if (i > 0) {\n          jobIdFilterStr += ' OR ';\n        }\n        jobIdFilterStr += 'job_id:';\n        jobIdFilterStr += jobId;\n      });\n      boolCriteria.push({\n        query_string: {\n          analyze_wildcard: false,\n          query: jobIdFilterStr\n        }\n      });\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: 0,\n      body: {\n        query: {\n          bool: {\n            filter: [{\n              query_string: {\n                query: 'result_type:bucket',\n                analyze_wildcard: false\n              }\n            }, {\n              bool: {\n                must: boolCriteria\n              }\n            }]\n          }\n        },\n        aggs: {\n          jobId: {\n            terms: {\n              field: 'job_id',\n              size: maxResults !== undefined ? maxResults : 5,\n              order: {\n                anomalyScore: 'desc'\n              }\n            },\n            aggs: {\n              anomalyScore: {\n                max: {\n                  field: 'anomaly_score'\n                }\n              },\n              byTime: {\n                date_histogram: {\n                  field: 'timestamp',\n                  interval: interval,\n                  min_doc_count: 1,\n                  extended_bounds: {\n                    min: earliestMs,\n                    max: latestMs\n                  }\n                },\n                aggs: {\n                  anomalyScore: {\n                    max: {\n                      field: 'anomaly_score'\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }).then(function (resp) {\n      var dataByJobId = _lodash2.default.get(resp, ['aggregations', 'jobId', 'buckets'], []);\n      _lodash2.default.each(dataByJobId, function (dataForJob) {\n        var jobId = dataForJob.key;\n\n        var resultsForTime = {};\n\n        var dataByTime = _lodash2.default.get(dataForJob, ['byTime', 'buckets'], []);\n        _lodash2.default.each(dataByTime, function (dataForTime) {\n          var value = _lodash2.default.get(dataForTime, ['anomalyScore', 'value']);\n          if (value !== undefined) {\n            var time = dataForTime.key;\n            resultsForTime[time] = _lodash2.default.get(dataForTime, ['anomalyScore', 'value']);\n          }\n        });\n        obj.results[jobId] = resultsForTime;\n      });\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Obtains a list of scheduled events by job ID and time.\n// Pass an empty array or ['*'] to search over all job IDs.\n// Returned response contains a events property, which will only\n// contains keys for jobs which have scheduled events for the specified time range.\nfunction getScheduledEventsByBucket(jobIds, earliestMs, latestMs, interval, maxJobs, maxEvents) {\n  return new Promise(function (resolve, reject) {\n    var obj = {\n      success: true,\n      events: {}\n    };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Adds criteria for the time range plus any specified job IDs.\n    var boolCriteria = [{\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }, {\n      exists: { field: 'scheduled_events' }\n    }];\n\n    if (jobIds && jobIds.length > 0 && !(jobIds.length === 1 && jobIds[0] === '*')) {\n      var jobIdFilterStr = '';\n      _lodash2.default.each(jobIds, function (jobId, i) {\n        jobIdFilterStr += (i > 0 ? ' OR ' : '') + 'job_id:' + jobId;\n      });\n      boolCriteria.push({\n        query_string: {\n          analyze_wildcard: false,\n          query: jobIdFilterStr\n        }\n      });\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: 0,\n      body: {\n        query: {\n          bool: {\n            filter: [{\n              query_string: {\n                query: 'result_type:bucket',\n                analyze_wildcard: false\n              }\n            }, {\n              bool: {\n                must: boolCriteria\n              }\n            }]\n          }\n        },\n        aggs: {\n          jobs: {\n            terms: {\n              field: 'job_id',\n              min_doc_count: 1,\n              size: maxJobs\n            },\n            aggs: {\n              times: {\n                date_histogram: {\n                  field: 'timestamp',\n                  interval: interval,\n                  min_doc_count: 1\n                },\n                aggs: {\n                  events: {\n                    terms: {\n                      field: 'scheduled_events',\n                      size: maxEvents\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }).then(function (resp) {\n      var dataByJobId = _lodash2.default.get(resp, ['aggregations', 'jobs', 'buckets'], []);\n      _lodash2.default.each(dataByJobId, function (dataForJob) {\n        var jobId = dataForJob.key;\n        var resultsForTime = {};\n        var dataByTime = _lodash2.default.get(dataForJob, ['times', 'buckets'], []);\n        _lodash2.default.each(dataByTime, function (dataForTime) {\n          var time = dataForTime.key;\n          var events = _lodash2.default.get(dataForTime, ['events', 'buckets']);\n          resultsForTime[time] = _lodash2.default.map(events, 'key');\n        });\n        obj.events[jobId] = resultsForTime;\n      });\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Obtains the top influencers, by maximum influencer score, for the specified index, time range and job ID(s).\n// Pass an empty array or ['*'] to search over all job IDs.\n// An optional array of influencers may be supplied, with each object in the array having 'fieldName'\n// and 'fieldValue' properties, to limit data to the supplied list of influencers.\n// Returned response contains an influencers property, with a key for each of the influencer field names,\n// whose value is an array of objects containing influencerFieldValue, maxAnomalyScore and sumAnomalyScore keys.\nfunction getTopInfluencers(jobIds, earliestMs, latestMs) {\n  var maxFieldValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n  var influencers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n  return new Promise(function (resolve, reject) {\n    var obj = { success: true, influencers: {} };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Adds criteria for the time range plus any specified job IDs.\n    var boolCriteria = [{\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }, {\n      range: {\n        influencer_score: {\n          gt: 0\n        }\n      }\n    }];\n\n    if (jobIds && jobIds.length > 0 && !(jobIds.length === 1 && jobIds[0] === '*')) {\n      var jobIdFilterStr = '';\n      _lodash2.default.each(jobIds, function (jobId, i) {\n        if (i > 0) {\n          jobIdFilterStr += ' OR ';\n        }\n        jobIdFilterStr += 'job_id:';\n        jobIdFilterStr += jobId;\n      });\n      boolCriteria.push({\n        query_string: {\n          analyze_wildcard: false,\n          query: jobIdFilterStr\n        }\n      });\n    }\n\n    // Add a should query to filter for each of the specified influencers.\n    if (influencers.length > 0) {\n      boolCriteria.push({\n        bool: {\n          should: influencers.map(function (influencer) {\n            return {\n              bool: {\n                must: [{ term: { influencer_field_name: influencer.fieldName } }, { term: { influencer_field_value: influencer.fieldValue } }]\n              }\n            };\n          }),\n          minimum_should_match: 1\n        }\n      });\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: 0,\n      body: {\n        query: {\n          bool: {\n            filter: [{\n              query_string: {\n                query: 'result_type:influencer',\n                analyze_wildcard: false\n              }\n            }, {\n              bool: {\n                must: boolCriteria\n              }\n            }]\n          }\n        },\n        aggs: {\n          influencerFieldNames: {\n            terms: {\n              field: 'influencer_field_name',\n              size: 5,\n              order: {\n                maxAnomalyScore: 'desc'\n              }\n            },\n            aggs: {\n              maxAnomalyScore: {\n                max: {\n                  field: 'influencer_score'\n                }\n              },\n              influencerFieldValues: {\n                terms: {\n                  field: 'influencer_field_value',\n                  size: maxFieldValues,\n                  order: {\n                    maxAnomalyScore: 'desc'\n                  }\n                },\n                aggs: {\n                  maxAnomalyScore: {\n                    max: {\n                      field: 'influencer_score'\n                    }\n                  },\n                  sumAnomalyScore: {\n                    sum: {\n                      field: 'influencer_score'\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }).then(function (resp) {\n      var fieldNameBuckets = _lodash2.default.get(resp, ['aggregations', 'influencerFieldNames', 'buckets'], []);\n      _lodash2.default.each(fieldNameBuckets, function (nameBucket) {\n        var fieldName = nameBucket.key;\n        var fieldValues = [];\n\n        var fieldValueBuckets = _lodash2.default.get(nameBucket, ['influencerFieldValues', 'buckets'], []);\n        _lodash2.default.each(fieldValueBuckets, function (valueBucket) {\n          var fieldValueResult = {\n            influencerFieldValue: valueBucket.key,\n            maxAnomalyScore: valueBucket.maxAnomalyScore.value,\n            sumAnomalyScore: valueBucket.sumAnomalyScore.value\n          };\n          fieldValues.push(fieldValueResult);\n        });\n\n        obj.influencers[fieldName] = fieldValues;\n      });\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Obtains the top influencer field values, by maximum anomaly score, for a\n// particular index, field name and job ID(s).\n// Pass an empty array or ['*'] to search over all job IDs.\n// Returned response contains a results property, which is an array of objects\n// containing influencerFieldValue, maxAnomalyScore and sumAnomalyScore keys.\nfunction getTopInfluencerValues(jobIds, influencerFieldName, earliestMs, latestMs, maxResults) {\n  return new Promise(function (resolve, reject) {\n    var obj = { success: true, results: [] };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Adds criteria for the time range plus any specified job IDs.\n    var boolCriteria = [{\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }];\n\n    if (jobIds && jobIds.length > 0 && !(jobIds.length === 1 && jobIds[0] === '*')) {\n      var jobIdFilterStr = '';\n      _lodash2.default.each(jobIds, function (jobId, i) {\n        if (i > 0) {\n          jobIdFilterStr += ' OR ';\n        }\n        jobIdFilterStr += 'job_id:';\n        jobIdFilterStr += jobId;\n      });\n      boolCriteria.push({\n        query_string: {\n          analyze_wildcard: false,\n          query: jobIdFilterStr\n        }\n      });\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: 0,\n      body: {\n        query: {\n          bool: {\n            filter: [{\n              query_string: {\n                query: 'result_type:influencer AND influencer_field_name: ' + (0, _string_utils.escapeForElasticsearchQuery)(influencerFieldName),\n                analyze_wildcard: false\n              }\n            }, {\n              bool: {\n                must: boolCriteria\n              }\n            }]\n          }\n        },\n        aggs: {\n          influencerFieldValues: {\n            terms: {\n              field: 'influencer_field_value',\n              size: maxResults !== undefined ? maxResults : 2,\n              order: {\n                maxAnomalyScore: 'desc'\n              }\n            },\n            aggs: {\n              maxAnomalyScore: {\n                max: {\n                  field: 'influencer_score'\n                }\n              },\n              sumAnomalyScore: {\n                sum: {\n                  field: 'influencer_score'\n                }\n              }\n            }\n          }\n        }\n      }\n    }).then(function (resp) {\n      var buckets = _lodash2.default.get(resp, ['aggregations', 'influencerFieldValues', 'buckets'], []);\n      _lodash2.default.each(buckets, function (bucket) {\n        var result = {\n          influencerFieldValue: bucket.key,\n          maxAnomalyScore: bucket.maxAnomalyScore.value,\n          sumAnomalyScore: bucket.sumAnomalyScore.value };\n        obj.results.push(result);\n      });\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Obtains the overall bucket scores for the specified job ID(s).\n// Pass ['*'] to search over all job IDs.\n// Returned response contains a results property as an object of max score by time.\nfunction getOverallBucketScores(jobIds, topN, earliestMs, latestMs, interval) {\n  return new Promise(function (resolve, reject) {\n    var obj = { success: true, results: {} };\n\n    _ml_api_service.ml.overallBuckets({\n      jobId: jobIds,\n      topN: topN,\n      bucketSpan: interval,\n      start: earliestMs,\n      end: latestMs\n    }).then(function (resp) {\n      var dataByTime = _lodash2.default.get(resp, ['overall_buckets'], []);\n      _lodash2.default.each(dataByTime, function (dataForTime) {\n        var value = _lodash2.default.get(dataForTime, ['overall_score']);\n        if (value !== undefined) {\n          obj.results[dataForTime.timestamp] = value;\n        }\n      });\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Obtains the maximum score by influencer_field_value and by time for the specified job ID(s)\n// (pass an empty array or ['*'] to search over all job IDs), and specified influencer field\n// values (pass an empty array to search over all field values).\n// Returned response contains a results property with influencer field values keyed\n// against max score by time.\nfunction getInfluencerValueMaxScoreByTime(jobIds, influencerFieldName, influencerFieldValues, earliestMs, latestMs, interval, maxResults) {\n  return new Promise(function (resolve, reject) {\n    var obj = { success: true, results: {} };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Adds criteria for the time range plus any specified job IDs.\n    var boolCriteria = [{\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }, {\n      range: {\n        influencer_score: {\n          gt: 0\n        }\n      }\n    }];\n\n    if (jobIds && jobIds.length > 0 && !(jobIds.length === 1 && jobIds[0] === '*')) {\n      var jobIdFilterStr = '';\n      _lodash2.default.each(jobIds, function (jobId, i) {\n        if (i > 0) {\n          jobIdFilterStr += ' OR ';\n        }\n        jobIdFilterStr += 'job_id:' + jobId;\n      });\n      boolCriteria.push({\n        query_string: {\n          analyze_wildcard: false,\n          query: jobIdFilterStr\n        }\n      });\n    }\n\n    if (influencerFieldValues && influencerFieldValues.length > 0) {\n      var influencerFilterStr = '';\n      _lodash2.default.each(influencerFieldValues, function (value, i) {\n        if (i > 0) {\n          influencerFilterStr += ' OR ';\n        }\n        if (value.trim().length > 0) {\n          influencerFilterStr += 'influencer_field_value:' + (0, _string_utils.escapeForElasticsearchQuery)(value);\n        } else {\n          // Wrap whitespace influencer field values in quotes for the query_string query.\n          influencerFilterStr += 'influencer_field_value:\"' + value + '\"';\n        }\n      });\n      boolCriteria.push({\n        query_string: {\n          analyze_wildcard: false,\n          query: influencerFilterStr\n        }\n      });\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: 0,\n      body: {\n        query: {\n          bool: {\n            filter: [{\n              query_string: {\n                query: 'result_type:influencer AND influencer_field_name: ' + (0, _string_utils.escapeForElasticsearchQuery)(influencerFieldName),\n                analyze_wildcard: false\n              }\n            }, {\n              bool: {\n                must: boolCriteria\n              }\n            }]\n          }\n        },\n        aggs: {\n          influencerFieldValues: {\n            terms: {\n              field: 'influencer_field_value',\n              size: maxResults !== undefined ? maxResults : 10,\n              order: {\n                maxAnomalyScore: 'desc'\n              }\n            },\n            aggs: {\n              maxAnomalyScore: {\n                max: {\n                  field: 'influencer_score'\n                }\n              },\n              byTime: {\n                date_histogram: {\n                  field: 'timestamp',\n                  interval: interval,\n                  min_doc_count: 1\n                },\n                aggs: {\n                  maxAnomalyScore: {\n                    max: {\n                      field: 'influencer_score'\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }).then(function (resp) {\n      var fieldValueBuckets = _lodash2.default.get(resp, ['aggregations', 'influencerFieldValues', 'buckets'], []);\n      _lodash2.default.each(fieldValueBuckets, function (valueBucket) {\n        var fieldValue = valueBucket.key;\n        var fieldValues = {};\n\n        var timeBuckets = _lodash2.default.get(valueBucket, ['byTime', 'buckets'], []);\n        _lodash2.default.each(timeBuckets, function (timeBucket) {\n          var time = timeBucket.key;\n          var score = timeBucket.maxAnomalyScore.value;\n          fieldValues[time] = score;\n        });\n\n        obj.results[fieldValue] = fieldValues;\n      });\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Queries Elasticsearch to obtain record level results containing the influencers\n// for the specified job(s), record score threshold, and time range.\n// Pass an empty array or ['*'] to search over all job IDs.\n// Returned response contains a records property, with each record containing\n// only the fields job_id, detector_index, record_score and influencers.\nfunction getRecordInfluencers(jobIds, threshold, earliestMs, latestMs, maxResults) {\n  return new Promise(function (resolve, reject) {\n    var obj = { success: true, records: [] };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Adds criteria for the existence of the nested influencers field, time range,\n    // record score, plus any specified job IDs.\n    var boolCriteria = [{\n      nested: {\n        path: 'influencers',\n        query: {\n          bool: {\n            must: [{\n              exists: { field: 'influencers' }\n            }]\n          }\n        }\n      }\n    }, {\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }, {\n      range: {\n        record_score: {\n          gte: threshold\n        }\n      }\n    }];\n\n    if (jobIds && jobIds.length > 0 && !(jobIds.length === 1 && jobIds[0] === '*')) {\n      var jobIdFilterStr = '';\n      _lodash2.default.each(jobIds, function (jobId, i) {\n        if (i > 0) {\n          jobIdFilterStr += ' OR ';\n        }\n        jobIdFilterStr += 'job_id:';\n        jobIdFilterStr += jobId;\n      });\n      boolCriteria.push({\n        query_string: {\n          analyze_wildcard: false,\n          query: jobIdFilterStr\n        }\n      });\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: maxResults !== undefined ? maxResults : 100,\n      rest_total_hits_as_int: true,\n      body: {\n        _source: ['job_id', 'detector_index', 'influencers', 'record_score'],\n        query: {\n          bool: {\n            filter: [{\n              query_string: {\n                query: 'result_type:record',\n                analyze_wildcard: false\n              }\n            }, {\n              bool: {\n                must: boolCriteria\n              }\n            }]\n          }\n        },\n        sort: [{ record_score: { order: 'desc' } }]\n      }\n    }).then(function (resp) {\n      if (resp.hits.total !== 0) {\n        _lodash2.default.each(resp.hits.hits, function (hit) {\n          obj.records.push(hit._source);\n        });\n      }\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Queries Elasticsearch to obtain the record level results containing the specified influencer(s),\n// for the specified job(s), time range, and record score threshold.\n// influencers parameter must be an array, with each object in the array having 'fieldName'\n// 'fieldValue' properties. The influencer array uses 'should' for the nested bool query,\n// so this returns record level results which have at least one of the influencers.\n// Pass an empty array or ['*'] to search over all job IDs.\nfunction getRecordsForInfluencer(jobIds, influencers, threshold, earliestMs, latestMs, maxResults) {\n  return new Promise(function (resolve, reject) {\n    var obj = { success: true, records: [] };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Add criteria for the time range, record score, plus any specified job IDs.\n    var boolCriteria = [{\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }, {\n      range: {\n        record_score: {\n          gte: threshold\n        }\n      }\n    }];\n\n    if (jobIds && jobIds.length > 0 && !(jobIds.length === 1 && jobIds[0] === '*')) {\n      var jobIdFilterStr = '';\n      _lodash2.default.each(jobIds, function (jobId, i) {\n        if (i > 0) {\n          jobIdFilterStr += ' OR ';\n        }\n        jobIdFilterStr += 'job_id:';\n        jobIdFilterStr += jobId;\n      });\n      boolCriteria.push({\n        query_string: {\n          analyze_wildcard: false,\n          query: jobIdFilterStr\n        }\n      });\n    }\n\n    // Add a nested query to filter for each of the specified influencers.\n    if (influencers.length > 0) {\n      boolCriteria.push({\n        bool: {\n          should: influencers.map(function (influencer) {\n            return {\n              nested: {\n                path: 'influencers',\n                query: {\n                  bool: {\n                    must: [{\n                      match: {\n                        'influencers.influencer_field_name': influencer.fieldName\n                      }\n                    }, {\n                      match: {\n                        'influencers.influencer_field_values': influencer.fieldValue\n                      }\n                    }]\n                  }\n                }\n              }\n            };\n          }),\n          minimum_should_match: 1\n        }\n      });\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: maxResults !== undefined ? maxResults : 100,\n      rest_total_hits_as_int: true,\n      body: {\n        query: {\n          bool: {\n            filter: [{\n              query_string: {\n                query: 'result_type:record',\n                analyze_wildcard: false\n              }\n            }, {\n              bool: {\n                must: boolCriteria\n              }\n            }]\n          }\n        },\n        sort: [{ record_score: { order: 'desc' } }]\n      }\n    }).then(function (resp) {\n      if (resp.hits.total !== 0) {\n        _lodash2.default.each(resp.hits.hits, function (hit) {\n          obj.records.push(hit._source);\n        });\n      }\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Queries Elasticsearch to obtain the record level results for the specified job and detector,\n// time range, record score threshold, and whether to only return results containing influencers.\n// An additional, optional influencer field name and value may also be provided.\nfunction getRecordsForDetector(jobId, detectorIndex, checkForInfluencers, influencerFieldName, influencerFieldValue, threshold, earliestMs, latestMs, maxResults) {\n  return new Promise(function (resolve, reject) {\n    var obj = { success: true, records: [] };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Add criteria for the time range, record score, plus any specified job IDs.\n    var boolCriteria = [{\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }, {\n      term: { job_id: jobId }\n    }, {\n      term: { detector_index: detectorIndex }\n    }, {\n      range: {\n        record_score: {\n          gte: threshold\n        }\n      }\n    }];\n\n    // Add a nested query to filter for the specified influencer field name and value.\n    if (influencerFieldName && influencerFieldValue) {\n      boolCriteria.push({\n        nested: {\n          path: 'influencers',\n          query: {\n            bool: {\n              must: [{\n                match: {\n                  'influencers.influencer_field_name': influencerFieldName\n                }\n              }, {\n                match: {\n                  'influencers.influencer_field_values': influencerFieldValue\n                }\n              }]\n            }\n          }\n        }\n      });\n    } else {\n      if (checkForInfluencers === true) {\n        boolCriteria.push({\n          nested: {\n            path: 'influencers',\n            query: {\n              bool: {\n                must: [{\n                  exists: { field: 'influencers' }\n                }]\n              }\n            }\n          }\n        });\n      }\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: maxResults !== undefined ? maxResults : 100,\n      rest_total_hits_as_int: true,\n      body: {\n        query: {\n          bool: {\n            filter: [{\n              query_string: {\n                query: 'result_type:record',\n                analyze_wildcard: false\n              }\n            }, {\n              bool: {\n                must: boolCriteria\n              }\n            }]\n          }\n        },\n        sort: [{ record_score: { order: 'desc' } }]\n      }\n    }).then(function (resp) {\n      if (resp.hits.total !== 0) {\n        _lodash2.default.each(resp.hits.hits, function (hit) {\n          obj.records.push(hit._source);\n        });\n      }\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Queries Elasticsearch to obtain all the record level results for the specified job(s), time range,\n// and record score threshold.\n// Pass an empty array or ['*'] to search over all job IDs.\n// Returned response contains a records property, which is an array of the matching results.\nfunction getRecords(jobIds, threshold, earliestMs, latestMs, maxResults) {\n  return this.getRecordsForInfluencer(jobIds, [], threshold, earliestMs, latestMs, maxResults);\n}\n\n// Queries Elasticsearch to obtain the record level results matching the given criteria,\n// for the specified job(s), time range, and record score threshold.\n// criteriaFields parameter must be an array, with each object in the array having 'fieldName'\n// 'fieldValue' properties.\n// Pass an empty array or ['*'] to search over all job IDs.\nfunction getRecordsForCriteria(jobIds, criteriaFields, threshold, earliestMs, latestMs, maxResults) {\n  return new Promise(function (resolve, reject) {\n    var obj = { success: true, records: [] };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Add criteria for the time range, record score, plus any specified job IDs.\n    var boolCriteria = [{\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }, {\n      range: {\n        record_score: {\n          gte: threshold\n        }\n      }\n    }];\n\n    if (jobIds && jobIds.length > 0 && !(jobIds.length === 1 && jobIds[0] === '*')) {\n      var jobIdFilterStr = '';\n      _lodash2.default.each(jobIds, function (jobId, i) {\n        if (i > 0) {\n          jobIdFilterStr += ' OR ';\n        }\n        jobIdFilterStr += 'job_id:';\n        jobIdFilterStr += jobId;\n      });\n      boolCriteria.push({\n        query_string: {\n          analyze_wildcard: false,\n          query: jobIdFilterStr\n        }\n      });\n    }\n\n    // Add in term queries for each of the specified criteria.\n    _lodash2.default.each(criteriaFields, function (criteria) {\n      boolCriteria.push({\n        term: _defineProperty({}, criteria.fieldName, criteria.fieldValue)\n      });\n    });\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      rest_total_hits_as_int: true,\n      size: maxResults !== undefined ? maxResults : 100,\n      body: {\n        query: {\n          bool: {\n            filter: [{\n              query_string: {\n                query: 'result_type:record',\n                analyze_wildcard: false\n              }\n            }, {\n              bool: {\n                must: boolCriteria\n              }\n            }]\n          }\n        },\n        sort: [{ record_score: { order: 'desc' } }]\n      }\n    }).then(function (resp) {\n      if (resp.hits.total !== 0) {\n        _lodash2.default.each(resp.hits.hits, function (hit) {\n          obj.records.push(hit._source);\n        });\n      }\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Queries Elasticsearch to obtain metric aggregation results.\n// index can be a String, or String[], of index names to search.\n// types must be a String[] of types to search.\n// entityFields parameter must be an array, with each object in the array having 'fieldName'\n//  and 'fieldValue' properties.\n// Extra query object can be supplied, or pass null if no additional query\n// to that built from the supplied entity fields.\n// Returned response contains a results property containing the requested aggregation.\nfunction getMetricData(index, types, entityFields, query, metricFunction, // ES aggregation name\nmetricFieldName, timeFieldName, earliestMs, latestMs, interval) {\n  return new Promise(function (resolve, reject) {\n    var obj = { success: true, results: {} };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Add criteria for the types, time range, entity fields,\n    // plus any additional supplied query.\n    var mustCriteria = [];\n    var shouldCriteria = [];\n\n    if (types && types.length) {\n      mustCriteria.push({ terms: { _type: types } });\n    }\n\n    mustCriteria.push({\n      range: _defineProperty({}, timeFieldName, {\n        gte: earliestMs,\n        lte: latestMs,\n        format: 'epoch_millis'\n      })\n    });\n\n    if (query) {\n      mustCriteria.push(query);\n    }\n\n    _lodash2.default.each(entityFields, function (entity) {\n      if (entity.fieldValue.length !== 0) {\n        mustCriteria.push({\n          term: _defineProperty({}, entity.fieldName, entity.fieldValue)\n        });\n      } else {\n        // Add special handling for blank entity field values, checking for either\n        // an empty string or the field not existing.\n        shouldCriteria.push({\n          bool: {\n            must: [{\n              term: _defineProperty({}, entity.fieldName, '')\n            }]\n          }\n        });\n        shouldCriteria.push({\n          bool: {\n            must_not: [{\n              exists: { field: entity.fieldName }\n            }]\n          }\n        });\n      }\n    });\n\n    var body = {\n      query: {\n        bool: {\n          must: mustCriteria\n        }\n      },\n      size: 0,\n      _source: {\n        excludes: []\n      },\n      aggs: {\n        byTime: {\n          date_histogram: {\n            field: timeFieldName,\n            interval: interval,\n            min_doc_count: 0\n          }\n\n        }\n      }\n    };\n\n    if (shouldCriteria.length > 0) {\n      body.query.bool.should = shouldCriteria;\n      body.query.bool.minimum_should_match = shouldCriteria.length / 2;\n    }\n\n    if (metricFieldName !== undefined && metricFieldName !== '') {\n      body.aggs.byTime.aggs = {};\n\n      var metricAgg = _defineProperty({}, metricFunction, {\n        field: metricFieldName\n      });\n\n      if (metricFunction === 'percentiles') {\n        metricAgg[metricFunction].percents = [_job_utils.ML_MEDIAN_PERCENTS];\n      }\n      body.aggs.byTime.aggs.metric = metricAgg;\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: index,\n      body: body\n    }).then(function (resp) {\n      var dataByTime = _lodash2.default.get(resp, ['aggregations', 'byTime', 'buckets'], []);\n      _lodash2.default.each(dataByTime, function (dataForTime) {\n        if (metricFunction === 'count') {\n          obj.results[dataForTime.key] = dataForTime.doc_count;\n        } else {\n          var value = _lodash2.default.get(dataForTime, ['metric', 'value']);\n          var values = _lodash2.default.get(dataForTime, ['metric', 'values']);\n          if (dataForTime.doc_count === 0) {\n            obj.results[dataForTime.key] = null;\n          } else if (value !== undefined) {\n            obj.results[dataForTime.key] = value;\n          } else if (values !== undefined) {\n            // Percentiles agg currently returns NaN rather than null when none of the docs in the\n            // bucket contain the field used in the aggregation\n            // (see elasticsearch issue https://github.com/elastic/elasticsearch/issues/29066).\n            // Store as null, so values can be handled in the same manner downstream as other aggs\n            // (min, mean, max) which return null.\n            var medianValues = values[_job_utils.ML_MEDIAN_PERCENTS];\n            obj.results[dataForTime.key] = !isNaN(medianValues) ? medianValues : null;\n          } else {\n            obj.results[dataForTime.key] = null;\n          }\n        }\n      });\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Queries Elasticsearch to obtain event rate data i.e. the count\n// of documents over time.\n// index can be a String, or String[], of index names to search.\n// Extra query object can be supplied, or pass null if no additional query.\n// Returned response contains a results property, which is an object\n// of document counts against time (epoch millis).\nfunction getEventRateData(index, query, timeFieldName, earliestMs, latestMs, interval) {\n  return new Promise(function (resolve, reject) {\n    var obj = { success: true, results: {} };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Add criteria for the types, time range, entity fields,\n    // plus any additional supplied query.\n    var mustCriteria = [{\n      range: _defineProperty({}, timeFieldName, {\n        gte: earliestMs,\n        lte: latestMs,\n        format: 'epoch_millis'\n      })\n    }];\n\n    if (query) {\n      mustCriteria.push(query);\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: index,\n      rest_total_hits_as_int: true,\n      size: 0,\n      body: {\n        query: {\n          bool: {\n            must: mustCriteria\n          }\n        },\n        _source: {\n          excludes: []\n        },\n        aggs: {\n          eventRate: {\n            date_histogram: {\n              field: timeFieldName,\n              interval: interval,\n              min_doc_count: 0,\n              extended_bounds: {\n                min: earliestMs,\n                max: latestMs\n              }\n            }\n          }\n        }\n      }\n    }).then(function (resp) {\n      var dataByTimeBucket = _lodash2.default.get(resp, ['aggregations', 'eventRate', 'buckets'], []);\n      _lodash2.default.each(dataByTimeBucket, function (dataForTime) {\n        var time = dataForTime.key;\n        obj.results[time] = dataForTime.doc_count;\n      });\n      obj.total = resp.hits.total;\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Queries Elasticsearch to obtain event distribution i.e. the count\n// of entities over time.\n// index can be a String, or String[], of index names to search.\n// Extra query object can be supplied, or pass null if no additional query.\n// Returned response contains a results property, which is an object\n// of document counts against time (epoch millis).\nvar SAMPLER_TOP_TERMS_SHARD_SIZE = 20000;\nvar ENTITY_AGGREGATION_SIZE = 10;\nvar AGGREGATION_MIN_DOC_COUNT = 1;\nvar CARDINALITY_PRECISION_THRESHOLD = 100;\nfunction getEventDistributionData(index, types, splitField) {\n  var filterField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var query = arguments[4];\n  var metricFunction = arguments[5];\n  var // ES aggregation name\n  metricFieldName = arguments[6];\n  var timeFieldName = arguments[7];\n  var earliestMs = arguments[8];\n  var latestMs = arguments[9];\n  var interval = arguments[10];\n\n  return new Promise(function (resolve, reject) {\n    if (splitField === undefined) {\n      return resolve([]);\n    }\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Add criteria for the types, time range, entity fields,\n    // plus any additional supplied query.\n    var mustCriteria = [];\n\n    if (types && types.length) {\n      mustCriteria.push({ terms: { _type: types } });\n    }\n\n    mustCriteria.push({\n      range: _defineProperty({}, timeFieldName, {\n        gte: earliestMs,\n        lte: latestMs,\n        format: 'epoch_millis'\n      })\n    });\n\n    if (query) {\n      mustCriteria.push(query);\n    }\n\n    if (filterField !== null) {\n      mustCriteria.push({\n        term: _defineProperty({}, filterField.fieldName, filterField.fieldValue)\n      });\n    }\n\n    var body = {\n      query: {\n        // using function_score and random_score to get a random sample of documents.\n        // otherwise all documents would have the same score and the sampler aggregation\n        // would pick the first N documents instead of a random set.\n        function_score: {\n          query: {\n            bool: {\n              must: mustCriteria\n            }\n          },\n          functions: [{\n            random_score: {\n              // static seed to get same randomized results on every request\n              seed: 10,\n              field: '_seq_no'\n            }\n          }]\n        }\n      },\n      size: 0,\n      _source: {\n        excludes: []\n      },\n      aggs: {\n        sample: {\n          sampler: {\n            shard_size: SAMPLER_TOP_TERMS_SHARD_SIZE\n          },\n          aggs: {\n            byTime: {\n              date_histogram: {\n                field: timeFieldName,\n                interval: interval,\n                min_doc_count: AGGREGATION_MIN_DOC_COUNT\n              },\n              aggs: {\n                entities: {\n                  terms: {\n                    field: splitField.fieldName,\n                    size: ENTITY_AGGREGATION_SIZE,\n                    min_doc_count: AGGREGATION_MIN_DOC_COUNT\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n\n    if (metricFieldName !== undefined && metricFieldName !== '') {\n      body.aggs.sample.aggs.byTime.aggs.entities.aggs = {};\n\n      var metricAgg = _defineProperty({}, metricFunction, {\n        field: metricFieldName\n      });\n\n      if (metricFunction === 'percentiles') {\n        metricAgg[metricFunction].percents = [_job_utils.ML_MEDIAN_PERCENTS];\n      }\n\n      if (metricFunction === 'cardinality') {\n        metricAgg[metricFunction].precision_threshold = CARDINALITY_PRECISION_THRESHOLD;\n      }\n      body.aggs.sample.aggs.byTime.aggs.entities.aggs.metric = metricAgg;\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: index,\n      body: body,\n      rest_total_hits_as_int: true\n    }).then(function (resp) {\n      // Because of the sampling, results of metricFunctions which use sum or count\n      // can be significantly skewed. Taking into account totalHits we calculate a\n      // a factor to normalize results for these metricFunctions.\n      var totalHits = _lodash2.default.get(resp, ['hits', 'total'], 0);\n      var successfulShards = _lodash2.default.get(resp, ['_shards', 'successful'], 0);\n\n      var normalizeFactor = 1;\n      if (totalHits > successfulShards * SAMPLER_TOP_TERMS_SHARD_SIZE) {\n        normalizeFactor = totalHits / (successfulShards * SAMPLER_TOP_TERMS_SHARD_SIZE);\n      }\n\n      var dataByTime = _lodash2.default.get(resp, ['aggregations', 'sample', 'byTime', 'buckets'], []);\n      var data = dataByTime.reduce(function (d, dataForTime) {\n        var date = +dataForTime.key;\n        var entities = _lodash2.default.get(dataForTime, ['entities', 'buckets'], []);\n        entities.forEach(function (entity) {\n          var value = metricFunction === 'count' ? entity.doc_count : entity.metric.value;\n\n          if (metricFunction === 'count' || metricFunction === 'cardinality' || metricFunction === 'sum') {\n            value = value * normalizeFactor;\n          }\n\n          d.push({\n            date: date,\n            entity: entity.key,\n            value: value\n          });\n        });\n        return d;\n      }, []);\n      resolve(data);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\nfunction getModelPlotOutput(jobId, detectorIndex, criteriaFields, earliestMs, latestMs, interval, aggType) {\n  return new Promise(function (resolve, reject) {\n    var obj = {\n      success: true,\n      results: {}\n    };\n\n    // if an aggType object has been passed in, use it.\n    // otherwise default to min and max aggs for the upper and lower bounds\n    var modelAggs = aggType === undefined ? { max: 'max', min: 'min' } : {\n      max: aggType.max,\n      min: aggType.min\n    };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Add criteria for the job ID and time range.\n    var mustCriteria = [{\n      term: { job_id: jobId }\n    }, {\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }];\n\n    // Add in term queries for each of the specified criteria.\n    _lodash2.default.each(criteriaFields, function (criteria) {\n      mustCriteria.push({\n        term: _defineProperty({}, criteria.fieldName, criteria.fieldValue)\n      });\n    });\n\n    // Add criteria for the detector index. Results from jobs created before 6.1 will not\n    // contain a detector_index field, so use a should criteria with a 'not exists' check.\n    var shouldCriteria = [{\n      term: { detector_index: detectorIndex }\n    }, {\n      bool: {\n        must_not: [{\n          exists: { field: 'detector_index' }\n        }]\n      }\n    }];\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: 0,\n      body: {\n        query: {\n          bool: {\n            filter: [{\n              query_string: {\n                query: 'result_type:model_plot',\n                analyze_wildcard: true\n              }\n            }, {\n              bool: {\n                must: mustCriteria,\n                should: shouldCriteria,\n                minimum_should_match: 1\n              }\n            }]\n          }\n        },\n        aggs: {\n          times: {\n            date_histogram: {\n              field: 'timestamp',\n              interval: interval,\n              min_doc_count: 0\n            },\n            aggs: {\n              actual: {\n                avg: {\n                  field: 'actual'\n                }\n              },\n              modelUpper: _defineProperty({}, modelAggs.max, {\n                field: 'model_upper'\n              }),\n              modelLower: _defineProperty({}, modelAggs.min, {\n                field: 'model_lower'\n              })\n            }\n          }\n        }\n      }\n    }).then(function (resp) {\n      var aggregationsByTime = _lodash2.default.get(resp, ['aggregations', 'times', 'buckets'], []);\n      _lodash2.default.each(aggregationsByTime, function (dataForTime) {\n        var time = dataForTime.key;\n        var modelUpper = _lodash2.default.get(dataForTime, ['modelUpper', 'value']);\n        var modelLower = _lodash2.default.get(dataForTime, ['modelLower', 'value']);\n        var actual = _lodash2.default.get(dataForTime, ['actual', 'value']);\n\n        if (modelUpper === undefined || isFinite(modelUpper) === false) {\n          modelUpper = null;\n        }\n        if (modelLower === undefined || isFinite(modelLower) === false) {\n          modelLower = null;\n        }\n\n        obj.results[time] = {\n          actual: actual,\n          modelUpper: modelUpper,\n          modelLower: modelLower\n        };\n      });\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Queries Elasticsearch to obtain the max record score over time for the specified job,\n// criteria, time range, and aggregation interval.\n// criteriaFields parameter must be an array, with each object in the array having 'fieldName'\n// 'fieldValue' properties.\nfunction getRecordMaxScoreByTime(jobId, criteriaFields, earliestMs, latestMs, interval) {\n  return new Promise(function (resolve, reject) {\n    var obj = {\n      success: true,\n      results: {}\n    };\n\n    // Build the criteria to use in the bool filter part of the request.\n    var mustCriteria = [{\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }, { term: { job_id: jobId } }];\n    var shouldCriteria = [];\n\n    _lodash2.default.each(criteriaFields, function (criteria) {\n      if (criteria.fieldValue.length !== 0) {\n        mustCriteria.push({\n          term: _defineProperty({}, criteria.fieldName, criteria.fieldValue)\n        });\n      } else {\n        // Add special handling for blank entity field values, checking for either\n        // an empty string or the field not existing.\n        var emptyFieldCondition = {\n          bool: {\n            must: [{\n              term: {}\n            }]\n          }\n        };\n        emptyFieldCondition.bool.must[0].term[criteria.fieldName] = '';\n        shouldCriteria.push(emptyFieldCondition);\n        shouldCriteria.push({\n          bool: {\n            must_not: [{\n              exists: { field: criteria.fieldName }\n            }]\n          }\n        });\n      }\n    });\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: 0,\n      body: {\n        query: {\n          bool: {\n            filter: [{\n              query_string: {\n                query: 'result_type:record',\n                analyze_wildcard: true\n              }\n            }, {\n              bool: {\n                must: mustCriteria\n              }\n            }]\n          }\n        },\n        aggs: {\n          times: {\n            date_histogram: {\n              field: 'timestamp',\n              interval: interval,\n              min_doc_count: 1\n            },\n            aggs: {\n              recordScore: {\n                max: {\n                  field: 'record_score'\n                }\n              }\n            }\n          }\n        }\n      }\n    }).then(function (resp) {\n      var aggregationsByTime = _lodash2.default.get(resp, ['aggregations', 'times', 'buckets'], []);\n      _lodash2.default.each(aggregationsByTime, function (dataForTime) {\n        var time = dataForTime.key;\n        obj.results[time] = {\n          score: _lodash2.default.get(dataForTime, ['recordScore', 'value'])\n        };\n      });\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\nvar mlResultsService = exports.mlResultsService = {\n  getScoresByBucket: getScoresByBucket,\n  getScheduledEventsByBucket: getScheduledEventsByBucket,\n  getTopInfluencers: getTopInfluencers,\n  getTopInfluencerValues: getTopInfluencerValues,\n  getOverallBucketScores: getOverallBucketScores,\n  getInfluencerValueMaxScoreByTime: getInfluencerValueMaxScoreByTime,\n  getRecordInfluencers: getRecordInfluencers,\n  getRecordsForInfluencer: getRecordsForInfluencer,\n  getRecordsForDetector: getRecordsForDetector,\n  getRecords: getRecords,\n  getRecordsForCriteria: getRecordsForCriteria,\n  getMetricData: getMetricData,\n  getEventRateData: getEventRateData,\n  getEventDistributionData: getEventDistributionData,\n  getModelPlotOutput: getModelPlotOutput,\n  getRecordMaxScoreByTime: getRecordMaxScoreByTime\n};",null]}