{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/shared/layers/sources/es_geo_grid_source/convert_to_geojson.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/shared/layers/sources/es_geo_grid_source/convert_to_geojson.js","mtime":1567631712019},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nexports.convertToGeoJson = convertToGeoJson;\n\nvar _decode_geo_hash = require('ui/utils/decode_geo_hash');\n\nvar _grid_dimensions = require('ui/vis/map/grid_dimensions');\n\n/*\n * Fork of ui/public/vis/map/convert_to_geojson.js that supports multiple metrics\n */\nfunction convertToGeoJson(tabifiedResponse) {\n\n  var features = void 0;\n  var min = Infinity;\n  var max = -Infinity;\n  var geoAgg = void 0;\n\n  if (tabifiedResponse && tabifiedResponse.rows) {\n\n    var table = tabifiedResponse;\n    var geohashColumn = table.columns.find(function (column) {\n      return column.aggConfig.type.dslName === 'geohash_grid';\n    });\n\n    if (!geohashColumn) {\n      features = [];\n    } else {\n\n      geoAgg = geohashColumn.aggConfig;\n\n      var metricColumns = table.columns.filter(function (column) {\n        return column.aggConfig.type.type === 'metrics' && column.aggConfig.type.dslName !== 'geo_centroid';\n      });\n      var geocentroidColumn = table.columns.find(function (column) {\n        return column.aggConfig.type.dslName === 'geo_centroid';\n      });\n\n      features = table.rows.map(function (row) {\n\n        var geohash = row[geohashColumn.id];\n        if (!geohash) return false;\n        var geohashLocation = (0, _decode_geo_hash.decodeGeoHash)(geohash);\n\n        var pointCoordinates = void 0;\n        if (geocentroidColumn) {\n          var location = row[geocentroidColumn.id];\n          pointCoordinates = [location.lon, location.lat];\n        } else {\n          pointCoordinates = [geohashLocation.longitude[2], geohashLocation.latitude[2]];\n        }\n\n        var rectangle = [[geohashLocation.latitude[0], geohashLocation.longitude[0]], [geohashLocation.latitude[0], geohashLocation.longitude[1]], [geohashLocation.latitude[1], geohashLocation.longitude[1]], [geohashLocation.latitude[1], geohashLocation.longitude[0]]];\n\n        var centerLatLng = [geohashLocation.latitude[2], geohashLocation.longitude[2]];\n\n        if (geoAgg.params.useGeocentroid) {\n          // see https://github.com/elastic/elasticsearch/issues/24694 for why clampGrid is used\n          pointCoordinates[0] = clampGrid(pointCoordinates[0], geohashLocation.longitude[0], geohashLocation.longitude[1]);\n          pointCoordinates[1] = clampGrid(pointCoordinates[1], geohashLocation.latitude[0], geohashLocation.latitude[1]);\n        }\n\n        var metrics = {};\n        metricColumns.forEach(function (metricColumn) {\n          metrics[metricColumn.aggConfig.id] = row[metricColumn.id];\n        });\n        //const value = row[metricColumn.id];\n        //min = Math.min(min, value);\n        //max = Math.max(max, value);\n\n        return {\n          type: 'Feature',\n          geometry: {\n            type: 'Point',\n            coordinates: pointCoordinates\n          },\n          properties: _extends({\n            geohash: geohash,\n            geohash_meta: {\n              center: centerLatLng,\n              rectangle: rectangle\n            }\n          }, metrics)\n        };\n      }).filter(function (row) {\n        return row;\n      });\n    }\n  } else {\n    features = [];\n  }\n\n  var featureCollection = {\n    type: 'FeatureCollection',\n    features: features\n  };\n\n  return {\n    featureCollection: featureCollection,\n    meta: {\n      min: min,\n      max: max,\n      geohashGridDimensionsAtEquator: geoAgg && (0, _grid_dimensions.gridDimensions)(geoAgg.params.precision)\n    }\n  };\n}\n\nfunction clampGrid(val, min, max) {\n  if (val > max) val = max;else if (val < min) val = min;\n  return val;\n}",null]}