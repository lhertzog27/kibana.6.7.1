{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/components/workpad_page/index.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/components/workpad_page/index.js","mtime":1567631711929},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WorkpadPage = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _reactRedux = require('react-redux');\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _recompose = require('recompose');\n\nvar _aeroelastic_kibana = require('../../lib/aeroelastic_kibana');\n\nvar _elements = require('../../state/actions/elements');\n\nvar _app = require('../../state/selectors/app');\n\nvar _workpad = require('../../state/selectors/workpad');\n\nvar _functional = require('../../lib/aeroelastic/functional');\n\nvar _event_handlers = require('./event_handlers');\n\nvar _workpad_page = require('./workpad_page');\n\nvar _transient = require('./../../state/actions/transient');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /*\n                                                                                                                                                                                                     * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                     * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                     * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                     */\n\nvar mapStateToProps = function mapStateToProps(state, ownProps) {\n  return {\n    isEditable: !(0, _app.getFullscreen)(state) && (0, _workpad.isWriteable)(state) && (0, _app.canUserWrite)(state),\n    elements: (0, _workpad.getNodes)(state, ownProps.page.id)\n  };\n};\n\nvar mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    insertNodes: function insertNodes(pageId) {\n      return function (selectedElements) {\n        return dispatch((0, _elements.insertNodes)(selectedElements, pageId));\n      };\n    },\n    removeElements: function removeElements(pageId) {\n      return function (elementIds) {\n        return dispatch((0, _elements.removeElements)(elementIds, pageId));\n      };\n    },\n    selectElement: function selectElement(selectedElement) {\n      return dispatch((0, _transient.selectElement)(selectedElement));\n    },\n    // TODO: Abstract this out. This is the same code as in sidebar/index.js\n    elementLayer: function elementLayer(pageId, selectedElement, movement) {\n      dispatch((0, _elements.elementLayer)({\n        pageId: pageId,\n        elementId: selectedElement.id,\n        movement: movement\n      }));\n    }\n  };\n};\n\nvar getRootElementId = function getRootElementId(lookup, id) {\n  if (!lookup.has(id)) {\n    return null;\n  }\n\n  var element = lookup.get(id);\n  return element.parent && element.parent.subtype !== 'adHocGroup' ? getRootElementId(lookup, element.parent) : element.id;\n};\n\nvar WorkpadPage = exports.WorkpadPage = (0, _recompose.compose)((0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps), (0, _recompose.withProps)(function (_ref) {\n  var isSelected = _ref.isSelected,\n      animation = _ref.animation;\n\n  function getClassName() {\n    if (animation) {\n      return animation.name;\n    }\n    return isSelected ? 'canvasPage--isActive' : 'canvasPage--isInactive';\n  }\n\n  function getAnimationStyle() {\n    if (!animation) {\n      return {};\n    }\n    return {\n      animationDirection: animation.direction,\n      // TODO: Make this configurable\n      animationDuration: '1s'\n    };\n  }\n\n  return {\n    className: getClassName(),\n    animationStyle: getAnimationStyle()\n  };\n}), (0, _recompose.withState)('updateCount', 'setUpdateCount', 0), // TODO: remove this, see setUpdateCount below\n(0, _recompose.withProps)(function (_ref2) {\n  var updateCount = _ref2.updateCount,\n      setUpdateCount = _ref2.setUpdateCount,\n      page = _ref2.page,\n      pageElements = _ref2.elements;\n\n  var _aeroelastic$getStore = _aeroelastic_kibana.aeroelastic.getStore(page.id).currentScene,\n      shapes = _aeroelastic$getStore.shapes,\n      _aeroelastic$getStore2 = _aeroelastic$getStore.selectedPrimaryShapes,\n      selectedPrimaryShapes = _aeroelastic$getStore2 === undefined ? [] : _aeroelastic$getStore2,\n      cursor = _aeroelastic$getStore.cursor;\n\n  var elementLookup = new Map(pageElements.map(function (element) {\n    return [element.id, element];\n  }));\n  var recurseGroupTree = function recurseGroupTree(shapeId) {\n    return [shapeId].concat(_toConsumableArray((0, _functional.flatten)(shapes.filter(function (s) {\n      return s.parent === shapeId && s.type !== 'annotation';\n    }).map(function (s) {\n      return s.id;\n    }).map(recurseGroupTree))));\n  };\n\n  var selectedPrimaryShapeObjects = selectedPrimaryShapes.map(function (id) {\n    return shapes.find(function (s) {\n      return s.id === id;\n    });\n  }).filter(function (shape) {\n    return shape;\n  });\n\n  var selectedPersistentPrimaryShapes = (0, _functional.flatten)(selectedPrimaryShapeObjects.map(function (shape) {\n    return shape.subtype === 'adHocGroup' ? shapes.filter(function (s) {\n      return s.parent === shape.id && s.type !== 'annotation';\n    }).map(function (s) {\n      return s.id;\n    }) : [shape.id];\n  }));\n  var selectedElementIds = (0, _functional.flatten)(selectedPersistentPrimaryShapes.map(recurseGroupTree));\n  var selectedElements = [];\n  var elements = shapes.map(function (shape) {\n    var element = null;\n    if (elementLookup.has(shape.id)) {\n      element = elementLookup.get(shape.id);\n      if (selectedElementIds.indexOf(shape.id) > -1) {\n        selectedElements.push(_extends({}, element, { id: shape.id }));\n      }\n    }\n    // instead of just combining `element` with `shape`, we make property transfer explicit\n    return element ? _extends({}, shape, { filter: element.filter, expression: element.expression }) : shape;\n  });\n  return {\n    elements: elements,\n    cursor: cursor,\n    selectedElementIds: selectedElementIds,\n    selectedElements: selectedElements,\n    selectedPrimaryShapes: selectedPrimaryShapes,\n    commit: function commit() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _aeroelastic_kibana.aeroelastic.commit.apply(_aeroelastic_kibana.aeroelastic, [page.id].concat(args));\n      // TODO: remove this, it's a hack to force react to rerender\n      setUpdateCount(updateCount + 1);\n    }\n  };\n}), // Updates states; needs to have both local and global\n(0, _recompose.withHandlers)({\n  groupElements: function groupElements(_ref3) {\n    var commit = _ref3.commit;\n    return function () {\n      return commit('actionEvent', {\n        event: 'group'\n      });\n    };\n  },\n  ungroupElements: function ungroupElements(_ref4) {\n    var commit = _ref4.commit;\n    return function () {\n      return commit('actionEvent', {\n        event: 'ungroup'\n      });\n    };\n  }\n}), (0, _recompose.withHandlers)(_event_handlers.eventHandlers) // Captures user intent, needs to have reconciled state\n)(_workpad_page.WorkpadPage);\n\nWorkpadPage.propTypes = {\n  page: _propTypes2.default.shape({\n    id: _propTypes2.default.string.isRequired\n  }).isRequired\n};",null]}