{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/store/map.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/store/map.js","mtime":1567631712022},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nexports.map = map;\n\nvar _store_actions = require('../actions/store_actions');\n\nvar _util = require('./util');\n\nvar _constants = require('../../common/constants');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar getLayerIndex = function getLayerIndex(list, layerId) {\n  return list.findIndex(function (_ref) {\n    var id = _ref.id;\n    return layerId === id;\n  });\n};\n\nvar updateLayerInList = function updateLayerInList(state, layerId, attribute, newValue) {\n  if (!layerId) {\n    return state;\n  }\n  var layerList = state.layerList;\n\n  var layerIdx = getLayerIndex(layerList, layerId);\n  var updatedLayer = _extends({}, layerList[layerIdx], _defineProperty({}, attribute, newValue || newValue === '' || newValue === 0 ? newValue : !layerList[layerIdx][attribute]));\n  var updatedList = [].concat(_toConsumableArray(layerList.slice(0, layerIdx)), [updatedLayer], _toConsumableArray(layerList.slice(layerIdx + 1)));\n  return _extends({}, state, { layerList: updatedList });\n};\n\nvar updateLayerSourceDescriptorProp = function updateLayerSourceDescriptorProp(state, layerId, propName, value) {\n  var layerList = state.layerList;\n\n  var layerIdx = getLayerIndex(layerList, layerId);\n  var updatedLayer = _extends({}, layerList[layerIdx], {\n    sourceDescriptor: _extends({}, layerList[layerIdx].sourceDescriptor, _defineProperty({}, propName, value))\n  });\n  var updatedList = [].concat(_toConsumableArray(layerList.slice(0, layerIdx)), [updatedLayer], _toConsumableArray(layerList.slice(layerIdx + 1)));\n  return _extends({}, state, { layerList: updatedList });\n};\n\nvar INITIAL_STATE = {\n  ready: false,\n  goto: null,\n  mapState: {\n    zoom: 4,\n    center: {\n      lon: -100.41,\n      lat: 32.82\n    },\n    extent: null,\n    mouseCoordinates: null,\n    timeFilters: null,\n    query: null,\n    refreshConfig: null,\n    refreshTimerLastTriggeredAt: null\n  },\n  selectedLayerId: null,\n  __transientLayerId: null,\n  layerList: [],\n  waitingForMapReadyLayerList: []\n};\n\nfunction map() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE;\n  var action = arguments[1];\n\n  switch (action.type) {\n    case _store_actions.REMOVE_TRACKED_LAYER_STATE:\n      return removeTrackedLayerState(state, action.layerId);\n    case _store_actions.TRACK_CURRENT_LAYER_STATE:\n      return trackCurrentLayerState(state, action.layerId);\n    case _store_actions.ROLLBACK_TO_TRACKED_LAYER_STATE:\n      return rollbackTrackedLayerState(state, action.layerId);\n    case _store_actions.SET_MOUSE_COORDINATES:\n      return _extends({}, state, {\n        mapState: _extends({}, state.mapState, {\n          mouseCoordinates: {\n            lat: action.lat,\n            lon: action.lon\n          }\n        })\n      });\n    case _store_actions.CLEAR_MOUSE_COORDINATES:\n      return _extends({}, state, {\n        mapState: _extends({}, state.mapState, {\n          mouseCoordinates: null\n        })\n      });\n    case _store_actions.SET_GOTO:\n      return _extends({}, state, {\n        goto: {\n          center: action.center,\n          bounds: action.bounds\n        }\n      });\n    case _store_actions.CLEAR_GOTO:\n      return _extends({}, state, {\n        goto: null\n      });\n    case _store_actions.SET_LAYER_ERROR_STATUS:\n      var layerList = state.layerList;\n\n      var layerIdx = getLayerIndex(layerList, action.layerId);\n      if (layerIdx === -1) {\n        return state;\n      }\n\n      return _extends({}, state, {\n        layerList: [].concat(_toConsumableArray(layerList.slice(0, layerIdx)), [_extends({}, layerList[layerIdx], {\n          __isInErrorState: action.isInErrorState,\n          __errorMessage: action.errorMessage\n        })], _toConsumableArray(layerList.slice(layerIdx + 1)))\n      });\n    case _store_actions.UPDATE_SOURCE_DATA_REQUEST:\n      return updateSourceDataRequest(state, action);\n    case _store_actions.LAYER_DATA_LOAD_STARTED:\n      return updateWithDataRequest(state, action);\n    case _store_actions.LAYER_DATA_LOAD_ERROR:\n      return resetDataRequest(state, action);\n    case _store_actions.LAYER_DATA_LOAD_ENDED:\n      return updateWithDataResponse(state, action);\n    case _store_actions.TOUCH_LAYER:\n      //action to enforce a reflow of the styles\n      var layer = state.layerList.find(function (layer) {\n        return layer.id === action.layerId;\n      });\n      if (!layer) {\n        return state;\n      }\n      var indexOfLayer = state.layerList.indexOf(layer);\n      var newLayer = _extends({}, layer);\n      var newLayerList = [].concat(_toConsumableArray(state.layerList));\n      newLayerList[indexOfLayer] = newLayer;\n      return _extends({}, state, { layerList: newLayerList });\n    case _store_actions.MAP_READY:\n      return _extends({}, state, { ready: true });\n    case _store_actions.MAP_DESTROYED:\n      return _extends({}, state, { ready: false });\n    case _store_actions.MAP_EXTENT_CHANGED:\n      var newMapState = {\n        center: action.mapState.center,\n        zoom: action.mapState.zoom,\n        extent: action.mapState.extent,\n        buffer: action.mapState.buffer\n      };\n      return _extends({}, state, { mapState: _extends({}, state.mapState, newMapState) });\n    case _store_actions.SET_QUERY:\n      var query = action.query,\n          timeFilters = action.timeFilters;\n\n      return _extends({}, state, {\n        mapState: _extends({}, state.mapState, {\n          query: query,\n          timeFilters: timeFilters\n        })\n      });\n    case _store_actions.SET_REFRESH_CONFIG:\n      var isPaused = action.isPaused,\n          interval = action.interval;\n\n      return _extends({}, state, {\n        mapState: _extends({}, state.mapState, {\n          refreshConfig: {\n            isPaused: isPaused,\n            interval: interval\n          }\n        })\n      });\n    case _store_actions.TRIGGER_REFRESH_TIMER:\n      return _extends({}, state, {\n        mapState: _extends({}, state.mapState, {\n          refreshTimerLastTriggeredAt: new Date().toISOString()\n        })\n      });\n    case _store_actions.SET_SELECTED_LAYER:\n      var selectedMatch = state.layerList.find(function (layer) {\n        return layer.id === action.selectedLayerId;\n      });\n      return _extends({}, state, { selectedLayerId: selectedMatch ? action.selectedLayerId : null });\n    case _store_actions.SET_TRANSIENT_LAYER:\n      var transientMatch = state.layerList.find(function (layer) {\n        return layer.id === action.transientLayerId;\n      });\n      return _extends({}, state, { __transientLayerId: transientMatch ? action.transientLayerId : null });\n    case _store_actions.UPDATE_LAYER_ORDER:\n      return _extends({}, state, { layerList: action.newLayerOrder.map(function (layerNumber) {\n          return state.layerList[layerNumber];\n        }) });\n    case _store_actions.UPDATE_LAYER_PROP:\n      return updateLayerInList(state, action.id, action.propName, action.newValue);\n    case _store_actions.UPDATE_SOURCE_PROP:\n      return updateLayerSourceDescriptorProp(state, action.layerId, action.propName, action.value);\n    case _store_actions.SET_JOINS:\n      var layerDescriptor = state.layerList.find(function (descriptor) {\n        return descriptor.id === action.layer.getId();\n      });\n      if (layerDescriptor) {\n        var newLayerDescriptor = _extends({}, layerDescriptor, { joins: action.joins.slice() });\n        var index = state.layerList.findIndex(function (descriptor) {\n          return descriptor.id === action.layer.getId();\n        });\n        var _newLayerList = state.layerList.slice();\n        _newLayerList[index] = newLayerDescriptor;\n        return _extends({}, state, { layerList: _newLayerList });\n      }\n      return state;\n    case _store_actions.ADD_LAYER:\n      return _extends({}, state, {\n        layerList: [].concat(_toConsumableArray(state.layerList), [action.layer])\n      });\n    case _store_actions.REMOVE_LAYER:\n      return _extends({}, state, { layerList: [].concat(_toConsumableArray(state.layerList.filter(function (_ref2) {\n          var id = _ref2.id;\n          return id !== action.id;\n        })))\n      });\n    case _store_actions.ADD_WAITING_FOR_MAP_READY_LAYER:\n      return _extends({}, state, {\n        waitingForMapReadyLayerList: [].concat(_toConsumableArray(state.waitingForMapReadyLayerList), [action.layer])\n      });\n    case _store_actions.CLEAR_WAITING_FOR_MAP_READY_LAYER_LIST:\n      return _extends({}, state, {\n        waitingForMapReadyLayerList: []\n      });\n    case _store_actions.TOGGLE_LAYER_VISIBLE:\n      return updateLayerInList(state, action.layerId, 'visible');\n    case _store_actions.UPDATE_LAYER_STYLE:\n      var styleLayerId = action.layerId;\n      return updateLayerInList(state, styleLayerId, 'style', _extends({}, action.style));\n    default:\n      return state;\n  }\n}\n\nfunction findDataRequest(layerDescriptor, dataRequestAction) {\n\n  if (!layerDescriptor.__dataRequests) {\n    return;\n  }\n\n  return layerDescriptor.__dataRequests.find(function (dataRequest) {\n    return dataRequest.dataId === dataRequestAction.dataId;\n  });\n}\n\nfunction updateWithDataRequest(state, action) {\n  var dataRequest = getValidDataRequest(state, action, false);\n  var layerRequestingData = findLayerById(state, action.layerId);\n\n  if (!dataRequest) {\n    dataRequest = {\n      dataId: action.dataId\n    };\n    layerRequestingData.__dataRequests = [].concat(_toConsumableArray(layerRequestingData.__dataRequests ? layerRequestingData.__dataRequests : []), [dataRequest]);\n  }\n  dataRequest.dataMetaAtStart = action.meta;\n  dataRequest.dataRequestToken = action.requestToken;\n  var layerList = [].concat(_toConsumableArray(state.layerList));\n  return _extends({}, state, { layerList: layerList });\n}\n\nfunction updateSourceDataRequest(state, action) {\n  var layerDescriptor = findLayerById(state, action.layerId);\n  if (!layerDescriptor) {\n    return state;\n  }\n  var dataRequest = layerDescriptor.__dataRequests.find(function (dataRequest) {\n    return dataRequest.dataId === _constants.SOURCE_DATA_ID_ORIGIN;\n  });\n  if (!dataRequest) {\n    return state;\n  }\n\n  dataRequest.data = action.newData;\n  return resetDataRequest(state, action, dataRequest);\n}\n\nfunction updateWithDataResponse(state, action) {\n  var dataRequest = getValidDataRequest(state, action);\n  if (!dataRequest) {\n    return state;\n  }\n\n  dataRequest.data = action.data;\n  dataRequest.dataMeta = _extends({}, dataRequest.dataMetaAtStart, action.meta);\n  dataRequest.dataMetaAtStart = null;\n  return resetDataRequest(state, action, dataRequest);\n}\n\nfunction resetDataRequest(state, action, request) {\n  var dataRequest = request || getValidDataRequest(state, action);\n  if (!dataRequest) {\n    return state;\n  }\n\n  dataRequest.dataRequestToken = null;\n  dataRequest.dataId = action.dataId;\n  var layerList = [].concat(_toConsumableArray(state.layerList));\n  return _extends({}, state, { layerList: layerList });\n}\n\nfunction getValidDataRequest(state, action) {\n  var checkRequestToken = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  var layer = findLayerById(state, action.layerId);\n  if (!layer) {\n    return;\n  }\n\n  var dataRequest = findDataRequest(layer, action);\n  if (!dataRequest) {\n    return;\n  }\n\n  if (checkRequestToken && dataRequest.dataRequestToken && dataRequest.dataRequestToken !== action.requestToken) {\n    // ignore responses to outdated requests\n    return;\n  }\n  return dataRequest;\n}\n\nfunction findLayerById(state, id) {\n  return state.layerList.find(function (layer) {\n    return layer.id === id;\n  });\n}\n\nfunction trackCurrentLayerState(state, layerId) {\n  var layer = findLayerById(state, layerId);\n  var layerCopy = (0, _util.copyPersistentState)(layer);\n  return updateLayerInList(state, layerId, _util.TRACKED_LAYER_DESCRIPTOR, layerCopy);\n}\n\nfunction removeTrackedLayerState(state, layerId) {\n  var layer = findLayerById(state, layerId);\n  if (!layer) {\n    return state;\n  }\n\n  var copyLayer = _extends({}, layer);\n  delete copyLayer[_util.TRACKED_LAYER_DESCRIPTOR];\n\n  return _extends({}, state, {\n    layerList: replaceInLayerList(state.layerList, layerId, copyLayer)\n  });\n}\n\nfunction rollbackTrackedLayerState(state, layerId) {\n  var layer = findLayerById(state, layerId);\n  if (!layer) {\n    return state;\n  }\n  var trackedLayerDescriptor = layer[_util.TRACKED_LAYER_DESCRIPTOR];\n\n  //this assumes that any nested temp-state in the layer-descriptor (e.g. of styles), is not relevant and can be recovered easily (e.g. this is not the case for __dataRequests)\n  //That assumption is true in the context of this app, but not generalizable.\n  //consider rewriting copyPersistentState to only strip the first level of temp state.\n  var rolledbackLayer = _extends({}, layer, trackedLayerDescriptor);\n  delete rolledbackLayer[_util.TRACKED_LAYER_DESCRIPTOR];\n\n  return _extends({}, state, {\n    layerList: replaceInLayerList(state.layerList, layerId, rolledbackLayer)\n  });\n}\n\nfunction replaceInLayerList(layerList, layerId, newLayerDescriptor) {\n  var layerIndex = getLayerIndex(layerList, layerId);\n  var newLayerList = [].concat(_toConsumableArray(layerList));\n  newLayerList[layerIndex] = newLayerDescriptor;\n  return newLayerList;\n}",null]}