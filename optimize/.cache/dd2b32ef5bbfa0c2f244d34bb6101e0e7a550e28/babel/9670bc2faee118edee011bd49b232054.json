{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/monitoring/public/components/logstash/pipeline_viewer/models/graph/index.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/monitoring/public/components/logstash/pipeline_viewer/models/graph/index.js","mtime":1567631712090},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Graph = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _vertex_factory = require('./vertex_factory');\n\nvar _edge_factory = require('./edge_factory');\n\nvar _queue_vertex = require('./queue_vertex');\n\nvar _plugin_vertex = require('./plugin_vertex');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Graph = exports.Graph = function () {\n  function Graph() {\n    _classCallCheck(this, Graph);\n\n    this.json = null;\n    this.verticesById = {};\n    this.edgesById = {};\n    this.edgesByFrom = {};\n    this.edgesByTo = {};\n  }\n\n  _createClass(Graph, [{\n    key: 'getVertexById',\n    value: function getVertexById(id) {\n      return this.verticesById[id];\n    }\n  }, {\n    key: 'getVertices',\n    value: function getVertices() {\n      // Its safe to cache vertices because vertices are never added or removed from the graph. This is because\n      // such changes also result in changing the hash of the pipeline, which ends up creating a new graph altogether.\n      if (this.vertexCache === undefined) {\n        this.vertexCache = Object.values(this.verticesById);\n      }\n      return this.vertexCache;\n    }\n  }, {\n    key: 'update',\n    value: function update(jsonRepresentation) {\n      var _this = this;\n\n      this.json = jsonRepresentation;\n\n      jsonRepresentation.vertices.forEach(function (vJson) {\n        var existingVertex = _this.verticesById[vJson.id];\n        if (existingVertex !== undefined) {\n          existingVertex.update(vJson);\n        } else {\n          var newVertex = (0, _vertex_factory.vertexFactory)(_this, vJson);\n          _this.verticesById[vJson.id] = newVertex;\n        }\n      });\n\n      jsonRepresentation.edges.forEach(function (eJson) {\n        var existingEdge = _this.edgesById[eJson.id];\n        if (existingEdge !== undefined) {\n          existingEdge.update(eJson);\n        } else {\n          var newEdge = (0, _edge_factory.edgeFactory)(_this, eJson);\n          _this.edgesById[eJson.id] = newEdge;\n          if (_this.edgesByFrom[newEdge.from.json.id] === undefined) {\n            _this.edgesByFrom[newEdge.from.json.id] = [];\n          }\n          _this.edgesByFrom[newEdge.from.json.id].push(newEdge);\n\n          if (_this.edgesByTo[newEdge.to.json.id] === undefined) {\n            _this.edgesByTo[newEdge.to.json.id] = [];\n          }\n          _this.edgesByTo[newEdge.to.json.id].push(newEdge);\n        }\n      });\n\n      this.annotateVerticesWithStages();\n    }\n  }, {\n    key: 'annotateVerticesWithStages',\n\n\n    /**\n     * Give each vertex a pipeline stage (input, filter, or output)\n     */\n    value: function annotateVerticesWithStages() {\n      // NOTE: order of the following statements is important. In particular,\n      // it is important to annotate output stage vertices BEFORE annotating\n      // filter stage vertices as the latter requires the former.\n      this.annotateInputStageVertices();\n      this.annotateOutputStageVertices();\n      this.annotateFilterStageVertices();\n    }\n\n    /**\n     * Annotate any input stage vertices as such\n     */\n\n  }, {\n    key: 'annotateInputStageVertices',\n    value: function annotateInputStageVertices() {\n      // A Queue vertex exists if and only if there are input stage vertices\n\n      // If there is no Queue vertex, there are no input stage vertices so we are done\n      if (!this.hasQueueVertex) {\n        return;\n      }\n\n      // At this point, we know there are input stage vertices. Further, they\n      // must be all the start vertices of the graph\n      this.startVertices.forEach(function (v) {\n        return v.pipelineStage = 'input';\n      });\n    }\n\n    /**\n     * Annotate any output stage vertices as such\n     */\n\n  }, {\n    key: 'annotateOutputStageVertices',\n    value: function annotateOutputStageVertices() {\n      // First, we perform a couple of simple short-circuiting checks.\n\n      // If there is only one end vertex in this pipeline graph and it is the queue\n      // vertex, then there are no output stage vertices so we are done here\n      if (this.endVertices.length === 1 && this.endVertices[0] instanceof _queue_vertex.QueueVertex) {\n        return;\n      }\n\n      // Now we can guarantee that the end vertices are plugin vertices, in either the\n      // filter or output stages of the pipeline. If they are filter plugin vertices, we\n      // are done here\n      if (this.endVertices.every(function (v) {\n        return v.pluginType === 'filter';\n      })) {\n        return;\n      }\n\n      // Now we can guarantee that the end vertices are output plugin vertices. Starting\n      // from these, we work our way backwards (via our parents) until one of our parents\n      // is either:\n      // - a filter plugin vertex (for pipelines with a filter stage), or\n      // - the queue vertex (for pipelines with an input stage but no filter stage), or\n      // - nothing (for pipelines with neither an input stage nor a filter stage)\n      // When we reach one of these cases, we annotate the current vertex and its descendants\n      // as output stage vertices\n      var pending = [].concat(_toConsumableArray(this.endVertices));\n      while (pending.length > 0) {\n        var currentVertex = pending.shift();\n        var parents = currentVertex.incomingVertices;\n\n        var isParentFilterPluginVertex = parents.some(function (p) {\n          return p instanceof _plugin_vertex.PluginVertex && p.pluginType === 'filter';\n        });\n        var isParentQueueVertex = parents.some(function (p) {\n          return p instanceof _queue_vertex.QueueVertex;\n        });\n        var isParentNothing = parents.length === 0;\n\n        var isParentOutputStageVertex = !(isParentFilterPluginVertex || isParentQueueVertex || isParentNothing);\n\n        if (isParentOutputStageVertex) {\n          pending.push.apply(pending, _toConsumableArray(parents));\n        } else {\n          currentVertex.pipelineStage = 'output';\n          var descendantVertices = currentVertex.descendants().vertices;\n          descendantVertices.forEach(function (v) {\n            return v.pipelineStage = 'output';\n          });\n        }\n      }\n    }\n\n    /**\n     * Annotate any filter stage vertices as such\n     * PRE-CONDITION: All other stage vertices have been annotated\n     */\n\n  }, {\n    key: 'annotateFilterStageVertices',\n    value: function annotateFilterStageVertices() {\n      var pending = [];\n      if (this.hasQueueVertex) {\n        pending.push.apply(pending, _toConsumableArray(this.queueVertex.outgoingVertices));\n      } else {\n        pending.push.apply(pending, _toConsumableArray(this.startVertices));\n      }\n\n      while (pending.length > 0) {\n        var currentVertex = pending.shift();\n        if (!currentVertex.pipelineStage) {\n          currentVertex.pipelineStage = 'filter';\n          pending.push.apply(pending, _toConsumableArray(currentVertex.outgoingVertices));\n        }\n      }\n    }\n  }, {\n    key: 'queueVertex',\n    get: function get() {\n      return this.getVertices().find(function (v) {\n        return v instanceof _queue_vertex.QueueVertex;\n      });\n    }\n  }, {\n    key: 'processorVertices',\n    get: function get() {\n      return this.getVertices().filter(function (v) {\n        return v.isProcessor;\n      });\n    }\n  }, {\n    key: 'edges',\n    get: function get() {\n      return Object.values(this.edgesById);\n    }\n  }, {\n    key: 'startVertices',\n    get: function get() {\n      return this.getVertices().filter(function (v) {\n        return v.incomingEdges.length === 0;\n      });\n    }\n  }, {\n    key: 'endVertices',\n    get: function get() {\n      return this.getVertices().filter(function (v) {\n        return v.outgoingEdges.length === 0;\n      });\n    }\n  }, {\n    key: 'hasQueueVertex',\n    get: function get() {\n      return !!this.queueVertex;\n    }\n  }]);\n\n  return Graph;\n}();",null]}