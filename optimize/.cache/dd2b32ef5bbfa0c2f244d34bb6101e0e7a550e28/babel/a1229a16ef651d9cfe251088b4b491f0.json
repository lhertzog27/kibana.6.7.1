{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/util/index_utils.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/util/index_utils.js","mtime":1567631712071},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.refreshIndexPatterns = undefined;\nexports.loadIndexPatterns = loadIndexPatterns;\nexports.getIndexPatterns = getIndexPatterns;\nexports.getIndexPatternNames = getIndexPatternNames;\nexports.getIndexPatternIdFromName = getIndexPatternIdFromName;\nexports.loadCurrentIndexPattern = loadCurrentIndexPattern;\nexports.getIndexPatternById = getIndexPatternById;\nexports.loadCurrentSavedSearch = loadCurrentSavedSearch;\nexports.getCurrentIndexPattern = getCurrentIndexPattern;\nexports.getCurrentSavedSearch = getCurrentSavedSearch;\nexports.timeBasedIndexCheck = timeBasedIndexCheck;\n\nvar _notify = require('ui/notify');\n\nvar _saved_objects = require('ui/saved_objects');\n\nvar _i18n = require('@kbn/i18n');\n\nvar indexPatternCache = []; /*\n                             * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                             * or more contributor license agreements. Licensed under the Elastic License;\n                             * you may not use this file except in compliance with the Elastic License.\n                             */\n\nvar fullIndexPatterns = [];\nvar currentIndexPattern = null;\nvar currentSavedSearch = null;\n\nvar refreshIndexPatterns = exports.refreshIndexPatterns = null;\n\nfunction loadIndexPatterns(Private, indexPatterns) {\n  fullIndexPatterns = indexPatterns;\n  var savedObjectsClient = Private(_saved_objects.SavedObjectsClientProvider);\n  return savedObjectsClient.find({\n    type: 'index-pattern',\n    fields: ['title', 'type'],\n    perPage: 10000\n  }).then(function (response) {\n    indexPatternCache = response.savedObjects;\n\n    if (refreshIndexPatterns === null) {\n      exports.refreshIndexPatterns = refreshIndexPatterns = function refreshIndexPatterns() {\n        return new Promise(function (resolve, reject) {\n          loadIndexPatterns(Private, indexPatterns).then(function (resp) {\n            resolve(resp);\n          }).catch(function (error) {\n            reject(error);\n          });\n        });\n      };\n    }\n\n    return indexPatternCache;\n  });\n}\n\nfunction getIndexPatterns() {\n  return indexPatternCache;\n}\n\nfunction getIndexPatternNames() {\n  return indexPatternCache.map(function (i) {\n    return i.attributes && i.attributes.title;\n  });\n}\n\nfunction getIndexPatternIdFromName(name) {\n  for (var j = 0; j < indexPatternCache.length; j++) {\n    if (indexPatternCache[j].get('title') === name) {\n      return indexPatternCache[j].id;\n    }\n  }\n  return name;\n}\n\nfunction loadCurrentIndexPattern(indexPatterns, $route) {\n  fullIndexPatterns = indexPatterns;\n  currentIndexPattern = fullIndexPatterns.get($route.current.params.index);\n  return currentIndexPattern;\n}\n\nfunction getIndexPatternById(id) {\n  return fullIndexPatterns.get(id);\n}\n\nfunction loadCurrentSavedSearch($route, savedSearches) {\n  currentSavedSearch = savedSearches.get($route.current.params.savedSearchId);\n  return currentSavedSearch;\n}\n\nfunction getCurrentIndexPattern() {\n  return currentIndexPattern;\n}\n\nfunction getCurrentSavedSearch() {\n  return currentSavedSearch;\n}\n\n// returns true if the index passed in is time based\n// an optional flag will trigger the display a notification at the top of the page\n// warning that the index is not time based\nfunction timeBasedIndexCheck(indexPattern) {\n  var showNotification = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (indexPattern.isTimeBased() === false) {\n    if (showNotification) {\n      _notify.toastNotifications.addWarning({\n        title: _i18n.i18n.translate('xpack.ml.indexPatternNotBasedOnTimeSeriesNotificationTitle', {\n          defaultMessage: 'The index pattern {indexPatternTitle} is not based on a time series',\n          values: { indexPatternTitle: indexPattern.title }\n        }),\n        text: _i18n.i18n.translate('xpack.ml.indexPatternNotBasedOnTimeSeriesNotificationDescription', {\n          defaultMessage: 'Anomaly detection only runs over time-based indices'\n        })\n      });\n    }\n    return false;\n  } else {\n    return true;\n  }\n}",null]}