{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/watcher/public/models/watch/base_watch.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/watcher/public/models/watch/base_watch.js","mtime":1567631712344},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseWatch = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _get_search_value = require('plugins/watcher/lib/get_search_value');\n\nvar _lodash = require('lodash');\n\nvar _action = require('../action');\n\nvar _watch_status = require('../watch_status');\n\nvar _watch_errors = require('../watch_errors');\n\nvar _create_action_id = require('./lib/create_action_id');\n\nvar _check_action_id_collision = require('./lib/check_action_id_collision');\n\nvar _i18n = require('@kbn/i18n');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BaseWatch = exports.BaseWatch = function () {\n  /**\n   * BaseWatch model constructor\n   *\n   * @param {object} props An object used to instantiate a watch instance\n   * @param {string} props.id Id of the watch\n   * @param {string} props.name Optional name for the watch\n   * @param {object} props.watch Watch definition\n   * @param {object} props.watchStatus WatchStatus definition\n   * @param {array} props.actions Action definitions\n   */\n  function BaseWatch() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, BaseWatch);\n\n    _initialiseProps.call(this);\n\n    this.id = (0, _lodash.get)(props, 'id');\n    this.type = (0, _lodash.get)(props, 'type');\n    this.isNew = (0, _lodash.get)(props, 'isNew', true);\n\n    this.name = (0, _lodash.get)(props, 'name', '');\n    this.isSystemWatch = Boolean((0, _lodash.get)(props, 'isSystemWatch'));\n    this.watchStatus = _watch_status.WatchStatus.fromUpstreamJson((0, _lodash.get)(props, 'watchStatus'));\n    this.watchErrors = _watch_errors.WatchErrors.fromUpstreamJson((0, _lodash.get)(props, 'watchErrors'));\n\n    var actions = (0, _lodash.get)(props, 'actions', []);\n    this.actions = actions.map(_action.Action.fromUpstreamJson);\n  }\n\n  _createClass(BaseWatch, [{\n    key: 'validate',\n\n\n    /**\n     * Client validation of the Watch.\n     * Currently we are *only* validating the Watch \"Actions\"\n     */\n    value: function validate() {\n\n      // Get the errors from each watch action\n      var actionsErrors = this.actions.reduce(function (actionsErrors, action) {\n        if (action.validate) {\n          var _action$validate = action.validate(),\n              errors = _action$validate.errors;\n\n          if (!errors) {\n            return actionsErrors;\n          }\n          return [].concat(_toConsumableArray(actionsErrors), _toConsumableArray(errors));\n        }\n        return actionsErrors;\n      }, []);\n\n      if (!actionsErrors.length) {\n        return { warning: null };\n      }\n\n      // Concatenate their message\n      var warningMessage = actionsErrors.reduce(function (message, error) {\n        return !!message ? message + ', ' + error.message : error.message;\n      }, '');\n\n      // We are not doing any *blocking* validation in the client,\n      // so we return the errors as a _warning_\n      return {\n        warning: {\n          message: warningMessage\n        }\n      };\n    }\n  }, {\n    key: 'displayName',\n    get: function get() {\n      if (this.isNew) {\n        return _i18n.i18n.translate('xpack.watcher.models.baseWatch.displayName', {\n          defaultMessage: 'New Watch'\n        });\n      } else if (this.name) {\n        return this.name;\n      } else {\n        return this.id;\n      }\n    }\n  }, {\n    key: 'searchValue',\n    get: function get() {\n      return (0, _get_search_value.getSearchValue)(this, ['id', 'name']);\n    }\n  }, {\n    key: 'typeName',\n    get: function get() {\n      return this.constructor.typeName;\n    }\n  }, {\n    key: 'iconClass',\n    get: function get() {\n      return this.constructor.iconClass;\n    }\n  }, {\n    key: 'selectMessage',\n    get: function get() {\n      return this.constructor.selectMessage;\n    }\n  }, {\n    key: 'selectSortOrder',\n    get: function get() {\n      return this.constructor.selectSortOrder;\n    }\n  }, {\n    key: 'upstreamJson',\n    get: function get() {\n      return {\n        id: this.id,\n        name: this.name,\n        type: this.type,\n        actions: (0, _lodash.map)(this.actions, function (action) {\n          return action.upstreamJson;\n        })\n      };\n    }\n  }]);\n\n  return BaseWatch;\n}();\n\nBaseWatch.typeName = _i18n.i18n.translate('xpack.watcher.models.baseWatch.typeName', {\n  defaultMessage: 'Watch'\n});\nBaseWatch.iconClass = '';\nBaseWatch.selectMessage = _i18n.i18n.translate('xpack.watcher.models.baseWatch.selectMessageText', {\n  defaultMessage: 'Set up a new watch.'\n});\nBaseWatch.isCreatable = true;\nBaseWatch.selectSortOrder = 0;\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this = this;\n\n  this.updateWatchStatus = function (watchStatus) {\n    _this.watchStatus = watchStatus;\n  };\n\n  this.createAction = function (type, defaults) {\n    var ActionTypes = _action.Action.getActionTypes();\n    var ActionType = ActionTypes[type];\n\n    if (!Boolean(ActionType)) {\n      throw new Error(_i18n.i18n.translate('xpack.watcher.models.baseWatch.createUnknownActionTypeErrorMessage', {\n        defaultMessage: 'Attempted to create unknown action type {type}.',\n        values: { type: type }\n      }));\n    }\n\n    var id = (0, _create_action_id.createActionId)(_this.actions, type);\n    var props = (0, _lodash.merge)({}, defaults, { id: id, type: type });\n\n    var action = new ActionType(props);\n    _this.addAction(action);\n  };\n\n  this.addAction = function (action) {\n    if ((0, _check_action_id_collision.checkActionIdCollision)(_this.actions, action)) {\n      action.id = (0, _create_action_id.createActionId)(_this.actions, action.type);\n    }\n\n    _this.actions.push(action);\n  };\n\n  this.deleteAction = function (action) {\n    (0, _lodash.remove)(_this.actions, action);\n  };\n\n  this.resetActions = function () {\n    _this.actions = [];\n  };\n\n  this.isEqualTo = function (otherWatch) {\n    // We need to create a POJO copies because isEqual would return false\n    // because of property getters\n    var cleanWatch = _extends({}, _this);\n    var cleanOtherWatch = _extends({}, otherWatch);\n\n    return (0, _lodash.isEqual)(cleanWatch, cleanOtherWatch);\n  };\n};",null]}