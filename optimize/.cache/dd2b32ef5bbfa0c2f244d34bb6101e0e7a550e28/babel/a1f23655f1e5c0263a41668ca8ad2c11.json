{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/reducers/pages.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/reducers/pages.js","mtime":1567631711936},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pagesReducer = undefined;\n\nvar _handleActions;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nvar _reduxActions = require('redux-actions');\n\nvar _objectPathImmutable = require('object-path-immutable');\n\nvar _clone_subgraphs = require('../../lib/clone_subgraphs');\n\nvar _get_id = require('../../lib/get_id');\n\nvar _router_provider = require('../../lib/router_provider');\n\nvar _defaults = require('../defaults');\n\nvar _pages = require('../actions/pages');\n\nvar actions = _interopRequireWildcard(_pages);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction setPageIndex(workpadState, index) {\n  if (index < 0 || !workpadState.pages[index]) {\n    return workpadState;\n  }\n  return (0, _objectPathImmutable.set)(workpadState, 'page', index);\n}\n\nfunction getPageIndexById(workpadState, id) {\n  return workpadState.pages.findIndex(function (page) {\n    return page.id === id;\n  });\n}\n\nfunction addPage(workpadState, payload) {\n  var srcIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : workpadState.pages.length - 1;\n\n  return (0, _objectPathImmutable.insert)(workpadState, 'pages', payload || (0, _defaults.getDefaultPage)(), srcIndex + 1);\n}\n\nfunction clonePage(page) {\n  // TODO: would be nice if we could more reliably know which parameters need to get a unique id\n  // this makes a pretty big assumption about the shape of the page object\n  var elements = page.elements;\n  var groups = page.groups || [];\n  var nodes = elements.concat(groups);\n  var newNodes = (0, _clone_subgraphs.cloneSubgraphs)(nodes);\n  return _extends({}, page, {\n    id: (0, _get_id.getId)('page'),\n    groups: newNodes.filter(function (n) {\n      return n.position.type === 'group';\n    }),\n    elements: newNodes.filter(function (n) {\n      return n.position.type !== 'group';\n    })\n  });\n}\n\nvar pagesReducer = exports.pagesReducer = (0, _reduxActions.handleActions)((_handleActions = {}, _defineProperty(_handleActions, actions.addPage, function (workpadState, _ref) {\n  var payload = _ref.payload;\n  var activePage = workpadState.page;\n\n  var withNewPage = addPage(workpadState, payload, activePage);\n  var newState = setPageIndex(withNewPage, activePage + 1);\n\n  // changes to the page require navigation\n  var router = (0, _router_provider.routerProvider)();\n  router.navigateTo('loadWorkpad', { id: newState.id, page: newState.page + 1 });\n\n  return newState;\n}), _defineProperty(_handleActions, actions.duplicatePage, function (workpadState, _ref2) {\n  var payload = _ref2.payload;\n\n  var srcPage = workpadState.pages.find(function (page) {\n    return page.id === payload;\n  });\n\n  // if the page id is invalid, don't change the state\n  if (!srcPage) {\n    return workpadState;\n  }\n\n  var srcIndex = workpadState.pages.indexOf(srcPage);\n  var newPageIndex = srcIndex + 1;\n  var insertedWorkpadState = addPage(workpadState, clonePage(srcPage), srcIndex);\n  var newState = setPageIndex(insertedWorkpadState, newPageIndex);\n\n  // changes to the page require navigation\n  var router = (0, _router_provider.routerProvider)();\n  router.navigateTo('loadWorkpad', { id: newState.id, page: newPageIndex + 1 });\n\n  return newState;\n}), _defineProperty(_handleActions, actions.setPage, function (workpadState, _ref3) {\n  var payload = _ref3.payload;\n\n  return setPageIndex(workpadState, payload);\n}), _defineProperty(_handleActions, actions.movePage, function (workpadState, _ref4) {\n  var payload = _ref4.payload;\n  var id = payload.id,\n      position = payload.position;\n\n  var pageIndex = getPageIndexById(workpadState, id);\n  var newIndex = pageIndex + position;\n\n  // TODO: do something better when given an invalid page id\n  if (pageIndex < 0) {\n    return workpadState;\n  }\n\n  // don't move pages past the first or last position\n  if (newIndex < 0 || newIndex >= workpadState.pages.length) {\n    return workpadState;\n  }\n\n  // remove and re-insert the page\n  var page = _extends({}, workpadState.pages[pageIndex]);\n  var newState = (0, _objectPathImmutable.insert)((0, _objectPathImmutable.del)(workpadState, 'pages.' + pageIndex), 'pages', page, newIndex);\n\n  // adjust the selected page index and return the new state\n  var selectedId = workpadState.pages[workpadState.page].id;\n  var newSelectedIndex = newState.pages.findIndex(function (page) {\n    return page.id === selectedId;\n  });\n  newState = (0, _objectPathImmutable.set)(newState, 'page', newSelectedIndex);\n\n  // changes to the page require navigation\n  var router = (0, _router_provider.routerProvider)();\n  router.navigateTo('loadWorkpad', { id: newState.id, page: newState.page + 1 });\n\n  return newState;\n}), _defineProperty(_handleActions, actions.removePage, function (workpadState, _ref5) {\n  var payload = _ref5.payload;\n\n  var curIndex = workpadState.page;\n  var delIndex = getPageIndexById(workpadState, payload);\n  if (delIndex >= 0) {\n    var newState = (0, _objectPathImmutable.del)(workpadState, 'pages.' + delIndex);\n    var router = (0, _router_provider.routerProvider)();\n    var wasSelected = curIndex === delIndex;\n    var wasOnlyPage = newState.pages.length === 0;\n    var newSelectedPage = curIndex >= delIndex ? curIndex - 1 : curIndex;\n\n    // if we removed the only page, create a new empty one\n    if (wasOnlyPage) {\n      newState = addPage(newState);\n    }\n\n    if (wasOnlyPage || wasSelected) {\n      // if we removed the only page or the selected one, select the first one\n      newState = (0, _objectPathImmutable.set)(newState, 'page', 0);\n    } else {\n      // set the adjusted selected page on new state\n      newState = (0, _objectPathImmutable.set)(newState, 'page', newSelectedPage);\n    }\n\n    // changes to the page require navigation\n    router.navigateTo('loadWorkpad', { id: newState.id, page: newState.page + 1 });\n\n    return newState;\n  }\n}), _defineProperty(_handleActions, actions.stylePage, function (workpadState, _ref6) {\n  var payload = _ref6.payload;\n\n  var pageIndex = workpadState.pages.findIndex(function (page) {\n    return page.id === payload.pageId;\n  });\n  return (0, _objectPathImmutable.set)(workpadState, ['pages', pageIndex, 'style'], payload.style);\n}), _defineProperty(_handleActions, actions.setPageTransition, function (workpadState, _ref7) {\n  var payload = _ref7.payload;\n\n  var pageIndex = workpadState.pages.findIndex(function (page) {\n    return page.id === payload.pageId;\n  });\n  return (0, _objectPathImmutable.set)(workpadState, ['pages', pageIndex, 'transition'], payload.transition);\n}), _handleActions), {});",null]}