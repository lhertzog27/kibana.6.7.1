{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/console/public/src/mappings.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/console/public/src/mappings.js","mtime":1567631711527},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar $ = require('jquery');\nvar _ = require('lodash');\nvar es = require('./es');\nvar settings = require('./settings');\n\nvar perIndexTypes = {};\nvar perAliasIndexes = [];\nvar templates = [];\n\nvar mappingObj = {};\n\nfunction expandAliases(indicesOrAliases) {\n  // takes a list of indices or aliases or a string which may be either and returns a list of indices\n  // returns a list for multiple values or a string for a single.\n\n  if (!indicesOrAliases) {\n    return indicesOrAliases;\n  }\n\n  if (typeof indicesOrAliases === 'string') {\n    indicesOrAliases = [indicesOrAliases];\n  }\n  indicesOrAliases = $.map(indicesOrAliases, function (iOrA) {\n    if (perAliasIndexes[iOrA]) {\n      return perAliasIndexes[iOrA];\n    }\n    return [iOrA];\n  });\n  var ret = [].concat.apply([], indicesOrAliases);\n  ret.sort();\n  var last = void 0;\n  ret = $.map(ret, function (v) {\n    var r = last === v ? null : v;\n    last = v;\n    return r;\n  });\n  return ret.length > 1 ? ret : ret[0];\n}\n\nfunction getTemplates() {\n  return [].concat(_toConsumableArray(templates));\n}\nfunction getFields(indices, types) {\n  // get fields for indices and types. Both can be a list, a string or null (meaning all).\n  var ret = [];\n  indices = expandAliases(indices);\n  if (typeof indices === 'string') {\n\n    var typeDict = perIndexTypes[indices];\n    if (!typeDict) {\n      return [];\n    }\n\n    if (typeof types === 'string') {\n      var f = typeDict[types];\n      ret = f ? f : [];\n    } else {\n      // filter what we need\n      $.each(typeDict, function (type, fields) {\n        if (!types || types.length === 0 || $.inArray(type, types) !== -1) {\n          ret.push(fields);\n        }\n      });\n\n      ret = [].concat.apply([], ret);\n    }\n  } else {\n    // multi index mode.\n    $.each(perIndexTypes, function (index) {\n      if (!indices || indices.length === 0 || $.inArray(index, indices) !== -1) {\n        ret.push(getFields(index, types));\n      }\n    });\n    ret = [].concat.apply([], ret);\n  }\n\n  return _.uniq(ret, function (f) {\n    return f.name + ':' + f.type;\n  });\n}\n\nfunction getTypes(indices) {\n  var ret = [];\n  indices = expandAliases(indices);\n  if (typeof indices === 'string') {\n    var typeDict = perIndexTypes[indices];\n    if (!typeDict) {\n      return [];\n    }\n\n    // filter what we need\n    $.each(typeDict, function (type) {\n      ret.push(type);\n    });\n  } else {\n    // multi index mode.\n    $.each(perIndexTypes, function (index) {\n      if (!indices || $.inArray(index, indices) !== -1) {\n        ret.push(getTypes(index));\n      }\n    });\n    ret = [].concat.apply([], ret);\n  }\n\n  return _.uniq(ret);\n}\n\nfunction getIndices(includeAliases) {\n  var ret = [];\n  $.each(perIndexTypes, function (index) {\n    ret.push(index);\n  });\n  if (typeof includeAliases === 'undefined' ? true : includeAliases) {\n    $.each(perAliasIndexes, function (alias) {\n      ret.push(alias);\n    });\n  }\n  return ret;\n}\n\nfunction getFieldNamesFromFieldMapping(fieldName, fieldMapping) {\n  if (fieldMapping.enabled === false) {\n    return [];\n  }\n  var nestedFields = void 0;\n\n  function applyPathSettings(nestedFieldNames) {\n    var pathType = fieldMapping.path || 'full';\n    if (pathType === 'full') {\n      return $.map(nestedFieldNames, function (f) {\n        f.name = fieldName + '.' + f.name;\n        return f;\n      });\n    }\n    return nestedFieldNames;\n  }\n\n  if (fieldMapping.properties) {\n    // derived object type\n    nestedFields = getFieldNamesFromTypeMapping(fieldMapping);\n    return applyPathSettings(nestedFields);\n  }\n\n  var fieldType = fieldMapping.type;\n\n  if (fieldType === 'multi_field') {\n    nestedFields = $.map(fieldMapping.fields, function (fieldMapping, fieldName) {\n      return getFieldNamesFromFieldMapping(fieldName, fieldMapping);\n    });\n\n    return applyPathSettings(nestedFields);\n  }\n\n  var ret = { name: fieldName, type: fieldType };\n\n  if (fieldMapping.index_name) {\n    ret.name = fieldMapping.index_name;\n  }\n\n  if (fieldMapping.fields) {\n    nestedFields = $.map(fieldMapping.fields, function (fieldMapping, fieldName) {\n      return getFieldNamesFromFieldMapping(fieldName, fieldMapping);\n    });\n    nestedFields = applyPathSettings(nestedFields);\n    nestedFields.unshift(ret);\n    return nestedFields;\n  }\n\n  return [ret];\n}\n\nfunction getFieldNamesFromTypeMapping(typeMapping) {\n  var fieldList = $.map(typeMapping.properties || {}, function (fieldMapping, fieldName) {\n    return getFieldNamesFromFieldMapping(fieldName, fieldMapping);\n  });\n\n  // deduping\n  return _.uniq(fieldList, function (f) {\n    return f.name + ':' + f.type;\n  });\n}\n\nfunction loadTemplates(templatesObject) {\n  templates = Object.keys(templatesObject);\n}\n\nfunction loadMappings(mappings) {\n  perIndexTypes = {};\n  $.each(mappings, function (index, indexMapping) {\n    var normalizedIndexMappings = {};\n    // 1.0.0 mapping format has changed, extract underlying mapping\n    if (indexMapping.mappings && _.keys(indexMapping).length === 1) {\n      indexMapping = indexMapping.mappings;\n    }\n    $.each(indexMapping, function (typeName, typeMapping) {\n      var fieldList = getFieldNamesFromTypeMapping(typeMapping);\n      normalizedIndexMappings[typeName] = fieldList;\n    });\n    perIndexTypes[index] = normalizedIndexMappings;\n  });\n}\n\nfunction loadAliases(aliases) {\n  perAliasIndexes = {};\n  $.each(aliases || {}, function (index, omdexAliases) {\n    // verify we have an index defined. useful when mapping loading is disabled\n    perIndexTypes[index] = perIndexTypes[index] || {};\n\n    $.each(omdexAliases.aliases || {}, function (alias) {\n      if (alias === index) {\n        return;\n      } // alias which is identical to index means no index.\n      var curAliases = perAliasIndexes[alias];\n      if (!curAliases) {\n        curAliases = [];\n        perAliasIndexes[alias] = curAliases;\n      }\n      curAliases.push(index);\n    });\n  });\n\n  perAliasIndexes._all = getIndices(false);\n}\n\nfunction clear() {\n  perIndexTypes = {};\n  perAliasIndexes = {};\n  templates = [];\n}\n\nfunction retrieveAutocompleteInfoFromServer() {\n  var autocompleteSettings = settings.getAutocomplete();\n  var mappingPromise = void 0;\n  var aliasesPromise = void 0;\n  var templatesPromise = void 0;\n  if (autocompleteSettings.fields) {\n    mappingPromise = es.send('GET', '_mapping', null, null, true);\n  } else {\n    mappingPromise = new $.Deferred();\n    mappingPromise.resolve();\n  }\n  if (autocompleteSettings.indices) {\n    aliasesPromise = es.send('GET', '_aliases', null, null, true);\n  } else {\n    aliasesPromise = new $.Deferred();\n    aliasesPromise.resolve();\n  }\n  if (autocompleteSettings.templates) {\n    templatesPromise = es.send('GET', '_template', null, null, true);\n  } else {\n    templatesPromise = new $.Deferred();\n    templatesPromise.resolve();\n  }\n\n  $.when(mappingPromise, aliasesPromise, templatesPromise).done(function (mappings, aliases, templates) {\n    if (!mappings) {\n      mappings = {};\n    } else if (mappings[0].length < 10 * 1024 * 1024) {\n      mappings = JSON.parse(mappings[0]);\n    } else {\n      console.warn('mapping size is larger than 10MB (' + mappings[0].length / 1024 / 1024 + ' MB). ignoring..');\n      mappings = {};\n    }\n    loadMappings(mappings);\n    if (aliases) {\n      loadAliases(JSON.parse(aliases[0]));\n    } else {\n      aliases = [{}];\n      loadAliases({});\n    }\n    if (templates) {\n      loadTemplates(JSON.parse(templates[0]));\n    } else {\n      templates = [];\n    }\n    // Trigger an update event with the mappings, aliases\n    $(mappingObj).trigger('update', [mappings[0], aliases[0]]);\n  });\n}\n\nfunction autocompleteRetriever() {\n  retrieveAutocompleteInfoFromServer();\n  setTimeout(function () {\n    autocompleteRetriever();\n  }, 60000);\n}\n\nexports.default = _.assign(mappingObj, {\n  getFields: getFields,\n  getTemplates: getTemplates,\n  getIndices: getIndices,\n  getTypes: getTypes,\n  loadMappings: loadMappings,\n  loadAliases: loadAliases,\n  expandAliases: expandAliases,\n  clear: clear,\n  startRetrievingAutoCompleteInfo: autocompleteRetriever\n});\nmodule.exports = exports['default'];",null]}