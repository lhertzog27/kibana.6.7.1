{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/components/custom_url_editor/utils.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/components/custom_url_editor/utils.js","mtime":1567631712047},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNewCustomUrlDefaults = getNewCustomUrlDefaults;\nexports.getQueryEntityFieldNames = getQueryEntityFieldNames;\nexports.isValidCustomUrlSettingsTimeRange = isValidCustomUrlSettingsTimeRange;\nexports.isValidCustomUrlSettings = isValidCustomUrlSettings;\nexports.buildCustomUrlFromSettings = buildCustomUrlFromSettings;\nexports.getTestUrl = getTestUrl;\n\nvar _constants = require('./constants');\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _risonNode = require('rison-node');\n\nvar _risonNode2 = _interopRequireDefault(_risonNode);\n\nvar _index_patterns = require('../../../../common/constants/index_patterns');\n\nvar _job_utils = require('../../../../common/util/job_utils');\n\nvar _parse_interval = require('../../../../common/util/parse_interval');\n\nvar _custom_url_utils = require('../../../util/custom_url_utils');\n\nvar _ml_api_service = require('../../../services/ml_api_service');\n\nvar _job_service = require('../../../services/job_service');\n\nvar _string_utils = require('../../../util/string_utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /*\n                                                                                                                                                                                                     * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                     * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                     * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                     */\n\nfunction getNewCustomUrlDefaults(job, dashboards, indexPatterns) {\n  // Returns the settings object in the format used by the custom URL editor\n  // for a new custom URL.\n  var kibanaSettings = {\n    queryFieldNames: []\n  };\n\n  // Set the default type.\n  var urlType = _constants.URL_TYPE.OTHER;\n  if (dashboards !== undefined && dashboards.length > 0) {\n    urlType = _constants.URL_TYPE.KIBANA_DASHBOARD;\n    kibanaSettings.dashboardId = dashboards[0].id;\n  } else if (indexPatterns !== undefined && indexPatterns.length > 0) {\n    urlType = _constants.URL_TYPE.KIBANA_DISCOVER;\n  }\n\n  // For the Discover option, set the default index pattern to that\n  // which matches the (first) index configured in the job datafeed.\n  var datafeedConfig = job.datafeed_config;\n  if (indexPatterns !== undefined && indexPatterns.length > 0 && datafeedConfig !== undefined && datafeedConfig.indices !== undefined && datafeedConfig.indices.length > 0) {\n\n    var datafeedIndex = datafeedConfig.indices[0];\n    var defaultIndexPattern = indexPatterns.find(function (indexPattern) {\n      return indexPattern.title === datafeedIndex;\n    });\n\n    if (defaultIndexPattern === undefined) {\n      defaultIndexPattern = indexPatterns[0];\n    }\n\n    kibanaSettings.discoverIndexPatternId = defaultIndexPattern.id;\n  }\n\n  return {\n    label: '',\n    type: urlType,\n    // Note timeRange is only editable in new URLs for Dashboard and Discover URLs,\n    // as for other URLs we have no way of knowing how the field will be used in the URL.\n    timeRange: {\n      type: _constants.TIME_RANGE_TYPE.AUTO,\n      interval: ''\n    },\n    kibanaSettings: kibanaSettings,\n    otherUrlSettings: {\n      urlValue: ''\n    }\n  };\n}\n\nfunction getQueryEntityFieldNames(job) {\n  // Returns the list of partitioning and influencer field names that can be used\n  // as entities to add to the query used when linking to a Kibana dashboard or Discover.\n  var influencers = job.analysis_config.influencers;\n  var detectors = job.analysis_config.detectors;\n  var entityFieldNames = [];\n  if (influencers !== undefined) {\n    entityFieldNames.push.apply(entityFieldNames, _toConsumableArray(influencers));\n  }\n\n  detectors.forEach(function (detector, detectorIndex) {\n    var partitioningFields = (0, _job_utils.getPartitioningFieldNames)(job, detectorIndex);\n\n    partitioningFields.forEach(function (fieldName) {\n      if (entityFieldNames.indexOf(fieldName) === -1) {\n        entityFieldNames.push(fieldName);\n      }\n    });\n  });\n\n  return entityFieldNames;\n}\n\nfunction isValidCustomUrlSettingsTimeRange(timeRangeSettings) {\n  if (timeRangeSettings.type === _constants.TIME_RANGE_TYPE.INTERVAL) {\n    var interval = (0, _parse_interval.parseInterval)(timeRangeSettings.interval);\n    return interval !== null;\n  }\n\n  return true;\n}\n\nfunction isValidCustomUrlSettings(settings, savedCustomUrls) {\n  var isValid = (0, _custom_url_utils.isValidLabel)(settings.label, savedCustomUrls);\n  if (isValid === true) {\n    isValid = isValidCustomUrlSettingsTimeRange(settings.timeRange);\n  }\n  return isValid;\n}\n\nfunction buildCustomUrlFromSettings(settings) {\n  // Dashboard URL returns a Promise as a query is made to obtain the full dashboard config.\n  // So wrap the other two return types in a Promise for consistent return type.\n  if (settings.type === _constants.URL_TYPE.KIBANA_DASHBOARD) {\n    return buildDashboardUrlFromSettings(settings);\n  } else if (settings.type === _constants.URL_TYPE.KIBANA_DISCOVER) {\n    return Promise.resolve(buildDiscoverUrlFromSettings(settings));\n  } else {\n    var urlToAdd = {\n      url_name: settings.label,\n      url_value: settings.otherUrlSettings.urlValue\n    };\n\n    return Promise.resolve(urlToAdd);\n  }\n}\n\nfunction buildDashboardUrlFromSettings(settings) {\n  // Get the complete list of attributes for the selected dashboard (query, filters).\n  return new Promise(function (resolve, reject) {\n    var _settings$kibanaSetti = settings.kibanaSettings,\n        dashboardId = _settings$kibanaSetti.dashboardId,\n        queryFieldNames = _settings$kibanaSetti.queryFieldNames;\n\n\n    var savedObjectsClient = _chrome2.default.getSavedObjectsClient();\n    savedObjectsClient.get('dashboard', dashboardId).then(function (response) {\n      // Use the filters from the saved dashboard if there are any.\n      var filters = [];\n\n      // Use the query from the dashboard only if no job entities are selected.\n      var query = undefined;\n\n      var searchSourceJSON = response.get('kibanaSavedObjectMeta.searchSourceJSON');\n      if (searchSourceJSON !== undefined) {\n        var searchSourceData = JSON.parse(searchSourceJSON);\n        if (searchSourceData.filter !== undefined) {\n          filters = searchSourceData.filter;\n        }\n        query = searchSourceData.query;\n      }\n\n      // Add time settings to the global state URL parameter with $earliest$ and\n      // $latest$ tokens which get substituted for times around the time of the\n      // anomaly on which the URL will be run against.\n      var _g = _risonNode2.default.encode({\n        time: {\n          from: '$earliest$',\n          to: '$latest$',\n          mode: 'absolute'\n        }\n      });\n\n      var appState = {\n        filters: filters\n      };\n\n      // To put entities in filters section would involve creating parameters of the form\n      // filters:!(('$state':(store:appState),meta:(alias:!n,disabled:!f,index:b30fd340-efb4-11e7-a600-0f58b1422b87,\n      // key:airline,negate:!f,params:(query:AAL,type:phrase),type:phrase,value:AAL),query:(match:(airline:(query:AAL,type:phrase)))))\n      // which includes the ID of the index holding the field used in the filter.\n\n      // So for simplicity, put entities in the query, replacing any query which is there already.\n      // e.g. query:(language:lucene,query:'region:us-east-1%20AND%20instance:i-20d061fa')\n      if (queryFieldNames !== undefined && queryFieldNames.length > 0) {\n        var queryString = '';\n        queryFieldNames.forEach(function (fieldName, index) {\n          if (index > 0) {\n            queryString += ' AND ';\n          }\n          queryString += (0, _string_utils.escapeForElasticsearchQuery)(fieldName) + ':\"$' + fieldName + '$\"';\n        });\n\n        query = {\n          language: 'lucene',\n          query: queryString\n        };\n      }\n\n      if (query !== undefined) {\n        appState.query = query;\n      }\n\n      var _a = _risonNode2.default.encode(appState);\n\n      var urlValue = 'kibana#/dashboard/' + dashboardId + '?_g=' + _g + '&_a=' + _a;\n\n      var urlToAdd = {\n        url_name: settings.label,\n        url_value: urlValue,\n        time_range: _constants.TIME_RANGE_TYPE.AUTO\n      };\n\n      if (settings.timeRange.type === _constants.TIME_RANGE_TYPE.INTERVAL) {\n        urlToAdd.time_range = settings.timeRange.interval;\n      }\n\n      resolve(urlToAdd);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\nfunction buildDiscoverUrlFromSettings(settings) {\n  var _settings$kibanaSetti2 = settings.kibanaSettings,\n      discoverIndexPatternId = _settings$kibanaSetti2.discoverIndexPatternId,\n      queryFieldNames = _settings$kibanaSetti2.queryFieldNames;\n\n  // Add time settings to the global state URL parameter with $earliest$ and\n  // $latest$ tokens which get substituted for times around the time of the\n  // anomaly on which the URL will be run against.\n\n  var _g = _risonNode2.default.encode({\n    time: {\n      from: '$earliest$',\n      to: '$latest$',\n      mode: 'absolute'\n    }\n  });\n\n  // Add the index pattern and query to the appState part of the URL.\n  var appState = {\n    index: discoverIndexPatternId\n  };\n\n  // If partitioning field entities have been configured add tokens\n  // to the URL to use in the Discover page search.\n\n  // Ideally we would put entities in the filters section, but currently this involves creating parameters of the form\n  // filters:!(('$state':(store:appState),meta:(alias:!n,disabled:!f,index:b30fd340-efb4-11e7-a600-0f58b1422b87,\n  // key:airline,negate:!f,params:(query:AAL,type:phrase),type:phrase,value:AAL),query:(match:(airline:(query:AAL,type:phrase)))))\n  // which includes the ID of the index holding the field used in the filter.\n\n  // So for simplicity, put entities in the query, replacing any query which is there already.\n  // e.g. query:(language:lucene,query:'region:us-east-1%20AND%20instance:i-20d061fa')\n  if (queryFieldNames !== undefined && queryFieldNames.length > 0) {\n    var queryString = '';\n    queryFieldNames.forEach(function (fieldName, i) {\n      if (i > 0) {\n        queryString += ' AND ';\n      }\n      queryString += (0, _string_utils.escapeForElasticsearchQuery)(fieldName) + ':\"$' + fieldName + '$\"';\n    });\n\n    appState.query = {\n      language: 'lucene',\n      query: queryString\n    };\n  }\n\n  var _a = _risonNode2.default.encode(appState);\n\n  var urlValue = 'kibana#/discover?_g=' + _g + '&_a=' + _a;\n\n  var urlToAdd = {\n    url_name: settings.label,\n    url_value: urlValue,\n    time_range: _constants.TIME_RANGE_TYPE.AUTO\n  };\n\n  if (settings.timeRange.type === _constants.TIME_RANGE_TYPE.INTERVAL) {\n    urlToAdd.time_range = settings.timeRange.interval;\n  }\n\n  return urlToAdd;\n}\n\n// Builds the full URL for testing out a custom URL configuration, which\n// may contain dollar delimited partition / influencer entity tokens and\n// drilldown time range settings.\nfunction getTestUrl(job, customUrl) {\n  var urlValue = customUrl.url_value;\n  var bucketSpanSecs = (0, _parse_interval.parseInterval)(job.analysis_config.bucket_span).asSeconds();\n\n  // By default, return configured url_value. Look to substitute any dollar-delimited\n  // tokens with values from the highest scoring anomaly, or if no anomalies, with\n  // values from a document returned by the search in the job datafeed.\n  var testUrl = customUrl.url_value;\n\n  // Query to look for the highest scoring anomaly.\n  var body = {\n    query: {\n      bool: {\n        must: [{ term: { job_id: job.job_id } }, { term: { result_type: 'record' } }]\n      }\n    },\n    size: 1,\n    _source: {\n      excludes: []\n    },\n    sort: [{ record_score: { order: 'desc' } }]\n  };\n\n  return new Promise(function (resolve, reject) {\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      rest_total_hits_as_int: true,\n      body: body\n    }).then(function (resp) {\n      if (resp.hits.total > 0) {\n        var record = resp.hits.hits[0]._source;\n        testUrl = (0, _custom_url_utils.replaceTokensInUrlValue)(customUrl, bucketSpanSecs, record, 'timestamp');\n        resolve(testUrl);\n      } else {\n        // No anomalies yet for this job, so do a preview of the search\n        // configured in the job datafeed to obtain sample docs.\n        _job_service.mlJobService.searchPreview(job).then(function (response) {\n          var testDoc = void 0;\n          var docTimeFieldName = job.data_description.time_field;\n\n          // Handle datafeeds which use aggregations or documents.\n          if (response.aggregations) {\n            // Create a dummy object which contains the fields necessary to build the URL.\n            var firstBucket = response.aggregations.buckets.buckets[0];\n            testDoc = _defineProperty({}, docTimeFieldName, firstBucket.key);\n\n            // Look for bucket aggregations which match the tokens in the URL.\n            urlValue.replace(/\\$([^?&$\\'\"]{1,40})\\$/g, function (match, name) {\n              if (name !== 'earliest' && name !== 'latest' && firstBucket[name] !== undefined) {\n                var tokenBuckets = firstBucket[name];\n                if (tokenBuckets.buckets) {\n                  testDoc[name] = tokenBuckets.buckets[0].key;\n                }\n              }\n            });\n          } else {\n            if (response.hits.total > 0) {\n              testDoc = response.hits.hits[0]._source;\n            }\n          }\n\n          if (testDoc !== undefined) {\n            testUrl = (0, _custom_url_utils.replaceTokensInUrlValue)(customUrl, bucketSpanSecs, testDoc, docTimeFieldName);\n          }\n\n          resolve(testUrl);\n        });\n      }\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}",null]}