{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/common/lib/autocomplete.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/common/lib/autocomplete.js","mtime":1567631711911},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\nexports.getFnArgDefAtPosition = getFnArgDefAtPosition;\nexports.getAutocompleteSuggestions = getAutocompleteSuggestions;\n\nvar _lodash = require('lodash');\n\nvar _common = require('@kbn/interpreter/common');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar MARKER = 'CANVAS_SUGGESTION_MARKER';\n\n/**\n * Generates the AST with the given expression and then returns the function and argument definitions\n * at the given position in the expression, if there are any.\n */\nfunction getFnArgDefAtPosition(specs, expression, position) {\n  var text = expression.substr(0, position) + MARKER + expression.substr(position);\n  try {\n    var ast = (0, _common.parse)(text, { addMeta: true });\n\n    var _getFnArgAtPosition = getFnArgAtPosition(ast, position),\n        newAst = _getFnArgAtPosition.ast,\n        fnIndex = _getFnArgAtPosition.fnIndex,\n        argName = _getFnArgAtPosition.argName;\n\n    var fn = newAst.node.chain[fnIndex].node;\n\n    var fnDef = (0, _common.getByAlias)(specs, fn.function.replace(MARKER, ''));\n    if (fnDef && argName) {\n      var argDef = (0, _common.getByAlias)(fnDef.args, argName);\n      return { fnDef: fnDef, argDef: argDef };\n    }\n    return { fnDef: fnDef };\n  } catch (e) {\n    // Fail silently\n  }\n  return [];\n}\n\n/**\n * Gets a list of suggestions for the given expression at the given position. It does this by\n * inserting a marker at the given position, then parsing the resulting expression. This way we can\n * see what the marker would turn into, which tells us what sorts of things to suggest. For\n * example, if the marker turns into a function name, then we suggest functions. If it turns into\n * an unnamed argument, we suggest argument names. If it turns into a value, we suggest values.\n */\nfunction getAutocompleteSuggestions(specs, expression, position) {\n  var text = expression.substr(0, position) + MARKER + expression.substr(position);\n  try {\n    var ast = (0, _common.parse)(text, { addMeta: true });\n\n    var _getFnArgAtPosition2 = getFnArgAtPosition(ast, position),\n        newAst = _getFnArgAtPosition2.ast,\n        fnIndex = _getFnArgAtPosition2.fnIndex,\n        argName = _getFnArgAtPosition2.argName,\n        argIndex = _getFnArgAtPosition2.argIndex;\n\n    var fn = newAst.node.chain[fnIndex].node;\n\n    if (fn.function.includes(MARKER)) {\n      return getFnNameSuggestions(specs, newAst, fnIndex);\n    }\n\n    if (argName === '_') {\n      return getArgNameSuggestions(specs, newAst, fnIndex, argName, argIndex);\n    }\n\n    if (argName) {\n      return getArgValueSuggestions(specs, newAst, fnIndex, argName, argIndex);\n    }\n  } catch (e) {\n    // Fail silently\n  }\n  return [];\n}\n\n/**\n * Get the function and argument (if there is one) at the given position.\n */\nfunction getFnArgAtPosition(ast, position) {\n  var fnIndex = ast.node.chain.findIndex(function (fn) {\n    return fn.start <= position && position <= fn.end;\n  });\n  var fn = ast.node.chain[fnIndex];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Object.entries(fn.node.arguments)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      var argName = _ref2[0];\n      var argValues = _ref2[1];\n\n      for (var argIndex = 0; argIndex < argValues.length; argIndex++) {\n        var value = argValues[argIndex];\n        if (value.start <= position && position <= value.end) {\n          if (value.node !== null && value.node.type === 'expression') {\n            return getFnArgAtPosition(value, position);\n          }\n          return { ast: ast, fnIndex: fnIndex, argName: argName, argIndex: argIndex };\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return { ast: ast, fnIndex: fnIndex };\n}\n\nfunction getFnNameSuggestions(specs, ast, fnIndex) {\n  // Filter the list of functions by the text at the marker\n  var _ast$node$chain$fnInd = ast.node.chain[fnIndex],\n      start = _ast$node$chain$fnInd.start,\n      end = _ast$node$chain$fnInd.end,\n      fn = _ast$node$chain$fnInd.node;\n\n  var query = fn.function.replace(MARKER, '');\n  var matchingFnDefs = specs.filter(function (_ref3) {\n    var name = _ref3.name;\n    return textMatches(name, query);\n  });\n\n  // Sort by whether or not the function expects the previous function's return type, then by\n  // whether or not the function name starts with the text at the marker, then alphabetically\n  var prevFn = ast.node.chain[fnIndex - 1];\n  var prevFnDef = prevFn && (0, _common.getByAlias)(specs, prevFn.node.function);\n  var prevFnType = prevFnDef && prevFnDef.type;\n  var comparator = combinedComparator(prevFnTypeComparator(prevFnType), invokeWithProp(startsWithComparator(query), 'name'), invokeWithProp(alphanumericalComparator, 'name'));\n  var fnDefs = matchingFnDefs.sort(comparator);\n\n  return fnDefs.map(function (fnDef) {\n    return { type: 'function', text: fnDef.name + ' ', start: start, end: end - MARKER.length, fnDef: fnDef };\n  });\n}\n\nfunction getArgNameSuggestions(specs, ast, fnIndex, argName, argIndex) {\n  // Get the list of args from the function definition\n  var fn = ast.node.chain[fnIndex].node;\n  var fnDef = (0, _common.getByAlias)(specs, fn.function);\n  if (!fnDef) {\n    return [];\n  }\n\n  // We use the exact text instead of the value because it is always a string and might be quoted\n  var _fn$arguments$argName = fn.arguments[argName][argIndex],\n      text = _fn$arguments$argName.text,\n      start = _fn$arguments$argName.start,\n      end = _fn$arguments$argName.end;\n\n  // Filter the list of args by the text at the marker\n\n  var query = text.replace(MARKER, '');\n  var matchingArgDefs = Object.values(fnDef.args).filter(function (_ref4) {\n    var name = _ref4.name;\n    return textMatches(name, query);\n  });\n\n  // Filter the list of args by those which aren't already present (unless they allow multi)\n  var argEntries = Object.entries(fn.arguments).map(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n        name = _ref6[0],\n        values = _ref6[1];\n\n    return [name, values.filter(function (value) {\n      return !value.text.includes(MARKER);\n    })];\n  });\n  var unusedArgDefs = matchingArgDefs.filter(function (argDef) {\n    if (argDef.multi) {\n      return true;\n    }\n    return !argEntries.some(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 2),\n          name = _ref8[0],\n          values = _ref8[1];\n\n      return values.length && (name === argDef.name || argDef.aliases.includes(name));\n    });\n  });\n\n  // Sort by whether or not the arg is also the unnamed, then by whether or not the arg name starts\n  // with the text at the marker, then alphabetically\n  var comparator = combinedComparator(unnamedArgComparator, invokeWithProp(startsWithComparator(query), 'name'), invokeWithProp(alphanumericalComparator, 'name'));\n  var argDefs = unusedArgDefs.sort(comparator);\n\n  return argDefs.map(function (argDef) {\n    return { type: 'argument', text: argDef.name + '=', start: start, end: end - MARKER.length, argDef: argDef };\n  });\n}\n\nfunction getArgValueSuggestions(specs, ast, fnIndex, argName, argIndex) {\n  // Get the list of values from the argument definition\n  var fn = ast.node.chain[fnIndex].node;\n  var fnDef = (0, _common.getByAlias)(specs, fn.function);\n  if (!fnDef) {\n    return [];\n  }\n  var argDef = (0, _common.getByAlias)(fnDef.args, argName);\n  if (!argDef) {\n    return [];\n  }\n\n  // Get suggestions from the argument definition, including the default\n  var _fn$arguments$argName2 = fn.arguments[argName][argIndex],\n      start = _fn$arguments$argName2.start,\n      end = _fn$arguments$argName2.end,\n      node = _fn$arguments$argName2.node;\n\n  var query = node.replace(MARKER, '');\n  var suggestions = (0, _lodash.uniq)(argDef.options.concat(argDef.default || []));\n\n  // Filter the list of suggestions by the text at the marker\n  var filtered = suggestions.filter(function (option) {\n    return textMatches(String(option), query);\n  });\n\n  // Sort by whether or not the value starts with the text at the marker, then alphabetically\n  var comparator = combinedComparator(startsWithComparator(query), alphanumericalComparator);\n  var sorted = filtered.sort(comparator);\n\n  return sorted.map(function (value) {\n    var text = maybeQuote(value) + ' ';\n    return { start: start, end: end - MARKER.length, type: 'value', text: text };\n  });\n}\n\nfunction textMatches(text, query) {\n  return text.toLowerCase().includes(query.toLowerCase().trim());\n}\n\nfunction maybeQuote(value) {\n  if (typeof value === 'string') {\n    if (value.match(/^\\{.*\\}$/)) {\n      return value;\n    }\n    return '\"' + value.replace(/\"/g, '\\\\\"') + '\"';\n  }\n  return value;\n}\n\nfunction prevFnTypeComparator(prevFnType) {\n  return function (a, b) {\n    return Boolean(b.context.types && b.context.types.includes(prevFnType)) - Boolean(a.context.types && a.context.types.includes(prevFnType));\n  };\n}\n\nfunction unnamedArgComparator(a, b) {\n  return b.aliases.includes('_') - a.aliases.includes('_');\n}\n\nfunction alphanumericalComparator(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\n\nfunction startsWithComparator(query) {\n  return function (a, b) {\n    return String(b).startsWith(query) - String(a).startsWith(query);\n  };\n}\n\nfunction combinedComparator() {\n  for (var _len = arguments.length, comparators = Array(_len), _key = 0; _key < _len; _key++) {\n    comparators[_key] = arguments[_key];\n  }\n\n  return function (a, b) {\n    return comparators.reduce(function (acc, comparator) {\n      if (acc !== 0) {\n        return acc;\n      }\n      return comparator(a, b);\n    }, 0);\n  };\n}\n\nfunction invokeWithProp(fn, prop) {\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return fn.apply(undefined, _toConsumableArray(args.map(function (arg) {\n      return arg[prop];\n    })));\n  };\n}",null]}