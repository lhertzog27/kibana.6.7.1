{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/components/utils/app_state_settings.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/components/utils/app_state_settings.js","mtime":1567631712057},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nexports.populateAppStateSettings = populateAppStateSettings;\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction populateAppStateSettings(appState, scope) {\n  if (appState.mlJobSettings !== undefined && Object.keys(appState.mlJobSettings).length) {\n    var finish = function finish(success) {\n      if (success) {\n        (0, _jquery2.default)('#job-id-input').focus();\n      }\n    };\n\n    var jobSettings = appState.mlJobSettings;\n\n    (function () {\n      if (scope.formConfig.hasOwnProperty('field')) {\n        // single metric configuration\n        return populateSingleMetricSettings(jobSettings, scope);\n      } else if (scope.formConfig.hasOwnProperty('overField')) {\n        // population configuration\n        return populatePopulationSettings(jobSettings, scope);\n      } else if (scope.formConfig.hasOwnProperty('fields')) {\n        // multi metric configuration\n        return populateMultiMetricSettings(jobSettings, scope);\n      }\n    })().then(function () {\n      return finish(true);\n    }).catch(function () {\n      return finish(false);\n    });\n  }\n}\n\n// single metric page\nfunction populateSingleMetricSettings(jobSettings, scope) {\n  return new Promise(function (resolve, reject) {\n    jobSettings.fields.forEach(function (f) {\n\n      if (f.agg !== undefined) {\n        // find the aggregation object in the aggTypeOptions list which has the same name\n        // as the agg setting in the url\n        var agg = scope.ui.aggTypeOptions.find(function (o) {\n          return o.mlName === f.agg;\n        });\n        if (agg !== undefined) {\n          scope.formConfig.agg.type = agg;\n          scope.aggChange();\n        }\n      }\n      if (f.fieldName !== undefined) {\n        var field = scope.ui.fields.find(function (o) {\n          return o.name === f.fieldName;\n        });\n        // always set the field\n        // a field has been set in the url, but it has not been found. so we should set\n        // the selected field to be undefined to show this.\n        // otherwise it will remain unchanged and it may have already been set by default\n        // if there is only one in the dropdown list.\n        scope.formConfig.field = field || null;\n      }\n    });\n\n    if (scope.formConfig.agg.type !== undefined && scope.formConfig.field !== undefined || scope.formConfig.agg.type.name === 'count' && scope.formConfig.field === undefined) {\n\n      populateCommonSettings(jobSettings, scope);\n      resolve();\n    } else {\n      reject();\n    }\n  });\n}\n\n// multi metric page\nfunction populateMultiMetricSettings(jobSettings, scope) {\n  return new Promise(function (resolve, reject) {\n    jobSettings.fields.forEach(function (f) {\n\n      var fieldName = f.fieldName !== undefined ? f.fieldName : '__ml_event_rate_count__';\n      var field = scope.ui.fields.find(function (o) {\n        return o.id === fieldName;\n      });\n      if (field !== undefined) {\n        scope.formConfig.fields[field.id] = field;\n      }\n\n      if (f.agg !== undefined) {\n        var agg = scope.ui.aggTypeOptions.find(function (o) {\n          return o.mlName === f.agg;\n        });\n        if (agg !== undefined) {\n          scope.formConfig.fields[field.id].agg.type = agg;\n        }\n      }\n    });\n\n    if (jobSettings.split !== undefined) {\n      var field = scope.ui.splitFields.find(function (o) {\n        return o.name === jobSettings.split;\n      });\n      if (field !== undefined) {\n        scope.formConfig.splitField = field;\n        scope.splitChange();\n      }\n    }\n\n    if (scope.formConfig.fields !== undefined && Object.keys(scope.formConfig.fields).length > 0) {\n      populateCommonSettings(jobSettings, scope);\n      resolve();\n    } else {\n      reject();\n    }\n  });\n}\n\n// population page\nfunction populatePopulationSettings(jobSettings, scope) {\n  return new Promise(function (resolve, reject) {\n    if (jobSettings.population !== undefined) {\n\n      // loop over each field and draw the split cards if necessary.\n      // note, makes use of splitChange's returned promise so not to\n      // fire off too many requests at once and not to attempt to draw\n      // the card animations all at once\n      var loop = function loop(i) {\n        var f = jobSettings.fields[i];\n        if (f.split !== undefined) {\n          var splitField = scope.ui.splitFields.find(function (o) {\n            return o.name === f.split;\n          });\n          if (splitField !== undefined) {\n            scope.splitChange(i, splitField).then(function () {\n              check(i);\n            });\n          } else {\n            check(i);\n          }\n        } else {\n          // no split, move to the next field\n          check(i);\n        }\n      };\n\n      var check = function check(i) {\n        if (i + 1 < jobSettings.fields.length) {\n          loop(i + 1);\n        }\n      };\n\n      var overField = scope.ui.overFields.find(function (o) {\n        return o.name === jobSettings.population;\n      });\n      if (overField !== undefined) {\n        scope.formConfig.overField = overField;\n        scope.overChange();\n      }\n\n      jobSettings.fields.forEach(function (f) {\n        var fieldName = f.fieldName !== undefined ? f.fieldName : '__ml_event_rate_count__';\n        var tempField = scope.ui.fields.find(function (o) {\n          return o.id === fieldName;\n        });\n        var field = _extends({}, tempField);\n        if (field !== undefined) {\n\n          if (f.agg !== undefined) {\n            var agg = scope.ui.aggTypeOptions.find(function (o) {\n              return o.mlName === f.agg;\n            });\n            if (agg !== undefined) {\n              field.agg = { type: agg };\n            }\n          }\n          scope.formConfig.fields.push(field);\n        }\n      });\n\n      scope.formChange();\n      loop(0);\n    }\n    if (scope.formConfig.fields !== undefined && Object.keys(scope.formConfig.fields).length > 0) {\n      populateCommonSettings(jobSettings, scope);\n      resolve();\n    } else {\n      reject();\n    }\n  });\n}\n\nfunction populateCommonSettings(jobSettings, scope) {\n  if (typeof jobSettings.modelMemoryLimit === 'string') {\n    scope.formConfig.modelMemoryLimit = jobSettings.modelMemoryLimit;\n  }\n\n  if (typeof jobSettings.bucketSpan === 'string') {\n    scope.formConfig.bucketSpan = jobSettings.bucketSpan;\n  } else {\n    runEstimateBucketSpan(scope);\n  }\n\n  if (typeof jobSettings.description === 'string') {\n    scope.formConfig.description = jobSettings.description;\n  }\n\n  if (Array.isArray(jobSettings.groups)) {\n    scope.formConfig.jobGroups = jobSettings.groups;\n  }\n\n  if (Array.isArray(jobSettings.influencers)) {\n    scope.formConfig.influencerFields = jobSettings.influencers.map(function (i) {\n      return scope.ui.fields.find(function (f) {\n        return f.id === i;\n      });\n    });\n  }\n\n  scope.formConfig.useDedicatedIndex = jobSettings.resultsIndexName !== 'shared';\n  scope.ui.showAdvanced = scope.formConfig.useDedicatedIndex;\n}\n\nfunction runEstimateBucketSpan(scope) {\n  setTimeout(function () {\n    if (scope.bucketSpanEstimatorExportedFunctions.guessBucketSpan && typeof scope.bucketSpanEstimatorExportedFunctions.guessBucketSpan === 'function') {\n      scope.bucketSpanEstimatorExportedFunctions.guessBucketSpan();\n    }\n  }, 0);\n}",null]}