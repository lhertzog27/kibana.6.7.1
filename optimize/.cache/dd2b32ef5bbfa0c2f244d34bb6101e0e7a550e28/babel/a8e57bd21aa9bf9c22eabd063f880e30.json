{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/lib/angular_bootstrap_patch.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/lib/angular_bootstrap_patch.js","mtime":1567631712061},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nrequire('ui-bootstrap');\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable @kbn/license-header/require-license-header */\n\n/**\n * @notice\n *\n * This product includes code that was extracted from angular-ui-bootstrap@0.13.1\n * which is available under an \"MIT\" license\n *\n * The MIT License\n *\n * Copyright (c) 2012-2016 the AngularUI Team, http://angular-ui.github.io/bootstrap/\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n// This file contains a section of code taken from angular-ui-bootstrap@0.13.1\n// and adds it to kibana's included version of 0.12.1\n// It adds the ability to allow html to be used as the content of the popover component\n// and also adds support for dropdown-append-to-body flag, allowing the dropdown\n// menu to be appended to be the body and for the menu to be right aligned to the dropdown\n// (by addition of the dropdown-menu-right class to the dropdown-menu)\n_angular2.default.module('ui.bootstrap.popover').directive('popoverHtmlUnsafePopup', function ($compile) {\n  var template = '<div class=\"popover {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">';\n  template += '<div class=\"arrow\"></div>';\n  template += '<div class=\"popover-inner\">';\n  template += '<h3 class=\"popover-title\" bind-html-unsafe=\"title\" ng-show=\"title\"></h3>';\n  template += '<div class=\"popover-content\" bind-html-unsafe=\"content\" ></div>';\n  template += '</div></div>';\n  return {\n    restrict: 'EA',\n    replace: true,\n    scope: {\n      title: '@',\n      content: '@',\n      placement: '@',\n      animation: '&',\n      isOpen: '&'\n    },\n    template: template,\n    link: function link(scope, element) {\n      // The content of the popup is added as a string and does not run through angular's templating system.\n      // therefore {{stuff}} substitutions don't happen.\n      // we have to manually apply the template, compile it with this scope and then set it as the html\n      scope.$apply();\n      var cont = $compile(scope.content)(scope);\n      element.find('.popover-content').html(cont);\n\n      // function to force the popover to close\n      scope.closePopover = function () {\n        scope.$parent.$parent.isOpen = false;\n        scope.$parent.$parent.$applyAsync();\n        element.remove();\n      };\n    }\n  };\n}).directive('popoverHtmlUnsafe', ['$tooltip', function ($tooltip) {\n  return $tooltip('popoverHtmlUnsafe', 'popover', 'click');\n}]);\n\n_angular2.default.module('ui.bootstrap.dropdown', ['ui.bootstrap.position']).constant('dropdownConfig', {\n  openClass: 'open'\n}).service('dropdownService', ['$document', '$rootScope', function ($document, $rootScope) {\n  var openScope = null;\n\n  var closeDropdown = function closeDropdown(evt) {\n    // This method may still be called during the same mouse event that\n    // unbound this event handler. So check openScope before proceeding.\n    if (!openScope) {\n      return;\n    }\n\n    if (evt && openScope.getAutoClose() === 'disabled') {\n      return;\n    }\n\n    var toggleElement = openScope.getToggleElement();\n    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n      return;\n    }\n\n    var $element = openScope.getElement();\n    if (evt && openScope.getAutoClose() === 'outsideClick' && $element && $element[0].contains(evt.target)) {\n      return;\n    }\n\n    openScope.isOpen = false;\n\n    if (!$rootScope.$$phase) {\n      openScope.$apply();\n    }\n  };\n\n  var escapeKeyBind = function escapeKeyBind(evt) {\n    if (evt.which === 27) {\n      openScope.focusToggleElement();\n      closeDropdown();\n    }\n  };\n\n  this.open = function (dropdownScope) {\n    if (!openScope) {\n      $document.bind('click', closeDropdown);\n      $document.bind('keydown', escapeKeyBind);\n    }\n\n    if (openScope && openScope !== dropdownScope) {\n      openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n  };\n\n  this.close = function (dropdownScope) {\n    if (openScope === dropdownScope) {\n      openScope = null;\n      $document.unbind('click', closeDropdown);\n      $document.unbind('keydown', escapeKeyBind);\n    }\n  };\n}]).controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', '$position', '$document', function ($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate, $position, $document) {\n  var self = this;\n  var scope = $scope.$new(); // create a child scope so we are not polluting original one\n  var openClass = dropdownConfig.openClass;\n  var getIsOpen = void 0;\n  var setIsOpen = _angular2.default.noop;\n  var toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : _angular2.default.noop;\n  var appendToBody = false;\n\n  this.init = function (element) {\n    self.$element = element;\n\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function (value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    appendToBody = _angular2.default.isDefined($attrs.dropdownAppendToBody);\n\n    if (appendToBody && self.dropdownMenu) {\n      $document.find('body').append(self.dropdownMenu);\n      element.on('$destroy', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function (open) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function () {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function () {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function () {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function () {\n    return self.$element;\n  };\n\n  scope.focusToggleElement = function () {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function (isOpen, wasOpen) {\n    if (appendToBody && self.dropdownMenu) {\n      var pos = $position.positionElements(self.$element, self.dropdownMenu, 'bottom-left', true);\n      var css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        css.right = window.innerWidth - (pos.left + self.$element.prop('offsetWidth')) + 'px';\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    $animate[isOpen ? 'addClass' : 'removeClass'](self.$element, openClass);\n\n    if (isOpen) {\n      scope.focusToggleElement();\n      dropdownService.open(scope);\n    } else {\n      dropdownService.close(scope);\n    }\n\n    setIsOpen($scope, isOpen);\n    if (_angular2.default.isDefined(isOpen) && isOpen !== wasOpen) {\n      toggleInvoker($scope, { open: !!isOpen });\n    }\n  });\n\n  $scope.$on('$locationChangeSuccess', function () {\n    scope.isOpen = false;\n  });\n\n  $scope.$on('$destroy', function () {\n    scope.$destroy();\n  });\n}]).directive('dropdown', function () {\n  return {\n    controller: 'DropdownController',\n    link: function link(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init(element);\n    }\n  };\n}).directive('dropdownMenu', function () {\n  return {\n    restrict: 'AC',\n    require: '?^dropdown',\n    link: function link(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl) {\n        return;\n      }\n      dropdownCtrl.dropdownMenu = element;\n    }\n  };\n}).directive('dropdownToggle', function () {\n  return {\n    require: '?^dropdown',\n    link: function link(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function toggleDropdown(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function () {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function (isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function () {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n});",null]}