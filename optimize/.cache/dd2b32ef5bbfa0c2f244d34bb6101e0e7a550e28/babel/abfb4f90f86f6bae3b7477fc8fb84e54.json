{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/monitoring/public/components/logstash/pipeline_viewer/models/graph/plugin_vertex.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/monitoring/public/components/logstash/pipeline_viewer/models/graph/plugin_vertex.js","mtime":1567631712090},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PluginVertex = exports.SLOWNESS_STANDARD_DEVIATIONS_ABOVE_THE_MEAN = exports.TIME_CONSUMING_PROCESSOR_THRESHOLD_COEFFICIENT = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = require('lodash');\n\nvar _vertex = require('./vertex');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar TIME_CONSUMING_PROCESSOR_THRESHOLD_COEFFICIENT = exports.TIME_CONSUMING_PROCESSOR_THRESHOLD_COEFFICIENT = 2;\nvar SLOWNESS_STANDARD_DEVIATIONS_ABOVE_THE_MEAN = exports.SLOWNESS_STANDARD_DEVIATIONS_ABOVE_THE_MEAN = 2;\n\nvar PluginVertex = exports.PluginVertex = function (_Vertex) {\n  _inherits(PluginVertex, _Vertex);\n\n  function PluginVertex() {\n    _classCallCheck(this, PluginVertex);\n\n    return _possibleConstructorReturn(this, (PluginVertex.__proto__ || Object.getPrototypeOf(PluginVertex)).apply(this, arguments));\n  }\n\n  _createClass(PluginVertex, [{\n    key: 'isTimeConsuming',\n    value: function isTimeConsuming() {\n      // We assume that a 'normal' processor takes an equal share of execution time\n      var expectedPercentOfTotalProcessorTime = 1 / this.graph.processorVertices.length;\n\n      // If a processor takes more than some threshold beyond that it may be slow\n      var threshold = TIME_CONSUMING_PROCESSOR_THRESHOLD_COEFFICIENT * expectedPercentOfTotalProcessorTime;\n\n      return this.percentOfTotalProcessorTime > threshold;\n    }\n  }, {\n    key: 'isSlow',\n    value: function isSlow() {\n      var totalProcessorVertices = this.graph.processorVertices.length;\n\n      if (totalProcessorVertices === 0) {\n        return 0;\n      }\n\n      var meanmillisPerEvent = this.graph.processorVertices.reduce(function (acc, v) {\n        return acc + v.latestMillisPerEvent || 0;\n      }, 0) / totalProcessorVertices;\n\n      var variance = this.graph.processorVertices.reduce(function (acc, v) {\n        var difference = (v.latestMillisPerEvent || 0) - meanmillisPerEvent;\n        var square = difference * difference;\n        return acc + square;\n      }, 0) / totalProcessorVertices;\n\n      var stdDeviation = Math.sqrt(variance);\n\n      // Std deviations above the mean\n      var slowness = (this.latestMillisPerEvent - meanmillisPerEvent) / stdDeviation;\n\n      return slowness > SLOWNESS_STANDARD_DEVIATIONS_ABOVE_THE_MEAN;\n    }\n  }, {\n    key: 'typeString',\n    get: function get() {\n      return 'plugin';\n    }\n  }, {\n    key: 'name',\n    get: function get() {\n      return this.json.config_name;\n    }\n  }, {\n    key: 'title',\n    get: function get() {\n      return this.name;\n    }\n  }, {\n    key: 'pluginType',\n    get: function get() {\n      return this.json.plugin_type;\n    }\n  }, {\n    key: 'isInput',\n    get: function get() {\n      return this.pluginType === 'input';\n    }\n  }, {\n    key: 'isFilter',\n    get: function get() {\n      return this.pluginType === 'filter';\n    }\n  }, {\n    key: 'isOutput',\n    get: function get() {\n      return this.pluginType === 'output';\n    }\n  }, {\n    key: 'isProcessor',\n    get: function get() {\n      return this.isFilter || this.isOutput;\n    }\n  }, {\n    key: 'latestMillisPerEvent',\n    get: function get() {\n      return (0, _lodash.get)(this.stats, 'millis_per_event');\n    }\n  }, {\n    key: 'percentOfTotalProcessorTime',\n    get: function get() {\n      return (0, _lodash.get)(this.stats, 'percent_of_total_processor_duration');\n    }\n  }, {\n    key: 'eventsPerMillisecond',\n    get: function get() {\n      return this.isInput ? this.stats.events_out_per_millisecond : this.stats.events_in_per_millisecond;\n    }\n  }, {\n    key: 'eventsPerSecond',\n    get: function get() {\n      if (!this.eventsPerMillisecond.hasOwnProperty('data')) {\n        return this.eventsPerMillisecond * 1000;\n      }\n\n      var eps = _extends({}, this.eventsPerMillisecond); // Clone the object so we don't modify the original one\n      eps.data = this.eventsPerMillisecond.data.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            timestamp = _ref2[0],\n            value = _ref2[1];\n\n        return [timestamp, value * 1000];\n      });\n      return eps;\n    }\n  }, {\n    key: 'latestEventsPerSecond',\n    get: function get() {\n      if (!this.eventsPerSecond.hasOwnProperty('data')) {\n        return this.eventsPerSecond;\n      }\n\n      var numTimeseriesBuckets = this.eventsPerSecond.data.length;\n      return this.eventsPerSecond.data[numTimeseriesBuckets - 1][1];\n    }\n  }, {\n    key: 'iconType',\n    get: function get() {\n      switch (this.pluginType) {\n        case 'input':\n          return 'logstashInput';\n        case 'filter':\n          return 'logstashFilter';\n        case 'output':\n          return 'logstashOutput';\n        default:\n          throw new Error('Unknown plugin type ' + this.pluginType + '! This shouldn\\'t happen!');\n      }\n    }\n  }, {\n    key: 'next',\n    get: function get() {\n      var firstOutgoingEdge = this.outgoingEdges[0] || {};\n      return firstOutgoingEdge.to;\n    }\n  }]);\n\n  return PluginVertex;\n}(_vertex.Vertex);",null]}