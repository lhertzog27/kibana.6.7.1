{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/window_error_handler.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/window_error_handler.js","mtime":1567631711934},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _errors = require('../../common/lib/errors');\n\nvar knownErrors = _interopRequireWildcard(_errors);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar oldHandler = window.onerror; /*\n                                  * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                  * or more contributor license agreements. Licensed under the Elastic License;\n                                  * you may not use this file except in compliance with the Elastic License.\n                                  */\n\nfunction showError(err) {\n  var body = document.querySelector('body');\n  var notice = document.createElement('div');\n  notice.classList.add('window-error');\n\n  var close = document.createElement('a');\n  close.textContent = 'close';\n  close.onclick = function (ev) {\n    ev.preventDefault();\n    body.removeChild(notice);\n  };\n  notice.appendChild(close);\n\n  notice.insertAdjacentHTML('beforeend', '<h3>Uncaught error swallowed in dev mode</h3>');\n\n  var message = document.createElement('p');\n  message.textContent = 'Error: ' + err.message;\n  notice.appendChild(message);\n\n  if (err.stack) {\n    var stack = document.createElement('pre');\n    stack.textContent = err.stack.split('\\n').slice(0, 2).concat('...').join('\\n');\n    notice.appendChild(stack);\n  }\n\n  notice.insertAdjacentHTML('beforeend', '<p>Check console for more information</p>');\n  body.appendChild(notice);\n}\n\nwindow.canvasInitErrorHandler = function () {\n  // React will delegate to window.onerror, even when errors are caught with componentWillCatch,\n  // so check for a known custom error type and skip the default error handling when we find one\n  window.onerror = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var message = args[0],\n        err = args[4];\n\n\n    var isKnownError = Object.keys(knownErrors).find(function (errorName) {\n      return err.constructor.name === errorName || message.indexOf(errorName) >= 0;\n    });\n    if (isKnownError) {\n      return;\n    }\n\n    // uncaught errors are silenced in dev mode\n    // NOTE: react provides no way I can tell to distingish that an error came from react, it just\n    // throws generic Errors. In development mode, it throws those errors even if you catch them in\n    // an error boundary. This uses in the stack trace to try to detect it, but that stack changes\n    // between development and production modes. Fortunately, beginWork exists in both, so it uses\n    // a mix of the runtime mode and checking for another react method (renderRoot) for development\n    // TODO: this is *super* fragile. If the React method names ever change, which seems kind of likely,\n    // this check will break.\n    var isProduction = process.env.NODE_ENV === 'production';\n    if (!isProduction) {\n      // TODO: we should do something here to let the user know something failed,\n      // but we don't currently have an error logging service\n      console.error(err);\n      console.warn('*** Uncaught error swallowed in dev mode ***\\n\\n  Check and fix the above error. This will blow up Kibana when run in production mode!');\n      showError(err);\n      return;\n    }\n\n    // fall back to the default kibana uncaught error handler\n    oldHandler.apply(undefined, args);\n  };\n};\n\nwindow.canvasRestoreErrorHandler = function () {\n  window.onerror = oldHandler;\n};",null]}