{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/components/timeseries_chart/timeseries_chart.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/components/timeseries_chart/timeseries_chart.js","mtime":1567631712069},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TimeseriesChart = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _class, _temp; /*\n                    * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                    * or more contributor license agreements. Licensed under the Elastic License;\n                    * you may not use this file except in compliance with the Elastic License.\n                    */\n\n/*\n * React component chart plotting data from a single time series, with or without model plot enabled,\n * annotated with anomalies.\n */\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _anomaly_utils = require('../../../../common/util/anomaly_utils');\n\nvar _annotations_service = require('../../../services/annotations_service');\n\nvar _observable_utils = require('../../../util/observable_utils');\n\nvar _format_value = require('../../../formatters/format_value');\n\nvar _chart_utils = require('../../../util/chart_utils');\n\nvar _date_utils = require('../../../util/date_utils');\n\nvar _time_buckets = require('ui/time_buckets');\n\nvar _table_service = require('../../../services/table_service');\n\nvar _context_chart_mask = require('../context_chart_mask');\n\nvar _timeseriesexplorer_utils = require('../../timeseriesexplorer_utils');\n\nvar _string_utils = require('../../../util/string_utils');\n\nvar _field_format_service = require('../../../services/field_format_service');\n\nvar _chart_tooltip_service = require('../../../components/chart_tooltip/chart_tooltip_service');\n\nvar _timeseries_chart_annotations = require('./timeseries_chart_annotations');\n\nvar _react3 = require('@kbn/i18n/react');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar focusZoomPanelHeight = 25;\nvar focusChartHeight = 310;\nvar focusHeight = focusZoomPanelHeight + focusChartHeight;\nvar contextChartHeight = 60;\nvar contextChartLineTopMargin = 3;\nvar chartSpacing = 25;\nvar swimlaneHeight = 30;\nvar margin = { top: 20, right: 10, bottom: 15, left: 40 };\n\nvar ZOOM_INTERVAL_OPTIONS = [{ duration: _moment2.default.duration(1, 'h'), label: '1h' }, { duration: _moment2.default.duration(12, 'h'), label: '12h' }, { duration: _moment2.default.duration(1, 'd'), label: '1d' }, { duration: _moment2.default.duration(1, 'w'), label: '1w' }, { duration: _moment2.default.duration(2, 'w'), label: '2w' }, { duration: _moment2.default.duration(1, 'M'), label: '1M' }];\n\n// Set up the color scale to use for indicating score.\nvar anomalyColorScale = _d2.default.scale.threshold().domain([3, 25, 50, 75, 100]).range(['#d2e9f7', '#8bc8fb', '#ffdd00', '#ff7e00', '#fe5050']);\n\n// Create a gray-toned version of the color scale to use under the context chart mask.\nvar anomalyGrayScale = _d2.default.scale.threshold().domain([3, 25, 50, 75, 100]).range(['#dce7ed', '#b0c5d6', '#b1a34e', '#b17f4e', '#c88686']);\n\nfunction getSvgHeight() {\n  return focusHeight + contextChartHeight + swimlaneHeight + chartSpacing + margin.top + margin.bottom;\n}\n\nvar TimeseriesChartIntl = (0, _react3.injectI18n)((_temp = _class = function (_React$Component) {\n  _inherits(TimeseriesChart, _React$Component);\n\n  function TimeseriesChart() {\n    _classCallCheck(this, TimeseriesChart);\n\n    return _possibleConstructorReturn(this, (TimeseriesChart.__proto__ || Object.getPrototypeOf(TimeseriesChart)).apply(this, arguments));\n  }\n\n  _createClass(TimeseriesChart, [{\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var element = _d2.default.select(this.rootNode);\n      element.html('');\n\n      _table_service.mlTableService.rowMouseenter.unwatch(this.tableRecordMousenterListener);\n      _table_service.mlTableService.rowMouseleave.unwatch(this.tableRecordMouseleaveListener);\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props = this.props,\n          annotationsEnabled = _props.annotationsEnabled,\n          svgWidth = _props.svgWidth;\n\n\n      this.vizWidth = svgWidth - margin.left - margin.right;\n      var vizWidth = this.vizWidth;\n\n      this.focusXScale = _d2.default.time.scale().range([0, vizWidth]);\n      this.focusYScale = _d2.default.scale.linear().range([focusHeight, focusZoomPanelHeight]);\n      var focusXScale = this.focusXScale;\n      var focusYScale = this.focusYScale;\n\n      this.focusXAxis = _d2.default.svg.axis().scale(focusXScale).orient('bottom').innerTickSize(-focusChartHeight).outerTickSize(0).tickPadding(10);\n      this.focusYAxis = _d2.default.svg.axis().scale(focusYScale).orient('left').innerTickSize(-vizWidth).outerTickSize(0).tickPadding(10);\n\n      this.focusValuesLine = _d2.default.svg.line().x(function (d) {\n        return focusXScale(d.date);\n      }).y(function (d) {\n        return focusYScale(d.value);\n      }).defined(function (d) {\n        return d.value !== null;\n      });\n      this.focusBoundedArea = _d2.default.svg.area().x(function (d) {\n        return focusXScale(d.date) || 1;\n      }).y0(function (d) {\n        return focusYScale(d.upper);\n      }).y1(function (d) {\n        return focusYScale(d.lower);\n      }).defined(function (d) {\n        return d.lower !== null && d.upper !== null;\n      });\n\n      this.contextXScale = _d2.default.time.scale().range([0, vizWidth]);\n      this.contextYScale = _d2.default.scale.linear().range([contextChartHeight, contextChartLineTopMargin]);\n\n      this.fieldFormat = undefined;\n\n      // Annotations Brush\n      if (annotationsEnabled) {\n        this.annotateBrush = _timeseries_chart_annotations.getAnnotationBrush.call(this);\n      }\n\n      // brush for focus brushing\n      this.brush = _d2.default.svg.brush();\n\n      this.mask = undefined;\n\n      // Listeners for mouseenter/leave events for rows in the table\n      // to highlight the corresponding anomaly mark in the focus chart.\n      var highlightFocusChartAnomaly = this.highlightFocusChartAnomaly.bind(this);\n      var boundHighlightFocusChartAnnotation = _timeseries_chart_annotations.highlightFocusChartAnnotation.bind(this);\n      this.tableRecordMousenterListener = function (record) {\n        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'anomaly';\n\n        if (type === 'anomaly') {\n          highlightFocusChartAnomaly(record);\n        } else if (type === 'annotation') {\n          boundHighlightFocusChartAnnotation(record);\n        }\n      };\n\n      var unhighlightFocusChartAnomaly = this.unhighlightFocusChartAnomaly.bind(this);\n      var boundUnhighlightFocusChartAnnotation = _timeseries_chart_annotations.unhighlightFocusChartAnnotation.bind(this);\n      this.tableRecordMouseleaveListener = function (record) {\n        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'anomaly';\n\n        if (type === 'anomaly') {\n          unhighlightFocusChartAnomaly(record);\n        } else {\n          boundUnhighlightFocusChartAnnotation(record);\n        }\n      };\n\n      _table_service.mlTableService.rowMouseenter.watch(this.tableRecordMousenterListener);\n      _table_service.mlTableService.rowMouseleave.watch(this.tableRecordMouseleaveListener);\n\n      this.renderChart();\n      this.drawContextChartSelection();\n      this.renderFocusChart();\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      if (this.props.renderFocusChartOnly === false) {\n        this.renderChart();\n        this.drawContextChartSelection();\n      }\n\n      this.renderFocusChart();\n\n      if (this.props.annotationsEnabled && this.props.annotation === null) {\n        var chartElement = _d2.default.select(this.rootNode);\n        chartElement.select('g.mlAnnotationBrush').call(this.annotateBrush.extent([0, 0]));\n      }\n    }\n  }, {\n    key: 'renderChart',\n    value: function renderChart() {\n      var _props2 = this.props,\n          annotationsEnabled = _props2.annotationsEnabled,\n          contextChartData = _props2.contextChartData,\n          contextForecastData = _props2.contextForecastData,\n          detectorIndex = _props2.detectorIndex,\n          modelPlotEnabled = _props2.modelPlotEnabled,\n          selectedJob = _props2.selectedJob,\n          svgWidth = _props2.svgWidth;\n\n\n      var createFocusChart = this.createFocusChart.bind(this);\n      var drawContextElements = this.drawContextElements.bind(this);\n      var focusXScale = this.focusXScale;\n      var focusYAxis = this.focusYAxis;\n      var focusYScale = this.focusYScale;\n\n      var svgHeight = getSvgHeight();\n\n      // Clear any existing elements from the visualization,\n      // then build the svg elements for the bubble chart.\n      var chartElement = _d2.default.select(this.rootNode);\n      chartElement.selectAll('*').remove();\n\n      if (typeof selectedJob !== 'undefined') {\n        this.fieldFormat = _field_format_service.mlFieldFormatService.getFieldFormat(selectedJob.job_id, detectorIndex);\n      } else {\n        return;\n      }\n\n      if (contextChartData === undefined) {\n        return;\n      }\n\n      var fieldFormat = this.fieldFormat;\n\n      var svg = chartElement.append('svg').attr('width', svgWidth).attr('height', svgHeight);\n\n      var contextDataMin = void 0;\n      var contextDataMax = void 0;\n      if (modelPlotEnabled === true || contextForecastData !== undefined && contextForecastData.length > 0) {\n        var combinedData = contextForecastData === undefined ? contextChartData : contextChartData.concat(contextForecastData);\n\n        contextDataMin = _d2.default.min(combinedData, function (d) {\n          return Math.min(d.value, d.lower);\n        });\n        contextDataMax = _d2.default.max(combinedData, function (d) {\n          return Math.max(d.value, d.upper);\n        });\n      } else {\n        contextDataMin = _d2.default.min(contextChartData, function (d) {\n          return d.value;\n        });\n        contextDataMax = _d2.default.max(contextChartData, function (d) {\n          return d.value;\n        });\n      }\n\n      // Set the size of the left margin according to the width of the largest y axis tick label.\n      // The min / max of the aggregated context chart data may be less than the min / max of the\n      // data which is displayed in the focus chart which is likely to be plotted at a lower\n      // aggregation interval. Therefore ceil the min / max with the higher absolute value to allow\n      // for extra space for chart labels which may have higher values than the context data\n      // e.g. aggregated max may be 9500, whereas focus plot max may be 11234.\n      var ceiledMax = contextDataMax > 0 ? Math.pow(10, Math.ceil(Math.log10(Math.abs(contextDataMax)))) : contextDataMax;\n\n      var flooredMin = contextDataMin >= 0 ? contextDataMin : -1 * Math.pow(10, Math.ceil(Math.log10(Math.abs(contextDataMin))));\n\n      // Temporarily set the domain of the focus y axis to the min / max of the full context chart\n      // data range so that we can measure the maximum tick label width on temporary text elements.\n      focusYScale.domain([flooredMin, ceiledMax]);\n\n      var maxYAxisLabelWidth = 0;\n      var tempLabelText = svg.append('g').attr('class', 'temp-axis-label tick');\n      tempLabelText.selectAll('text.temp.axis').data(focusYScale.ticks()).enter().append('text').text(function (d) {\n        if (fieldFormat !== undefined) {\n          return fieldFormat.convert(d, 'text');\n        } else {\n          return focusYScale.tickFormat()(d);\n        }\n      }).each(function () {\n        maxYAxisLabelWidth = Math.max(this.getBBox().width + focusYAxis.tickPadding(), maxYAxisLabelWidth);\n      }).remove();\n      _d2.default.select('.temp-axis-label').remove();\n\n      margin.left = Math.max(maxYAxisLabelWidth, 40);\n      this.vizWidth = Math.max(svgWidth - margin.left - margin.right, 0);\n      focusXScale.range([0, this.vizWidth]);\n      focusYAxis.innerTickSize(-this.vizWidth);\n\n      var focus = svg.append('g').attr('class', 'focus-chart').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n      var context = svg.append('g').attr('class', 'context-chart').attr('transform', 'translate(' + margin.left + ',' + (focusHeight + margin.top + chartSpacing) + ')');\n\n      // Mask to hide annotations overflow\n      if (annotationsEnabled) {\n        var annotationsMask = svg.append('defs').append('mask').attr('id', _timeseries_chart_annotations.ANNOTATION_MASK_ID);\n\n        annotationsMask.append('rect').attr('x', 0).attr('y', 0).attr('width', this.vizWidth).attr('height', focusHeight).style('fill', 'white');\n      }\n\n      // Draw each of the component elements.\n      createFocusChart(focus, this.vizWidth, focusHeight);\n      drawContextElements(context, this.vizWidth, contextChartHeight, swimlaneHeight);\n    }\n  }, {\n    key: 'drawContextChartSelection',\n    value: function drawContextChartSelection() {\n      var _props3 = this.props,\n          contextChartData = _props3.contextChartData,\n          contextChartSelected = _props3.contextChartSelected,\n          contextForecastData = _props3.contextForecastData,\n          zoomFrom = _props3.zoomFrom,\n          zoomTo = _props3.zoomTo;\n\n\n      if (contextChartData === undefined) {\n        return;\n      }\n\n      var setContextBrushExtent = this.setContextBrushExtent.bind(this);\n\n      // Make appropriate selection in the context chart to trigger loading of the focus chart.\n      var focusLoadFrom = void 0;\n      var focusLoadTo = void 0;\n      var contextXMin = this.contextXScale.domain()[0].getTime();\n      var contextXMax = this.contextXScale.domain()[1].getTime();\n\n      var combinedData = contextChartData;\n      if (contextForecastData !== undefined) {\n        combinedData = combinedData.concat(contextForecastData);\n      }\n\n      if (zoomFrom) {\n        focusLoadFrom = zoomFrom.getTime();\n      } else {\n        focusLoadFrom = _lodash2.default.reduce(combinedData, function (memo, point) {\n          return Math.min(memo, point.date.getTime());\n        }, new Date(2099, 12, 31).getTime());\n      }\n      focusLoadFrom = Math.max(focusLoadFrom, contextXMin);\n\n      if (zoomTo) {\n        focusLoadTo = zoomTo.getTime();\n      } else {\n        focusLoadTo = _lodash2.default.reduce(combinedData, function (memo, point) {\n          return Math.max(memo, point.date.getTime());\n        }, 0);\n      }\n      focusLoadTo = Math.min(focusLoadTo, contextXMax);\n\n      if (focusLoadFrom !== contextXMin || focusLoadTo !== contextXMax) {\n        setContextBrushExtent(new Date(focusLoadFrom), new Date(focusLoadTo), true);\n      } else {\n        // Don't set the brush if the selection is the full context chart domain.\n        this.setBrushVisibility(false);\n        var selectedBounds = this.contextXScale.domain();\n        this.selectedBounds = { min: (0, _moment2.default)(new Date(selectedBounds[0])), max: (0, _moment2.default)(selectedBounds[1]) };\n        contextChartSelected({ from: selectedBounds[0], to: selectedBounds[1] });\n      }\n    }\n  }, {\n    key: 'createFocusChart',\n    value: function createFocusChart(fcsGroup, fcsWidth, fcsHeight) {\n      // Split out creation of the focus chart from the rendering,\n      // as we want to re-render the paths and points when the zoom area changes.\n\n      var _props4 = this.props,\n          annotationsEnabled = _props4.annotationsEnabled,\n          contextForecastData = _props4.contextForecastData;\n\n      // Add a group at the top to display info on the chart aggregation interval\n      // and links to set the brush span to 1h, 1d, 1w etc.\n\n      var zoomGroup = fcsGroup.append('g').attr('class', 'focus-zoom');\n      zoomGroup.append('rect').attr('x', 0).attr('y', 0).attr('width', fcsWidth).attr('height', focusZoomPanelHeight).attr('class', 'chart-border');\n      this.createZoomInfoElements(zoomGroup, fcsWidth);\n\n      // Create the elements for annotations\n      if (annotationsEnabled) {\n        var annotateBrush = this.annotateBrush.bind(this);\n\n        fcsGroup.append('g').attr('class', 'mlAnnotationBrush').call(annotateBrush).selectAll('rect').attr('x', 0).attr('y', focusZoomPanelHeight).attr('height', focusChartHeight);\n\n        fcsGroup.append('g').classed('mlAnnotations', true);\n      }\n\n      // Add border round plot area.\n      fcsGroup.append('rect').attr('x', 0).attr('y', focusZoomPanelHeight).attr('width', fcsWidth).attr('height', focusChartHeight).attr('class', 'chart-border');\n\n      // Add background for x axis.\n      var xAxisBg = fcsGroup.append('g').attr('class', 'x-axis-background');\n      xAxisBg.append('rect').attr('x', 0).attr('y', fcsHeight).attr('width', fcsWidth).attr('height', chartSpacing);\n      xAxisBg.append('line').attr('x1', 0).attr('y1', fcsHeight).attr('x2', 0).attr('y2', fcsHeight + chartSpacing);\n      xAxisBg.append('line').attr('x1', fcsWidth).attr('y1', fcsHeight).attr('x2', fcsWidth).attr('y2', fcsHeight + chartSpacing);\n      xAxisBg.append('line').attr('x1', 0).attr('y1', fcsHeight + chartSpacing).attr('x2', fcsWidth).attr('y2', fcsHeight + chartSpacing);\n\n      var axes = fcsGroup.append('g');\n      axes.append('g').attr('class', 'x axis').attr('transform', 'translate(0,' + fcsHeight + ')');\n      axes.append('g').attr('class', 'y axis');\n\n      // Create the elements for the metric value line and model bounds area.\n      fcsGroup.append('path').attr('class', 'area bounds');\n      fcsGroup.append('path').attr('class', 'values-line');\n      fcsGroup.append('g').attr('class', 'focus-chart-markers');\n\n      // Create the path elements for the forecast value line and bounds area.\n      if (contextForecastData) {\n        fcsGroup.append('path').attr('class', 'area forecast');\n        fcsGroup.append('path').attr('class', 'values-line forecast');\n        fcsGroup.append('g').attr('class', 'focus-chart-markers forecast');\n      }\n\n      fcsGroup.append('rect').attr('x', 0).attr('y', 0).attr('width', fcsWidth).attr('height', fcsHeight + 24).attr('class', 'chart-border chart-border-highlight');\n    }\n  }, {\n    key: 'renderFocusChart',\n    value: function renderFocusChart() {\n      var _this2 = this;\n\n      var _props5 = this.props,\n          annotationsEnabled = _props5.annotationsEnabled,\n          focusAggregationInterval = _props5.focusAggregationInterval,\n          focusAnnotationData = _props5.focusAnnotationData,\n          focusChartData = _props5.focusChartData,\n          focusForecastData = _props5.focusForecastData,\n          modelPlotEnabled = _props5.modelPlotEnabled,\n          selectedJob = _props5.selectedJob,\n          showAnnotations = _props5.showAnnotations,\n          showForecast = _props5.showForecast,\n          showModelBounds = _props5.showModelBounds,\n          intl = _props5.intl;\n\n\n      if (focusChartData === undefined) {\n        return;\n      }\n\n      var data = focusChartData;\n\n      var contextYScale = this.contextYScale;\n      var showFocusChartTooltip = this.showFocusChartTooltip.bind(this);\n\n      var focusChart = _d2.default.select('.focus-chart');\n\n      // Update the plot interval labels.\n      var focusAggInt = focusAggregationInterval.expression;\n      var bucketSpan = selectedJob.analysis_config.bucket_span;\n      var chartElement = _d2.default.select(this.rootNode);\n      chartElement.select('.zoom-aggregation-interval').text(intl.formatMessage({\n        id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.zoomAggregationIntervalLabel',\n        defaultMessage: '(aggregation interval: {focusAggInt}, bucket span: {bucketSpan})'\n      }, { focusAggInt: focusAggInt, bucketSpan: bucketSpan }));\n\n      // Render the axes.\n\n      // Calculate the x axis domain.\n      // Elasticsearch aggregation returns points at start of bucket,\n      // so set the x-axis min to the start of the first aggregation interval,\n      // and the x-axis max to the end of the last aggregation interval.\n      var bounds = this.selectedBounds;\n      if (typeof bounds === 'undefined') {\n        return;\n      }\n      var aggMs = focusAggregationInterval.asMilliseconds();\n      var earliest = (0, _moment2.default)(Math.floor(bounds.min.valueOf() / aggMs) * aggMs);\n      var latest = (0, _moment2.default)(Math.ceil(bounds.max.valueOf() / aggMs) * aggMs);\n      this.focusXScale.domain([earliest.toDate(), latest.toDate()]);\n\n      // Calculate the y-axis domain.\n      if (focusChartData.length > 0 || focusForecastData !== undefined && focusForecastData.length > 0) {\n        if (this.fieldFormat !== undefined) {\n          this.focusYAxis.tickFormat(function (d) {\n            return _this2.fieldFormat.convert(d, 'text');\n          });\n        } else {\n          // Use default tick formatter.\n          this.focusYAxis.tickFormat(null);\n        }\n\n        // Calculate the min/max of the metric data and the forecast data.\n        var yMin = 0;\n        var yMax = 0;\n\n        var combinedData = data;\n        if (focusForecastData !== undefined && focusForecastData.length > 0) {\n          combinedData = data.concat(focusForecastData);\n        }\n\n        yMin = _d2.default.min(combinedData, function (d) {\n          var metricValue = d.value;\n          if (metricValue === null && d.anomalyScore !== undefined && d.actual !== undefined) {\n            // If an anomaly coincides with a gap in the data, use the anomaly actual value.\n            metricValue = Array.isArray(d.actual) ? d.actual[0] : d.actual;\n          }\n          return d.lower !== undefined ? Math.min(metricValue, d.lower) : metricValue;\n        });\n        yMax = _d2.default.max(combinedData, function (d) {\n          var metricValue = d.value;\n          if (metricValue === null && d.anomalyScore !== undefined && d.actual !== undefined) {\n            // If an anomaly coincides with a gap in the data, use the anomaly actual value.\n            metricValue = Array.isArray(d.actual) ? d.actual[0] : d.actual;\n          }\n          return d.upper !== undefined ? Math.max(metricValue, d.upper) : metricValue;\n        });\n\n        if (yMax === yMin) {\n          if (this.contextYScale.domain()[0] !== contextYScale.domain()[1] && yMin >= contextYScale.domain()[0] && yMax <= contextYScale.domain()[1]) {\n            // Set the focus chart limits to be the same as the context chart.\n            yMin = contextYScale.domain()[0];\n            yMax = contextYScale.domain()[1];\n          } else {\n            yMin -= yMin * 0.05;\n            yMax += yMax * 0.05;\n          }\n        }\n\n        // if annotations are present, we extend yMax to avoid overlap\n        // between annotation labels, chart lines and anomalies.\n        if (annotationsEnabled && focusAnnotationData && focusAnnotationData.length > 0) {\n          var levels = (0, _timeseries_chart_annotations.getAnnotationLevels)(focusAnnotationData);\n          var maxLevel = _d2.default.max(Object.keys(levels).map(function (key) {\n            return levels[key];\n          }));\n          // TODO needs revisiting to be a more robust normalization\n          yMax = yMax * (1 + (maxLevel + 1) / 5);\n        }\n        this.focusYScale.domain([yMin, yMax]);\n      } else {\n        // Display 10 unlabelled ticks.\n        this.focusYScale.domain([0, 10]);\n        this.focusYAxis.tickFormat('');\n      }\n\n      // Get the scaled date format to use for x axis tick labels.\n      var timeBuckets = new _time_buckets.TimeBuckets();\n      timeBuckets.setInterval('auto');\n      timeBuckets.setBounds(bounds);\n      var xAxisTickFormat = timeBuckets.getScaledDateFormat();\n      focusChart.select('.x.axis').call(this.focusXAxis.ticks((0, _chart_utils.numTicksForDateFormat)(this.vizWidth), xAxisTickFormat).tickFormat(function (d) {\n        return (0, _moment2.default)(d).format(xAxisTickFormat);\n      }));\n      focusChart.select('.y.axis').call(this.focusYAxis);\n\n      (0, _chart_utils.filterAxisLabels)(focusChart.select('.x.axis'), this.vizWidth);\n\n      // Render the bounds area and values line.\n      if (modelPlotEnabled === true) {\n        focusChart.select('.area.bounds').attr('d', this.focusBoundedArea(data)).classed('hidden', !showModelBounds);\n      }\n\n      if (annotationsEnabled) {\n        (0, _timeseries_chart_annotations.renderAnnotations)(focusChart, focusAnnotationData, focusZoomPanelHeight, focusChartHeight, this.focusXScale, showAnnotations, showFocusChartTooltip);\n\n        // disable brushing (creation of annotations) when annotations aren't shown\n        focusChart.select('.mlAnnotationBrush').style('display', showAnnotations ? null : 'none');\n      }\n\n      focusChart.select('.values-line').attr('d', this.focusValuesLine(data));\n      (0, _chart_utils.drawLineChartDots)(data, focusChart, this.focusValuesLine);\n\n      // Render circle markers for the points.\n      // These are used for displaying tooltips on mouseover.\n      // Don't render dots where value=null (data gaps, with no anomalies)\n      // or for multi-bucket anomalies.\n      var dots = _d2.default.select('.focus-chart-markers').selectAll('.metric-value').data(data.filter(function (d) {\n        return (d.value !== null || typeof d.anomalyScore === 'number') && !(0, _chart_utils.showMultiBucketAnomalyMarker)(d);\n      }));\n\n      // Remove dots that are no longer needed i.e. if number of chart points has decreased.\n      dots.exit().remove();\n      // Create any new dots that are needed i.e. if number of chart points has increased.\n      dots.enter().append('circle').attr('r', _chart_utils.LINE_CHART_ANOMALY_RADIUS).on('mouseover', function (d) {\n        showFocusChartTooltip(d, this);\n      }).on('mouseout', function () {\n        return _chart_tooltip_service.mlChartTooltipService.hide();\n      });\n\n      // Update all dots to new positions.\n      dots.attr('cx', function (d) {\n        return _this2.focusXScale(d.date);\n      }).attr('cy', function (d) {\n        return _this2.focusYScale(d.value);\n      }).attr('class', function (d) {\n        var markerClass = 'metric-value';\n        if (_lodash2.default.has(d, 'anomalyScore')) {\n          markerClass += ' anomaly-marker ' + (0, _anomaly_utils.getSeverityWithLow)(d.anomalyScore).id;\n        }\n        return markerClass;\n      });\n\n      // Render cross symbols for any multi-bucket anomalies.\n      var multiBucketMarkers = _d2.default.select('.focus-chart-markers').selectAll('.multi-bucket').data(data.filter(function (d) {\n        return d.anomalyScore !== null && (0, _chart_utils.showMultiBucketAnomalyMarker)(d) === true;\n      }));\n\n      // Remove multi-bucket markers that are no longer needed.\n      multiBucketMarkers.exit().remove();\n\n      // Add any new markers that are needed i.e. if number of multi-bucket points has increased.\n      multiBucketMarkers.enter().append('path').attr('d', _d2.default.svg.symbol().size(_chart_utils.MULTI_BUCKET_SYMBOL_SIZE).type('cross')).on('mouseover', function (d) {\n        showFocusChartTooltip(d, this);\n      }).on('mouseout', function () {\n        return _chart_tooltip_service.mlChartTooltipService.hide();\n      });\n\n      // Update all markers to new positions.\n      multiBucketMarkers.attr('transform', function (d) {\n        return 'translate(' + _this2.focusXScale(d.date) + ', ' + _this2.focusYScale(d.value) + ')';\n      }).attr('class', function (d) {\n        return 'anomaly-marker multi-bucket ' + (0, _anomaly_utils.getSeverityWithLow)(d.anomalyScore).id;\n      });\n\n      // Add rectangular markers for any scheduled events.\n      var scheduledEventMarkers = _d2.default.select('.focus-chart-markers').selectAll('.scheduled-event-marker').data(data.filter(function (d) {\n        return d.scheduledEvents !== undefined;\n      }));\n\n      // Remove markers that are no longer needed i.e. if number of chart points has decreased.\n      scheduledEventMarkers.exit().remove();\n\n      // Create any new markers that are needed i.e. if number of chart points has increased.\n      scheduledEventMarkers.enter().append('rect').attr('width', _chart_utils.LINE_CHART_ANOMALY_RADIUS * 2).attr('height', _chart_utils.SCHEDULED_EVENT_SYMBOL_HEIGHT).attr('class', 'scheduled-event-marker').attr('rx', 1).attr('ry', 1);\n\n      // Update all markers to new positions.\n      scheduledEventMarkers.attr('x', function (d) {\n        return _this2.focusXScale(d.date) - _chart_utils.LINE_CHART_ANOMALY_RADIUS;\n      }).attr('y', function (d) {\n        return _this2.focusYScale(d.value) - 3;\n      });\n\n      // Plot any forecast data in scope.\n      if (focusForecastData !== undefined) {\n        focusChart.select('.area.forecast').attr('d', this.focusBoundedArea(focusForecastData)).classed('hidden', !showForecast);\n        focusChart.select('.values-line.forecast').attr('d', this.focusValuesLine(focusForecastData)).classed('hidden', !showForecast);\n\n        var forecastDots = _d2.default.select('.focus-chart-markers.forecast').selectAll('.metric-value').data(focusForecastData);\n\n        // Remove dots that are no longer needed i.e. if number of forecast points has decreased.\n        forecastDots.exit().remove();\n        // Create any new dots that are needed i.e. if number of forecast points has increased.\n        forecastDots.enter().append('circle').attr('r', _chart_utils.LINE_CHART_ANOMALY_RADIUS).on('mouseover', function (d) {\n          showFocusChartTooltip(d, this);\n        }).on('mouseout', function () {\n          return _chart_tooltip_service.mlChartTooltipService.hide();\n        });\n\n        // Update all dots to new positions.\n        forecastDots.attr('cx', function (d) {\n          return _this2.focusXScale(d.date);\n        }).attr('cy', function (d) {\n          return _this2.focusYScale(d.value);\n        }).attr('class', 'metric-value').classed('hidden', !showForecast);\n      }\n    }\n  }, {\n    key: 'createZoomInfoElements',\n    value: function createZoomInfoElements(zoomGroup, fcsWidth) {\n      var _props6 = this.props,\n          autoZoomDuration = _props6.autoZoomDuration,\n          modelPlotEnabled = _props6.modelPlotEnabled,\n          timefilter = _props6.timefilter,\n          intl = _props6.intl;\n\n\n      var setZoomInterval = this.setZoomInterval.bind(this);\n\n      // Create zoom duration links applicable for the current time span.\n      // Don't add links for any durations which would give a brush extent less than 10px.\n      var bounds = timefilter.getActiveBounds();\n      var boundsSecs = bounds.max.unix() - bounds.min.unix();\n      var minSecs = 10 / this.vizWidth * boundsSecs;\n\n      var xPos = 10;\n      var zoomLabel = zoomGroup.append('text').attr('x', xPos).attr('y', 17).attr('class', 'zoom-info-text').text(intl.formatMessage({\n        id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.zoomLabel',\n        defaultMessage: 'Zoom:'\n      }));\n\n      var zoomOptions = [{ durationMs: autoZoomDuration, label: 'auto' }];\n      _lodash2.default.each(ZOOM_INTERVAL_OPTIONS, function (option) {\n        if (option.duration.asSeconds() > minSecs && option.duration.asSeconds() < boundsSecs) {\n          zoomOptions.push({ durationMs: option.duration.asMilliseconds(), label: option.label });\n        }\n      });\n      xPos += zoomLabel.node().getBBox().width + 4;\n\n      _lodash2.default.each(zoomOptions, function (option) {\n        var text = zoomGroup.append('a').attr('data-ms', option.durationMs).attr('href', '').append('text').attr('x', xPos).attr('y', 17).attr('class', 'zoom-info-text').text(option.label);\n\n        xPos += text.node().getBBox().width + 4;\n      });\n\n      zoomGroup.append('text').attr('x', xPos + 6).attr('y', 17).attr('class', 'zoom-info-text zoom-aggregation-interval').text(intl.formatMessage({\n        id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.zoomGroupAggregationIntervalLabel',\n        defaultMessage: '(aggregation interval: , bucket span: )'\n      }));\n\n      if (modelPlotEnabled === false) {\n        var modelPlotLabel = zoomGroup.append('text').attr('x', 300).attr('y', 17).attr('class', 'zoom-info-text').text(intl.formatMessage({\n          id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.modelBoundsNotAvailableLabel',\n          defaultMessage: 'Model bounds are not available'\n        }));\n\n        modelPlotLabel.attr('x', fcsWidth - (modelPlotLabel.node().getBBox().width + 10));\n      }\n\n      var chartElement = _d2.default.select(this.rootNode);\n      chartElement.selectAll('.focus-zoom a').on('click', function () {\n        _d2.default.event.preventDefault();\n        setZoomInterval(_d2.default.select(this).attr('data-ms'));\n      });\n    }\n  }, {\n    key: 'drawContextElements',\n    value: function drawContextElements(cxtGroup, cxtWidth, cxtChartHeight, swlHeight) {\n      var _this3 = this;\n\n      var _props7 = this.props,\n          contextChartData = _props7.contextChartData,\n          contextForecastData = _props7.contextForecastData,\n          modelPlotEnabled = _props7.modelPlotEnabled,\n          timefilter = _props7.timefilter;\n\n\n      var data = contextChartData;\n\n      var calculateContextXAxisDomain = this.calculateContextXAxisDomain.bind(this);\n      var drawContextBrush = this.drawContextBrush.bind(this);\n      var drawSwimlane = this.drawSwimlane.bind(this);\n\n      this.contextXScale = _d2.default.time.scale().range([0, cxtWidth]).domain(calculateContextXAxisDomain());\n\n      var combinedData = contextForecastData === undefined ? data : data.concat(contextForecastData);\n      var valuesRange = { min: Number.MAX_VALUE, max: Number.MIN_VALUE };\n      _lodash2.default.each(combinedData, function (item) {\n        valuesRange.min = Math.min(item.value, valuesRange.min);\n        valuesRange.max = Math.max(item.value, valuesRange.max);\n      });\n      var dataMin = valuesRange.min;\n      var dataMax = valuesRange.max;\n      var chartLimits = { min: dataMin, max: dataMax };\n\n      if (modelPlotEnabled === true || contextForecastData !== undefined && contextForecastData.length > 0) {\n        var boundsRange = { min: Number.MAX_VALUE, max: Number.MIN_VALUE };\n        _lodash2.default.each(combinedData, function (item) {\n          boundsRange.min = Math.min(item.lower, boundsRange.min);\n          boundsRange.max = Math.max(item.upper, boundsRange.max);\n        });\n        dataMin = Math.min(dataMin, boundsRange.min);\n        dataMax = Math.max(dataMax, boundsRange.max);\n\n        // Set the y axis domain so that the range of actual values takes up at least 50% of the full range.\n        if (valuesRange.max - valuesRange.min < 0.5 * (dataMax - dataMin)) {\n          if (valuesRange.min > dataMin) {\n            chartLimits.min = valuesRange.min - 0.5 * (valuesRange.max - valuesRange.min);\n          }\n\n          if (valuesRange.max < dataMax) {\n            chartLimits.max = valuesRange.max + 0.5 * (valuesRange.max - valuesRange.min);\n          }\n        }\n      }\n\n      this.contextYScale = _d2.default.scale.linear().range([cxtChartHeight, contextChartLineTopMargin]).domain([chartLimits.min, chartLimits.max]);\n\n      var borders = cxtGroup.append('g').attr('class', 'axis');\n\n      // Add borders left and right.\n      borders.append('line').attr('x1', 0).attr('y1', 0).attr('x2', 0).attr('y2', cxtChartHeight + swlHeight);\n      borders.append('line').attr('x1', cxtWidth).attr('y1', 0).attr('x2', cxtWidth).attr('y2', cxtChartHeight + swlHeight);\n\n      // Add x axis.\n      var bounds = timefilter.getActiveBounds();\n      var timeBuckets = new _time_buckets.TimeBuckets();\n      timeBuckets.setInterval('auto');\n      timeBuckets.setBounds(bounds);\n      var xAxisTickFormat = timeBuckets.getScaledDateFormat();\n      var xAxis = _d2.default.svg.axis().scale(this.contextXScale).orient('top').innerTickSize(-cxtChartHeight).outerTickSize(0).tickPadding(0).ticks((0, _chart_utils.numTicksForDateFormat)(cxtWidth, xAxisTickFormat)).tickFormat(function (d) {\n        return (0, _moment2.default)(d).format(xAxisTickFormat);\n      });\n\n      cxtGroup.datum(data);\n\n      var contextBoundsArea = _d2.default.svg.area().x(function (d) {\n        return _this3.contextXScale(d.date);\n      }).y0(function (d) {\n        return _this3.contextYScale(Math.min(chartLimits.max, Math.max(d.lower, chartLimits.min)));\n      }).y1(function (d) {\n        return _this3.contextYScale(Math.max(chartLimits.min, Math.min(d.upper, chartLimits.max)));\n      }).defined(function (d) {\n        return d.lower !== null && d.upper !== null;\n      });\n\n      if (modelPlotEnabled === true) {\n        cxtGroup.append('path').datum(data).attr('class', 'area context').attr('d', contextBoundsArea);\n      }\n\n      var contextValuesLine = _d2.default.svg.line().x(function (d) {\n        return _this3.contextXScale(d.date);\n      }).y(function (d) {\n        return _this3.contextYScale(d.value);\n      }).defined(function (d) {\n        return d.value !== null;\n      });\n\n      cxtGroup.append('path').datum(data).attr('class', 'values-line').attr('d', contextValuesLine);\n      (0, _chart_utils.drawLineChartDots)(data, cxtGroup, contextValuesLine, 1);\n\n      // Create the path elements for the forecast value line and bounds area.\n      if (contextForecastData !== undefined) {\n        cxtGroup.append('path').datum(contextForecastData).attr('class', 'area forecast').attr('d', contextBoundsArea);\n        cxtGroup.append('path').datum(contextForecastData).attr('class', 'values-line forecast').attr('d', contextValuesLine);\n      }\n\n      // Create and draw the anomaly swimlane.\n      var swimlane = cxtGroup.append('g').attr('class', 'swimlane').attr('transform', 'translate(0,' + cxtChartHeight + ')');\n\n      drawSwimlane(swimlane, cxtWidth, swlHeight);\n\n      // Draw a mask over the sections of the context chart and swimlane\n      // which fall outside of the zoom brush selection area.\n      this.mask = new _context_chart_mask.ContextChartMask(cxtGroup, contextChartData, modelPlotEnabled, swlHeight).x(this.contextXScale).y(this.contextYScale);\n\n      // Draw the x axis on top of the mask so that the labels are visible.\n      cxtGroup.append('g').attr('class', 'x axis context-chart-axis').call(xAxis);\n\n      // Move the x axis labels up so that they are inside the contact chart area.\n      cxtGroup.selectAll('.x.context-chart-axis text').attr('dy', cxtChartHeight - 5);\n\n      (0, _chart_utils.filterAxisLabels)(cxtGroup.selectAll('.x.context-chart-axis'), cxtWidth);\n\n      drawContextBrush(cxtGroup);\n    }\n  }, {\n    key: 'drawContextBrush',\n    value: function drawContextBrush(contextGroup) {\n      var contextChartSelected = this.props.contextChartSelected;\n\n\n      var brush = this.brush;\n      var contextXScale = this.contextXScale;\n      var setBrushVisibility = this.setBrushVisibility.bind(this);\n      var mask = this.mask;\n\n      // Create the brush for zooming in to the focus area of interest.\n      brush.x(contextXScale).on('brush', brushing).on('brushend', brushed);\n\n      contextGroup.append('g').attr('class', 'x brush').call(brush).selectAll('rect').attr('y', -1).attr('height', contextChartHeight + swimlaneHeight + 1);\n\n      // move the left and right resize areas over to\n      // be under the handles\n      contextGroup.selectAll('.w rect').attr('x', -10).attr('width', 10);\n\n      contextGroup.selectAll('.e rect').attr('x', 0).attr('width', 10);\n\n      var topBorder = contextGroup.append('rect').attr('class', 'top-border').attr('y', -2).attr('height', contextChartLineTopMargin);\n\n      // Draw the brush handles using SVG foreignObject elements.\n      // Note these are not supported on IE11 and below, so will not appear in IE.\n      var leftHandle = contextGroup.append('foreignObject').attr('width', 10).attr('height', 90).attr('class', 'brush-handle').html('<div class=\"brush-handle-inner brush-handle-inner-left\"><i class=\"fa fa-caret-left\"></i></div>');\n      var rightHandle = contextGroup.append('foreignObject').attr('width', 10).attr('height', 90).attr('class', 'brush-handle').html('<div class=\"brush-handle-inner brush-handle-inner-right\"><i class=\"fa fa-caret-right\"></i></div>');\n\n      setBrushVisibility(!brush.empty());\n\n      function showBrush(show) {\n        if (show === true) {\n          var brushExtent = brush.extent();\n          mask.reveal(brushExtent);\n          leftHandle.attr('x', contextXScale(brushExtent[0]) - 10);\n          rightHandle.attr('x', contextXScale(brushExtent[1]) + 0);\n\n          topBorder.attr('x', contextXScale(brushExtent[0]) + 1);\n          topBorder.attr('width', contextXScale(brushExtent[1]) - contextXScale(brushExtent[0]) - 2);\n        }\n\n        setBrushVisibility(show);\n      }\n\n      function brushing() {\n        var isEmpty = brush.empty();\n        showBrush(!isEmpty);\n      }\n\n      var that = this;\n      function brushed() {\n        var isEmpty = brush.empty();\n        showBrush(!isEmpty);\n\n        var selectedBounds = isEmpty ? contextXScale.domain() : brush.extent();\n        var selectionMin = selectedBounds[0].getTime();\n        var selectionMax = selectedBounds[1].getTime();\n\n        // Set the color of the swimlane cells according to whether they are inside the selection.\n        contextGroup.selectAll('.swimlane-cell').style('fill', function (d) {\n          var cellMs = d.date.getTime();\n          if (cellMs < selectionMin || cellMs > selectionMax) {\n            return anomalyGrayScale(d.score);\n          } else {\n            return anomalyColorScale(d.score);\n          }\n        });\n\n        that.selectedBounds = { min: (0, _moment2.default)(selectionMin), max: (0, _moment2.default)(selectionMax) };\n        contextChartSelected({ from: selectedBounds[0], to: selectedBounds[1] });\n      }\n    }\n  }, {\n    key: 'setBrushVisibility',\n    value: function setBrushVisibility(show) {\n      var mask = this.mask;\n\n      if (mask !== undefined) {\n        var visibility = show ? 'visible' : 'hidden';\n        mask.style('visibility', visibility);\n\n        _d2.default.selectAll('.brush').style('visibility', visibility);\n\n        var brushHandles = _d2.default.selectAll('.brush-handle-inner');\n        brushHandles.style('visibility', visibility);\n\n        var topBorder = _d2.default.selectAll('.top-border');\n        topBorder.style('visibility', visibility);\n\n        var border = _d2.default.selectAll('.chart-border-highlight');\n        border.style('visibility', visibility);\n      }\n    }\n  }, {\n    key: 'drawSwimlane',\n    value: function drawSwimlane(swlGroup, swlWidth, swlHeight) {\n      var _props8 = this.props,\n          contextAggregationInterval = _props8.contextAggregationInterval,\n          swimlaneData = _props8.swimlaneData;\n\n\n      var calculateContextXAxisDomain = this.calculateContextXAxisDomain.bind(this);\n\n      var data = swimlaneData;\n\n      if (typeof data === 'undefined') {\n        return;\n      }\n\n      // Calculate the x axis domain.\n      // Elasticsearch aggregation returns points at start of bucket, so set the\n      // x-axis min to the start of the aggregation interval.\n      // Need to use the min(earliest) and max(earliest) of the context chart\n      // aggregation to align the axes of the chart and swimlane elements.\n      var xAxisDomain = calculateContextXAxisDomain();\n      var x = _d2.default.time.scale().range([0, swlWidth]).domain(xAxisDomain);\n\n      var y = _d2.default.scale.linear().range([swlHeight, 0]).domain([0, swlHeight]);\n\n      var xAxis = _d2.default.svg.axis().scale(x).orient('bottom').innerTickSize(-swlHeight).outerTickSize(0);\n\n      var yAxis = _d2.default.svg.axis().scale(y).orient('left').tickValues(y.domain()).innerTickSize(-swlWidth).outerTickSize(0);\n\n      var axes = swlGroup.append('g');\n\n      axes.append('g').attr('class', 'x axis').attr('transform', 'translate(0,' + swlHeight + ')').call(xAxis);\n\n      axes.append('g').attr('class', 'y axis').call(yAxis);\n\n      var earliest = xAxisDomain[0].getTime();\n      var latest = xAxisDomain[1].getTime();\n      var swimlaneAggMs = contextAggregationInterval.asMilliseconds();\n      var cellWidth = swlWidth / ((latest - earliest) / swimlaneAggMs);\n      if (cellWidth < 1) {\n        cellWidth = 1;\n      }\n\n      var cells = swlGroup.append('g').attr('class', 'swimlane-cells').selectAll('rect').data(data);\n\n      cells.enter().append('rect').attr('x', function (d) {\n        return x(d.date);\n      }).attr('y', 0).attr('rx', 0).attr('ry', 0).attr('class', function (d) {\n        return d.score > 0 ? 'swimlane-cell' : 'swimlane-cell-hidden';\n      }).attr('width', cellWidth).attr('height', swlHeight).style('fill', function (d) {\n        return anomalyColorScale(d.score);\n      });\n    }\n  }, {\n    key: 'calculateContextXAxisDomain',\n    value: function calculateContextXAxisDomain() {\n      var _props9 = this.props,\n          contextAggregationInterval = _props9.contextAggregationInterval,\n          swimlaneData = _props9.swimlaneData,\n          timefilter = _props9.timefilter;\n      // Calculates the x axis domain for the context elements.\n      // Elasticsearch aggregation returns points at start of bucket,\n      // so set the x-axis min to the start of the first aggregation interval,\n      // and the x-axis max to the end of the last aggregation interval.\n      // Context chart and swimlane use the same aggregation interval.\n\n      var bounds = timefilter.getActiveBounds();\n      var earliest = bounds.min.valueOf();\n\n      if (swimlaneData !== undefined && swimlaneData.length > 0) {\n        // Adjust the earliest back to the time of the first swimlane point\n        // if this is before the time filter minimum.\n        earliest = Math.min(_lodash2.default.first(swimlaneData).date.getTime(), bounds.min.valueOf());\n      }\n\n      var contextAggMs = contextAggregationInterval.asMilliseconds();\n      var earliestMs = Math.floor(earliest / contextAggMs) * contextAggMs;\n      var latestMs = Math.ceil(bounds.max.valueOf() / contextAggMs) * contextAggMs;\n\n      return [new Date(earliestMs), new Date(latestMs)];\n    }\n\n    // Sets the extent of the brush on the context chart to the\n    // supplied from and to Date objects.\n\n  }, {\n    key: 'setContextBrushExtent',\n    value: function setContextBrushExtent(from, to, fireEvent) {\n      var brush = this.brush;\n      brush.extent([from, to]);\n      brush(_d2.default.select('.brush'));\n      if (fireEvent) {\n        brush.event(_d2.default.select('.brush'));\n      }\n    }\n  }, {\n    key: 'setZoomInterval',\n    value: function setZoomInterval(ms) {\n      var _props10 = this.props,\n          timefilter = _props10.timefilter,\n          zoomTo = _props10.zoomTo;\n\n\n      var setContextBrushExtent = this.setContextBrushExtent.bind(this);\n\n      var bounds = timefilter.getActiveBounds();\n      var minBoundsMs = bounds.min.valueOf();\n      var maxBoundsMs = bounds.max.valueOf();\n\n      // Attempt to retain the same zoom end time.\n      // If not, go back to the bounds start and add on the required millis.\n      var millis = +ms;\n      var to = zoomTo.getTime();\n      var from = to - millis;\n      if (from < minBoundsMs) {\n        from = minBoundsMs;\n        to = Math.min(minBoundsMs + millis, maxBoundsMs);\n      }\n\n      setContextBrushExtent(new Date(from), new Date(to), true);\n    }\n  }, {\n    key: 'showFocusChartTooltip',\n    value: function showFocusChartTooltip(marker, circle) {\n      var _props11 = this.props,\n          annotationsEnabled = _props11.annotationsEnabled,\n          modelPlotEnabled = _props11.modelPlotEnabled,\n          intl = _props11.intl;\n\n\n      var fieldFormat = this.fieldFormat;\n\n      // Show the time and metric values in the tooltip.\n      // Uses date, value, upper, lower and anomalyScore (optional) marker properties.\n      var formattedDate = (0, _date_utils.formatHumanReadableDateTimeSeconds)(marker.date);\n      var contents = formattedDate + '<br/><hr/>';\n\n      if (_lodash2.default.has(marker, 'anomalyScore')) {\n        var score = parseInt(marker.anomalyScore);\n        var displayScore = score > 0 ? score : '< 1';\n        contents += intl.formatMessage({\n          id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.anomalyScoreLabel',\n          defaultMessage: 'anomaly score: {displayScore}{br}'\n        }, { displayScore: displayScore, br: '<br />' });\n\n        if ((0, _chart_utils.showMultiBucketAnomalyTooltip)(marker) === true) {\n          contents += intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.multiBucketImpactLabel',\n            defaultMessage: 'multi-bucket impact: {multiBucketImpactLabel}{br}'\n          }, {\n            br: '<br />',\n            multiBucketImpactLabel: (0, _anomaly_utils.getMultiBucketImpactLabel)(marker.multiBucketImpact)\n          });\n        }\n\n        if (modelPlotEnabled === false) {\n          // Show actual/typical when available except for rare detectors.\n          // Rare detectors always have 1 as actual and the probability as typical.\n          // Exposing those values in the tooltip with actual/typical labels might irritate users.\n          if (_lodash2.default.has(marker, 'actual') && marker.function !== 'rare') {\n            // Display the record actual in preference to the chart value, which may be\n            // different depending on the aggregation interval of the chart.\n            contents += intl.formatMessage({\n              id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.actualLabel',\n              defaultMessage: 'actual: {actualValue}'\n            }, {\n              actualValue: (0, _format_value.formatValue)(marker.actual, marker.function, fieldFormat)\n            });\n            contents += intl.formatMessage({\n              id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.typicalLabel',\n              defaultMessage: '{br}typical: {typicalValue}'\n            }, {\n              br: '<br />',\n              typicalValue: (0, _format_value.formatValue)(marker.typical, marker.function, fieldFormat)\n            });\n          } else {\n            contents += intl.formatMessage({\n              id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.valueLabel',\n              defaultMessage: 'value: {value}'\n            }, {\n              value: (0, _format_value.formatValue)(marker.value, marker.function, fieldFormat)\n            });\n            if (_lodash2.default.has(marker, 'byFieldName') && _lodash2.default.has(marker, 'numberOfCauses')) {\n              var numberOfCauses = marker.numberOfCauses;\n              // If numberOfCauses === 1, won't go into this block as actual/typical copied to top level fields.\n              var byFieldName = (0, _string_utils.mlEscape)(marker.byFieldName);\n              contents += intl.formatMessage({\n                id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.moreThanOneUnusualByFieldValuesLabel',\n                defaultMessage: '{br} {numberOfCauses}{plusSign} unusual {byFieldName} values'\n              }, {\n                br: '<br />',\n                numberOfCauses: numberOfCauses,\n                byFieldName: byFieldName,\n                // Maximum of 10 causes are stored in the record, so '10' may mean more than 10.\n                plusSign: numberOfCauses < 10 ? '' : '+'\n              });\n            }\n          }\n        } else {\n          contents += intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.modelPlotEnabled.valueLabel',\n            defaultMessage: 'value: {value}'\n          }, {\n            value: (0, _format_value.formatValue)(marker.value, marker.function, fieldFormat)\n          });\n          contents += intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.modelPlotEnabled.upperBoundsLabel',\n            defaultMessage: '{br}upper bounds: {upperBoundsValue}'\n          }, {\n            br: '<br />',\n            upperBoundsValue: (0, _format_value.formatValue)(marker.upper, marker.function, fieldFormat)\n          });\n          contents += intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.modelPlotEnabled.lowerBoundsLabel',\n            defaultMessage: '{br}lower bounds: {lowerBoundsValue}'\n          }, {\n            br: '<br />',\n            lowerBoundsValue: (0, _format_value.formatValue)(marker.lower, marker.function, fieldFormat)\n          });\n        }\n      } else {\n        // TODO - need better formatting for small decimals.\n        if (_lodash2.default.get(marker, 'isForecast', false) === true) {\n          contents += intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.withoutAnomalyScore.predictionLabel',\n            defaultMessage: 'prediction: {predictionValue}'\n          }, {\n            predictionValue: (0, _format_value.formatValue)(marker.value, marker.function, fieldFormat)\n          });\n        } else {\n          contents += intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.withoutAnomalyScore.valueLabel',\n            defaultMessage: 'value: {value}'\n          }, {\n            value: (0, _format_value.formatValue)(marker.value, marker.function, fieldFormat)\n          });\n        }\n\n        if (modelPlotEnabled === true) {\n          contents += intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.withoutAnomalyScoreAndModelPlotEnabled.upperBoundsLabel',\n            defaultMessage: '{br}upper bounds: {upperBoundsValue}'\n          }, {\n            br: '<br />',\n            upperBoundsValue: (0, _format_value.formatValue)(marker.upper, marker.function, fieldFormat)\n          });\n          contents += intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.withoutAnomalyScoreAndModelPlotEnabled.lowerBoundsLabel',\n            defaultMessage: '{br}lower bounds: {lowerBoundsValue}'\n          }, {\n            br: '<br />',\n            lowerBoundsValue: (0, _format_value.formatValue)(marker.lower, marker.function, fieldFormat)\n          });\n        }\n      }\n\n      if (_lodash2.default.has(marker, 'scheduledEvents')) {\n        contents += '<br/><hr/>' + intl.formatMessage({\n          id: 'xpack.ml.timeSeriesExplorer.timeSeriesChart.scheduledEventsLabel',\n          defaultMessage: 'Scheduled events:{br}{scheduledEventsValue}'\n        }, {\n          br: '<br />',\n          scheduledEventsValue: marker.scheduledEvents.map(_string_utils.mlEscape).join('<br/>')\n        });\n      }\n\n      if (annotationsEnabled && _lodash2.default.has(marker, 'annotation')) {\n        contents = (0, _string_utils.mlEscape)(marker.annotation);\n        contents += '<br />' + (0, _moment2.default)(marker.timestamp).format('MMMM Do YYYY, HH:mm');\n\n        if (typeof marker.end_timestamp !== 'undefined') {\n          contents += ' - ' + (0, _moment2.default)(marker.end_timestamp).format('MMMM Do YYYY, HH:mm');\n        }\n      }\n\n      _chart_tooltip_service.mlChartTooltipService.show(contents, circle, {\n        x: _chart_utils.LINE_CHART_ANOMALY_RADIUS * 2,\n        y: 0\n      });\n    }\n  }, {\n    key: 'highlightFocusChartAnomaly',\n    value: function highlightFocusChartAnomaly(record) {\n      // Highlights the anomaly marker in the focus chart corresponding to the specified record.\n\n      var focusChartData = this.props.focusChartData;\n\n\n      var focusXScale = this.focusXScale;\n      var focusYScale = this.focusYScale;\n      var showFocusChartTooltip = this.showFocusChartTooltip.bind(this);\n\n      // Find the anomaly marker which corresponds to the time of the anomaly record.\n      // Depending on the way the chart is aggregated, there may not be\n      // a point at exactly the same time as the record being highlighted.\n      var anomalyTime = record.source.timestamp;\n      var markerToSelect = (0, _timeseriesexplorer_utils.findChartPointForAnomalyTime)(focusChartData, anomalyTime);\n\n      // Render an additional highlighted anomaly marker on the focus chart.\n      // TODO - plot anomaly markers for cases where there is an anomaly due\n      // to the absence of data and model plot is enabled.\n      if (markerToSelect !== undefined) {\n        var selectedMarker = _d2.default.select('.focus-chart-markers').selectAll('.focus-chart-highlighted-marker').data([markerToSelect]);\n        if ((0, _chart_utils.showMultiBucketAnomalyMarker)(markerToSelect) === true) {\n          selectedMarker.enter().append('path').attr('d', _d2.default.svg.symbol().size(_chart_utils.MULTI_BUCKET_SYMBOL_SIZE).type('cross')).attr('transform', function (d) {\n            return 'translate(' + focusXScale(d.date) + ', ' + focusYScale(d.value) + ')';\n          }).attr('class', function (d) {\n            return 'anomaly-marker multi-bucket ' + (0, _anomaly_utils.getSeverityWithLow)(d.anomalyScore).id + ' highlighted';\n          });\n        } else {\n          selectedMarker.enter().append('circle').attr('r', _chart_utils.LINE_CHART_ANOMALY_RADIUS).attr('cx', function (d) {\n            return focusXScale(d.date);\n          }).attr('cy', function (d) {\n            return focusYScale(d.value);\n          }).attr('class', function (d) {\n            return 'anomaly-marker metric-value ' + (0, _anomaly_utils.getSeverityWithLow)(d.anomalyScore).id + ' highlighted';\n          });\n        }\n\n        // Display the chart tooltip for this marker.\n        // Note the values of the record and marker may differ depending on the levels of aggregation.\n        var chartElement = _d2.default.select(this.rootNode);\n        var anomalyMarker = chartElement.selectAll('.focus-chart-markers .anomaly-marker.highlighted');\n        if (anomalyMarker.length) {\n          showFocusChartTooltip(markerToSelect, anomalyMarker[0][0]);\n        }\n      }\n    }\n  }, {\n    key: 'unhighlightFocusChartAnomaly',\n    value: function unhighlightFocusChartAnomaly() {\n      _d2.default.select('.focus-chart-markers').selectAll('.anomaly-marker.highlighted').remove();\n      _chart_tooltip_service.mlChartTooltipService.hide();\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate() {\n      return true;\n    }\n  }, {\n    key: 'setRef',\n    value: function setRef(componentNode) {\n      this.rootNode = componentNode;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return _react2.default.createElement('div', { className: 'ml-timeseries-chart-react', ref: this.setRef.bind(this) });\n    }\n  }]);\n\n  return TimeseriesChart;\n}(_react2.default.Component), _class.propTypes = {\n  annotationsEnabled: _propTypes2.default.bool,\n  annotation: _propTypes2.default.object,\n  autoZoomDuration: _propTypes2.default.number,\n  contextAggregationInterval: _propTypes2.default.object,\n  contextChartData: _propTypes2.default.array,\n  contextForecastData: _propTypes2.default.array,\n  contextChartSelected: _propTypes2.default.func.isRequired,\n  detectorIndex: _propTypes2.default.string,\n  focusAggregationInterval: _propTypes2.default.object,\n  focusAnnotationData: _propTypes2.default.array,\n  focusChartData: _propTypes2.default.array,\n  focusForecastData: _propTypes2.default.array,\n  modelPlotEnabled: _propTypes2.default.bool.isRequired,\n  renderFocusChartOnly: _propTypes2.default.bool.isRequired,\n  selectedJob: _propTypes2.default.object,\n  showForecast: _propTypes2.default.bool.isRequired,\n  showModelBounds: _propTypes2.default.bool.isRequired,\n  svgWidth: _propTypes2.default.number.isRequired,\n  swimlaneData: _propTypes2.default.array,\n  timefilter: _propTypes2.default.object.isRequired,\n  zoomFrom: _propTypes2.default.object,\n  zoomTo: _propTypes2.default.object\n}, _temp));\n\nvar TimeseriesChart = exports.TimeseriesChart = (0, _observable_utils.injectObservablesAsProps)({ annotation: _annotations_service.annotation$ }, TimeseriesChartIntl);",null]}