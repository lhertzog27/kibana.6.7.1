{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/console/public/src/curl.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/console/public/src/curl.js","mtime":1567631691126},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.detectCURL = detectCURL;\nexports.parseCURL = parseCURL;\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nfunction detectCURLinLine(line) {\n  // returns true if text matches a curl request\n  return line.match(/^\\s*?curl\\s+(-X[A-Z]+)?\\s*['\"]?.*?['\"]?(\\s*$|\\s+?-d\\s*?['\"])/);\n}\n\nfunction detectCURL(text) {\n  // returns true if text matches a curl request\n  if (!text) return false;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = text.split('\\n')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var line = _step.value;\n\n      if (detectCURLinLine(line)) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction parseCURL(text) {\n  var state = 'NONE';\n  var out = [];\n  var body = [];\n  var line = '';\n  var lines = text.trim().split('\\n');\n  var matches = void 0;\n\n  var EmptyLine = /^\\s*$/;\n  var Comment = /^\\s*(?:#|\\/{2,})(.*)\\n?$/;\n  var ExecutionComment = /^\\s*#!/;\n  var ClosingSingleQuote = /^([^']*)'/;\n  var ClosingDoubleQuote = /^((?:[^\\\\\"]|\\\\.)*)\"/;\n  var EscapedQuotes = /^((?:[^\\\\\"']|\\\\.)+)/;\n\n  var LooksLikeCurl = /^\\s*curl\\s+/;\n  var CurlVerb = /-X ?(GET|HEAD|POST|PUT|DELETE)/;\n\n  var HasProtocol = /[\\s\"']https?:\\/\\//;\n  var CurlRequestWithProto = /[\\s\"']https?:\\/\\/[^\\/ ]+\\/+([^\\s\"']+)/;\n  var CurlRequestWithoutProto = /[\\s\"'][^\\/ ]+\\/+([^\\s\"']+)/;\n  var CurlData = /^.+\\s(--data|-d)\\s*/;\n  var SenseLine = /^\\s*(GET|HEAD|POST|PUT|DELETE)\\s+\\/?(.+)/;\n\n  if (lines.length > 0 && ExecutionComment.test(lines[0])) {\n    lines.shift();\n  }\n\n  function nextLine() {\n    if (line.length > 0) {\n      return true;\n    }\n    if (lines.length === 0) {\n      return false;\n    }\n    line = lines.shift().replace(/[\\r\\n]+/g, '\\n') + '\\n';\n    return true;\n  }\n\n  function unescapeLastBodyEl() {\n    var str = body.pop().replace(/\\\\([\\\\\"'])/g, '$1');\n    body.push(str);\n  }\n\n  // Is the next char a single or double quote?\n  // If so remove it\n  function detectQuote() {\n    if (line.substr(0, 1) === '\\'') {\n      line = line.substr(1);\n      state = 'SINGLE_QUOTE';\n    } else if (line.substr(0, 1) === '\"') {\n      line = line.substr(1);\n      state = 'DOUBLE_QUOTE';\n    } else {\n      state = 'UNQUOTED';\n    }\n  }\n\n  // Body is finished - append to output with final LF\n  function addBodyToOut() {\n    if (body.length > 0) {\n      out.push(body.join(''));\n      body = [];\n    }\n    state = 'LF';\n    out.push('\\n');\n  }\n\n  // If the pattern matches, then the state is about to change,\n  // so add the capture to the body and detect the next state\n  // Otherwise add the whole line\n  function consumeMatching(pattern) {\n    var matches = line.match(pattern);\n    if (matches) {\n      body.push(matches[1]);\n      line = line.substr(matches[0].length);\n      detectQuote();\n    } else {\n      body.push(line);\n      line = '';\n    }\n  }\n\n  function parseCurlLine() {\n    var verb = 'GET';\n    var request = '';\n    var matches = void 0;\n    if (matches = line.match(CurlVerb)) {\n      verb = matches[1];\n    }\n\n    // JS regexen don't support possessive quantifiers, so\n    // we need two distinct patterns\n    var pattern = HasProtocol.test(line) ? CurlRequestWithProto : CurlRequestWithoutProto;\n\n    if (matches = line.match(pattern)) {\n      request = matches[1];\n    }\n\n    out.push(verb + ' /' + request + '\\n');\n\n    if (matches = line.match(CurlData)) {\n      line = line.substr(matches[0].length);\n      detectQuote();\n      if (EmptyLine.test(line)) {\n        line = '';\n      }\n    } else {\n      state = 'NONE';\n      line = '';\n      out.push('');\n    }\n  }\n\n  while (nextLine()) {\n\n    if (state === 'SINGLE_QUOTE') {\n      consumeMatching(ClosingSingleQuote);\n    } else if (state === 'DOUBLE_QUOTE') {\n      consumeMatching(ClosingDoubleQuote);\n      unescapeLastBodyEl();\n    } else if (state === 'UNQUOTED') {\n      consumeMatching(EscapedQuotes);\n      if (body.length) {\n        unescapeLastBodyEl();\n      }\n      if (state === 'UNQUOTED') {\n        addBodyToOut();\n        line = '';\n      }\n    }\n\n    // the BODY state (used to match the body of a Sense request)\n    // can be terminated early if it encounters\n    // a comment or an empty line\n    else if (state === 'BODY') {\n        if (Comment.test(line) || EmptyLine.test(line)) {\n          addBodyToOut();\n        } else {\n          body.push(line);\n          line = '';\n        }\n      } else if (EmptyLine.test(line)) {\n        if (state !== 'LF') {\n          out.push('\\n');\n          state = 'LF';\n        }\n        line = '';\n      } else if (matches = line.match(Comment)) {\n        out.push('#' + matches[1] + '\\n');\n        state = 'NONE';\n        line = '';\n      } else if (LooksLikeCurl.test(line)) {\n        parseCurlLine();\n      } else if (matches = line.match(SenseLine)) {\n        out.push(matches[1] + ' /' + matches[2] + '\\n');\n        line = '';\n        state = 'BODY';\n      }\n\n      // Nothing else matches, so output with a prefix of !!! for debugging purposes\n      else {\n          out.push('### ' + line);\n          line = '';\n        }\n  }\n\n  addBodyToOut();\n  return out.join('').trim();\n}",null]}