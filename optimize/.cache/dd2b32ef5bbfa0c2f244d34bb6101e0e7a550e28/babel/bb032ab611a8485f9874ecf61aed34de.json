{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/explorer/explorer_swimlane.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/explorer/explorer_swimlane.js","mtime":1567631712041},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExplorerSwimlane = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _class, _temp2; /*\n                     * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                     * or more contributor license agreements. Licensed under the Elastic License;\n                     * you may not use this file except in compliance with the Elastic License.\n                     */\n\n/*\n * React component for rendering Explorer dashboard swimlanes.\n */\n\n// don't use something like plugins/ml/../common\n// because it won't work with the jest tests\n\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _date_utils = require('../util/date_utils');\n\nvar _chart_utils = require('../util/chart_utils');\n\nvar _anomaly_utils = require('../../common/util/anomaly_utils');\n\nvar _string_utils = require('../util/string_utils');\n\nvar _chart_tooltip_service = require('../components/chart_tooltip/chart_tooltip_service');\n\nvar _explorer_dashboard_service = require('./explorer_dashboard_service');\n\nvar _explorer_constants = require('./explorer_constants');\n\nvar _react3 = require('@kbn/i18n/react');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar SCSS = {\n  mlDragselectDragging: 'mlDragselectDragging',\n  mlHideRangeSelection: 'mlHideRangeSelection'\n};\n\nvar ExplorerSwimlane = exports.ExplorerSwimlane = (0, _react3.injectI18n)((_temp2 = _class = function (_React$Component) {\n  _inherits(ExplorerSwimlane, _React$Component);\n\n  function ExplorerSwimlane() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, ExplorerSwimlane);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ExplorerSwimlane.__proto__ || Object.getPrototypeOf(ExplorerSwimlane)).call.apply(_ref, [this].concat(args))), _this), _this.cellMouseoverActive = true, _this.boundDragSelectListener = null, _this.previousSelectedData = null, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  // Since this component is mostly rendered using d3 and cellMouseoverActive is only\n  // relevant for d3 based interaction, we don't manage this using React's state\n  // and intentionally circumvent the component lifecycle when updating it.\n\n\n  _createClass(ExplorerSwimlane, [{\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      _explorer_dashboard_service.mlExplorerDashboardService.dragSelect.unwatch(this.boundDragSelectListener);\n      var element = _d2.default.select(this.rootNode);\n      element.html('');\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      // save the bound dragSelectListener to this property so it can be accessed again\n      // in componentWillUnmount(), otherwise mlExplorerDashboardService.dragSelect.unwatch\n      // is not able to check properly if it's still the same listener\n      this.boundDragSelectListener = this.dragSelectListener.bind(this);\n      _explorer_dashboard_service.mlExplorerDashboardService.dragSelect.watch(this.boundDragSelectListener);\n\n      this.renderSwimlane();\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.renderSwimlane();\n    }\n\n    // property to remember the bound dragSelectListener\n\n\n    // property for data comparison to be able to filter\n    // consecutive click events with the same data.\n\n  }, {\n    key: 'dragSelectListener',\n\n\n    // Listen for dragSelect events\n    value: function dragSelectListener(_ref2) {\n      var action = _ref2.action,\n          _ref2$elements = _ref2.elements,\n          elements = _ref2$elements === undefined ? [] : _ref2$elements;\n\n      var element = _d2.default.select(this.rootNode.parentNode);\n      var swimlaneType = this.props.swimlaneType;\n\n\n      if (action === _explorer_constants.DRAG_SELECT_ACTION.NEW_SELECTION && elements.length > 0) {\n        var firstSelectedCell = _d2.default.select(elements[0]).node().__clickData__;\n\n        if (typeof firstSelectedCell !== 'undefined' && swimlaneType === firstSelectedCell.swimlaneType) {\n          var selectedData = elements.reduce(function (d, e) {\n            var cell = _d2.default.select(e).node().__clickData__;\n            d.bucketScore = Math.max(d.bucketScore, cell.bucketScore);\n            d.laneLabels.push(cell.laneLabel);\n            d.times.push(cell.time);\n            return d;\n          }, {\n            bucketScore: 0,\n            laneLabels: [],\n            times: []\n          });\n\n          selectedData.laneLabels = _lodash2.default.uniq(selectedData.laneLabels);\n          selectedData.times = _lodash2.default.uniq(selectedData.times);\n          if (_lodash2.default.isEqual(selectedData, this.previousSelectedData) === false) {\n            this.selectCell(elements, selectedData);\n            this.previousSelectedData = selectedData;\n          }\n        }\n\n        this.cellMouseoverActive = true;\n      } else if (action === _explorer_constants.DRAG_SELECT_ACTION.ELEMENT_SELECT) {\n        element.classed(SCSS.mlDragselectDragging, true);\n        return;\n      } else if (action === _explorer_constants.DRAG_SELECT_ACTION.DRAG_START) {\n        this.cellMouseoverActive = false;\n        return;\n      }\n\n      this.previousSelectedData = null;\n      element.classed(SCSS.mlDragselectDragging, false);\n      elements.map(function (e) {\n        return _d2.default.select(e).classed('ds-selected', false);\n      });\n    }\n  }, {\n    key: 'selectCell',\n    value: function selectCell(cellsToSelect, _ref3) {\n      var laneLabels = _ref3.laneLabels,\n          bucketScore = _ref3.bucketScore,\n          times = _ref3.times;\n      var _props = this.props,\n          selection = _props.selection,\n          swimlaneCellClick = _props.swimlaneCellClick,\n          swimlaneData = _props.swimlaneData,\n          swimlaneType = _props.swimlaneType;\n\n\n      var triggerNewSelection = false;\n\n      if (cellsToSelect.length > 1 || bucketScore > 0) {\n        triggerNewSelection = true;\n      }\n\n      // Check if the same cells were selected again, if so clear the selection,\n      // otherwise activate the new selection. The two objects are built for\n      // comparison because we cannot simply compare to \"appState.mlExplorerSwimlane\"\n      // since it also includes the \"viewBy\" attribute which might differ depending\n      // on whether the overall or viewby swimlane was selected.\n      var oldSelection = {\n        selectedType: selection && selection.type,\n        selectedLanes: selection && selection.lanes,\n        selectedTimes: selection && selection.times\n      };\n\n      var newSelection = {\n        selectedType: swimlaneType,\n        selectedLanes: laneLabels,\n        selectedTimes: _d2.default.extent(times)\n      };\n\n      if (_lodash2.default.isEqual(oldSelection, newSelection)) {\n        triggerNewSelection = false;\n      }\n\n      if (triggerNewSelection === false) {\n        swimlaneCellClick({});\n        return;\n      }\n\n      var selectedCells = {\n        viewByFieldName: swimlaneData.fieldName,\n        lanes: laneLabels,\n        times: _d2.default.extent(times),\n        type: swimlaneType\n      };\n      swimlaneCellClick(selectedCells);\n    }\n  }, {\n    key: 'highlightSelection',\n    value: function highlightSelection(cellsToSelect, laneLabels, times) {\n      var swimlaneType = this.props.swimlaneType;\n\n      // This selects both overall and viewby swimlane\n\n      var wrapper = _d2.default.selectAll('.ml-explorer-swimlane');\n\n      wrapper.selectAll('.lane-label').classed('lane-label-masked', true);\n      wrapper.selectAll('.sl-cell-inner,.sl-cell-inner-dragselect').classed('sl-cell-inner-masked', true);\n      wrapper.selectAll('.sl-cell-inner.sl-cell-inner-selected,.sl-cell-inner-dragselect.sl-cell-inner-selected').classed('sl-cell-inner-selected', false);\n\n      _d2.default.selectAll(cellsToSelect).selectAll('.sl-cell-inner,.sl-cell-inner-dragselect').classed('sl-cell-inner-masked', false).classed('sl-cell-inner-selected', true);\n\n      var rootParent = _d2.default.select(this.rootNode.parentNode);\n      rootParent.selectAll('.lane-label').classed('lane-label-masked', function () {\n        return laneLabels.indexOf(_d2.default.select(this).text()) === -1;\n      });\n\n      if (swimlaneType === 'viewBy') {\n        // If selecting a cell in the 'view by' swimlane, indicate the corresponding time in the Overall swimlane.\n        var overallSwimlane = _d2.default.select('.ml-swimlane-overall');\n        times.forEach(function (time) {\n          var overallCell = overallSwimlane.selectAll('div[data-time=\"' + time + '\"]').selectAll('.sl-cell-inner,.sl-cell-inner-dragselect');\n          overallCell.classed('sl-cell-inner-selected', true);\n        });\n      }\n    }\n  }, {\n    key: 'clearSelection',\n    value: function clearSelection() {\n      // This selects both overall and viewby swimlane\n      var wrapper = _d2.default.selectAll('.ml-explorer-swimlane');\n\n      wrapper.selectAll('.lane-label').classed('lane-label-masked', false);\n      wrapper.selectAll('.sl-cell-inner').classed('sl-cell-inner-masked', false);\n      wrapper.selectAll('.sl-cell-inner.sl-cell-inner-selected').classed('sl-cell-inner-selected', false);\n      wrapper.selectAll('.sl-cell-inner-dragselect.sl-cell-inner-selected').classed('sl-cell-inner-selected', false);\n      wrapper.selectAll('.ds-selected').classed('sl-cell-inner-selected', false);\n    }\n  }, {\n    key: 'renderSwimlane',\n    value: function renderSwimlane() {\n      var element = _d2.default.select(this.rootNode.parentNode);\n\n      // Consider the setting to support to select a range of cells\n      if (!_explorer_dashboard_service.mlExplorerDashboardService.allowCellRangeSelection) {\n        element.classed(SCSS.mlHideRangeSelection, true);\n      }\n\n      var cellMouseoverActive = this.cellMouseoverActive;\n\n      var _props2 = this.props,\n          chartWidth = _props2.chartWidth,\n          MlTimeBuckets = _props2.MlTimeBuckets,\n          swimlaneCellClick = _props2.swimlaneCellClick,\n          swimlaneData = _props2.swimlaneData,\n          swimlaneType = _props2.swimlaneType,\n          selection = _props2.selection,\n          intl = _props2.intl;\n      var lanes = swimlaneData.laneLabels,\n          startTime = swimlaneData.earliest,\n          endTime = swimlaneData.latest,\n          stepSecs = swimlaneData.interval,\n          points = swimlaneData.points;\n\n\n      function colorScore(value) {\n        return (0, _anomaly_utils.getSeverityColor)(value);\n      }\n\n      var numBuckets = parseInt((endTime - startTime) / stepSecs);\n      var cellHeight = 30;\n      var height = (lanes.length + 1) * cellHeight - 10;\n      var laneLabelWidth = 170;\n\n      element.style('height', height + 20 + 'px');\n      var swimlanes = element.select('.ml-swimlanes');\n      swimlanes.html('');\n\n      var cellWidth = Math.floor(chartWidth / numBuckets * 100) / 100;\n\n      var xAxisWidth = cellWidth * numBuckets;\n      var xAxisScale = _d2.default.time.scale().domain([new Date(startTime * 1000), new Date(endTime * 1000)]).range([0, xAxisWidth]);\n\n      // Get the scaled date format to use for x axis tick labels.\n      var timeBuckets = new MlTimeBuckets();\n      timeBuckets.setInterval(stepSecs + 's');\n      var xAxisTickFormat = timeBuckets.getScaledDateFormat();\n\n      function cellMouseOverFactory(time, i) {\n        // Don't use an arrow function here because we need access to `this`,\n        // which is where d3 supplies a reference to the corresponding DOM element.\n        return function (lane) {\n          var bucketScore = getBucketScore(lane, time);\n          if (bucketScore !== 0) {\n            cellMouseover(this, lane, bucketScore, i, time);\n          }\n        };\n      }\n\n      function cellMouseover(target, laneLabel, bucketScore, index, time) {\n        if (bucketScore === undefined || cellMouseoverActive === false) {\n          return;\n        }\n\n        var displayScore = bucketScore > 1 ? parseInt(bucketScore) : '< 1';\n\n        // Display date using same format as Kibana visualizations.\n        var formattedDate = (0, _date_utils.formatHumanReadableDateTime)(time * 1000);\n        var contents = formattedDate + '<br/><hr/>';\n        if (swimlaneData.fieldName !== undefined) {\n          contents += (0, _string_utils.mlEscape)(swimlaneData.fieldName) + ': ' + (0, _string_utils.mlEscape)(laneLabel) + '<br/><hr/>';\n        }\n        contents += intl.formatMessage({ id: 'xpack.ml.explorer.swimlane.maxAnomalyScoreLabel', defaultMessage: 'Max anomaly score: {displayScore}' }, { displayScore: displayScore });\n\n        var offsets = target.className === 'sl-cell-inner' ? { x: 0, y: 0 } : { x: 2, y: 1 };\n        _chart_tooltip_service.mlChartTooltipService.show(contents, target, {\n          x: target.offsetWidth - offsets.x,\n          y: 10 + offsets.y\n        });\n      }\n\n      function cellMouseleave() {\n        _chart_tooltip_service.mlChartTooltipService.hide();\n      }\n\n      var d3Lanes = swimlanes.selectAll('.lane').data(lanes);\n      var d3LanesEnter = d3Lanes.enter().append('div').classed('lane', true);\n\n      d3LanesEnter.append('div').classed('lane-label', true).style('width', laneLabelWidth + 'px').html(function (label) {\n        return (0, _string_utils.mlEscape)(label);\n      }).on('click', function () {\n        if (selection && typeof selection.lanes !== 'undefined') {\n          swimlaneCellClick({});\n        }\n      }).each(function () {\n        if (swimlaneData.fieldName !== undefined) {\n          _d2.default.select(this).attr('tooltip-html-unsafe', function (label) {\n            return (0, _string_utils.mlEscape)(swimlaneData.fieldName) + ': ' + (0, _string_utils.mlEscape)(label);\n          }).attr('tooltip-placement', 'right').attr('aria-label', function (label) {\n            return (0, _string_utils.mlEscape)(swimlaneData.fieldName) + ': ' + (0, _string_utils.mlEscape)(label);\n          });\n        }\n      });\n\n      var cellsContainer = d3LanesEnter.append('div').classed('cells-container', true);\n\n      function getBucketScore(lane, time) {\n        var bucketScore = 0;\n        var point = points.find(function (p) {\n          return p.value > 0 && p.laneLabel === lane && p.time === time;\n        });\n        if (typeof point !== 'undefined') {\n          bucketScore = point.value;\n        }\n        return bucketScore;\n      }\n\n      // TODO - mark if zoomed in to bucket width?\n      var time = startTime;\n      Array(numBuckets || 0).fill(null).forEach(function (v, i) {\n        var cell = cellsContainer.append('div').classed('sl-cell', true).style('width', cellWidth + 'px').attr('data-lane-label', function (label) {\n          return (0, _string_utils.mlEscape)(label);\n        }).attr('data-time', time).attr('data-bucket-score', function (lane) {\n          return getBucketScore(lane, time);\n        })\n        // use a factory here to bind the `time` and `i` values\n        // of this iteration to the event.\n        .on('mouseover', cellMouseOverFactory(time, i)).on('mouseleave', cellMouseleave).each(function (laneLabel) {\n          this.__clickData__ = {\n            bucketScore: getBucketScore(laneLabel, time),\n            laneLabel: laneLabel,\n            swimlaneType: swimlaneType,\n            time: time\n          };\n        });\n\n        // calls itself with each() to get access to lane (= d3 data)\n        cell.append('div').each(function (lane) {\n          var el = _d2.default.select(this);\n\n          var color = 'none';\n          var bucketScore = 0;\n\n          var point = points.find(function (p) {\n            return p.value > 0 && p.laneLabel === lane && p.time === time;\n          });\n\n          if (typeof point !== 'undefined') {\n            bucketScore = point.value;\n            color = colorScore(bucketScore);\n            el.classed('sl-cell-inner', true).style('background-color', color);\n          } else {\n            el.classed('sl-cell-inner-dragselect', true);\n          }\n        });\n\n        time += stepSecs;\n      });\n\n      // ['x-axis'] is just a placeholder so we have an array of 1.\n      var laneTimes = swimlanes.selectAll('.time-tick-labels').data(['x-axis']).enter().append('div').classed('time-tick-labels', true);\n\n      // height of .time-tick-labels\n      var svgHeight = 25;\n      var svg = laneTimes.append('svg').attr('width', chartWidth).attr('height', svgHeight);\n\n      var xAxis = _d2.default.svg.axis().scale(xAxisScale).ticks((0, _chart_utils.numTicksForDateFormat)(chartWidth, xAxisTickFormat)).tickFormat(function (tick) {\n        return (0, _moment2.default)(tick).format(xAxisTickFormat);\n      });\n\n      var gAxis = svg.append('g').attr('class', 'x axis').call(xAxis);\n\n      // remove overlapping labels\n      var overlapCheck = 0;\n      gAxis.selectAll('g.tick').each(function () {\n        var tick = _d2.default.select(this);\n        var xTransform = _d2.default.transform(tick.attr('transform')).translate[0];\n        var tickWidth = tick.select('text').node().getBBox().width;\n        var xMinOffset = xTransform - tickWidth / 2;\n        var xMaxOffset = xTransform + tickWidth / 2;\n        // if the tick label overlaps the previous label\n        // (or overflows the chart to the left), remove it;\n        // otherwise pick that label's offset as the new offset to check against\n        if (xMinOffset < overlapCheck) {\n          tick.remove();\n        } else {\n          overlapCheck = xTransform + tickWidth / 2;\n        }\n        // if the last tick label overflows the chart to the right, remove it\n        if (xMaxOffset > chartWidth) {\n          tick.remove();\n        }\n      });\n\n      // Check for selection and reselect the corresponding swimlane cell\n      // if the time range and lane label are still in view.\n      var selectionState = selection;\n      var selectedType = _lodash2.default.get(selectionState, 'type', undefined);\n      var selectionViewByFieldName = _lodash2.default.get(selectionState, 'viewByFieldName', '');\n\n      // If a selection was done in the other swimlane, add the \"masked\" classes\n      // to de-emphasize the swimlane cells.\n      if (swimlaneType !== selectedType && selectedType !== undefined) {\n        element.selectAll('.lane-label').classed('lane-label-masked', true);\n        element.selectAll('.sl-cell-inner').classed('sl-cell-inner-masked', true);\n      }\n\n      this.props.swimlaneRenderDoneListener();\n\n      if (swimlaneType !== selectedType || swimlaneData.fieldName !== undefined && swimlaneData.fieldName !== selectionViewByFieldName) {\n        // Not this swimlane which was selected.\n        return;\n      }\n\n      var cellsToSelect = [];\n      var selectedLanes = _lodash2.default.get(selectionState, 'lanes', []);\n      var selectedTimes = _lodash2.default.get(selectionState, 'times', []);\n      var selectedTimeExtent = _d2.default.extent(selectedTimes);\n\n      selectedLanes.forEach(function (selectedLane) {\n        if (lanes.indexOf(selectedLane) > -1 && selectedTimeExtent[0] >= startTime && selectedTimeExtent[1] <= endTime) {\n          // Locate matching cell - look for exact time, otherwise closest before.\n          var swimlaneElements = element.select('.ml-swimlanes');\n          var laneCells = swimlaneElements.selectAll('div[data-lane-label=\"' + (0, _string_utils.mlEscape)(selectedLane) + '\"]');\n\n          laneCells.each(function () {\n            var cell = _d2.default.select(this);\n            var cellTime = cell.attr('data-time');\n            if (cellTime >= selectedTimeExtent[0] && cellTime <= selectedTimeExtent[1]) {\n              cellsToSelect.push(cell.node());\n            }\n          });\n        }\n      });\n\n      var selectedMaxBucketScore = cellsToSelect.reduce(function (maxBucketScore, cell) {\n        return Math.max(maxBucketScore, +_d2.default.select(cell).attr('data-bucket-score') || 0);\n      }, 0);\n\n      if (cellsToSelect.length > 1 || selectedMaxBucketScore > 0) {\n        this.highlightSelection(cellsToSelect, selectedLanes, selectedTimes);\n      } else {\n        this.clearSelection();\n      }\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate() {\n      return true;\n    }\n  }, {\n    key: 'setRef',\n    value: function setRef(componentNode) {\n      this.rootNode = componentNode;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var swimlaneType = this.props.swimlaneType;\n\n\n      return _react2.default.createElement('div', { className: 'ml-swimlanes ml-swimlane-' + swimlaneType, ref: this.setRef.bind(this) });\n    }\n  }]);\n\n  return ExplorerSwimlane;\n}(_react2.default.Component), _class.propTypes = {\n  chartWidth: _propTypes2.default.number.isRequired,\n  MlTimeBuckets: _propTypes2.default.func.isRequired,\n  swimlaneCellClick: _propTypes2.default.func.isRequired,\n  swimlaneData: _propTypes2.default.shape({\n    laneLabels: _propTypes2.default.array.isRequired\n  }).isRequired,\n  swimlaneType: _propTypes2.default.string.isRequired,\n  selection: _propTypes2.default.object,\n  swimlaneRenderDoneListener: _propTypes2.default.func.isRequired }, _temp2));",null]}