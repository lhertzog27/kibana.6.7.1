{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/single_metric/create_job/create_job_controller.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/single_metric/create_job/create_job_controller.js","mtime":1567631712060},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nrequire('angular-ui-select');\n\nvar _index = require('ui/agg_types/index');\n\nvar _validation_utils = require('plugins/ml/../common/util/validation_utils');\n\nvar _parse_interval = require('plugins/ml/../common/util/parse_interval');\n\nvar _datemath = require('@elastic/datemath');\n\nvar _datemath2 = _interopRequireDefault(_datemath);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _routes = require('ui/routes');\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nvar _job_utils = require('plugins/ml/../common/util/job_utils');\n\nvar _check_license = require('plugins/ml/license/check_license');\n\nvar _check_privilege = require('plugins/ml/privilege/check_privilege');\n\nvar _ml_time_buckets = require('plugins/ml/util/ml_time_buckets');\n\nvar _filter_agg_types = require('plugins/ml/jobs/new_job/simple/components/utils/filter_agg_types');\n\nvar _validate_job = require('plugins/ml/jobs/new_job/simple/components/utils/validate_job');\n\nvar _adjust_interval = require('plugins/ml/jobs/new_job/simple/components/utils/adjust_interval');\n\nvar _create_fields = require('plugins/ml/jobs/new_job/simple/components/utils/create_fields');\n\nvar _change_job_id_case = require('plugins/ml/jobs/new_job/simple/components/general_job_details/change_job_id_case');\n\nvar _states = require('plugins/ml/jobs/new_job/simple/components/constants/states');\n\nvar _index_utils = require('plugins/ml/util/index_utils');\n\nvar _check_ml_nodes = require('plugins/ml/ml_nodes_check/check_ml_nodes');\n\nvar _new_job_defaults = require('plugins/ml/jobs/new_job/utils/new_job_defaults');\n\nvar _new_job_utils = require('plugins/ml/jobs/new_job/utils/new_job_utils');\n\nvar _job_service = require('plugins/ml/services/job_service');\n\nvar _prepopulate_job_settings = require('plugins/ml/jobs/new_job/simple/components/utils/prepopulate_job_settings');\n\nvar _create_job_service = require('./create_job_service');\n\nvar _full_time_range_selector_service = require('plugins/ml/components/full_time_range_selector/full_time_range_selector_service');\n\nvar _messagebar_service = require('plugins/ml/components/messagebar/messagebar_service');\n\nvar _create_job = require('./create_job.html');\n\nvar _create_job2 = _interopRequireDefault(_create_job);\n\nvar _timefilter = require('ui/timefilter');\n\nvar _modules = require('ui/modules');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_routes2.default.when('/jobs/new_job/simple/single_metric', {\n  template: _create_job2.default,\n  resolve: {\n    CheckLicense: _check_license.checkLicenseExpired,\n    privileges: _check_privilege.checkCreateJobsPrivilege,\n    indexPattern: _index_utils.loadCurrentIndexPattern,\n    savedSearch: _index_utils.loadCurrentSavedSearch,\n    checkMlNodesAvailable: _check_ml_nodes.checkMlNodesAvailable,\n    loadNewJobDefaults: _new_job_defaults.loadNewJobDefaults\n  }\n}); /*\n     * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n     * or more contributor license agreements. Licensed under the Elastic License;\n     * you may not use this file except in compliance with the Elastic License.\n     */\n\nvar _module = _modules.uiModules.get('apps/ml');\n\n_module.controller('MlCreateSingleMetricJob', function ($scope, $route, $filter, $timeout, Private, AppState, i18n) {\n\n  _timefilter.timefilter.enableTimeRangeSelector();\n  _timefilter.timefilter.disableAutoRefreshSelector();\n  var msgs = _messagebar_service.mlMessageBarService;\n  var MlTimeBuckets = Private(_ml_time_buckets.IntervalHelperProvider);\n  var moveToAdvancedJobCreation = Private(_new_job_utils.moveToAdvancedJobCreationProvider);\n  var mlSingleMetricJobService = Private(_create_job_service.SingleMetricJobServiceProvider);\n  var mlFullTimeRangeSelectorService = Private(_full_time_range_selector_service.FullTimeRangeSelectorServiceProvider);\n\n  var stateDefaults = {\n    mlJobSettings: {}\n  };\n  var appState = new AppState(stateDefaults);\n\n  $scope.index = $route.current.params.index;\n  $scope.chartData = mlSingleMetricJobService.chartData;\n  $scope.changeJobIDCase = _change_job_id_case.changeJobIDCase;\n  $scope.addNewJobToRecentlyAccessed = _new_job_utils.addNewJobToRecentlyAccessed;\n\n  var PAGE_WIDTH = _angular2.default.element('.single-metric-job-container').width();\n  var BAR_TARGET = PAGE_WIDTH > 2000 ? 1000 : PAGE_WIDTH / 2;\n  var MAX_BARS = BAR_TARGET + BAR_TARGET / 100 * 100; // 100% larger than bar target\n  var REFRESH_INTERVAL_MS = 100;\n  var MAX_BUCKET_DIFF = 3;\n  var METRIC_AGG_TYPE = 'metrics';\n  var DEFAULT_MODEL_MEMORY_LIMIT = '10MB';\n\n  var jobProgressChecks = {\n    25: false,\n    50: false,\n    75: false\n  };\n\n  var refreshCounter = 0;\n\n  $scope.JOB_STATE = _states.JOB_STATE;\n  $scope.jobState = $scope.JOB_STATE.NOT_STARTED;\n\n  $scope.CHART_STATE = _states.CHART_STATE;\n  $scope.chartState = _states.CHART_STATE.NOT_STARTED;\n\n  // flag to stop all results polling if the user navigates away from this page\n  var globalForceStop = false;\n\n  var createSearchItems = Private(_new_job_utils.SearchItemsProvider);\n\n  var _createSearchItems = createSearchItems(),\n      indexPattern = _createSearchItems.indexPattern,\n      savedSearch = _createSearchItems.savedSearch,\n      query = _createSearchItems.query,\n      filters = _createSearchItems.filters,\n      combinedQuery = _createSearchItems.combinedQuery;\n\n  (0, _index_utils.timeBasedIndexCheck)(indexPattern, true);\n\n  $scope.indexPatternLinkText = i18n('xpack.ml.newJob.simple.singleMetric.noResultsFound.indexPatternLinkText', {\n    defaultMessage: 'full {indexPatternTitle} data',\n    values: { indexPatternTitle: indexPattern.title }\n  });\n  $scope.nameNotValidMessage = i18n('xpack.ml.newJob.simple.singleMetric.nameNotValidMessage', {\n    defaultMessage: 'Enter a name for the job'\n  });\n  $scope.showAdvancedButtonAriaLabel = i18n('xpack.ml.newJob.simple.singleMetric.showAdvancedButtonAriaLabel', {\n    defaultMessage: 'Show Advanced'\n  });\n  $scope.hideAdvancedButtonAriaLabel = i18n('xpack.ml.newJob.simple.singleMetric.hideAdvancedButtonAriaLabel', {\n    defaultMessage: 'Hide Advanced'\n  });\n  var pageTitle = savedSearch.id !== undefined ? i18n('xpack.ml.newJob.simple.singleMetric.savedSearchPageTitle', {\n    defaultMessage: 'saved search {savedSearchTitle}',\n    values: { savedSearchTitle: savedSearch.title }\n  }) : i18n('xpack.ml.newJob.simple.singleMetric.indexPatternPageTitle', {\n    defaultMessage: 'index pattern {indexPatternTitle}',\n    values: { indexPatternTitle: indexPattern.title }\n  });\n\n  $scope.ui = {\n    indexPattern: indexPattern,\n    pageTitle: pageTitle,\n    showJobInput: false,\n    showJobFinished: false,\n    dirty: true,\n    formValid: false,\n    bucketSpanValid: true,\n    bucketSpanEstimator: { status: 0, message: '' },\n    aggTypeOptions: (0, _filter_agg_types.filterAggTypes)(_index.aggTypes.byType[METRIC_AGG_TYPE]),\n    fields: [],\n    timeFields: [],\n    intervals: [{\n      title: i18n('xpack.ml.newJob.simple.singleMetric.autoIntervalUnitTitle', {\n        defaultMessage: 'Auto'\n      }),\n      value: 'auto'\n      /*enabled: function (agg) {\n        // not only do we need a time field, but the selected field needs\n        // to be the time field. (see #3028)\n        return agg.fieldIsTimeField();\n      }*/\n    }, {\n      title: i18n('xpack.ml.newJob.simple.singleMetric.millisecondIntervalUnitTitle', {\n        defaultMessage: 'Millisecond'\n      }),\n      value: 'ms'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.singleMetric.secondIntervalUnitTitle', {\n        defaultMessage: 'Second'\n      }),\n      value: 's'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.singleMetric.minuteIntervalUnitTitle', {\n        defaultMessage: 'Minute'\n      }),\n      value: 'm'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.singleMetric.hourlyIntervalUnitTitle', {\n        defaultMessage: 'Hourly'\n      }),\n      value: 'h'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.singleMetric.dailyIntervalUnitTitle', {\n        defaultMessage: 'Daily'\n      }),\n      value: 'd'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.singleMetric.weeklyIntervalUnitTitle', {\n        defaultMessage: 'Weekly'\n      }),\n      value: 'w'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.singleMetric.monthlyIntervalUnitTitle', {\n        defaultMessage: 'Monthly'\n      }),\n      value: 'M'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.singleMetric.yearlyIntervalUnitTitle', {\n        defaultMessage: 'Yearly'\n      }),\n      value: 'y'\n    }, {\n      title: i18n('xpack.ml.newJob.simple.singleMetric.customIntervalUnitTitle', {\n        defaultMessage: 'Custom'\n      }),\n      value: 'custom'\n    }],\n    chartHeight: 310,\n    showAdvanced: false,\n    resultsUrl: '',\n    validation: {\n      checks: {\n        jobId: { valid: true },\n        groupIds: { valid: true },\n        modelMemoryLimit: { valid: true }\n      }\n    },\n    isCountOrSum: false\n  };\n\n  $scope.formConfig = {\n    agg: {\n      type: undefined\n    },\n    field: null,\n    bucketSpan: '15m',\n    chartInterval: undefined,\n    resultsIntervalSeconds: undefined,\n    start: 0,\n    end: 0,\n    timeField: indexPattern.timeFieldName,\n    indexPattern: undefined,\n    usesSavedSearch: savedSearch.id !== undefined,\n    query: query,\n    filters: filters,\n    combinedQuery: combinedQuery,\n    jobId: '',\n    description: '',\n    jobGroups: [],\n    useDedicatedIndex: false,\n    isSparseData: false,\n    modelMemoryLimit: DEFAULT_MODEL_MEMORY_LIMIT\n  };\n\n  // this is passed into the bucketspan estimator and  reference to the guessBucketSpan function is inserted\n  // to allow it for be called automatically without user interaction.\n  $scope.bucketSpanEstimatorExportedFunctions = {};\n\n  $scope.aggChange = function () {\n    loadFields();\n    $scope.ui.isFormValid();\n    $scope.ui.dirty = true;\n\n    $scope.ui.isCountOrSum = $scope.formConfig.agg.type.dslName === 'count' || $scope.formConfig.agg.type.dslName === 'sum';\n\n    // clear the field if count is selected\n    if ($scope.formConfig.agg.type.dslName === 'count') {\n      $scope.formConfig.field = null;\n    }\n  };\n\n  $scope.fieldChange = function () {\n    $scope.ui.isFormValid();\n    $scope.ui.dirty = true;\n  };\n\n  $scope.bucketSpanFieldChange = function () {\n    $scope.ui.isFormValid();\n    $scope.ui.bucketSpanEstimator.status = 0;\n    $scope.ui.bucketSpanEstimator.message = '';\n\n    $scope.ui.bucketSpanValid = true;\n    var bucketSpanInterval = (0, _parse_interval.parseInterval)($scope.formConfig.bucketSpan);\n    if (bucketSpanInterval === null || bucketSpanInterval.asMilliseconds() === 0) {\n      $scope.ui.bucketSpanValid = false;\n    }\n  };\n\n  function setTime() {\n    $scope.ui.bucketSpanValid = true;\n    $scope.formConfig.start = _datemath2.default.parse(_timefilter.timefilter.getTime().from).valueOf();\n    $scope.formConfig.end = _datemath2.default.parse(_timefilter.timefilter.getTime().to).valueOf();\n    $scope.formConfig.format = 'epoch_millis';\n\n    var bucketSpanInterval = (0, _parse_interval.parseInterval)($scope.formConfig.bucketSpan);\n    if (bucketSpanInterval === null || bucketSpanInterval.asMilliseconds() === 0) {\n      $scope.ui.bucketSpanValid = false;\n    }\n\n    var bounds = _timefilter.timefilter.getActiveBounds();\n    $scope.formConfig.chartInterval = new MlTimeBuckets();\n    $scope.formConfig.chartInterval.setBarTarget(BAR_TARGET);\n    $scope.formConfig.chartInterval.setMaxBars(MAX_BARS);\n    $scope.formConfig.chartInterval.setInterval('auto');\n    $scope.formConfig.chartInterval.setBounds(bounds);\n\n    (0, _adjust_interval.adjustIntervalDisplayed)($scope.formConfig);\n\n    $scope.ui.isFormValid();\n    $scope.ui.dirty = true;\n  }\n\n  function loadFields() {\n    var agg = $scope.formConfig.agg;\n    var fields = [];\n    agg.type.params.forEach(function (param) {\n      if (param.name === 'field') {\n        fields = (0, _create_fields.getIndexedFields)(indexPattern, param.filterFieldTypes.split(','));\n      }\n    });\n\n    $scope.ui.fields = [];\n    _lodash2.default.each(fields, function (field, i) {\n      var id = (0, _job_utils.getSafeAggregationName)(field.displayName, i);\n      var f = {\n        id: id,\n        name: field.displayName,\n        tooltip: field.displayName,\n        agg: agg,\n        mlType: field.mlType\n      };\n      $scope.ui.fields.push(f);\n    });\n\n    if ($scope.ui.fields.length === 1 || $scope.formConfig.field === null && agg.type.name === 'cardinality') {\n      $scope.formConfig.field = $scope.ui.fields[0];\n    }\n  }\n\n  $scope.ui.isFormValid = function () {\n    if ($scope.formConfig.agg.type === undefined || $scope.formConfig.timeField === undefined) {\n\n      $scope.ui.formValid = false;\n    } else {\n      $scope.ui.formValid = true;\n    }\n    return $scope.ui.formValid;\n  };\n\n  $scope.loadVis = function () {\n    setTime();\n    $scope.ui.isFormValid();\n\n    if ($scope.ui.formValid) {\n\n      $scope.ui.showJobInput = true;\n      $scope.ui.showJobFinished = false;\n\n      $scope.formConfig.indexPattern = indexPattern;\n      $scope.ui.dirty = false;\n\n      $scope.chartState = _states.CHART_STATE.LOADING;\n      $scope.$applyAsync();\n\n      mlSingleMetricJobService.getLineChartResults($scope.formConfig).then(function (resp) {\n        $scope.chartState = resp.totalResults ? _states.CHART_STATE.LOADED : _states.CHART_STATE.NO_RESULTS;\n      }).catch(function (resp) {\n        msgs.error(resp.message);\n        $scope.chartState = _states.CHART_STATE.NO_RESULTS;\n      }).then(function () {\n        $scope.$broadcast('render');\n        $scope.$applyAsync();\n      });\n    }\n  };\n\n  var ignoreModel = false;\n  var refreshInterval = REFRESH_INTERVAL_MS;\n  // function for creating a new job.\n  // creates the job, opens it, creates the datafeed and starts it.\n  // the job may fail to open, but the datafeed should still be created\n  // if the job save was successful.\n  $scope.createJob = function () {\n    var tempJob = mlSingleMetricJobService.getJobFromConfig($scope.formConfig);\n    if ((0, _validate_job.validateJob)(tempJob, $scope.ui.validation.checks)) {\n      msgs.clear();\n      // create the new job\n      mlSingleMetricJobService.createJob($scope.formConfig).then(function (job) {\n        // if save was successful, open the job\n        _job_service.mlJobService.openJob(job.job_id).then(function () {\n          // if open was successful create a new datafeed\n          saveNewDatafeed(job, true);\n        }).catch(function (resp) {\n          msgs.error(i18n('xpack.ml.newJob.simple.singleMetric.openJobErrorMessage', {\n            defaultMessage: 'Could not open job: '\n          }), resp);\n          msgs.error(i18n('xpack.ml.newJob.simple.singleMetric.creatingDatafeedErrorMessage', {\n            defaultMessage: 'Job created, creating datafeed anyway'\n          }));\n          // if open failed, still attempt to create the datafeed\n          // as it may have failed because we've hit the limit of open jobs\n          saveNewDatafeed(job, false);\n        });\n      }).catch(function (resp) {\n        // save failed\n        msgs.error(i18n('xpack.ml.newJob.simple.singleMetric.saveFailedErrorMessage', {\n          defaultMessage: 'Save failed: '\n        }), resp.resp);\n        $scope.$applyAsync();\n      });\n    } else {\n      // show the advanced section as the model memory limit is invalid\n      if ($scope.ui.validation.checks.modelMemoryLimit.valid === false) {\n        $scope.ui.showAdvanced = true;\n      }\n    }\n\n    // save new datafeed internal function\n    // creates a new datafeed and attempts to start it depending\n    // on startDatafeedAfterSave flag\n    function saveNewDatafeed(job, startDatafeedAfterSave) {\n      _job_service.mlJobService.saveNewDatafeed(job.datafeed_config, job.job_id).then(function () {\n\n        if (startDatafeedAfterSave) {\n          mlSingleMetricJobService.startDatafeed($scope.formConfig).then(function () {\n            $scope.jobState = _states.JOB_STATE.RUNNING;\n            refreshCounter = 0;\n            ignoreModel = false;\n            refreshInterval = REFRESH_INTERVAL_MS;\n            // create the interval size for querying results.\n            // it should not be smaller than the bucket_span\n            $scope.formConfig.resultsIntervalSeconds = $scope.formConfig.chartInterval.getInterval().asSeconds();\n            var bucketSpanSeconds = (0, _parse_interval.parseInterval)($scope.formConfig.bucketSpan).asSeconds();\n            if ($scope.formConfig.resultsIntervalSeconds < bucketSpanSeconds) {\n              $scope.formConfig.resultsIntervalSeconds = bucketSpanSeconds;\n            }\n\n            $scope.resultsUrl = _job_service.mlJobService.createResultsUrl([$scope.formConfig.jobId], $scope.formConfig.start, $scope.formConfig.end, 'timeseriesexplorer');\n\n            (0, _new_job_utils.focusOnResultsLink)('job_running_view_results_link', $timeout);\n\n            loadCharts();\n          }).catch(function (resp) {\n            // datafeed failed\n            msgs.error(i18n('xpack.ml.newJob.simple.singleMetric.datafeedNotStartedErrorMessage', {\n              defaultMessage: 'Could not start datafeed: '\n            }), resp);\n          }).then(function () {\n            $scope.$applyAsync();\n          });\n        } else {\n          $scope.$applyAsync();\n        }\n      }).catch(function (resp) {\n        msgs.error(i18n('xpack.ml.newJob.simple.singleMetric.saveDatafeedFailedErrorMessage', {\n          defaultMessage: 'Save datafeed failed: '\n        }), resp);\n        $scope.$applyAsync();\n      });\n    }\n  };\n\n  (0, _validation_utils.addJobValidationMethods)($scope, mlSingleMetricJobService);\n\n  function loadCharts() {\n    var forceStop = globalForceStop;\n    // the percentage doesn't always reach 100, so periodically check the datafeed state\n    // to see if the datafeed has stopped\n    var counterLimit = 20 - refreshInterval / REFRESH_INTERVAL_MS;\n    if (refreshCounter >= counterLimit) {\n      refreshCounter = 0;\n      mlSingleMetricJobService.checkDatafeedState($scope.formConfig).then(function (state) {\n        if (state === 'stopped') {\n          console.log('Stopping poll because datafeed state is: ' + state);\n          $scope.$broadcast('render-results');\n          forceStop = true;\n          $scope.$applyAsync();\n        }\n        run();\n      });\n    } else {\n      run();\n    }\n\n    function run() {\n      refreshCounter++;\n      reloadSwimlane().then(function () {\n        if (forceStop === false && $scope.chartData.percentComplete < 100) {\n          // if state has been set to stopping (from the stop button), leave state as it is\n          if ($scope.jobState === _states.JOB_STATE.STOPPING) {\n            $scope.jobState = _states.JOB_STATE.STOPPING;\n          } else {\n            // otherwise assume the job is running\n            $scope.jobState = _states.JOB_STATE.RUNNING;\n          }\n        } else {\n          $scope.jobState = _states.JOB_STATE.FINISHED;\n          (0, _new_job_utils.focusOnResultsLink)('job_finished_view_results_link', $timeout);\n        }\n\n        if (ignoreModel) {\n          jobCheck();\n        } else {\n\n          // check to see if the percentage is past a threshold for reloading the full model\n          var fullModelRefresh = false;\n          _lodash2.default.each(jobProgressChecks, function (c, i) {\n            if (jobProgressChecks[i] === false && $scope.chartData.percentComplete >= i) {\n              jobProgressChecks[i] = true;\n              fullModelRefresh = true;\n            }\n          });\n          // the full model needs to be refreshed\n          if (fullModelRefresh) {\n            $scope.chartData.model = [];\n          }\n\n          reloadModelChart().catch(function () {\n            // on the 10th model load failure, set ignoreModel to true to stop trying to load it.\n            if (refreshCounter % 10 === 0) {\n              console.log('Model has failed to load 10 times. Stop trying to load it.');\n              ignoreModel = true;\n            }\n          }).then(function () {\n            jobCheck();\n          });\n        }\n        $scope.$applyAsync();\n      });\n    }\n  }\n\n  function jobCheck() {\n    var isLastRun = false;\n    if ($scope.jobState === _states.JOB_STATE.RUNNING || $scope.jobState === _states.JOB_STATE.STOPPING) {\n      refreshInterval = adjustRefreshInterval($scope.chartData.loadingDifference, refreshInterval);\n      _lodash2.default.delay(loadCharts, refreshInterval);\n    } else {\n      $scope.chartData.percentComplete = 100;\n      isLastRun = true;\n    }\n\n    if (isLastRun && !ignoreModel) {\n      // at the very end of the job, reload the full model just in case there are\n      // any jitters in the chart caused by previously loading the model mid job.\n      $scope.chartData.model = [];\n      reloadModelChart().catch(function () {}).then(function () {\n        $scope.chartData.percentComplete = 100;\n        $scope.$broadcast('render-results');\n        $scope.$applyAsync();\n      });\n    } else {\n      $scope.$broadcast('render-results');\n      $scope.$applyAsync();\n    }\n  }\n\n  function reloadModelChart() {\n    return mlSingleMetricJobService.loadModelData($scope.formConfig);\n  }\n\n  function reloadSwimlane() {\n    return mlSingleMetricJobService.loadSwimlaneData($scope.formConfig);\n  }\n\n  function adjustRefreshInterval(loadingDifference, currentInterval) {\n    var INTERVAL_INCREASE_MS = 100;\n    var MAX_INTERVAL = 10000;\n    var interval = currentInterval;\n\n    if (interval < MAX_INTERVAL) {\n      if (loadingDifference < MAX_BUCKET_DIFF) {\n        interval = interval + INTERVAL_INCREASE_MS;\n      } else {\n        if (interval - INTERVAL_INCREASE_MS >= REFRESH_INTERVAL_MS) {\n          interval = interval - INTERVAL_INCREASE_MS;\n        }\n      }\n    }\n    return interval;\n  }\n\n  $scope.resetJob = function () {\n    $scope.jobState = _states.JOB_STATE.NOT_STARTED;\n    _angular2.default.element('.model-chart, .swimlane').css('opacity', 0);\n\n    _lodash2.default.each(jobProgressChecks, function (c, i) {\n      jobProgressChecks[i] = false;\n    });\n\n    window.setTimeout(function () {\n      $scope.ui.showJobInput = true;\n      $scope.loadVis();\n    }, 500);\n  };\n\n  $scope.stopJob = function () {\n    // setting the state to STOPPING disables the stop button\n    $scope.jobState = _states.JOB_STATE.STOPPING;\n    mlSingleMetricJobService.stopDatafeed($scope.formConfig);\n  };\n\n  $scope.moveToAdvancedJobCreation = function () {\n    var job = mlSingleMetricJobService.getJobFromConfig($scope.formConfig);\n    moveToAdvancedJobCreation(job);\n  };\n\n  $scope.setFullTimeRange = function () {\n    return mlFullTimeRangeSelectorService.setFullTimeRange($scope.ui.indexPattern, $scope.formConfig.combinedQuery);\n  };\n\n  $scope.$listenAndDigestAsync(_timefilter.timefilter, 'fetch', $scope.loadVis);\n\n  $scope.$on('$destroy', function () {\n    globalForceStop = true;\n  });\n\n  $scope.$evalAsync(function () {\n    (0, _prepopulate_job_settings.preLoadJob)($scope, appState);\n  });\n});",null]}