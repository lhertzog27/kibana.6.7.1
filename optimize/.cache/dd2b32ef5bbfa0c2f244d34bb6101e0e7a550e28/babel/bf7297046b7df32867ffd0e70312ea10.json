{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/shared/layers/layer.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/maps/public/shared/layers/layer.js","mtime":1567631712019},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractLayer = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _turf = require('turf');\n\nvar _turf2 = _interopRequireDefault(_turf);\n\nvar _booleanContains = require('@turf/boolean-contains');\n\nvar _booleanContains2 = _interopRequireDefault(_booleanContains);\n\nvar _data_request = require('./util/data_request');\n\nvar _constants = require('../../../common/constants');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SOURCE_UPDATE_REQUIRED = true;\nvar NO_SOURCE_UPDATE_REQUIRED = false;\n\nvar AbstractLayer = exports.AbstractLayer = function () {\n  function AbstractLayer(_ref) {\n    var _this = this;\n\n    var layerDescriptor = _ref.layerDescriptor,\n        source = _ref.source,\n        style = _ref.style;\n\n    _classCallCheck(this, AbstractLayer);\n\n    this.renderSourceSettingsEditor = function (_ref2) {\n      var onChange = _ref2.onChange;\n\n      return _this._source.renderSourceSettingsEditor({ onChange: onChange });\n    };\n\n    this._descriptor = AbstractLayer.createDescriptor(layerDescriptor);\n    this._source = source;\n    this._style = style;\n    if (this._descriptor.__dataRequests) {\n      this._dataRequests = this._descriptor.__dataRequests.map(function (dataRequest) {\n        return new _data_request.DataRequest(dataRequest);\n      });\n    } else {\n      this._dataRequests = [];\n    }\n  }\n\n  _createClass(AbstractLayer, [{\n    key: 'destroy',\n    value: function destroy() {\n      if (this._source) {\n        this._source.destroy();\n      }\n    }\n  }, {\n    key: 'isJoinable',\n    value: function isJoinable() {\n      return this._source.isJoinable();\n    }\n  }, {\n    key: 'supportsFitToBounds',\n    value: function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._source.supportsFitToBounds();\n\n              case 2:\n                return _context.abrupt('return', _context.sent);\n\n              case 3:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function supportsFitToBounds() {\n        return _ref3.apply(this, arguments);\n      }\n\n      return supportsFitToBounds;\n    }()\n  }, {\n    key: 'getDisplayName',\n    value: function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._descriptor.label) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt('return', this._descriptor.label);\n\n              case 2:\n                _context2.next = 4;\n                return this._source.getDisplayName();\n\n              case 4:\n                _context2.t0 = _context2.sent;\n\n                if (_context2.t0) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.t0 = 'Layer ' + this._descriptor.id;\n\n              case 7:\n                return _context2.abrupt('return', _context2.t0);\n\n              case 8:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getDisplayName() {\n        return _ref4.apply(this, arguments);\n      }\n\n      return getDisplayName;\n    }()\n  }, {\n    key: 'getAttributions',\n    value: function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.hasErrors()) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this._source.getAttributions();\n\n              case 3:\n                return _context3.abrupt('return', _context3.sent);\n\n              case 4:\n                return _context3.abrupt('return', []);\n\n              case 5:\n              case 'end':\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getAttributions() {\n        return _ref5.apply(this, arguments);\n      }\n\n      return getAttributions;\n    }()\n  }, {\n    key: 'getLabel',\n    value: function getLabel() {\n      return this._descriptor.label ? this._descriptor.label : '';\n    }\n  }, {\n    key: 'getIcon',\n    value: function getIcon() {\n      console.warn('Icon not available for this layer type');\n    }\n  }, {\n    key: 'getTOCDetails',\n    value: function getTOCDetails() {\n      return null;\n    }\n  }, {\n    key: 'getId',\n    value: function getId() {\n      return this._descriptor.id;\n    }\n  }, {\n    key: 'getSource',\n    value: function getSource() {\n      return this._source;\n    }\n  }, {\n    key: 'isVisible',\n    value: function isVisible() {\n      return this._descriptor.visible;\n    }\n  }, {\n    key: 'showAtZoomLevel',\n    value: function showAtZoomLevel(zoom) {\n\n      if (zoom >= this._descriptor.minZoom && zoom <= this._descriptor.maxZoom) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: 'getMinZoom',\n    value: function getMinZoom() {\n      return this._descriptor.minZoom;\n    }\n  }, {\n    key: 'getMaxZoom',\n    value: function getMaxZoom() {\n      return this._descriptor.maxZoom;\n    }\n  }, {\n    key: 'getAlpha',\n    value: function getAlpha() {\n      return this._descriptor.alpha;\n    }\n  }, {\n    key: 'getZoomConfig',\n    value: function getZoomConfig() {\n      return {\n        minZoom: this._descriptor.minZoom,\n        maxZoom: this._descriptor.maxZoom\n      };\n    }\n  }, {\n    key: 'getSupportedStyles',\n    value: function getSupportedStyles() {\n      return [];\n    }\n  }, {\n    key: 'getCurrentStyle',\n    value: function getCurrentStyle() {\n      return this._style;\n    }\n  }, {\n    key: 'getImmutableSourceProperties',\n    value: function () {\n      var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt('return', this._source.getImmutableProperties());\n\n              case 1:\n              case 'end':\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getImmutableSourceProperties() {\n        return _ref6.apply(this, arguments);\n      }\n\n      return getImmutableSourceProperties;\n    }()\n  }, {\n    key: 'getSourceDataRequest',\n    value: function getSourceDataRequest() {\n      return this._dataRequests.find(function (dataRequest) {\n        return dataRequest.getDataId() === _constants.SOURCE_DATA_ID_ORIGIN;\n      });\n    }\n  }, {\n    key: 'isLayerLoading',\n    value: function isLayerLoading() {\n      return this._dataRequests.some(function (dataRequest) {\n        return dataRequest.isLoading();\n      });\n    }\n  }, {\n    key: 'hasErrors',\n    value: function hasErrors() {\n      return _lodash2.default.get(this._descriptor, '__isInErrorState', false);\n    }\n  }, {\n    key: 'getErrors',\n    value: function getErrors() {\n      return this.hasErrors() ? this._descriptor.__errorMessage : '';\n    }\n  }, {\n    key: 'toLayerDescriptor',\n    value: function toLayerDescriptor() {\n      return this._descriptor;\n    }\n  }, {\n    key: 'syncData',\n    value: function () {\n      var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n              case 'end':\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function syncData() {\n        return _ref7.apply(this, arguments);\n      }\n\n      return syncData;\n    }()\n  }, {\n    key: 'syncLayerWithMb',\n    value: function syncLayerWithMb() {\n      //no-op by default\n    }\n  }, {\n    key: 'updateDueToExtent',\n    value: function updateDueToExtent(source) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var dataFilters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var extentAware = source.isFilterByMapBounds();\n      if (!extentAware) {\n        return NO_SOURCE_UPDATE_REQUIRED;\n      }\n\n      var previousBuffer = meta.buffer;\n      var newBuffer = dataFilters.buffer;\n\n\n      if (!previousBuffer) {\n        return SOURCE_UPDATE_REQUIRED;\n      }\n\n      if (_lodash2.default.isEqual(previousBuffer, newBuffer)) {\n        return NO_SOURCE_UPDATE_REQUIRED;\n      }\n\n      var previousBufferGeometry = _turf2.default.bboxPolygon([previousBuffer.minLon, previousBuffer.minLat, previousBuffer.maxLon, previousBuffer.maxLat]);\n      var newBufferGeometry = _turf2.default.bboxPolygon([newBuffer.minLon, newBuffer.minLat, newBuffer.maxLon, newBuffer.maxLat]);\n      var doesPreviousBufferContainNewBuffer = (0, _booleanContains2.default)(previousBufferGeometry, newBufferGeometry);\n\n      var isTrimmed = _lodash2.default.get(meta, 'areResultsTrimmed', false);\n      return doesPreviousBufferContainNewBuffer && !isTrimmed ? NO_SOURCE_UPDATE_REQUIRED : SOURCE_UPDATE_REQUIRED;\n    }\n  }, {\n    key: 'getLayerTypeIconName',\n    value: function getLayerTypeIconName() {\n      throw new Error('should implement Layer#getLayerTypeIconName');\n    }\n  }, {\n    key: 'getBounds',\n    value: function () {\n      var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt('return', {\n                  min_lon: -180,\n                  max_lon: 180,\n                  min_lat: -89,\n                  max_lat: 89\n                });\n\n              case 1:\n              case 'end':\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getBounds() {\n        return _ref8.apply(this, arguments);\n      }\n\n      return getBounds;\n    }()\n  }, {\n    key: 'renderStyleEditor',\n    value: function renderStyleEditor(style, options) {\n      return style.renderEditor(options);\n    }\n  }, {\n    key: 'getIndexPatternIds',\n    value: function getIndexPatternIds() {\n      return [];\n    }\n  }, {\n    key: 'getOrdinalFields',\n    value: function () {\n      var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                return _context7.abrupt('return', []);\n\n              case 1:\n              case 'end':\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getOrdinalFields() {\n        return _ref9.apply(this, arguments);\n      }\n\n      return getOrdinalFields;\n    }()\n  }], [{\n    key: 'getBoundDataForSource',\n    value: function getBoundDataForSource(mbMap, sourceId) {\n      var mbStyle = mbMap.getStyle();\n      return mbStyle.sources[sourceId].data;\n    }\n  }, {\n    key: 'createDescriptor',\n    value: function createDescriptor() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var layerDescriptor = _extends({}, options);\n\n      layerDescriptor.__dataRequests = _lodash2.default.get(options, '__dataRequests', []);\n      layerDescriptor.id = _lodash2.default.get(options, 'id', Math.random().toString(36).substr(2, 5));\n      layerDescriptor.label = options.label && options.label.length > 0 ? options.label : null;\n      layerDescriptor.minZoom = _lodash2.default.get(options, 'minZoom', 0);\n      layerDescriptor.maxZoom = _lodash2.default.get(options, 'maxZoom', 24);\n      layerDescriptor.alpha = _lodash2.default.get(options, 'alpha', 0.75);\n      layerDescriptor.visible = _lodash2.default.get(options, 'visible', true);\n      layerDescriptor.style = _lodash2.default.get(options, 'style', {});\n      return layerDescriptor;\n    }\n  }]);\n\n  return AbstractLayer;\n}();",null]}