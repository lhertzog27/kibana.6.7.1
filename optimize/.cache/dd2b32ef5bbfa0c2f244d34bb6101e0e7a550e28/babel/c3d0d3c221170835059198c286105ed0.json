{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/timeseriesexplorer_controller.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/timeseriesexplorer_controller.js","mtime":1567631712070},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _momentTimezone = require('moment-timezone');\n\nvar _momentTimezone2 = _interopRequireDefault(_momentTimezone);\n\nrequire('plugins/ml/components/annotations/annotation_flyout/annotation_flyout_directive');\n\nrequire('plugins/ml/components/annotations/annotations_table');\n\nrequire('plugins/ml/components/anomalies_table');\n\nrequire('plugins/ml/components/controls');\n\nvar _notify = require('ui/notify');\n\nvar _routes = require('ui/routes');\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nvar _timefilter = require('ui/timefilter');\n\nvar _parse_interval = require('ui/utils/parse_interval');\n\nvar _check_license = require('plugins/ml/license/check_license');\n\nvar _check_privilege = require('plugins/ml/privilege/check_privilege');\n\nvar _job_utils = require('plugins/ml/../common/util/job_utils');\n\nvar _index_utils = require('plugins/ml/util/index_utils');\n\nvar _timeseriesexplorer_utils = require('plugins/ml/timeseriesexplorer/timeseriesexplorer_utils');\n\nvar _refresh_interval_watcher = require('plugins/ml/util/refresh_interval_watcher');\n\nvar _ml_time_buckets = require('plugins/ml/util/ml_time_buckets');\n\nvar _results_service = require('plugins/ml/services/results_service');\n\nvar _timeseriesexplorer = require('./timeseriesexplorer.html');\n\nvar _timeseriesexplorer2 = _interopRequireDefault(_timeseriesexplorer);\n\nvar _check_ml_nodes = require('plugins/ml/ml_nodes_check/check_ml_nodes');\n\nvar _ml_api_service = require('plugins/ml/services/ml_api_service');\n\nvar _job_service = require('plugins/ml/services/job_service');\n\nvar _field_format_service = require('plugins/ml/services/field_format_service');\n\nvar _job_select_service = require('plugins/ml/components/job_select_list/job_select_service');\n\nvar _forecast_service = require('plugins/ml/services/forecast_service');\n\nvar _timeseries_search_service = require('plugins/ml/timeseriesexplorer/timeseries_search_service');\n\nvar _search = require('../../common/constants/search');\n\nvar _annotations_service = require('../services/annotations_service');\n\nvar _chrome = require('ui/chrome');\n\nvar _chrome2 = _interopRequireDefault(_chrome);\n\nvar _modules = require('ui/modules');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /*\n                                                                                                                                                                                                     * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                     * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                     * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                     */\n\n/*\n * Angular controller for the Machine Learning Single Metric Viewer dashboard, which\n * allows the user to explore a single time series. The controller makes multiple queries\n * to Elasticsearch to obtain the data to populate all the components in the view.\n */\n\nvar mlAnnotationsEnabled = _chrome2.default.getInjected('mlAnnotationsEnabled', false);\n\n_routes2.default.when('/timeseriesexplorer/?', {\n  template: _timeseriesexplorer2.default,\n  resolve: {\n    CheckLicense: _check_license.checkFullLicense,\n    privileges: _check_privilege.checkGetJobsPrivilege,\n    indexPatterns: _index_utils.loadIndexPatterns,\n    mlNodeCount: _check_ml_nodes.getMlNodeCount\n  }\n});\n\nvar _module = _modules.uiModules.get('apps/ml');\n\n_module.controller('MlTimeSeriesExplorerController', function ($scope, $timeout, Private, AppState, config, mlSelectIntervalService, mlSelectSeverityService, i18n) {\n\n  $scope.timeFieldName = 'timestamp';\n  _timefilter.timefilter.enableTimeRangeSelector();\n  _timefilter.timefilter.enableAutoRefreshSelector();\n\n  var CHARTS_POINT_TARGET = 500;\n  var MAX_SCHEDULED_EVENTS = 10; // Max number of scheduled events displayed per bucket.\n  var TimeBuckets = Private(_ml_time_buckets.IntervalHelperProvider);\n  var mlJobSelectService = Private(_job_select_service.JobSelectServiceProvider);\n\n  $scope.jobPickerSelections = [];\n  $scope.selectedJob;\n  $scope.detectors = [];\n  $scope.loading = true;\n  $scope.loadCounter = 0;\n  $scope.hasResults = false;\n  $scope.anomalyRecords = [];\n\n  $scope.modelPlotEnabled = false;\n  $scope.showModelBounds = true; // Toggles display of model bounds in the focus chart\n  $scope.showModelBoundsCheckbox = false;\n  $scope.showAnnotations = mlAnnotationsEnabled; // Toggles display of annotations in the focus chart\n  $scope.showAnnotationsCheckbox = mlAnnotationsEnabled;\n  $scope.showForecast = true; // Toggles display of forecast data in the focus chart\n  $scope.showForecastCheckbox = false;\n\n  $scope.focusAnnotationData = [];\n\n  // Pass the timezone to the server for use when aggregating anomalies (by day / hour) for the table.\n  var tzConfig = config.get('dateFormat:tz');\n  var dateFormatTz = tzConfig !== 'Browser' ? tzConfig : _momentTimezone2.default.tz.guess();\n\n  $scope.permissions = {\n    canForecastJob: (0, _check_privilege.checkPermission)('canForecastJob')\n  };\n\n  $scope.initializeVis = function () {\n    // Initialize the AppState in which to store the zoom range.\n    var stateDefaults = {\n      mlTimeSeriesExplorer: {}\n    };\n    $scope.appState = new AppState(stateDefaults);\n\n    $scope.jobs = [];\n\n    // Load the job info needed by the visualization, then do the first load.\n    _job_service.mlJobService.loadJobs().then(function (resp) {\n\n      if (resp.jobs.length > 0) {\n        $scope.jobs = (0, _timeseriesexplorer_utils.createTimeSeriesJobData)(resp.jobs);\n        var timeSeriesJobIds = $scope.jobs.map(function (j) {\n          return j.id;\n        });\n\n        // Select any jobs set in the global state (i.e. passed in the URL).\n        var selectedJobIds = mlJobSelectService.getSelectedJobIds(true);\n\n        // Check if any of the jobs set in the URL are not time series jobs\n        // (e.g. if switching to this view straight from the Anomaly Explorer).\n        var invalidIds = _lodash2.default.difference(selectedJobIds, timeSeriesJobIds);\n        selectedJobIds = _lodash2.default.without.apply(_lodash2.default, [selectedJobIds].concat(_toConsumableArray(invalidIds)));\n        if (invalidIds.length > 0) {\n          var warningText = i18n('xpack.ml.timeSeriesExplorer.canNotViewRequestedJobsWarningMessage', {\n            defaultMessage: 'You can\\'t view requested {invalidIdsCount, plural, one {job} other {jobs}} {invalidIds} in this dashboard',\n            values: {\n              invalidIdsCount: invalidIds.length,\n              invalidIds: invalidIds\n            }\n          });\n          if (selectedJobIds.length === 0 && timeSeriesJobIds.length > 0) {\n            warningText += i18n('xpack.ml.timeSeriesExplorer.autoSelectingFirstJobText', {\n              defaultMessage: ', auto selecting first job'\n            });\n          }\n          _notify.toastNotifications.addWarning(warningText);\n        }\n\n        if (selectedJobIds.length > 1 || mlJobSelectService.groupIds.length) {\n          // if more than one job or a group has been loaded from the URL\n          if (selectedJobIds.length > 1) {\n            // if more than one job, select the first job from the selection.\n            _notify.toastNotifications.addWarning(i18n('xpack.ml.timeSeriesExplorer.youCanViewOneJobAtTimeWarningMessage', {\n              defaultMessage: 'You can only view one job at a time in this dashboard'\n            }));\n            mlJobSelectService.setJobIds([selectedJobIds[0]]);\n          } else {\n            // if a group has been loaded\n            if (selectedJobIds.length > 0) {\n              // if the group contains valid jobs, select the first\n              _notify.toastNotifications.addWarning(i18n('xpack.ml.timeSeriesExplorer.youCanViewOneJobAtTimeWarningMessage', {\n                defaultMessage: 'You can only view one job at a time in this dashboard'\n              }));\n              mlJobSelectService.setJobIds([selectedJobIds[0]]);\n            } else if ($scope.jobs.length > 0) {\n              // if there are no valid jobs in the group but there are valid jobs\n              // in the list of all jobs, select the first\n              mlJobSelectService.setJobIds([$scope.jobs[0].id]);\n            } else {\n              // if there are no valid jobs left.\n              $scope.loading = false;\n            }\n          }\n        } else if (invalidIds.length > 0 && selectedJobIds.length > 0) {\n          // if some ids have been filtered out because they were invalid.\n          // refresh the URL with the first valid id\n          mlJobSelectService.setJobIds([selectedJobIds[0]]);\n        } else if (selectedJobIds.length > 0) {\n          // normal behavior. a job ID has been loaded from the URL\n          loadForJobId(selectedJobIds[0]);\n        } else {\n          if (selectedJobIds.length === 0 && $scope.jobs.length > 0) {\n            // no jobs were loaded from the URL, so add the first job\n            // from the full jobs list.\n            mlJobSelectService.setJobIds([$scope.jobs[0].id]);\n          } else {\n            // Jobs exist, but no time series jobs.\n            $scope.loading = false;\n          }\n        }\n      } else {\n        $scope.loading = false;\n      }\n\n      $scope.$applyAsync();\n    }).catch(function (resp) {\n      console.log('Time series explorer - error getting job info from elasticsearch:', resp);\n    });\n  };\n\n  $scope.refresh = function () {\n\n    if ($scope.selectedJob === undefined) {\n      return;\n    }\n\n    $scope.loading = true;\n    $scope.hasResults = false;\n    delete $scope.chartDetails;\n    delete $scope.contextChartData;\n    delete $scope.focusChartData;\n    delete $scope.contextForecastData;\n    delete $scope.focusForecastData;\n\n    // Counter to keep track of what data sets have been loaded.\n    $scope.loadCounter++;\n    var awaitingCount = 3;\n\n    // finish() function, called after each data set has been loaded and processed.\n    // The last one to call it will trigger the page render.\n    function finish(counterVar) {\n      awaitingCount--;\n      if (awaitingCount === 0 && counterVar === $scope.loadCounter) {\n\n        if ($scope.contextChartData && $scope.contextChartData.length || $scope.contextForecastData && $scope.contextForecastData.length) {\n          $scope.hasResults = true;\n        } else {\n          $scope.hasResults = false;\n        }\n        $scope.loading = false;\n\n        // Set zoomFrom/zoomTo attributes in scope which will result in the metric chart automatically\n        // selecting the specified range in the context chart, and so loading that date range in the focus chart.\n        if ($scope.contextChartData.length) {\n          var focusRange = calculateInitialFocusRange();\n          $scope.zoomFrom = focusRange[0];\n          $scope.zoomTo = focusRange[1];\n        }\n\n        // Tell the results container directives to render.\n        // Need to use $timeout to ensure the broadcast happens after the child scope is updated with the new data.\n        if ($scope.contextChartData && $scope.contextChartData.length || $scope.contextForecastData && $scope.contextForecastData.length) {\n          $timeout(function () {\n            $scope.$broadcast('render');\n          }, 0);\n        } else {\n          // Call $applyAsync() if for any reason the upper condition doesn't trigger the $timeout.\n          // We still want to trigger a scope update about the changes above the condition.\n          $scope.$applyAsync();\n        }\n      }\n    }\n\n    var bounds = _timefilter.timefilter.getActiveBounds();\n\n    var detectorIndex = +$scope.detectorId;\n    $scope.modelPlotEnabled = (0, _job_utils.isModelPlotEnabled)($scope.selectedJob, detectorIndex, $scope.entities);\n\n    // Only filter on the entity if the field has a value.\n    var nonBlankEntities = _lodash2.default.filter($scope.entities, function (entity) {\n      return entity.fieldValue.length > 0;\n    });\n    $scope.criteriaFields = [{\n      'fieldName': 'detector_index',\n      'fieldValue': detectorIndex }].concat(nonBlankEntities);\n\n    // Calculate the aggregation interval for the context chart.\n    // Context chart swimlane will display bucket anomaly score at the same interval.\n    $scope.contextAggregationInterval = calculateAggregationInterval(bounds, CHARTS_POINT_TARGET, CHARTS_POINT_TARGET);\n    console.log('aggregationInterval for context data (s):', $scope.contextAggregationInterval.asSeconds());\n\n    // Ensure the search bounds align to the bucketing interval so that the first and last buckets are complete.\n    // For sum or count detectors, short buckets would hold smaller values, and model bounds would also be affected\n    // to some extent with all detector functions if not searching complete buckets.\n    var searchBounds = (0, _ml_time_buckets.getBoundsRoundedToInterval)(bounds, $scope.contextAggregationInterval, false);\n\n    // Query 1 - load metric data at low granularity across full time range.\n    // Pass a counter flag into the finish() function to make sure we only process the results\n    // for the most recent call to the load the data in cases where the job selection and time filter\n    // have been altered in quick succession (such as from the job picker with 'Apply time range').\n    var counter = $scope.loadCounter;\n    _timeseries_search_service.mlTimeSeriesSearchService.getMetricData($scope.selectedJob, detectorIndex, nonBlankEntities, searchBounds.min.valueOf(), searchBounds.max.valueOf(), $scope.contextAggregationInterval.expression).then(function (resp) {\n      var fullRangeChartData = (0, _timeseriesexplorer_utils.processMetricPlotResults)(resp.results, $scope.modelPlotEnabled);\n      $scope.contextChartData = fullRangeChartData;\n      console.log('Time series explorer context chart data set:', $scope.contextChartData);\n\n      finish(counter);\n    }).catch(function (resp) {\n      console.log('Time series explorer - error getting metric data from elasticsearch:', resp);\n    });\n\n    // Query 2 - load max record score at same granularity as context chart\n    // across full time range for use in the swimlane.\n    _results_service.mlResultsService.getRecordMaxScoreByTime($scope.selectedJob.job_id, $scope.criteriaFields, searchBounds.min.valueOf(), searchBounds.max.valueOf(), $scope.contextAggregationInterval.expression).then(function (resp) {\n      var fullRangeRecordScoreData = (0, _timeseriesexplorer_utils.processRecordScoreResults)(resp.results);\n      $scope.swimlaneData = fullRangeRecordScoreData;\n      console.log('Time series explorer swimlane anomalies data set:', $scope.swimlaneData);\n\n      finish(counter);\n    }).catch(function (resp) {\n      console.log('Time series explorer - error getting bucket anomaly scores from elasticsearch:', resp);\n    });\n\n    // Query 3 - load details on the chart used in the chart title (charting function and entity(s)).\n    _timeseries_search_service.mlTimeSeriesSearchService.getChartDetails($scope.selectedJob, detectorIndex, $scope.entities, searchBounds.min.valueOf(), searchBounds.max.valueOf()).then(function (resp) {\n      $scope.chartDetails = resp.results;\n      finish(counter);\n    }).catch(function (resp) {\n      console.log('Time series explorer - error getting entity counts from elasticsearch:', resp);\n    });\n\n    // Plus query for forecast data if there is a forecastId stored in the appState.\n    var forecastId = _lodash2.default.get($scope, 'appState.mlTimeSeriesExplorer.forecastId');\n    if (forecastId !== undefined) {\n      awaitingCount++;\n      var aggType = undefined;\n      var detector = $scope.selectedJob.analysis_config.detectors[detectorIndex];\n      var esAgg = (0, _job_utils.mlFunctionToESAggregation)(detector.function);\n      if ($scope.modelPlotEnabled === false && (esAgg === 'sum' || esAgg === 'count')) {\n        aggType = { avg: 'sum', max: 'sum', min: 'sum' };\n      }\n      _forecast_service.mlForecastService.getForecastData($scope.selectedJob, detectorIndex, forecastId, nonBlankEntities, searchBounds.min.valueOf(), searchBounds.max.valueOf(), $scope.contextAggregationInterval.expression, aggType).then(function (resp) {\n        $scope.contextForecastData = (0, _timeseriesexplorer_utils.processForecastResults)(resp.results);\n        finish(counter);\n      }).catch(function (resp) {\n        console.log('Time series explorer - error loading data for forecast ID ' + forecastId, resp);\n      });\n    }\n\n    loadEntityValues();\n  };\n\n  $scope.refreshFocusData = function (fromDate, toDate) {\n\n    // Counter to keep track of the queries to populate the chart.\n    var awaitingCount = 4;\n\n    // This object is used to store the results of individual remote requests\n    // before we transform it into the final data and apply it to $scope. Otherwise\n    // we might trigger multiple $digest cycles and depending on how deep $watches\n    // listen for changes we could miss updates.\n    var refreshFocusData = {};\n\n    // finish() function, called after each data set has been loaded and processed.\n    // The last one to call it will trigger the page render.\n    function finish() {\n      awaitingCount--;\n      if (awaitingCount === 0) {\n        // Tell the results container directives to render the focus chart.\n        refreshFocusData.focusChartData = (0, _timeseriesexplorer_utils.processDataForFocusAnomalies)(refreshFocusData.focusChartData, refreshFocusData.anomalyRecords, $scope.timeFieldName);\n\n        refreshFocusData.focusChartData = (0, _timeseriesexplorer_utils.processScheduledEventsForChart)(refreshFocusData.focusChartData, refreshFocusData.scheduledEvents);\n\n        // All the data is ready now for a scope update.\n        // Use $evalAsync to ensure the update happens after the child scope is updated with the new data.\n        $scope.$evalAsync(function () {\n          $scope = Object.assign($scope, refreshFocusData);\n          console.log('Time series explorer focus chart data set:', $scope.focusChartData);\n\n          $scope.loading = false;\n\n          // If the annotations failed to load and the feature flag is set to `false`,\n          // make sure the checkbox toggle gets hidden.\n          if (mlAnnotationsEnabled === false) {\n            $scope.showAnnotationsCheckbox = false;\n          }\n        });\n      }\n    }\n\n    var detectorIndex = +$scope.detectorId;\n    var nonBlankEntities = _lodash2.default.filter($scope.entities, function (entity) {\n      return entity.fieldValue.length > 0;\n    });\n\n    // Calculate the aggregation interval for the focus chart.\n    var bounds = { min: (0, _momentTimezone2.default)(fromDate), max: (0, _momentTimezone2.default)(toDate) };\n    $scope.focusAggregationInterval = calculateAggregationInterval(bounds, CHARTS_POINT_TARGET, CHARTS_POINT_TARGET);\n\n    // Ensure the search bounds align to the bucketing interval so that the first and last buckets are complete.\n    // For sum or count detectors, short buckets would hold smaller values, and model bounds would also be affected\n    // to some extent with all detector functions if not searching complete buckets.\n    var searchBounds = (0, _ml_time_buckets.getBoundsRoundedToInterval)(bounds, $scope.focusAggregationInterval, false);\n\n    // Query 1 - load metric data across selected time range.\n    _timeseries_search_service.mlTimeSeriesSearchService.getMetricData($scope.selectedJob, detectorIndex, nonBlankEntities, searchBounds.min.valueOf(), searchBounds.max.valueOf(), $scope.focusAggregationInterval.expression).then(function (resp) {\n      refreshFocusData.focusChartData = (0, _timeseriesexplorer_utils.processMetricPlotResults)(resp.results, $scope.modelPlotEnabled);\n      $scope.showModelBoundsCheckbox = $scope.modelPlotEnabled === true && refreshFocusData.focusChartData.length > 0;\n      finish();\n    }).catch(function (resp) {\n      console.log('Time series explorer - error getting metric data from elasticsearch:', resp);\n    });\n\n    // Query 2 - load all the records across selected time range for the chart anomaly markers.\n    _results_service.mlResultsService.getRecordsForCriteria([$scope.selectedJob.job_id], $scope.criteriaFields, 0, searchBounds.min.valueOf(), searchBounds.max.valueOf(), _search.ANOMALIES_TABLE_DEFAULT_QUERY_SIZE).then(function (resp) {\n      // Sort in descending time order before storing in scope.\n      refreshFocusData.anomalyRecords = _lodash2.default.chain(resp.records).sortBy(function (record) {\n        return record[$scope.timeFieldName];\n      }).reverse().value();\n      console.log('Time series explorer anomalies:', refreshFocusData.anomalyRecords);\n      finish();\n    });\n\n    // Query 3 - load any scheduled events for the selected job.\n    _results_service.mlResultsService.getScheduledEventsByBucket([$scope.selectedJob.job_id], searchBounds.min.valueOf(), searchBounds.max.valueOf(), $scope.focusAggregationInterval.expression, 1, MAX_SCHEDULED_EVENTS).then(function (resp) {\n      refreshFocusData.scheduledEvents = resp.events[$scope.selectedJob.job_id];\n      finish();\n    }).catch(function (resp) {\n      console.log('Time series explorer - error getting scheduled events from elasticsearch:', resp);\n    });\n\n    // Query 4 - load any annotations for the selected job.\n    if (mlAnnotationsEnabled) {\n      _ml_api_service.ml.annotations.getAnnotations({\n        jobIds: [$scope.selectedJob.job_id],\n        earliestMs: searchBounds.min.valueOf(),\n        latestMs: searchBounds.max.valueOf(),\n        maxAnnotations: _search.ANNOTATIONS_TABLE_DEFAULT_QUERY_SIZE\n      }).then(function (resp) {\n        refreshFocusData.focusAnnotationData = [];\n\n        if (Array.isArray(resp.annotations[$scope.selectedJob.job_id])) {\n          refreshFocusData.focusAnnotationData = resp.annotations[$scope.selectedJob.job_id].sort(function (a, b) {\n            return a.timestamp - b.timestamp;\n          }).map(function (d, i) {\n            d.key = String.fromCharCode(65 + i);\n            return d;\n          });\n        }\n\n        finish();\n      }).catch(function () {\n        // silently fail and disable annotations feature if loading annotations fails.\n        refreshFocusData.focusAnnotationData = [];\n        mlAnnotationsEnabled = false;\n        finish();\n      });\n    } else {\n      finish();\n    }\n\n    // Plus query for forecast data if there is a forecastId stored in the appState.\n    var forecastId = _lodash2.default.get($scope, 'appState.mlTimeSeriesExplorer.forecastId');\n    if (forecastId !== undefined) {\n      awaitingCount++;\n      var aggType = undefined;\n      var detector = $scope.selectedJob.analysis_config.detectors[detectorIndex];\n      var esAgg = (0, _job_utils.mlFunctionToESAggregation)(detector.function);\n      if ($scope.modelPlotEnabled === false && (esAgg === 'sum' || esAgg === 'count')) {\n        aggType = { avg: 'sum', max: 'sum', min: 'sum' };\n      }\n\n      _forecast_service.mlForecastService.getForecastData($scope.selectedJob, detectorIndex, forecastId, nonBlankEntities, searchBounds.min.valueOf(), searchBounds.max.valueOf(), $scope.focusAggregationInterval.expression, aggType).then(function (resp) {\n        refreshFocusData.focusForecastData = (0, _timeseriesexplorer_utils.processForecastResults)(resp.results);\n        refreshFocusData.showForecastCheckbox = refreshFocusData.focusForecastData.length > 0;\n        finish();\n      }).catch(function (resp) {\n        console.log('Time series explorer - error loading data for forecast ID ' + forecastId, resp);\n      });\n    }\n\n    // Load the data for the anomalies table.\n    loadAnomaliesTableData(searchBounds.min.valueOf(), searchBounds.max.valueOf());\n  };\n\n  $scope.saveSeriesPropertiesAndRefresh = function () {\n    $scope.appState.mlTimeSeriesExplorer.detectorIndex = +$scope.detectorId;\n    $scope.appState.mlTimeSeriesExplorer.entities = {};\n    _lodash2.default.each($scope.entities, function (entity) {\n      $scope.appState.mlTimeSeriesExplorer.entities[entity.fieldName] = entity.fieldValue;\n    });\n    $scope.appState.save();\n\n    $scope.refresh();\n  };\n\n  $scope.filter = function (field, value, operator) {\n    var entity = _lodash2.default.find($scope.entities, { fieldName: field });\n    if (entity !== undefined) {\n      if (operator === '+' && entity.fieldValue !== value) {\n        entity.fieldValue = value;\n        $scope.saveSeriesPropertiesAndRefresh();\n      } else if (operator === '-' && entity.fieldValue === value) {\n        entity.fieldValue = '';\n        $scope.saveSeriesPropertiesAndRefresh();\n      }\n    }\n  };\n\n  $scope.loadForForecastId = function (forecastId) {\n    _forecast_service.mlForecastService.getForecastDateRange($scope.selectedJob, forecastId).then(function (resp) {\n      var bounds = _timefilter.timefilter.getActiveBounds();\n      var earliest = (0, _momentTimezone2.default)(resp.earliest || _timefilter.timefilter.getTime().from);\n      var latest = (0, _momentTimezone2.default)(resp.latest || _timefilter.timefilter.getTime().to);\n\n      // Store forecast ID in the appState.\n      $scope.appState.mlTimeSeriesExplorer.forecastId = forecastId;\n\n      // Set the zoom to centre on the start of the forecast range, depending\n      // on the time range of the forecast and data.\n      var earliestDataDate = _lodash2.default.first($scope.contextChartData).date;\n      var zoomLatestMs = Math.min(earliest + $scope.autoZoomDuration / 2, latest.valueOf());\n      var zoomEarliestMs = Math.max(zoomLatestMs - $scope.autoZoomDuration, earliestDataDate.getTime());\n\n      var zoomState = {\n        from: (0, _momentTimezone2.default)(zoomEarliestMs).toISOString(),\n        to: (0, _momentTimezone2.default)(zoomLatestMs).toISOString()\n      };\n      $scope.appState.mlTimeSeriesExplorer.zoom = zoomState;\n\n      $scope.appState.save();\n\n      // Ensure the forecast data will be shown if hidden previously.\n      $scope.showForecast = true;\n\n      if (earliest.isBefore(bounds.min) || latest.isAfter(bounds.max)) {\n        var earliestMs = Math.min(earliest.valueOf(), bounds.min.valueOf());\n        var latestMs = Math.max(latest.valueOf(), bounds.max.valueOf());\n\n        _timefilter.timefilter.setTime({\n          from: (0, _momentTimezone2.default)(earliestMs).toISOString(),\n          to: (0, _momentTimezone2.default)(latestMs).toISOString()\n        });\n      } else {\n        // Refresh to show the requested forecast data.\n        $scope.refresh();\n      }\n    }).catch(function (resp) {\n      console.log('Time series explorer - error loading time range of forecast from elasticsearch:', resp);\n    });\n  };\n\n  $scope.detectorIndexChanged = function () {\n    updateControlsForDetector();\n    loadEntityValues();\n  };\n\n  $scope.toggleShowModelBounds = function () {\n    $timeout(function () {\n      $scope.showModelBounds = !$scope.showModelBounds;\n    }, 0);\n  };\n\n  if (mlAnnotationsEnabled) {\n    $scope.toggleShowAnnotations = function () {\n      $timeout(function () {\n        $scope.showAnnotations = !$scope.showAnnotations;\n      }, 0);\n    };\n  }\n\n  $scope.toggleShowForecast = function () {\n    $timeout(function () {\n      $scope.showForecast = !$scope.showForecast;\n    }, 0);\n  };\n\n  // Refresh the data when the time range is altered.\n  $scope.$listenAndDigestAsync(_timefilter.timefilter, 'fetch', $scope.refresh);\n\n  // Add a watcher for auto-refresh of the time filter to refresh all the data.\n  var refreshWatcher = Private(_refresh_interval_watcher.refreshIntervalWatcher);\n  refreshWatcher.init(function () {\n    $scope.refresh();\n  });\n\n  // Reload the anomalies table if the Interval or Threshold controls are changed.\n  var tableControlsListener = function tableControlsListener() {\n    if ($scope.zoomFrom !== undefined && $scope.zoomTo !== undefined) {\n      loadAnomaliesTableData($scope.zoomFrom.getTime(), $scope.zoomTo.getTime());\n    }\n  };\n  mlSelectIntervalService.state.watch(tableControlsListener);\n  mlSelectSeverityService.state.watch(tableControlsListener);\n\n  var annotationsRefreshSub = _annotations_service.annotationsRefresh$.subscribe($scope.refresh);\n\n  $scope.$on('$destroy', function () {\n    refreshWatcher.cancel();\n    mlSelectIntervalService.state.unwatch(tableControlsListener);\n    mlSelectSeverityService.state.unwatch(tableControlsListener);\n    annotationsRefreshSub.unsubscribe();\n  });\n\n  // Listen for changes to job selection.\n  mlJobSelectService.listenJobSelectionChange($scope, function (event, selections) {\n    // Clear the detectorIndex, entities and forecast info.\n    if (selections.length > 0) {\n      delete $scope.appState.mlTimeSeriesExplorer.detectorIndex;\n      delete $scope.appState.mlTimeSeriesExplorer.entities;\n      delete $scope.appState.mlTimeSeriesExplorer.forecastId;\n      $scope.appState.save();\n\n      $scope.showForecastCheckbox = false;\n      loadForJobId(selections[0]);\n    }\n  });\n\n  $scope.$on('contextChartSelected', function (event, selection) {\n    // Save state of zoom (adds to URL) if it is different to the default.\n    if (($scope.contextChartData === undefined || $scope.contextChartData.length === 0) && ($scope.contextForecastData === undefined || $scope.contextForecastData.length === 0)) {\n      return;\n    }\n\n    var defaultRange = calculateDefaultFocusRange();\n\n    if ((selection.from.getTime() !== defaultRange[0].getTime() || selection.to.getTime() !== defaultRange[1].getTime()) && isNaN(Date.parse(selection.from)) === false && isNaN(Date.parse(selection.to)) === false) {\n      var zoomState = { from: selection.from.toISOString(), to: selection.to.toISOString() };\n      $scope.appState.mlTimeSeriesExplorer.zoom = zoomState;\n    } else {\n      delete $scope.appState.mlTimeSeriesExplorer.zoom;\n    }\n    $scope.appState.save();\n\n    if ($scope.focusChartData === undefined || $scope.zoomFrom.getTime() !== selection.from.getTime() || $scope.zoomTo.getTime() !== selection.to.getTime()) {\n      $scope.refreshFocusData(selection.from, selection.to);\n    }\n\n    $scope.zoomFrom = selection.from;\n    $scope.zoomTo = selection.to;\n  });\n\n  function loadForJobId(jobId) {\n    // Validation that the ID is for a time series job must already have been performed.\n    // Check if the job was created since the page was first loaded.\n    var jobPickerSelectedJob = _lodash2.default.find($scope.jobs, { 'id': jobId });\n    if (jobPickerSelectedJob === undefined) {\n      var newJobs = [];\n      _lodash2.default.each(_job_service.mlJobService.jobs, function (job) {\n        if ((0, _job_utils.isTimeSeriesViewJob)(job) === true) {\n          var bucketSpan = (0, _parse_interval.parseInterval)(job.analysis_config.bucket_span);\n          newJobs.push({ id: job.job_id, selected: false, bucketSpanSeconds: bucketSpan.asSeconds() });\n        }\n      });\n      $scope.jobs = newJobs;\n      jobPickerSelectedJob = _lodash2.default.find(newJobs, { 'id': jobId });\n    }\n\n    $scope.selectedJob = _job_service.mlJobService.getJob(jobId);\n    $scope.jobPickerSelections = [jobPickerSelectedJob];\n\n    // Read the detector index and entities out of the AppState.\n    var jobDetectors = $scope.selectedJob.analysis_config.detectors;\n    var viewableDetectors = [];\n    _lodash2.default.each(jobDetectors, function (dtr, index) {\n      if ((0, _job_utils.isTimeSeriesViewDetector)($scope.selectedJob, index)) {\n        viewableDetectors.push({ index: '' + index, detector_description: dtr.detector_description });\n      }\n    });\n    $scope.detectors = viewableDetectors;\n\n    // Check the supplied index is valid.\n    var appStateDtrIdx = $scope.appState.mlTimeSeriesExplorer.detectorIndex;\n    var detectorIndex = appStateDtrIdx !== undefined ? appStateDtrIdx : +viewableDetectors[0].index;\n    if (_lodash2.default.find(viewableDetectors, { 'index': '' + detectorIndex }) === undefined) {\n      var warningText = i18n('xpack.ml.timeSeriesExplorer.requestedDetectorIndexNotValidWarningMessage', {\n        defaultMessage: 'Requested detector index {detectorIndex} is not valid for job {jobId}',\n        values: {\n          detectorIndex: detectorIndex,\n          jobId: $scope.selectedJob.job_id\n        }\n      });\n      _notify.toastNotifications.addWarning(warningText);\n      detectorIndex = +viewableDetectors[0].index;\n      $scope.appState.mlTimeSeriesExplorer.detectorIndex = detectorIndex;\n      $scope.appState.save();\n    }\n\n    // Store the detector index as a string so it can be used as ng-model in a select control.\n    $scope.detectorId = '' + detectorIndex;\n\n    updateControlsForDetector();\n\n    // Populate the map of jobs / detectors / field formatters for the selected IDs and refresh.\n    _field_format_service.mlFieldFormatService.populateFormats([jobId], (0, _index_utils.getIndexPatterns)()).catch(function (err) {\n      console.log('Error populating field formats:', err);\n    })\n    // Load the data - if the FieldFormats failed to populate\n    // the default formatting will be used for metric values.\n    .then(function () {\n      $scope.refresh();\n    });\n  }\n\n  function loadAnomaliesTableData(earliestMs, latestMs) {\n\n    _ml_api_service.ml.results.getAnomaliesTableData([$scope.selectedJob.job_id], $scope.criteriaFields, [], mlSelectIntervalService.state.get('interval').val, mlSelectSeverityService.state.get('threshold').val, earliestMs, latestMs, dateFormatTz, _search.ANOMALIES_TABLE_DEFAULT_QUERY_SIZE).then(function (resp) {\n      var anomalies = resp.anomalies;\n      var detectorsByJob = _job_service.mlJobService.detectorsByJob;\n      anomalies.forEach(function (anomaly) {\n        // Add a detector property to each anomaly.\n        // Default to functionDescription if no description available.\n        // TODO - when job_service is moved server_side, move this to server endpoint.\n        var jobId = anomaly.jobId;\n        var detector = _lodash2.default.get(detectorsByJob, [jobId, anomaly.detectorIndex]);\n        anomaly.detector = _lodash2.default.get(detector, ['detector_description'], anomaly.source.function_description);\n\n        // For detectors with rules, add a property with the rule count.\n        var customRules = detector.custom_rules;\n        if (customRules !== undefined) {\n          anomaly.rulesLength = customRules.length;\n        }\n\n        // Add properties used for building the links menu.\n        // TODO - when job_service is moved server_side, move this to server endpoint.\n        if (_lodash2.default.has(_job_service.mlJobService.customUrlsByJob, jobId)) {\n          anomaly.customUrls = _job_service.mlJobService.customUrlsByJob[jobId];\n        }\n      });\n\n      $scope.$evalAsync(function () {\n        $scope.tableData = {\n          anomalies: anomalies,\n          interval: resp.interval,\n          examplesByJobId: resp.examplesByJobId,\n          showViewSeriesLink: false\n        };\n      });\n    }).catch(function (resp) {\n      console.log('Time series explorer - error loading data for anomalies table:', resp);\n    });\n  }\n\n  function updateControlsForDetector() {\n    // Update the entity dropdown control(s) according to the partitioning fields for the selected detector.\n    var detectorIndex = +$scope.detectorId;\n    var detector = $scope.selectedJob.analysis_config.detectors[detectorIndex];\n\n    var entities = [];\n    var entitiesState = $scope.appState.mlTimeSeriesExplorer.entities || {};\n    var partitionFieldName = _lodash2.default.get(detector, 'partition_field_name');\n    var overFieldName = _lodash2.default.get(detector, 'over_field_name');\n    var byFieldName = _lodash2.default.get(detector, 'by_field_name');\n    if (partitionFieldName !== undefined) {\n      var partitionFieldValue = _lodash2.default.get(entitiesState, partitionFieldName, '');\n      entities.push({ fieldName: partitionFieldName, fieldValue: partitionFieldValue });\n    }\n    if (overFieldName !== undefined) {\n      var overFieldValue = _lodash2.default.get(entitiesState, overFieldName, '');\n      entities.push({ fieldName: overFieldName, fieldValue: overFieldValue });\n    }\n\n    // For jobs with by and over fields, don't add the 'by' field as this\n    // field will only be added to the top-level fields for record type results\n    // if it also an influencer over the bucket.\n    // TODO - metric data can be filtered by this field, so should only exclude\n    // from filter for the anomaly records.\n    if (byFieldName !== undefined && overFieldName === undefined) {\n      var byFieldValue = _lodash2.default.get(entitiesState, byFieldName, '');\n      entities.push({ fieldName: byFieldName, fieldValue: byFieldValue });\n    }\n\n    $scope.entities = entities;\n  }\n\n  function loadEntityValues() {\n    // Populate the entity input datalists with the values from the top records by score\n    // for the selected detector across the full time range. No need to pass through finish().\n    var bounds = _timefilter.timefilter.getActiveBounds();\n    var detectorIndex = +$scope.detectorId;\n\n    _results_service.mlResultsService.getRecordsForCriteria([$scope.selectedJob.job_id], [{ 'fieldName': 'detector_index', 'fieldValue': detectorIndex }], 0, bounds.min.valueOf(), bounds.max.valueOf(), _search.ANOMALIES_TABLE_DEFAULT_QUERY_SIZE).then(function (resp) {\n      if (resp.records && resp.records.length > 0) {\n        var firstRec = resp.records[0];\n\n        _lodash2.default.each($scope.entities, function (entity) {\n          if (firstRec.partition_field_name === entity.fieldName) {\n            entity.fieldValues = _lodash2.default.chain(resp.records).pluck('partition_field_value').uniq().value();\n          }\n          if (firstRec.over_field_name === entity.fieldName) {\n            entity.fieldValues = _lodash2.default.chain(resp.records).pluck('over_field_value').uniq().value();\n          }\n          if (firstRec.by_field_name === entity.fieldName) {\n            entity.fieldValues = _lodash2.default.chain(resp.records).pluck('by_field_value').uniq().value();\n          }\n        });\n        $scope.$applyAsync();\n      }\n    });\n  }\n\n  function calculateInitialFocusRange() {\n    // Check for a zoom parameter in the appState (URL).\n    var zoomState = $scope.appState.mlTimeSeriesExplorer.zoom;\n    if (zoomState !== undefined) {\n      // Calculate the 'auto' zoom duration which shows data at bucket span granularity.\n      $scope.autoZoomDuration = getAutoZoomDuration();\n\n      // Check that the zoom times are valid.\n      // zoomFrom must be at or after dashboard earliest,\n      // zoomTo must be at or before dashboard latest plus context chart agg interval.\n      var zoomFrom = (0, _momentTimezone2.default)(zoomState.from, 'YYYY-MM-DDTHH:mm:ss.SSSZ', true);\n      var zoomTo = (0, _momentTimezone2.default)(zoomState.to, 'YYYY-MM-DDTHH:mm:ss.SSSZ', true);\n      var aggIntervalMs = $scope.contextAggregationInterval.asMilliseconds();\n      var bounds = _timefilter.timefilter.getActiveBounds();\n      var earliest = bounds.min;\n      var latest = (0, _momentTimezone2.default)(bounds.max).add(aggIntervalMs, 'ms');\n\n      if (zoomFrom.isValid() && zoomTo.isValid && zoomTo.isAfter(zoomFrom) && zoomFrom.isBetween(earliest, latest, null, '[]') && zoomTo.isBetween(earliest, latest, null, '[]')) {\n        return [zoomFrom.toDate(), zoomTo.toDate()];\n      }\n    }\n\n    return calculateDefaultFocusRange();\n  }\n\n  function calculateDefaultFocusRange() {\n\n    $scope.autoZoomDuration = getAutoZoomDuration();\n    var isForecastData = $scope.contextForecastData !== undefined && $scope.contextForecastData.length > 0;\n\n    var combinedData = isForecastData === false ? $scope.contextChartData : $scope.contextChartData.concat($scope.contextForecastData);\n    var earliestDataDate = _lodash2.default.first(combinedData).date;\n    var latestDataDate = _lodash2.default.last(combinedData).date;\n\n    var rangeEarliestMs = void 0;\n    var rangeLatestMs = void 0;\n\n    if (isForecastData === true) {\n      // Return a range centred on the start of the forecast range, depending\n      // on the time range of the forecast and data.\n      var earliestForecastDataDate = _lodash2.default.first($scope.contextForecastData).date;\n      var latestForecastDataDate = _lodash2.default.last($scope.contextForecastData).date;\n\n      rangeLatestMs = Math.min(earliestForecastDataDate.getTime() + $scope.autoZoomDuration / 2, latestForecastDataDate.getTime());\n      rangeEarliestMs = Math.max(rangeLatestMs - $scope.autoZoomDuration, earliestDataDate.getTime());\n    } else {\n      // Returns the range that shows the most recent data at bucket span granularity.\n      rangeLatestMs = latestDataDate.getTime() + $scope.contextAggregationInterval.asMilliseconds();\n      rangeEarliestMs = Math.max(earliestDataDate.getTime(), rangeLatestMs - $scope.autoZoomDuration);\n    }\n\n    return [new Date(rangeEarliestMs), new Date(rangeLatestMs)];\n  }\n\n  function calculateAggregationInterval(bounds, bucketsTarget) {\n    // Aggregation interval used in queries should be a function of the time span of the chart\n    // and the bucket span of the selected job(s).\n    var barTarget = bucketsTarget !== undefined ? bucketsTarget : 100;\n    // Use a maxBars of 10% greater than the target.\n    var maxBars = Math.floor(1.1 * barTarget);\n    var buckets = new TimeBuckets();\n    buckets.setInterval('auto');\n    buckets.setBounds(bounds);\n    buckets.setBarTarget(Math.floor(barTarget));\n    buckets.setMaxBars(maxBars);\n\n    // Ensure the aggregation interval is always a multiple of the bucket span to avoid strange\n    // behaviour such as adjacent chart buckets holding different numbers of job results.\n    var bucketSpanSeconds = _lodash2.default.find($scope.jobs, { 'id': $scope.selectedJob.job_id }).bucketSpanSeconds;\n    var aggInterval = buckets.getIntervalToNearestMultiple(bucketSpanSeconds);\n\n    // Set the interval back to the job bucket span if the auto interval is smaller.\n    var secs = aggInterval.asSeconds();\n    if (secs < bucketSpanSeconds) {\n      buckets.setInterval(bucketSpanSeconds + 's');\n      aggInterval = buckets.getInterval();\n    }\n\n    console.log('calculateAggregationInterval() barTarget,maxBars,returning:', bucketsTarget, maxBars, bounds.max.diff(bounds.min) / aggInterval.asMilliseconds());\n\n    return aggInterval;\n  }\n\n  function getAutoZoomDuration() {\n    // Calculate the 'auto' zoom duration which shows data at bucket span granularity.\n    // Get the minimum bucket span of selected jobs.\n    // TODO - only look at jobs for which data has been returned?\n    var bucketSpanSeconds = _lodash2.default.find($scope.jobs, { 'id': $scope.selectedJob.job_id }).bucketSpanSeconds;\n\n    // In most cases the duration can be obtained by simply multiplying the points target\n    // Check that this duration returns the bucket span when run back through the\n    // TimeBucket interval calculation.\n    var autoZoomDuration = bucketSpanSeconds * 1000 * (CHARTS_POINT_TARGET - 1);\n\n    // Use a maxBars of 10% greater than the target.\n    var maxBars = Math.floor(1.1 * CHARTS_POINT_TARGET);\n    var buckets = new TimeBuckets();\n    buckets.setInterval('auto');\n    buckets.setBarTarget(Math.floor(CHARTS_POINT_TARGET));\n    buckets.setMaxBars(maxBars);\n\n    // Set bounds from 'now' for testing the auto zoom duration.\n    var nowMs = new Date().getTime();\n    var max = (0, _momentTimezone2.default)(nowMs);\n    var min = (0, _momentTimezone2.default)(nowMs - autoZoomDuration);\n    buckets.setBounds({ min: min, max: max });\n\n    var calculatedInterval = buckets.getIntervalToNearestMultiple(bucketSpanSeconds);\n    var calculatedIntervalSecs = calculatedInterval.asSeconds();\n    if (calculatedIntervalSecs !== bucketSpanSeconds) {\n      // If we haven't got the span back, which may occur depending on the 'auto' ranges\n      // used in TimeBuckets and the bucket span of the job, then multiply by the ratio\n      // of the bucket span to the calculated interval.\n      autoZoomDuration = autoZoomDuration * (bucketSpanSeconds / calculatedIntervalSecs);\n    }\n\n    return autoZoomDuration;\n  }\n\n  $scope.initializeVis();\n});",null]}