{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/reducers/elements.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/reducers/elements.js","mtime":1567631711936},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.elementsReducer = undefined;\n\nvar _handleActions;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nvar _reduxActions = require('redux-actions');\n\nvar _objectPathImmutable = require('object-path-immutable');\n\nvar _lodash = require('lodash');\n\nvar _elements = require('../actions/elements');\n\nvar actions = _interopRequireWildcard(_elements);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar getLocation = function getLocation(type) {\n  return type === 'group' ? 'groups' : 'elements';\n};\nvar firstOccurrence = function firstOccurrence(element, index, array) {\n  return array.indexOf(element) === index;\n};\n\nvar getLocationFromIds = function getLocationFromIds(workpadState, pageId, nodeId) {\n  var page = workpadState.pages.find(function (p) {\n    return p.id === pageId;\n  });\n  var groups = page == null ? [] : page.groups || [];\n  return groups.find(function (e) {\n    return e.id === nodeId;\n  }) ? 'groups' : 'elements';\n};\n\nfunction getPageIndexById(workpadState, pageId) {\n  return (0, _lodash.get)(workpadState, 'pages', []).findIndex(function (page) {\n    return page.id === pageId;\n  });\n}\n\nfunction getNodeIndexById(page, nodeId, location) {\n  return page[location].findIndex(function (node) {\n    return node.id === nodeId;\n  });\n}\n\nfunction assignNodeProperties(workpadState, pageId, nodeId, props) {\n  var pageIndex = getPageIndexById(workpadState, pageId);\n  var location = getLocationFromIds(workpadState, pageId, nodeId);\n  var nodesPath = ['pages', pageIndex, location];\n  var nodeIndex = (0, _lodash.get)(workpadState, nodesPath, []).findIndex(function (node) {\n    return node.id === nodeId;\n  });\n\n  if (pageIndex === -1 || nodeIndex === -1) {\n    return workpadState;\n  }\n\n  // remove any AST value from the element caused by https://github.com/elastic/kibana-canvas/issues/260\n  // TODO: remove this after a bit of time\n  var cleanWorkpadState = (0, _objectPathImmutable.del)(workpadState, nodesPath.concat([nodeIndex, 'ast']));\n\n  return (0, _objectPathImmutable.assign)(cleanWorkpadState, nodesPath.concat(nodeIndex), props);\n}\n\nfunction moveNodeLayer(workpadState, pageId, nodeId, movement, location) {\n  var pageIndex = getPageIndexById(workpadState, pageId);\n  var nodeIndex = getNodeIndexById(workpadState.pages[pageIndex], nodeId, location);\n  var nodes = (0, _lodash.get)(workpadState, ['pages', pageIndex, location]);\n  var from = nodeIndex;\n\n  var to = function () {\n    if (movement < Infinity && movement > -Infinity) {\n      return nodeIndex + movement;\n    }\n    if (movement === Infinity) {\n      return nodes.length - 1;\n    }\n    if (movement === -Infinity) {\n      return 0;\n    }\n    throw new Error('Invalid element layer movement');\n  }();\n\n  if (to > nodes.length - 1 || to < 0) {\n    return workpadState;\n  }\n\n  // Common\n  var newNodes = nodes.slice(0);\n  newNodes.splice(to, 0, newNodes.splice(from, 1)[0]);\n\n  return (0, _objectPathImmutable.set)(workpadState, ['pages', pageIndex, location], newNodes);\n}\n\nvar trimPosition = function trimPosition(_ref) {\n  var left = _ref.left,\n      top = _ref.top,\n      width = _ref.width,\n      height = _ref.height,\n      angle = _ref.angle,\n      parent = _ref.parent;\n  return {\n    left: left,\n    top: top,\n    width: width,\n    height: height,\n    angle: angle,\n    parent: parent\n  };\n};\n\nvar trimElement = function trimElement(_ref2) {\n  var id = _ref2.id,\n      position = _ref2.position,\n      expression = _ref2.expression,\n      filter = _ref2.filter;\n  return _extends({\n    id: id,\n    position: trimPosition(position)\n  }, position.type !== 'group' && { expression: expression }, filter !== void 0 && { filter: filter });\n};\n\nvar elementsReducer = exports.elementsReducer = (0, _reduxActions.handleActions)((_handleActions = {}, _defineProperty(_handleActions, actions.setExpression, function (workpadState, _ref3) {\n  var payload = _ref3.payload;\n  var expression = payload.expression,\n      pageId = payload.pageId,\n      elementId = payload.elementId;\n\n  return assignNodeProperties(workpadState, pageId, elementId, { expression: expression });\n}), _defineProperty(_handleActions, actions.setFilter, function (workpadState, _ref4) {\n  var payload = _ref4.payload;\n  var filter = payload.filter,\n      pageId = payload.pageId,\n      elementId = payload.elementId;\n\n  return assignNodeProperties(workpadState, pageId, elementId, { filter: filter });\n}), _defineProperty(_handleActions, actions.setMultiplePositions, function (workpadState, _ref5) {\n  var payload = _ref5.payload;\n  return payload.repositionedElements.reduce(function (previousWorkpadState, _ref6) {\n    var position = _ref6.position,\n        pageId = _ref6.pageId,\n        elementId = _ref6.elementId;\n    return assignNodeProperties(previousWorkpadState, pageId, elementId, {\n      position: trimPosition(position)\n    });\n  }, workpadState);\n}), _defineProperty(_handleActions, actions.elementLayer, function (workpadState, _ref7) {\n  var _ref7$payload = _ref7.payload,\n      pageId = _ref7$payload.pageId,\n      elementId = _ref7$payload.elementId,\n      movement = _ref7$payload.movement;\n\n  var location = getLocationFromIds(workpadState, pageId, elementId);\n  return moveNodeLayer(workpadState, pageId, elementId, movement, location);\n}), _defineProperty(_handleActions, actions.addElement, function (workpadState, _ref8) {\n  var _ref8$payload = _ref8.payload,\n      pageId = _ref8$payload.pageId,\n      element = _ref8$payload.element;\n\n  var pageIndex = getPageIndexById(workpadState, pageId);\n  if (pageIndex < 0) {\n    return workpadState;\n  }\n  return (0, _objectPathImmutable.push)(workpadState, ['pages', pageIndex, getLocation(element.position.type)], trimElement(element));\n}), _defineProperty(_handleActions, actions.insertNodes, function (workpadState, _ref9) {\n  var _ref9$payload = _ref9.payload,\n      pageId = _ref9$payload.pageId,\n      elements = _ref9$payload.elements;\n\n  var pageIndex = getPageIndexById(workpadState, pageId);\n  if (pageIndex < 0) {\n    return workpadState;\n  }\n  return elements.reduce(function (state, element) {\n    return (0, _objectPathImmutable.push)(state, ['pages', pageIndex, getLocation(element.position.type)], trimElement(element));\n  }, workpadState);\n}), _defineProperty(_handleActions, actions.removeElements, function (workpadState, _ref10) {\n  var _ref10$payload = _ref10.payload,\n      pageId = _ref10$payload.pageId,\n      elementIds = _ref10$payload.elementIds;\n\n  var pageIndex = getPageIndexById(workpadState, pageId);\n  if (pageIndex < 0) {\n    return workpadState;\n  }\n\n  var nodeIndices = elementIds.filter(firstOccurrence).map(function (nodeId) {\n    var location = getLocationFromIds(workpadState, pageId, nodeId);\n    return {\n      location: location,\n      index: getNodeIndexById(workpadState.pages[pageIndex], nodeId, location)\n    };\n  }).sort(function (a, b) {\n    return b.index - a.index;\n  }); // deleting from end toward beginning, otherwise indices will become off - todo fuse loops!\n\n  return nodeIndices.reduce(function (state, _ref11) {\n    var location = _ref11.location,\n        index = _ref11.index;\n\n    return (0, _objectPathImmutable.del)(state, ['pages', pageIndex, location, index]);\n  }, workpadState);\n}), _handleActions), {});",null]}