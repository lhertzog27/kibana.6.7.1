{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/population/create_job/create_job_chart_directive.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/jobs/new_job/simple/population/create_job/create_job_chart_directive.js","mtime":1567631712059},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _angular = require('angular');\n\nvar _angular2 = _interopRequireDefault(_angular);\n\nvar _moment = require('moment');\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _date_utils = require('../../../../../util/date_utils');\n\nvar _time_buckets = require('ui/time_buckets');\n\nvar _chart_utils = require('../../../../../util/chart_utils');\n\nvar _string_utils = require('../../../../../util/string_utils');\n\nvar _chart_tooltip_service = require('../../../../../components/chart_tooltip/chart_tooltip_service');\n\nvar _modules = require('ui/modules');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\n/*\n * Chart showing metric data, annotated with anomalies.\n */\n\nvar _module = _modules.uiModules.get('apps/ml');\n\n_module.directive('mlPopulationJobChart', function (i18n) {\n\n  function link(scope, element) {\n\n    var svgWidth = 0;\n    var chartHeight = scope.chartHeight;\n    var margin = { top: 0, right: 0, bottom: 20, left: scope.chartTicksMargin.width };\n    var svgHeight = chartHeight + margin.top + margin.bottom;\n    var vizWidth = svgWidth - margin.left - margin.right;\n    var chartLimits = { max: 0, min: 0 };\n\n    var chartXScale = null;\n    var chartYScale = null;\n\n    var chartGroup = void 0;\n    var swimlaneGroup = void 0;\n\n    var $progressBar = void 0;\n\n    scope.$on('render', function () {\n      init();\n      createSVGGroups();\n      drawChart();\n    });\n\n    scope.$on('render-results', function () {\n      drawResults();\n    });\n\n    element.on('$destroy', function () {\n      scope.$destroy();\n    });\n\n    function init() {\n      var $el = _angular2.default.element('.population-job-container .card-front');\n      var offset = $el.hasClass('card') ? 30 : 0;\n\n      margin.left = scope.chartTicksMargin.width;\n\n      svgWidth = $el.width() - offset;\n      vizWidth = svgWidth - margin.left - margin.right;\n\n      chartXScale = _d2.default.time.scale().range([0, vizWidth]);\n      chartYScale = _d2.default.scale.linear().range([chartHeight, 0]);\n    }\n\n    function createSVGGroups() {\n      if (scope.chartData.line === undefined) {\n        return;\n      }\n\n      // Clear any existing elements from the visualization,\n      // then build the svg elements for the chart.\n      var chartElement = _d2.default.select(element.get(0));\n      chartElement.select('svg').remove();\n      chartElement.select('.progress').remove();\n\n      if (chartElement.select('.progress-bar')[0][0] === null) {\n        var style = 'width: ' + (+vizWidth + 2) + 'px;\\n          margin-bottom: -' + (+chartHeight - 15) + 'px;\\n          margin-left: ' + (+margin.left - 1) + 'px;\\'';\n\n        chartElement.append('div').attr('class', 'progress').attr('style', style).append('div').attr('class', 'progress-bar');\n      }\n\n      $progressBar = (0, _jquery2.default)('.progress-bar');\n\n      var svg = chartElement.append('svg').attr('width', svgWidth).attr('height', svgHeight);\n\n      swimlaneGroup = svg.append('g').attr('class', 'swimlane').attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');\n\n      chartGroup = svg.append('g').attr('class', 'line-chart').attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');\n    }\n\n    function drawChart() {\n      if (scope.chartData.line.length === 0) {\n        return;\n      }\n\n      // create flat array of data points\n      var data = scope.chartData.line.reduce(function (p, c) {\n        if (c.values.length) {\n          c.values.forEach(function (v) {\n            p.push({ date: c.date, value: v.value, label: v.label });\n          });\n        } else {\n          // for empty buckets, still add an entry so we plot gaps\n          p.push({ date: c.date, value: null, label: null });\n        }\n        return p;\n      }, []);\n\n      chartXScale = chartXScale.domain(_d2.default.extent(data, function (d) {\n        return d.date;\n      }));\n\n      chartLimits.max = _d2.default.max(data, function (d) {\n        return d.value;\n      });\n      chartLimits.min = _d2.default.min(data, function (d) {\n        return d.value;\n      });\n\n      // add padding of 10% of the difference between max and min\n      // to the upper and lower ends of the y-axis\n      var padding = (chartLimits.max - chartLimits.min) * 0.05;\n      chartLimits.max += padding;\n      chartLimits.min -= padding;\n\n      chartYScale = chartYScale.domain([chartLimits.min, chartLimits.max]);\n\n      // Get the scaled date format to use for x axis tick labels.\n      var timeBuckets = new _time_buckets.TimeBuckets();\n      timeBuckets.setInterval('auto');\n      if (data.length > 0) {\n        var xDomain = chartXScale.domain();\n        var bounds = { min: (0, _moment2.default)(xDomain[0]), max: (0, _moment2.default)(xDomain[1]) };\n        timeBuckets.setBounds(bounds);\n      }\n      var xAxisTickFormat = timeBuckets.getScaledDateFormat();\n\n      var xAxis = _d2.default.svg.axis().scale(chartXScale).orient('bottom').innerTickSize(-chartHeight).outerTickSize(0).tickPadding(10).ticks((0, _chart_utils.numTicksForDateFormat)(vizWidth, xAxisTickFormat)).tickFormat(function (d) {\n        return (0, _moment2.default)(d).format(xAxisTickFormat);\n      });\n\n      var yAxis = _d2.default.svg.axis().scale(chartYScale).orient('left').innerTickSize(-vizWidth).outerTickSize(0).tickPadding(10);\n\n      if (scope.chartData.fieldFormat !== undefined) {\n        yAxis.tickFormat(function (d) {\n          return scope.chartData.fieldFormat.convert(d, 'text');\n        });\n      }\n\n      // add a white background to the chart\n      swimlaneGroup.append('rect').attr('x', 0).attr('y', 0).attr('height', chartHeight).attr('width', vizWidth).style('fill', '#FFFFFF');\n\n      // Add border round plot area.\n      chartGroup.append('rect').attr('x', 0).attr('y', 0).attr('height', chartHeight).attr('width', vizWidth).style('stroke', '#cccccc').style('fill', 'none').style('stroke-width', 1);\n\n      drawChartAxes(xAxis, yAxis);\n      drawChartDots(data);\n    }\n\n    function drawChartAxes(xAxis, yAxis) {\n\n      var axes = chartGroup.append('g');\n\n      axes.append('g').attr('class', 'x axis').attr('transform', 'translate(0, ' + chartHeight + ')').call(xAxis);\n\n      axes.append('g').attr('class', 'y axis').call(yAxis);\n    }\n\n    function drawChartDots(data) {\n      var dotGroup = chartGroup.append('g').classed('values-dots', true);\n      dotGroup.selectAll('circle').data(data).enter().append('circle').attr('cx', function (d) {\n        return chartXScale(d.date);\n      }).attr('cy', function (d) {\n        return chartYScale(d.value);\n      }).attr('r', 3).style('display', function (d) {\n        return d.value === null ? 'none' : 'auto';\n      }).on('mouseover', function (d) {\n        showTooltip(d, this);\n      }).on('mouseout', function () {\n        return _chart_tooltip_service.mlChartTooltipService.hide();\n      });\n    }\n\n    function showTooltip(data, el) {\n      scope;\n      var contents = '';\n      var formattedDate = (0, _date_utils.formatHumanReadableDateTime)(data.date);\n      contents += formattedDate + '<br/><hr/>';\n      contents += (0, _string_utils.mlEscape)(scope.overFieldName) + ': ' + (0, _string_utils.mlEscape)(data.label) + '<br/>';\n      contents += i18n('xpack.ml.newJob.simple.population.chartTooltipValueLabel', {\n        defaultMessage: 'Value: {dataValue}',\n        values: {\n          dataValue: scope.chartData.fieldFormat !== undefined ? scope.chartData.fieldFormat.convert(data.value, 'text') : parseInt(data.value)\n        }\n      });\n      _chart_tooltip_service.mlChartTooltipService.show(contents, el, {\n        x: 5,\n        y: 10\n      });\n    }\n\n    function drawResults() {\n      drawSwimlane(vizWidth, chartHeight);\n      updateProgressBar();\n    }\n\n    function drawSwimlane(swlWidth, swlHeight) {\n      var data = scope.chartData.swimlane;\n\n      var cellWidth = 0;\n      if (data.length > 0) {\n        cellWidth = chartXScale(data[0].time + scope.chartData.swimlaneInterval) - chartXScale(data[0].time);\n      }\n\n      _d2.default.time.scale().range([0, swlWidth]).domain(_d2.default.extent(data, function (d) {\n        return d.date;\n      }));\n\n      _d2.default.scale.linear().range([swlHeight, 0]).domain([0, swlHeight]);\n\n      // Set up the color scale to use for indicating score.\n      var color = _d2.default.scale.threshold().domain([3, 25, 50, 75, 100]).range(['#d2e9f7', '#8bc8fb', '#ffdd00', '#ff7e00', '#fe5050']);\n\n      swimlaneGroup.select('.swimlane-cells').remove();\n\n      var cells = swimlaneGroup.append('g').attr('class', 'swimlane-cells').selectAll('cells').data(data);\n\n      cells.enter().append('rect').attr('x', function (d) {\n        return chartXScale(d.date);\n      }).attr('y', 0).attr('rx', 0).attr('ry', 0).attr('class', function (d) {\n        return d.value > 0 ? 'swimlane-cell' : 'swimlane-cell-hidden';\n      }).attr('width', cellWidth - 0).attr('height', swlHeight - 0).style('fill', function (d) {\n        return color(d.value);\n      });\n    }\n\n    function updateProgressBar() {\n      var pcnt = scope.chartData.percentComplete < 100 ? scope.chartData.percentComplete : 0;\n      $progressBar.css('width', pcnt + '%');\n    }\n  }\n\n  return {\n    scope: {\n      chartData: '=',\n      chartHeight: '=',\n      chartTicksMargin: '=',\n      overFieldName: '='\n    },\n    link: link\n  };\n});",null]}