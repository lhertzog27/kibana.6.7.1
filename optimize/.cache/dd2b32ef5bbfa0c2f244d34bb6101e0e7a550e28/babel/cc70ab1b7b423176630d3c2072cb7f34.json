{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/aeroelastic/geometry.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/lib/aeroelastic/geometry.js","mtime":1567631711932},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.landmarkPoint = exports.shapesAt = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\nvar _matrix = require('./matrix');\n\n/**\n * Pure calculations with geometry awareness - a set of rectangles with known size (a, b) and projection (transform matrix)\n */\n\n/**\n *\n * a * x0 + b * x1 = x\n * a * y0 + b * y1 = y\n *\n * a, b = ?\n *\n * b = (y - a * y0) / y1\n *\n * a * x0 + b * x1 = x\n *\n * a * x0 + (y - a * y0) / y1 * x1 = x\n *\n * a * x0 + y / y1 * x1 - a * y0 / y1 * x1 = x\n *\n * a * x0 - a * y0 / y1 * x1 = x - y / y1 * x1\n *\n * a * (x0 - y0 / y1 * x1) = x - y / y1 * x1\n *\n * a = (x - y / y1 * x1) / (x0 - y0 / y1 * x1)\n * b = (y - a * y0) / y1\n *\n */\n// set of shapes under a specific point\nvar shapesAtPoint = function shapesAtPoint(shapes, x, y) {\n  return shapes.map(function (shape, index) {\n    var transformMatrix = shape.transformMatrix,\n        a = shape.a,\n        b = shape.b;\n\n    // Determine z (depth) by composing the x, y vector out of local unit x and unit y vectors; by knowing the\n    // scalar multipliers for the unit x and unit y vectors, we can determine z from their respective 'slope' (gradient)\n\n    var centerPoint = (0, _matrix.normalize)((0, _matrix.mvMultiply)(transformMatrix, _matrix.ORIGIN));\n    var rightPoint = (0, _matrix.normalize)((0, _matrix.mvMultiply)(transformMatrix, [1, 0, 0, 1]));\n    var upPoint = (0, _matrix.normalize)((0, _matrix.mvMultiply)(transformMatrix, [0, 1, 0, 1]));\n    var x0 = rightPoint[0] - centerPoint[0];\n    var y0 = rightPoint[1] - centerPoint[1];\n    var x1 = upPoint[0] - centerPoint[0];\n    var y1 = upPoint[1] - centerPoint[1];\n    var A = (x - centerPoint[0] - (y - centerPoint[1]) / y1 * x1) / (x0 - y0 / y1 * x1);\n    var B = (y - centerPoint[1] - A * y0) / y1;\n    var rightSlope = rightPoint[2] - centerPoint[2];\n    var upSlope = upPoint[2] - centerPoint[2];\n    var z = centerPoint[2] + (y1 ? rightSlope * A + upSlope * B : 0); // handle degenerate case: y1 === 0 (infinite slope)\n\n    // We go full tilt with the inverse transform approach because that's general enough to handle any non-pathological\n    // composition of transforms. Eg. this is a description of the idea: https://math.stackexchange.com/a/1685315\n    // Hmm maybe we should reuse the above right and up unit vectors to establish whether we're within the (a, b) 'radius'\n    // rather than using matrix inversion. Bound to be cheaper.\n\n    var inverseProjection = (0, _matrix.invert)(transformMatrix);\n    var intersection = (0, _matrix.normalize)((0, _matrix.mvMultiply)(inverseProjection, [x, y, z, 1]));\n\n    var _intersection = _slicedToArray(intersection, 2),\n        sx = _intersection[0],\n        sy = _intersection[1];\n\n    // z is needed downstream, to tell which one is the closest shape hit by an x, y ray (shapes can be tilted in z)\n    // it looks weird to even return items where inside === false, but it could be useful for hotspots outside the rectangle\n\n\n    return { z: z, intersection: intersection, inside: Math.abs(sx) <= a && Math.abs(sy) <= b, shape: shape, index: index };\n  });\n};\n\n// Z-order the possibly several shapes under the same point.\n// Since CSS X points to the right, Y to the bottom (not the top!) and Z toward the viewer, it's a left-handed coordinate\n// system. Yet another wording is that X and Z point toward the expected directions (right, and towards the viewer,\n// respectively), but Y is pointing toward the bottom (South). It's called left-handed because we can position the thumb (X),\n// index (Y) and middle finger (Z) on the left hand such that they're all perpendicular to one another, and point to the\n// positive direction.\n//\n// If it were a right handed coordinate system, AND Y still pointed down, then Z should increase away from the\n// viewer. But that's not the case. So we maximize the Z value to tell what's on top.\nvar shapesAt = exports.shapesAt = function shapesAt(shapes, _ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  return shapesAtPoint(shapes, x, y).filter(function (shape) {\n    return shape.inside;\n  }).sort(function (shape1, shape2) {\n    return shape2.z - shape1.z || shape2.index - shape1.index;\n  }) // stable sort: DOM insertion order!!!\n  .map(function (shape) {\n    return shape.shape;\n  });\n}; // decreasing order, ie. from front (closest to viewer) to back\n\nvar getExtremum = function getExtremum(transformMatrix, a, b) {\n  return (0, _matrix.normalize)((0, _matrix.mvMultiply)(transformMatrix, [a, b, 0, 1]));\n};\n\nvar landmarkPoint = exports.landmarkPoint = function landmarkPoint(a, b, transformMatrix, k, l) {\n  return getExtremum(transformMatrix, k * a, l * b);\n};",null]}