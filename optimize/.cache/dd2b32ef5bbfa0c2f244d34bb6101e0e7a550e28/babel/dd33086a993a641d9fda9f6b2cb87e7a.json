{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/timeseriesexplorer_utils.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/timeseriesexplorer_utils.js","mtime":1567631712070},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTimeSeriesJobData = createTimeSeriesJobData;\nexports.processMetricPlotResults = processMetricPlotResults;\nexports.processForecastResults = processForecastResults;\nexports.processRecordScoreResults = processRecordScoreResults;\nexports.processDataForFocusAnomalies = processDataForFocusAnomalies;\nexports.processScheduledEventsForChart = processScheduledEventsForChart;\nexports.findNearestChartPointToTime = findNearestChartPointToTime;\nexports.findChartPointForAnomalyTime = findChartPointForAnomalyTime;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _parse_interval = require('ui/utils/parse_interval');\n\nvar _job_utils = require('../../common/util/job_utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// create new job objects based on standard job config objects\n// new job objects just contain job id, bucket span in seconds and a selected flag.\n// only time series view jobs are allowed\nfunction createTimeSeriesJobData(jobs) {\n  var singleTimeSeriesJobs = jobs.filter(_job_utils.isTimeSeriesViewJob);\n  return singleTimeSeriesJobs.map(function (job) {\n    var bucketSpan = (0, _parse_interval.parseInterval)(job.analysis_config.bucket_span);\n    return {\n      id: job.job_id,\n      selected: false,\n      bucketSpanSeconds: bucketSpan.asSeconds()\n    };\n  });\n}\n\n// Return dataset in format used by the single metric chart.\n// i.e. array of Objects with keys date (JavaScript date) and value,\n// plus lower and upper keys if model plot is enabled for the series.\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\n/*\n * Contains a number of utility functions used for processing\n * the data for exploring a time series in the Single Metric\n * Viewer dashboard.\n */\n\nfunction processMetricPlotResults(metricPlotData, modelPlotEnabled) {\n  var metricPlotChartData = [];\n  if (modelPlotEnabled === true) {\n    _lodash2.default.each(metricPlotData, function (dataForTime, time) {\n      metricPlotChartData.push({\n        date: new Date(+time),\n        lower: dataForTime.modelLower,\n        value: dataForTime.actual,\n        upper: dataForTime.modelUpper\n      });\n    });\n  } else {\n    _lodash2.default.each(metricPlotData, function (dataForTime, time) {\n      metricPlotChartData.push({\n        date: new Date(+time),\n        value: dataForTime.actual\n      });\n    });\n  }\n\n  return metricPlotChartData;\n}\n\n// Returns forecast dataset in format used by the single metric chart.\n// i.e. array of Objects with keys date (JavaScript date), isForecast,\n// value, lower and upper keys.\nfunction processForecastResults(forecastData) {\n  var forecastPlotChartData = [];\n  _lodash2.default.each(forecastData, function (dataForTime, time) {\n    forecastPlotChartData.push({\n      date: new Date(+time),\n      isForecast: true,\n      lower: dataForTime.forecastLower,\n      value: dataForTime.prediction,\n      upper: dataForTime.forecastUpper\n    });\n  });\n\n  return forecastPlotChartData;\n}\n\n// Return dataset in format used by the swimlane.\n// i.e. array of Objects with keys date (JavaScript date) and score.\nfunction processRecordScoreResults(scoreData) {\n  var bucketScoreData = [];\n  _lodash2.default.each(scoreData, function (dataForTime, time) {\n    bucketScoreData.push({\n      date: new Date(+time),\n      score: dataForTime.score\n    });\n  });\n\n  return bucketScoreData;\n}\n\n// Uses data from the list of anomaly records to add anomalyScore,\n// function, actual and typical properties, plus causes and multi-bucket\n// info if applicable, to the chartData entries for anomalous buckets.\nfunction processDataForFocusAnomalies(chartData, anomalyRecords, timeFieldName) {\n\n  // Iterate through the anomaly records adding the\n  // various properties required for display.\n  anomalyRecords.forEach(function (record) {\n\n    // Look for a chart point with the same time as the record.\n    // If none found, find closest time in chartData set.\n    var recordTime = record[timeFieldName];\n    var chartPoint = findChartPointForAnomalyTime(chartData, recordTime);\n\n    // TODO - handle case where there is an anomaly due to the absence of data\n    // and there is no model plot.\n    if (chartPoint === undefined && chartData !== undefined && chartData.length) {\n      // In case there is a record with a time after that of the last chart point, set the score\n      // for the last chart point to that of the last record, if that record has a higher score.\n      var lastChartPoint = chartData[chartData.length - 1];\n      var lastChartPointScore = lastChartPoint.anomalyScore || 0;\n      if (record.record_score > lastChartPointScore) {\n        chartPoint = lastChartPoint;\n      }\n    }\n\n    if (chartPoint !== undefined) {\n      // If chart aggregation interval > bucket span, there may be more than\n      // one anomaly record in the interval, so use the properties from\n      // the record with the highest anomalyScore.\n      var recordScore = record.record_score;\n      var pointScore = chartPoint.anomalyScore;\n      if (pointScore === undefined || pointScore < recordScore) {\n        chartPoint.anomalyScore = recordScore;\n        chartPoint.function = record.function;\n\n        if (_lodash2.default.has(record, 'actual')) {\n          chartPoint.actual = record.actual;\n          chartPoint.typical = record.typical;\n        } else {\n          var causes = _lodash2.default.get(record, 'causes', []);\n          if (causes.length > 0) {\n            chartPoint.byFieldName = record.by_field_name;\n            chartPoint.numberOfCauses = causes.length;\n            if (causes.length === 1) {\n              // If only a single cause, copy actual and typical values to the top level.\n              var cause = _lodash2.default.first(record.causes);\n              chartPoint.actual = cause.actual;\n              chartPoint.typical = cause.typical;\n            }\n          }\n        }\n\n        if (_lodash2.default.has(record, 'multi_bucket_impact')) {\n          chartPoint.multiBucketImpact = record.multi_bucket_impact;\n        }\n      }\n    }\n  });\n\n  return chartData;\n}\n\n// Adds a scheduledEvents property to any points in the chart data set\n// which correspond to times of scheduled events for the job.\nfunction processScheduledEventsForChart(chartData, scheduledEvents) {\n  if (scheduledEvents !== undefined) {\n    _lodash2.default.each(scheduledEvents, function (events, time) {\n      var chartPoint = findNearestChartPointToTime(chartData, time);\n      if (chartPoint !== undefined) {\n        // Note if the scheduled event coincides with an absence of the underlying metric data,\n        // we don't worry about plotting the event.\n        chartPoint.scheduledEvents = events;\n      }\n    });\n  }\n\n  return chartData;\n}\n\n// Finds the chart point which is closest in time to the specified time.\nfunction findNearestChartPointToTime(chartData, time) {\n  var chartPoint = void 0;\n  if (chartData === undefined) {\n    return chartPoint;\n  }\n\n  for (var i = 0; i < chartData.length; i++) {\n    if (chartData[i].date.getTime() === time) {\n      chartPoint = chartData[i];\n      break;\n    }\n  }\n\n  if (chartPoint === undefined) {\n    // Find nearest point in time.\n    // loop through line items until the date is greater than bucketTime\n    // grab the current and previous items and compare the time differences\n    var foundItem = void 0;\n    for (var _i = 0; _i < chartData.length; _i++) {\n      var itemTime = chartData[_i].date.getTime();\n      if (itemTime > time) {\n        var item = chartData[_i];\n        var previousItem = chartData[_i - 1];\n\n        var diff1 = Math.abs(time - previousItem.date.getTime());\n        var diff2 = Math.abs(time - itemTime);\n\n        // foundItem should be the item with a date closest to bucketTime\n        if (previousItem === undefined || diff1 > diff2) {\n          foundItem = item;\n        } else {\n          foundItem = previousItem;\n        }\n\n        break;\n      }\n    }\n\n    chartPoint = foundItem;\n  }\n\n  return chartPoint;\n}\n\n// Finds the chart point which corresponds to an anomaly with the\n// specified time.\nfunction findChartPointForAnomalyTime(chartData, anomalyTime) {\n  var chartPoint = void 0;\n  if (chartData === undefined) {\n    return chartPoint;\n  }\n\n  for (var i = 0; i < chartData.length; i++) {\n    if (chartData[i].date.getTime() === anomalyTime) {\n      chartPoint = chartData[i];\n      break;\n    }\n  }\n\n  if (chartPoint === undefined) {\n    // Find the time of the point which falls immediately before the\n    // time of the anomaly. This is the start of the chart 'bucket'\n    // which contains the anomalous bucket.\n    var foundItem = void 0;\n    for (var _i2 = 0; _i2 < chartData.length; _i2++) {\n      var itemTime = chartData[_i2].date.getTime();\n      if (itemTime > anomalyTime) {\n        foundItem = _i2 > 0 ? chartData[_i2 - 1] : chartData[0];\n        break;\n      }\n    }\n\n    chartPoint = foundItem;\n  }\n\n  return chartPoint;\n}",null]}