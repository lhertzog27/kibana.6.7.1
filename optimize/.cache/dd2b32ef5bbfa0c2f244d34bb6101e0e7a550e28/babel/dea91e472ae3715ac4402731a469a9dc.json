{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/explorer/explorer.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/explorer/explorer.js","mtime":1567631712039},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Explorer = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _class, _temp2; /*\n                     * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                     * or more contributor license agreements. Licensed under the Elastic License;\n                     * you may not use this file except in compliance with the Elastic License.\n                     */\n\n/*\n * React component for rendering Explorer dashboard swimlanes.\n */\n\n// Explorer Charts\n\n\n// Anomalies Table\n\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _react3 = require('@kbn/i18n/react');\n\nvar _dragselect = require('dragselect');\n\nvar _dragselect2 = _interopRequireDefault(_dragselect);\n\nvar _eui = require('@elastic/eui');\n\nvar _annotations_service = require('../services/annotations_service');\n\nvar _annotation_flyout = require('../components/annotations/annotation_flyout');\n\nvar _annotations_table = require('../components/annotations/annotations_table');\n\nvar _components = require('./components');\n\nvar _explorer_swimlane = require('./explorer_swimlane');\n\nvar _date_utils = require('../util/date_utils');\n\nvar _ml_time_buckets = require('plugins/ml/util/ml_time_buckets');\n\nvar _influencers_list = require('../components/influencers_list');\n\nvar _explorer_dashboard_service = require('./explorer_dashboard_service');\n\nvar _results_service = require('plugins/ml/services/results_service');\n\nvar _loading_indicator = require('../components/loading_indicator/loading_indicator');\n\nvar _checkbox_showcharts = require('../components/controls/checkbox_showcharts/checkbox_showcharts');\n\nvar _select_interval = require('../components/controls/select_interval/select_interval');\n\nvar _select_limit = require('./select_limit/select_limit');\n\nvar _select_severity = require('../components/controls/select_severity/select_severity');\n\nvar _explorer_utils = require('./explorer_utils');\n\nvar _explorer_charts_container_service = require('./explorer_charts/explorer_charts_container_service');\n\nvar _legacy_utils = require('./legacy_utils');\n\nvar _explorer_constants = require('./explorer_constants');\n\nvar _explorer_charts_container = require('./explorer_charts/explorer_charts_container');\n\nvar _anomalies_table = require('../components/anomalies_table/anomalies_table');\n\nvar _timefilter = require('ui/timefilter');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction getExplorerDefaultState() {\n  return {\n    annotationsData: [],\n    anomalyChartRecords: [],\n    chartsData: (0, _explorer_charts_container_service.getDefaultChartsData)(),\n    hasResults: false,\n    influencers: {},\n    loading: true,\n    noInfluencersConfigured: true,\n    noJobsFound: true,\n    overallSwimlaneData: [],\n    selectedCells: null,\n    selectedJobs: null,\n    swimlaneViewByFieldName: undefined,\n    tableData: {},\n    viewByLoadedForTimeFormatted: null,\n    viewBySwimlaneData: (0, _explorer_utils.getDefaultViewBySwimlaneData)(),\n    viewBySwimlaneDataLoading: false,\n    viewBySwimlaneOptions: []\n  };\n}\n\nfunction mapSwimlaneOptionsToEuiOptions(options) {\n  return options.map(function (option) {\n    return {\n      value: option,\n      text: option\n    };\n  });\n}\n\nvar Explorer = exports.Explorer = (0, _react3.injectI18n)((_temp2 = _class = function (_React$Component) {\n  _inherits(Explorer, _React$Component);\n\n  function Explorer() {\n    var _ref,\n        _this2 = this;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Explorer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Explorer.__proto__ || Object.getPrototypeOf(Explorer)).call.apply(_ref, [this].concat(args))), _this), _this.state = getExplorerDefaultState(), _this._isMounted = false, _this.disableDragSelectOnMouseLeave = true, _this.skipCellClicks = true, _this.updateCharts = (0, _explorer_charts_container_service.explorerChartsContainerServiceFactory)(function (data) {\n      if (_this._isMounted) {\n        _this.setState({\n          chartsData: _extends({}, (0, _explorer_charts_container_service.getDefaultChartsData)(), {\n            chartsPerRow: data.chartsPerRow,\n            seriesToPlot: data.seriesToPlot,\n            // convert truthy/falsy value to Boolean\n            tooManyBuckets: !!data.tooManyBuckets\n          })\n        });\n      }\n    }), _this.ALLOW_CELL_RANGE_SELECTION = _explorer_dashboard_service.mlExplorerDashboardService.allowCellRangeSelection, _this.dragSelect = new _dragselect2.default({\n      selectables: document.getElementsByClassName('sl-cell'),\n      callback: function callback(elements) {\n        if (elements.length > 1 && !this.ALLOW_CELL_RANGE_SELECTION) {\n          elements = [elements[0]];\n        }\n\n        if (elements.length > 0) {\n          _explorer_dashboard_service.mlExplorerDashboardService.dragSelect.changed({\n            action: _explorer_constants.DRAG_SELECT_ACTION.NEW_SELECTION,\n            elements: elements\n          });\n        }\n\n        this.disableDragSelectOnMouseLeave = true;\n      },\n      onDragStart: function onDragStart() {\n        if (this.ALLOW_CELL_RANGE_SELECTION) {\n          _explorer_dashboard_service.mlExplorerDashboardService.dragSelect.changed({\n            action: _explorer_constants.DRAG_SELECT_ACTION.DRAG_START\n          });\n          this.disableDragSelectOnMouseLeave = false;\n        }\n      },\n      onElementSelect: function onElementSelect() {\n        if (this.ALLOW_CELL_RANGE_SELECTION) {\n          _explorer_dashboard_service.mlExplorerDashboardService.dragSelect.changed({\n            action: _explorer_constants.DRAG_SELECT_ACTION.ELEMENT_SELECT\n          });\n        }\n      }\n    }), _this.dashboardListener = function (action) {\n      var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      // Listen to the initial loading of jobs\n      if (action === _explorer_constants.EXPLORER_ACTION.INITIALIZE) {\n        var noJobsFound = payload.noJobsFound,\n            selectedCells = payload.selectedCells,\n            selectedJobs = payload.selectedJobs,\n            swimlaneViewByFieldName = payload.swimlaneViewByFieldName;\n\n        var currentSelectedCells = _this.state.selectedCells;\n        var currentSwimlaneViewByFieldName = _this.state.swimlaneViewByFieldName;\n\n        if (selectedCells !== undefined && currentSelectedCells === null) {\n          currentSelectedCells = selectedCells;\n          currentSwimlaneViewByFieldName = swimlaneViewByFieldName;\n        }\n\n        var stateUpdate = {\n          noInfluencersConfigured: !(0, _explorer_utils.selectedJobsHaveInfluencers)(selectedJobs),\n          noJobsFound: noJobsFound,\n          selectedCells: currentSelectedCells,\n          selectedJobs: selectedJobs,\n          swimlaneViewByFieldName: currentSwimlaneViewByFieldName\n        };\n\n        _this.updateExplorer(stateUpdate, true);\n      }\n\n      // Listen for changes to job selection.\n      if (action === _explorer_constants.EXPLORER_ACTION.JOB_SELECTION_CHANGE) {\n        var _selectedJobs = payload.selectedJobs;\n\n        var _stateUpdate = {\n          noInfluencersConfigured: !(0, _explorer_utils.selectedJobsHaveInfluencers)(_selectedJobs),\n          selectedJobs: _selectedJobs\n        };\n\n        _this.props.appStateHandler(_explorer_constants.APP_STATE_ACTION.CLEAR_SELECTION);\n        Object.assign(_stateUpdate, (0, _explorer_utils.getClearedSelectedAnomaliesState)());\n\n        if (_selectedJobs.length > 1) {\n          _this.props.appStateHandler(_explorer_constants.APP_STATE_ACTION.SAVE_SWIMLANE_VIEW_BY_FIELD_NAME, { swimlaneViewByFieldName: _explorer_constants.VIEW_BY_JOB_LABEL });\n          _stateUpdate.swimlaneViewByFieldName = _explorer_constants.VIEW_BY_JOB_LABEL;\n          // enforce a state update for swimlaneViewByFieldName\n          _this.setState({ swimlaneViewByFieldName: _explorer_constants.VIEW_BY_JOB_LABEL }, function () {\n            _this.updateExplorer(_stateUpdate, true);\n          });\n          return;\n        }\n\n        _this.updateExplorer(_stateUpdate, true);\n      }\n\n      // RELOAD reloads full Anomaly Explorer and clears the selection.\n      if (action === _explorer_constants.EXPLORER_ACTION.RELOAD) {\n        _this.props.appStateHandler(_explorer_constants.APP_STATE_ACTION.CLEAR_SELECTION);\n        _this.updateExplorer(_extends({}, payload, (0, _explorer_utils.getClearedSelectedAnomaliesState)()), true);\n      }\n\n      // REDRAW reloads Anomaly Explorer and tries to retain the selection.\n      if (action === _explorer_constants.EXPLORER_ACTION.REDRAW) {\n        _this.updateExplorer({}, false);\n      }\n    }, _this.checkboxShowChartsListener = function () {\n      var showCharts = _checkbox_showcharts.mlCheckboxShowChartsService.state.get('showCharts');\n      var _this$state = _this.state,\n          selectedCells = _this$state.selectedCells,\n          selectedJobs = _this$state.selectedJobs;\n\n\n      var bounds = _timefilter.timefilter.getActiveBounds();\n      var timerange = (0, _explorer_utils.getSelectionTimeRange)(selectedCells, _this.getSwimlaneBucketInterval(selectedJobs).asSeconds(), bounds);\n\n      if (showCharts && selectedCells !== null) {\n        _this.updateCharts(_this.state.anomalyChartRecords, timerange.earliestMs, timerange.latestMs);\n      } else {\n        _this.updateCharts([], timerange.earliestMs, timerange.latestMs);\n      }\n    }, _this.anomalyChartsSeverityListener = function () {\n      var showCharts = _checkbox_showcharts.mlCheckboxShowChartsService.state.get('showCharts');\n      var _this$state2 = _this.state,\n          anomalyChartRecords = _this$state2.anomalyChartRecords,\n          selectedCells = _this$state2.selectedCells,\n          selectedJobs = _this$state2.selectedJobs;\n\n      if (showCharts && selectedCells !== null) {\n        var bounds = _timefilter.timefilter.getActiveBounds();\n        var timerange = (0, _explorer_utils.getSelectionTimeRange)(selectedCells, _this.getSwimlaneBucketInterval(selectedJobs).asSeconds(), bounds);\n        _this.updateCharts(anomalyChartRecords, timerange.earliestMs, timerange.latestMs);\n      }\n    }, _this.tableControlsListener = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      var dateFormatTz, _this$state3, selectedCells, swimlaneViewByFieldName, selectedJobs, bounds, tableData;\n\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              dateFormatTz = _this.props.dateFormatTz;\n              _this$state3 = _this.state, selectedCells = _this$state3.selectedCells, swimlaneViewByFieldName = _this$state3.swimlaneViewByFieldName, selectedJobs = _this$state3.selectedJobs;\n              bounds = _timefilter.timefilter.getActiveBounds();\n              _context.next = 5;\n              return (0, _explorer_utils.loadAnomaliesTableData)(selectedCells, selectedJobs, dateFormatTz, _this.getSwimlaneBucketInterval(selectedJobs).asSeconds(), bounds, swimlaneViewByFieldName);\n\n            case 5:\n              tableData = _context.sent;\n\n              _this.setState({ tableData: tableData });\n\n            case 7:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, _this2);\n    })), _this.swimlaneLimitListener = function () {\n      _this.props.appStateHandler(_explorer_constants.APP_STATE_ACTION.CLEAR_SELECTION);\n      _this.updateExplorer((0, _explorer_utils.getClearedSelectedAnomaliesState)(), false);\n    }, _this.swimlaneRenderDoneListener = function () {\n      _this.dragSelect.clearSelection();\n      _this.dragSelect.setSelectables(document.getElementsByClassName('sl-cell'));\n    }, _this.annotationsRefreshSub = null, _this.loadOverallDataPreviousArgs = null, _this.loadOverallDataPreviousData = null, _this.loadViewBySwimlanePreviousArgs = null, _this.loadViewBySwimlanePreviousData = null, _this.topFieldsPreviousArgs = null, _this.topFieldsPreviousData = null, _this.anomaliesTablePreviousArgs = null, _this.anomaliesTablePreviousData = null, _this.annotationsTablePreviousArgs = null, _this.annotationsTablePreviousData = null, _this.viewByChangeHandler = function (e) {\n      return _this.setSwimlaneViewBy(e.target.value);\n    }, _this.setSwimlaneViewBy = function (swimlaneViewByFieldName) {\n      _this.props.appStateHandler(_explorer_constants.APP_STATE_ACTION.CLEAR_SELECTION);\n      _this.props.appStateHandler(_explorer_constants.APP_STATE_ACTION.SAVE_SWIMLANE_VIEW_BY_FIELD_NAME, { swimlaneViewByFieldName: swimlaneViewByFieldName });\n      _this.setState({ swimlaneViewByFieldName: swimlaneViewByFieldName }, function () {\n        _this.updateExplorer(_extends({\n          swimlaneViewByFieldName: swimlaneViewByFieldName\n        }, (0, _explorer_utils.getClearedSelectedAnomaliesState)()), false);\n      });\n    }, _this.onSwimlaneEnterHandler = function () {\n      return _this.setSwimlaneSelectActive(true);\n    }, _this.onSwimlaneLeaveHandler = function () {\n      return _this.setSwimlaneSelectActive(false);\n    }, _this.setSwimlaneSelectActive = function (active) {\n      if (!active && _this.disableDragSelectOnMouseLeave) {\n        _this.dragSelect.clearSelection();\n        _this.dragSelect.stop();\n        return;\n      }\n      _this.dragSelect.start();\n    }, _this.swimlaneCellClickQueue = [], _this.swimlaneCellClick = function (swimlaneSelectedCells) {\n      if (_this.skipCellClicks === true) {\n        _this.swimlaneCellClickQueue.push(swimlaneSelectedCells);\n        return;\n      }\n\n      // If selectedCells is an empty object we clear any existing selection,\n      // otherwise we save the new selection in AppState and update the Explorer.\n      if (Object.keys(swimlaneSelectedCells).length === 0) {\n        _this.props.appStateHandler(_explorer_constants.APP_STATE_ACTION.CLEAR_SELECTION);\n\n        var stateUpdate = (0, _explorer_utils.getClearedSelectedAnomaliesState)();\n        _this.updateExplorer(stateUpdate, false);\n      } else {\n        swimlaneSelectedCells.showTopFieldValues = false;\n\n        var currentSwimlaneType = _lodash2.default.get(_this.state, 'selectedCells.type');\n        var currentShowTopFieldValues = _lodash2.default.get(_this.state, 'selectedCells.showTopFieldValues', false);\n        var newSwimlaneType = _lodash2.default.get(swimlaneSelectedCells, 'type');\n\n        if (currentSwimlaneType === _explorer_constants.SWIMLANE_TYPE.OVERALL && newSwimlaneType === _explorer_constants.SWIMLANE_TYPE.VIEW_BY || newSwimlaneType === _explorer_constants.SWIMLANE_TYPE.OVERALL || currentShowTopFieldValues === true) {\n          swimlaneSelectedCells.showTopFieldValues = true;\n        }\n\n        _this.props.appStateHandler(_explorer_constants.APP_STATE_ACTION.SAVE_SELECTION, { swimlaneSelectedCells: swimlaneSelectedCells });\n        _this.updateExplorer({ selectedCells: swimlaneSelectedCells }, false);\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  // helper to avoid calling `setState()` in the listener for chart updates.\n\n\n  // make sure dragSelect is only available if the mouse pointer is actually over a swimlane\n\n  // skip listening to clicks on swimlanes while they are loading to avoid race conditions\n\n\n  // Listens to render updates of the swimlanes to update dragSelect\n\n\n  _createClass(Explorer, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _this3 = this;\n\n      this._isMounted = true;\n      _explorer_dashboard_service.mlExplorerDashboardService.explorer.watch(this.dashboardListener);\n      _checkbox_showcharts.mlCheckboxShowChartsService.state.watch(this.checkboxShowChartsListener);\n      _select_limit.mlSelectLimitService.state.watch(this.swimlaneLimitListener);\n      _select_severity.mlSelectSeverityService.state.watch(this.anomalyChartsSeverityListener);\n      _select_interval.mlSelectIntervalService.state.watch(this.tableControlsListener);\n      _select_severity.mlSelectSeverityService.state.watch(this.tableControlsListener);\n      this.annotationsRefreshSub = _annotations_service.annotationsRefresh$.subscribe(function () {\n        // clear the annotations cache and trigger an update\n        _this3.annotationsTablePreviousArgs = null;\n        _this3.annotationsTablePreviousData = null;\n        _this3.updateExplorer();\n      });\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this._isMounted = false;\n      _explorer_dashboard_service.mlExplorerDashboardService.explorer.unwatch(this.dashboardListener);\n      _checkbox_showcharts.mlCheckboxShowChartsService.state.unwatch(this.checkboxShowChartsListener);\n      _select_limit.mlSelectLimitService.state.unwatch(this.swimlaneLimitListener);\n      _select_severity.mlSelectSeverityService.state.unwatch(this.anomalyChartsSeverityListener);\n      _select_interval.mlSelectIntervalService.state.unwatch(this.tableControlsListener);\n      _select_severity.mlSelectSeverityService.state.unwatch(this.tableControlsListener);\n      this.annotationsRefreshSub.unsubscribe();\n    }\n  }, {\n    key: 'getSwimlaneBucketInterval',\n    value: function getSwimlaneBucketInterval(selectedJobs) {\n      var MlTimeBuckets = this.props.MlTimeBuckets;\n\n\n      var swimlaneWidth = (0, _legacy_utils.getSwimlaneContainerWidth)(this.state.noInfluencersConfigured);\n      // Bucketing interval should be the maximum of the chart related interval (i.e. time range related)\n      // and the max bucket span for the jobs shown in the chart.\n      var bounds = _timefilter.timefilter.getActiveBounds();\n      var buckets = new MlTimeBuckets();\n      buckets.setInterval('auto');\n      buckets.setBounds(bounds);\n\n      var intervalSeconds = buckets.getInterval().asSeconds();\n\n      // if the swimlane cell widths are too small they will not be visible\n      // calculate how many buckets will be drawn before the swimlanes are actually rendered\n      // and increase the interval to widen the cells if they're going to be smaller than 8px\n      // this has to be done at this stage so all searches use the same interval\n      var timerangeSeconds = (bounds.max.valueOf() - bounds.min.valueOf()) / 1000;\n      var numBuckets = parseInt(timerangeSeconds / intervalSeconds);\n      var cellWidth = Math.floor(swimlaneWidth / numBuckets * 100) / 100;\n\n      // if the cell width is going to be less than 8px, double the interval\n      if (cellWidth < 8) {\n        buckets.setInterval(intervalSeconds * 2 + 's');\n      }\n\n      var maxBucketSpanSeconds = selectedJobs.reduce(function (memo, job) {\n        return Math.max(memo, job.bucketSpanSeconds);\n      }, 0);\n      if (maxBucketSpanSeconds > intervalSeconds) {\n        buckets.setInterval(maxBucketSpanSeconds + 's');\n        buckets.setBounds(bounds);\n      }\n\n      return buckets.getInterval();\n    }\n  }, {\n    key: 'loadOverallData',\n    value: function loadOverallData(selectedJobs, interval, bounds) {\n      var _this4 = this;\n\n      var showLoadingIndicator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      return new Promise(function (resolve) {\n        // Loads the overall data components i.e. the overall swimlane and influencers list.\n        if (selectedJobs === null) {\n          resolve({\n            loading: false,\n            hasResuts: false\n          });\n          return;\n        }\n\n        // check if we can just return existing cached data\n        var compareArgs = {\n          selectedJobs: selectedJobs,\n          intervalAsSeconds: interval.asSeconds(),\n          boundsMin: bounds.min.valueOf(),\n          boundsMax: bounds.max.valueOf()\n        };\n\n        if (_lodash2.default.isEqual(compareArgs, _this4.loadOverallDataPreviousArgs)) {\n          var overallSwimlaneData = _this4.loadOverallDataPreviousData;\n          var hasResults = overallSwimlaneData.points && overallSwimlaneData.points.length > 0;\n          resolve({\n            hasResults: hasResults,\n            loading: false,\n            overallSwimlaneData: overallSwimlaneData\n          });\n          return;\n        }\n\n        if (showLoadingIndicator) {\n          _this4.setState({ hasResults: false, loading: true });\n        }\n\n        // Ensure the search bounds align to the bucketing interval used in the swimlane so\n        // that the first and last buckets are complete.\n        var searchBounds = (0, _ml_time_buckets.getBoundsRoundedToInterval)(bounds, interval, false);\n        var selectedJobIds = selectedJobs.map(function (d) {\n          return d.id;\n        });\n\n        // Load the overall bucket scores by time.\n        // Pass the interval in seconds as the swimlane relies on a fixed number of seconds between buckets\n        // which wouldn't be the case if e.g. '1M' was used.\n        // Pass 'true' when obtaining bucket bounds due to the way the overall_buckets endpoint works\n        // to ensure the search is inclusive of end time.\n        var overallBucketsBounds = (0, _ml_time_buckets.getBoundsRoundedToInterval)(bounds, interval, true);\n        _results_service.mlResultsService.getOverallBucketScores(selectedJobIds,\n        // Note there is an optimization for when top_n == 1.\n        // If top_n > 1, we should test what happens when the request takes long\n        // and refactor the loading calls, if necessary, to avoid delays in loading other components.\n        1, overallBucketsBounds.min.valueOf(), overallBucketsBounds.max.valueOf(), interval.asSeconds() + 's').then(function (resp) {\n          _this4.skipCellClicks = false;\n          var overallSwimlaneData = (0, _explorer_utils.processOverallResults)(resp.results, searchBounds, interval.asSeconds());\n          _this4.loadOverallDataPreviousArgs = compareArgs;\n          _this4.loadOverallDataPreviousData = overallSwimlaneData;\n\n          console.log('Explorer overall swimlane data set:', overallSwimlaneData);\n          var hasResults = overallSwimlaneData.points && overallSwimlaneData.points.length > 0;\n          resolve({\n            hasResults: hasResults,\n            loading: false,\n            overallSwimlaneData: overallSwimlaneData\n          });\n        });\n      });\n    }\n  }, {\n    key: 'loadViewBySwimlane',\n    value: function loadViewBySwimlane(fieldValues, overallSwimlaneData, selectedJobs, swimlaneViewByFieldName) {\n      var _this5 = this;\n\n      var limit = _select_limit.mlSelectLimitService.state.get('limit');\n      var swimlaneLimit = limit === undefined ? _explorer_constants.SWIMLANE_DEFAULT_LIMIT : limit.val;\n\n      var compareArgs = {\n        fieldValues: fieldValues,\n        overallSwimlaneData: overallSwimlaneData,\n        selectedJobs: selectedJobs,\n        swimlaneLimit: swimlaneLimit,\n        swimlaneViewByFieldName: swimlaneViewByFieldName,\n        interval: this.getSwimlaneBucketInterval(selectedJobs).asSeconds()\n      };\n\n      return new Promise(function (resolve) {\n        _this5.skipCellClicks = true;\n\n        // check if we can just return existing cached data\n        if (_lodash2.default.isEqual(compareArgs, _this5.loadViewBySwimlanePreviousArgs)) {\n          _this5.skipCellClicks = false;\n\n          resolve({\n            viewBySwimlaneData: _this5.loadViewBySwimlanePreviousData,\n            viewBySwimlaneDataLoading: false\n          });\n          return;\n        }\n\n        _this5.setState({\n          viewBySwimlaneData: (0, _explorer_utils.getDefaultViewBySwimlaneData)(),\n          viewBySwimlaneDataLoading: true\n        });\n\n        var finish = function finish(resp) {\n          _this5.skipCellClicks = false;\n          if (resp !== undefined) {\n            var viewBySwimlaneData = (0, _explorer_utils.processViewByResults)(resp.results, fieldValues, overallSwimlaneData, swimlaneViewByFieldName, _this5.getSwimlaneBucketInterval(selectedJobs).asSeconds());\n            _this5.loadViewBySwimlanePreviousArgs = compareArgs;\n            _this5.loadViewBySwimlanePreviousData = viewBySwimlaneData;\n            console.log('Explorer view by swimlane data set:', viewBySwimlaneData);\n\n            resolve({\n              viewBySwimlaneData: viewBySwimlaneData,\n              viewBySwimlaneDataLoading: false\n            });\n          } else {\n            resolve({ viewBySwimlaneDataLoading: false });\n          }\n        };\n\n        if (selectedJobs === undefined || swimlaneViewByFieldName === undefined) {\n          finish();\n          return;\n        } else {\n          // Ensure the search bounds align to the bucketing interval used in the swimlane so\n          // that the first and last buckets are complete.\n          var bounds = _timefilter.timefilter.getActiveBounds();\n          var searchBounds = (0, _ml_time_buckets.getBoundsRoundedToInterval)(bounds, _this5.getSwimlaneBucketInterval(selectedJobs), false);\n          var selectedJobIds = selectedJobs.map(function (d) {\n            return d.id;\n          });\n\n          // load scores by influencer/jobId value and time.\n          // Pass the interval in seconds as the swimlane relies on a fixed number of seconds between buckets\n          // which wouldn't be the case if e.g. '1M' was used.\n          var interval = _this5.getSwimlaneBucketInterval(selectedJobs).asSeconds() + 's';\n          if (swimlaneViewByFieldName !== _explorer_constants.VIEW_BY_JOB_LABEL) {\n            _results_service.mlResultsService.getInfluencerValueMaxScoreByTime(selectedJobIds, swimlaneViewByFieldName, fieldValues, searchBounds.min.valueOf(), searchBounds.max.valueOf(), interval, swimlaneLimit).then(finish);\n          } else {\n            var jobIds = fieldValues !== undefined && fieldValues.length > 0 ? fieldValues : selectedJobIds;\n            _results_service.mlResultsService.getScoresByBucket(jobIds, searchBounds.min.valueOf(), searchBounds.max.valueOf(), interval, swimlaneLimit).then(finish);\n          }\n        }\n      });\n    }\n  }, {\n    key: 'loadViewByTopFieldValuesForSelectedTime',\n    value: function loadViewByTopFieldValuesForSelectedTime(earliestMs, latestMs, selectedJobs, swimlaneViewByFieldName) {\n      var _this6 = this;\n\n      var selectedJobIds = selectedJobs.map(function (d) {\n        return d.id;\n      });\n      var limit = _select_limit.mlSelectLimitService.state.get('limit');\n      var swimlaneLimit = limit === undefined ? _explorer_constants.SWIMLANE_DEFAULT_LIMIT : limit.val;\n\n      var compareArgs = {\n        earliestMs: earliestMs, latestMs: latestMs, selectedJobIds: selectedJobIds, swimlaneLimit: swimlaneLimit, swimlaneViewByFieldName: swimlaneViewByFieldName,\n        interval: this.getSwimlaneBucketInterval(selectedJobs).asSeconds()\n      };\n\n      // Find the top field values for the selected time, and then load the 'view by'\n      // swimlane over the full time range for those specific field values.\n      return new Promise(function (resolve) {\n        if (_lodash2.default.isEqual(compareArgs, _this6.topFieldsPreviousArgs)) {\n          resolve(_this6.topFieldsPreviousData);\n          return;\n        }\n        _this6.topFieldsPreviousArgs = compareArgs;\n\n        if (swimlaneViewByFieldName !== _explorer_constants.VIEW_BY_JOB_LABEL) {\n          _results_service.mlResultsService.getTopInfluencers(selectedJobIds, earliestMs, latestMs, swimlaneLimit).then(function (resp) {\n            if (resp.influencers[swimlaneViewByFieldName] === undefined) {\n              _this6.topFieldsPreviousData = [];\n              resolve([]);\n            }\n\n            var topFieldValues = [];\n            var topInfluencers = resp.influencers[swimlaneViewByFieldName];\n            topInfluencers.forEach(function (influencerData) {\n              if (influencerData.maxAnomalyScore > 0) {\n                topFieldValues.push(influencerData.influencerFieldValue);\n              }\n            });\n            _this6.topFieldsPreviousData = topFieldValues;\n            resolve(topFieldValues);\n          });\n        } else {\n          _results_service.mlResultsService.getScoresByBucket(selectedJobIds, earliestMs, latestMs, _this6.getSwimlaneBucketInterval(selectedJobs).asSeconds() + 's', swimlaneLimit).then(function (resp) {\n            var topFieldValues = Object.keys(resp.results);\n            _this6.topFieldsPreviousData = topFieldValues;\n            resolve(topFieldValues);\n          });\n        }\n      });\n    }\n  }, {\n    key: 'updateExplorer',\n    value: function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        var stateUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var showOverallLoadingIndicator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        var _state$stateUpdate, noInfluencersConfigured, noJobsFound, selectedCells, selectedJobs, latestSelectedCells, dateFormatTz, jobIds, bounds, timerange, overallSwimlaneData, annotationsTableCompareArgs, viewBySwimlaneOptions, topFieldValues, viewBySwimlaneData, clearSelection, selectionInfluencers, updatedAnomalyChartRecords, anomaliesTableCompareArgs, tableData;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _state$stateUpdate = _extends({}, this.state, stateUpdate), noInfluencersConfigured = _state$stateUpdate.noInfluencersConfigured, noJobsFound = _state$stateUpdate.noJobsFound, selectedCells = _state$stateUpdate.selectedCells, selectedJobs = _state$stateUpdate.selectedJobs;\n\n\n                this.skipCellClicks = false;\n\n                if (!noJobsFound) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                this.setState(stateUpdate);\n                return _context2.abrupt('return');\n\n              case 5:\n                if (!(this.swimlaneCellClickQueue.length > 0)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                this.setState(stateUpdate);\n\n                latestSelectedCells = this.swimlaneCellClickQueue.pop();\n\n                this.swimlaneCellClickQueue.length = 0;\n                this.swimlaneCellClick(latestSelectedCells);\n                return _context2.abrupt('return');\n\n              case 11:\n                dateFormatTz = this.props.dateFormatTz;\n                jobIds = selectedCells !== null && selectedCells.viewByFieldName === _explorer_constants.VIEW_BY_JOB_LABEL ? selectedCells.lanes : selectedJobs.map(function (d) {\n                  return d.id;\n                });\n                bounds = _timefilter.timefilter.getActiveBounds();\n                timerange = (0, _explorer_utils.getSelectionTimeRange)(selectedCells, this.getSwimlaneBucketInterval(selectedJobs).asSeconds(), bounds);\n\n                // Load the overall data - if the FieldFormats failed to populate\n                // the default formatting will be used for metric values.\n\n                _context2.t0 = Object;\n                _context2.t1 = stateUpdate;\n                _context2.next = 19;\n                return this.loadOverallData(selectedJobs, this.getSwimlaneBucketInterval(selectedJobs), bounds, showOverallLoadingIndicator);\n\n              case 19:\n                _context2.t2 = _context2.sent;\n\n                _context2.t0.assign.call(_context2.t0, _context2.t1, _context2.t2);\n\n                overallSwimlaneData = stateUpdate.overallSwimlaneData;\n                annotationsTableCompareArgs = {\n                  selectedCells: selectedCells,\n                  selectedJobs: selectedJobs,\n                  interval: this.getSwimlaneBucketInterval(selectedJobs).asSeconds(),\n                  boundsMin: bounds.min.valueOf(),\n                  boundsMax: bounds.max.valueOf()\n                };\n\n                if (!_lodash2.default.isEqual(annotationsTableCompareArgs, this.annotationsTablePreviousArgs)) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                stateUpdate.annotationsData = this.annotationsTablePreviousData;\n                _context2.next = 31;\n                break;\n\n              case 27:\n                this.annotationsTablePreviousArgs = annotationsTableCompareArgs;\n                _context2.next = 30;\n                return (0, _explorer_utils.loadAnnotationsTableData)(selectedCells, selectedJobs, this.getSwimlaneBucketInterval(selectedJobs).asSeconds(), bounds);\n\n              case 30:\n                stateUpdate.annotationsData = this.annotationsTablePreviousData = _context2.sent;\n\n              case 31:\n                viewBySwimlaneOptions = (0, _explorer_utils.getViewBySwimlaneOptions)(selectedJobs, this.state.swimlaneViewByFieldName);\n\n                Object.assign(stateUpdate, viewBySwimlaneOptions);\n\n                if (!(selectedCells !== null && selectedCells.showTopFieldValues === true)) {\n                  _context2.next = 46;\n                  break;\n                }\n\n                _context2.next = 36;\n                return this.loadViewByTopFieldValuesForSelectedTime(timerange.earliestMs, timerange.latestMs, selectedJobs, viewBySwimlaneOptions.swimlaneViewByFieldName);\n\n              case 36:\n                topFieldValues = _context2.sent;\n                _context2.t3 = Object;\n                _context2.t4 = stateUpdate;\n                _context2.next = 41;\n                return this.loadViewBySwimlane(topFieldValues, overallSwimlaneData, selectedJobs, viewBySwimlaneOptions.swimlaneViewByFieldName);\n\n              case 41:\n                _context2.t5 = _context2.sent;\n                _context2.t6 = { viewByLoadedForTimeFormatted: (0, _date_utils.formatHumanReadableDateTime)(timerange.earliestMs) };\n\n                _context2.t3.assign.call(_context2.t3, _context2.t4, _context2.t5, _context2.t6);\n\n                _context2.next = 53;\n                break;\n\n              case 46:\n                _context2.t7 = Object;\n                _context2.t8 = stateUpdate;\n                _context2.t9 = viewBySwimlaneOptions;\n                _context2.next = 51;\n                return this.loadViewBySwimlane([], overallSwimlaneData, selectedJobs, viewBySwimlaneOptions.swimlaneViewByFieldName);\n\n              case 51:\n                _context2.t10 = _context2.sent;\n\n                _context2.t7.assign.call(_context2.t7, _context2.t8, _context2.t9, _context2.t10);\n\n              case 53:\n                viewBySwimlaneData = stateUpdate.viewBySwimlaneData;\n\n                // do a sanity check against selectedCells. It can happen that a previously\n                // selected lane loaded via URL/AppState is not available anymore.\n\n                clearSelection = false;\n\n                if (selectedCells !== null && selectedCells.type === _explorer_constants.SWIMLANE_TYPE.VIEW_BY) {\n                  clearSelection = !selectedCells.lanes.some(function (lane) {\n                    return viewBySwimlaneData.points.some(function (point) {\n                      return point.laneLabel === lane && point.time === selectedCells.times[0];\n                    });\n                  });\n                }\n\n                if (clearSelection === true) {\n                  this.props.appStateHandler(_explorer_constants.APP_STATE_ACTION.CLEAR_SELECTION);\n                  Object.assign(stateUpdate, (0, _explorer_utils.getClearedSelectedAnomaliesState)());\n                }\n\n                selectionInfluencers = (0, _explorer_utils.getSelectionInfluencers)(selectedCells, viewBySwimlaneOptions.swimlaneViewByFieldName);\n\n                if (!(selectionInfluencers.length === 0)) {\n                  _context2.next = 62;\n                  break;\n                }\n\n                _context2.next = 61;\n                return (0, _explorer_utils.loadTopInfluencers)(jobIds, timerange.earliestMs, timerange.latestMs, noInfluencersConfigured);\n\n              case 61:\n                stateUpdate.influencers = _context2.sent;\n\n              case 62:\n                _context2.next = 64;\n                return (0, _explorer_utils.loadDataForCharts)(jobIds, timerange.earliestMs, timerange.latestMs, selectionInfluencers, selectedCells);\n\n              case 64:\n                updatedAnomalyChartRecords = _context2.sent;\n\n                if (!(selectionInfluencers.length > 0 && updatedAnomalyChartRecords !== undefined)) {\n                  _context2.next = 69;\n                  break;\n                }\n\n                _context2.next = 68;\n                return (0, _explorer_utils.getFilteredTopInfluencers)(jobIds, timerange.earliestMs, timerange.latestMs, updatedAnomalyChartRecords, selectionInfluencers, noInfluencersConfigured);\n\n              case 68:\n                stateUpdate.influencers = _context2.sent;\n\n              case 69:\n\n                stateUpdate.anomalyChartRecords = updatedAnomalyChartRecords || [];\n\n                this.setState(stateUpdate);\n\n                if (_checkbox_showcharts.mlCheckboxShowChartsService.state.get('showCharts') && selectedCells !== null) {\n                  this.updateCharts(stateUpdate.anomalyChartRecords, timerange.earliestMs, timerange.latestMs);\n                } else {\n                  this.updateCharts([], timerange.earliestMs, timerange.latestMs);\n                }\n\n                anomaliesTableCompareArgs = {\n                  selectedCells: selectedCells,\n                  selectedJobs: selectedJobs,\n                  dateFormatTz: dateFormatTz,\n                  interval: this.getSwimlaneBucketInterval(selectedJobs).asSeconds(),\n                  boundsMin: bounds.min.valueOf(),\n                  boundsMax: bounds.max.valueOf(),\n                  swimlaneViewByFieldName: viewBySwimlaneOptions.swimlaneViewByFieldName\n                };\n\n                if (!_lodash2.default.isEqual(anomaliesTableCompareArgs, this.anomaliesTablePreviousArgs)) {\n                  _context2.next = 77;\n                  break;\n                }\n\n                this.setState(this.anomaliesTablePreviousData);\n                _context2.next = 82;\n                break;\n\n              case 77:\n                this.anomaliesTablePreviousArgs = anomaliesTableCompareArgs;\n                _context2.next = 80;\n                return (0, _explorer_utils.loadAnomaliesTableData)(selectedCells, selectedJobs, dateFormatTz, this.getSwimlaneBucketInterval(selectedJobs).asSeconds(), bounds, viewBySwimlaneOptions.swimlaneViewByFieldName);\n\n              case 80:\n                tableData = this.anomaliesTablePreviousData = _context2.sent;\n\n                this.setState({ tableData: tableData });\n\n              case 82:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function updateExplorer() {\n        return _ref3.apply(this, arguments);\n      }\n\n      return updateExplorer;\n    }()\n\n    // This queue tracks click events while the swimlanes are loading.\n    // To avoid race conditions we keep the click events selectedCells in this queue\n    // and trigger another event only after the current loading is done.\n    // The queue is necessary since a click in the overall swimlane triggers\n    // an update of the viewby swimlanes. If we'd just ignored click events\n    // during the loading, we could miss programmatically triggered events like\n    // those coming via AppState when a selection is part of the URL.\n\n\n    // Listener for click events in the swimlane to load corresponding anomaly data.\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          intl = _props.intl,\n          MlTimeBuckets = _props.MlTimeBuckets;\n      var _state = this.state,\n          annotationsData = _state.annotationsData,\n          anomalyChartRecords = _state.anomalyChartRecords,\n          chartsData = _state.chartsData,\n          influencers = _state.influencers,\n          hasResults = _state.hasResults,\n          noInfluencersConfigured = _state.noInfluencersConfigured,\n          noJobsFound = _state.noJobsFound,\n          overallSwimlaneData = _state.overallSwimlaneData,\n          selectedCells = _state.selectedCells,\n          swimlaneViewByFieldName = _state.swimlaneViewByFieldName,\n          tableData = _state.tableData,\n          viewByLoadedForTimeFormatted = _state.viewByLoadedForTimeFormatted,\n          viewBySwimlaneData = _state.viewBySwimlaneData,\n          viewBySwimlaneDataLoading = _state.viewBySwimlaneDataLoading,\n          viewBySwimlaneOptions = _state.viewBySwimlaneOptions;\n\n\n      var loading = this.props.loading || this.state.loading;\n\n      var swimlaneWidth = (0, _legacy_utils.getSwimlaneContainerWidth)(noInfluencersConfigured);\n\n      if (loading === true) {\n        return _react2.default.createElement(_loading_indicator.LoadingIndicator, {\n          label: intl.formatMessage({\n            id: 'xpack.ml.explorer.loadingLabel',\n            defaultMessage: 'Loading'\n          })\n        });\n      }\n\n      if (noJobsFound) {\n        return _react2.default.createElement(_components.ExplorerNoJobsFound, null);\n      }\n\n      if (noJobsFound && hasResults === false) {\n        return _react2.default.createElement(_components.ExplorerNoResultsFound, null);\n      }\n\n      var mainColumnWidthClassName = noInfluencersConfigured === true ? 'col-xs-12' : 'col-xs-10';\n      var mainColumnClasses = 'column ' + mainColumnWidthClassName;\n\n      var showViewBySwimlane = viewBySwimlaneData !== null && viewBySwimlaneData.laneLabels && viewBySwimlaneData.laneLabels.length > 0;\n\n      return _react2.default.createElement(\n        'div',\n        { className: 'results-container' },\n        noInfluencersConfigured && _react2.default.createElement(\n          'div',\n          { className: 'no-influencers-warning' },\n          _react2.default.createElement(_eui.EuiIconTip, {\n            content: intl.formatMessage({\n              id: 'xpack.ml.explorer.noConfiguredInfluencersTooltip',\n              defaultMessage: 'The Top Influencers list is hidden because no influencers have been configured for the selected jobs.'\n            }),\n            position: 'right',\n            type: 'iInCircle'\n          })\n        ),\n        noInfluencersConfigured === false && _react2.default.createElement(\n          'div',\n          { className: 'column col-xs-2 euiText' },\n          _react2.default.createElement(\n            'span',\n            { className: 'panel-title' },\n            _react2.default.createElement(_react3.FormattedMessage, {\n              id: 'xpack.ml.explorer.topInfuencersTitle',\n              defaultMessage: 'Top Influencers'\n            })\n          ),\n          _react2.default.createElement(_influencers_list.InfluencersList, { influencers: influencers })\n        ),\n        _react2.default.createElement(\n          'div',\n          { className: mainColumnClasses },\n          _react2.default.createElement(\n            'span',\n            { className: 'panel-title euiText' },\n            _react2.default.createElement(_react3.FormattedMessage, {\n              id: 'xpack.ml.explorer.anomalyTimelineTitle',\n              defaultMessage: 'Anomaly timeline'\n            })\n          ),\n          _react2.default.createElement(\n            'div',\n            {\n              className: 'ml-explorer-swimlane euiText',\n              onMouseEnter: this.onSwimlaneEnterHandler,\n              onMouseLeave: this.onSwimlaneLeaveHandler\n            },\n            _react2.default.createElement(_explorer_swimlane.ExplorerSwimlane, {\n              chartWidth: swimlaneWidth,\n              MlTimeBuckets: MlTimeBuckets,\n              swimlaneCellClick: this.swimlaneCellClick,\n              swimlaneData: overallSwimlaneData,\n              swimlaneType: _explorer_constants.SWIMLANE_TYPE.OVERALL,\n              selection: selectedCells,\n              swimlaneRenderDoneListener: this.swimlaneRenderDoneListener\n            })\n          ),\n          viewBySwimlaneOptions.length > 0 && _react2.default.createElement(\n            _react2.default.Fragment,\n            null,\n            _react2.default.createElement(\n              _eui.EuiFlexGroup,\n              { direction: 'row', gutterSize: 'l', responsive: true },\n              _react2.default.createElement(\n                _eui.EuiFlexItem,\n                { grow: false },\n                _react2.default.createElement(\n                  _eui.EuiFormRow,\n                  {\n                    label: intl.formatMessage({\n                      id: 'xpack.ml.explorer.viewByLabel',\n                      defaultMessage: 'View by'\n                    })\n                  },\n                  _react2.default.createElement(_eui.EuiSelect, {\n                    id: 'selectViewBy',\n                    options: mapSwimlaneOptionsToEuiOptions(viewBySwimlaneOptions),\n                    value: swimlaneViewByFieldName,\n                    onChange: this.viewByChangeHandler\n                  })\n                )\n              ),\n              _react2.default.createElement(\n                _eui.EuiFlexItem,\n                { grow: false },\n                _react2.default.createElement(\n                  _eui.EuiFormRow,\n                  {\n                    label: intl.formatMessage({\n                      id: 'xpack.ml.explorer.limitLabel',\n                      defaultMessage: 'Limit'\n                    })\n                  },\n                  _react2.default.createElement(_select_limit.SelectLimit, null)\n                )\n              ),\n              _react2.default.createElement(\n                _eui.EuiFlexItem,\n                { grow: false, style: { alignSelf: 'center' } },\n                _react2.default.createElement(\n                  _eui.EuiFormRow,\n                  { label: '\\u200B' },\n                  _react2.default.createElement(\n                    'div',\n                    { className: 'panel-sub-title' },\n                    viewByLoadedForTimeFormatted && _react2.default.createElement(_react3.FormattedMessage, {\n                      id: 'xpack.ml.explorer.sortedByMaxAnomalyScoreForTimeFormattedLabel',\n                      defaultMessage: '(Sorted by max anomaly score for {viewByLoadedForTimeFormatted})',\n                      values: { viewByLoadedForTimeFormatted: viewByLoadedForTimeFormatted }\n                    }),\n                    viewByLoadedForTimeFormatted === undefined && _react2.default.createElement(_react3.FormattedMessage, {\n                      id: 'xpack.ml.explorer.sortedByMaxAnomalyScoreLabel',\n                      defaultMessage: '(Sorted by max anomaly score)'\n                    })\n                  )\n                )\n              )\n            ),\n            showViewBySwimlane && _react2.default.createElement(\n              'div',\n              {\n                className: 'ml-explorer-swimlane euiText',\n                onMouseEnter: this.onSwimlaneEnterHandler,\n                onMouseLeave: this.onSwimlaneLeaveHandler\n              },\n              _react2.default.createElement(_explorer_swimlane.ExplorerSwimlane, {\n                chartWidth: swimlaneWidth,\n                MlTimeBuckets: MlTimeBuckets,\n                swimlaneCellClick: this.swimlaneCellClick,\n                swimlaneData: viewBySwimlaneData,\n                swimlaneType: _explorer_constants.SWIMLANE_TYPE.VIEW_BY,\n                selection: selectedCells,\n                swimlaneRenderDoneListener: this.swimlaneRenderDoneListener\n              })\n            ),\n            viewBySwimlaneDataLoading && _react2.default.createElement(_loading_indicator.LoadingIndicator, null),\n            !showViewBySwimlane && !viewBySwimlaneDataLoading && swimlaneViewByFieldName !== null && _react2.default.createElement(_components.ExplorerNoInfluencersFound, { swimlaneViewByFieldName: swimlaneViewByFieldName })\n          ),\n          annotationsData.length > 0 && _react2.default.createElement(\n            _react2.default.Fragment,\n            null,\n            _react2.default.createElement(\n              'span',\n              { className: 'panel-title euiText' },\n              _react2.default.createElement(_react3.FormattedMessage, {\n                id: 'xpack.ml.explorer.annotationsTitle',\n                defaultMessage: 'Annotations'\n              })\n            ),\n            _react2.default.createElement(_annotations_table.AnnotationsTable, {\n              annotations: annotationsData,\n              drillDown: true,\n              numberBadge: false\n            }),\n            _react2.default.createElement(_annotation_flyout.AnnotationFlyout, null),\n            _react2.default.createElement(_eui.EuiSpacer, { size: 'l' })\n          ),\n          _react2.default.createElement(\n            'span',\n            { className: 'panel-title euiText' },\n            _react2.default.createElement(_react3.FormattedMessage, { id: 'xpack.ml.explorer.anomaliesTitle', defaultMessage: 'Anomalies' })\n          ),\n          _react2.default.createElement(\n            _eui.EuiFlexGroup,\n            {\n              direction: 'row',\n              gutterSize: 'l',\n              responsive: true,\n              className: 'ml-anomalies-controls'\n            },\n            _react2.default.createElement(\n              _eui.EuiFlexItem,\n              { grow: false, style: { width: '170px' } },\n              _react2.default.createElement(\n                _eui.EuiFormRow,\n                {\n                  label: intl.formatMessage({\n                    id: 'xpack.ml.explorer.severityThresholdLabel',\n                    defaultMessage: 'Severity threshold'\n                  })\n                },\n                _react2.default.createElement(_select_severity.SelectSeverity, null)\n              )\n            ),\n            _react2.default.createElement(\n              _eui.EuiFlexItem,\n              { grow: false, style: { width: '170px' } },\n              _react2.default.createElement(\n                _eui.EuiFormRow,\n                {\n                  label: intl.formatMessage({\n                    id: 'xpack.ml.explorer.intervalLabel',\n                    defaultMessage: 'Interval'\n                  })\n                },\n                _react2.default.createElement(_select_interval.SelectInterval, null)\n              )\n            ),\n            anomalyChartRecords.length > 0 && _react2.default.createElement(\n              _eui.EuiFlexItem,\n              { grow: false, style: { alignSelf: 'center' } },\n              _react2.default.createElement(\n                _eui.EuiFormRow,\n                { label: '\\u200B' },\n                _react2.default.createElement(_checkbox_showcharts.CheckboxShowCharts, null)\n              )\n            )\n          ),\n          _react2.default.createElement(_eui.EuiSpacer, { size: 'm' }),\n          _react2.default.createElement(\n            'div',\n            { className: 'euiText explorer-charts' },\n            _react2.default.createElement(_explorer_charts_container.ExplorerChartsContainer, chartsData)\n          ),\n          _react2.default.createElement(_anomalies_table.AnomaliesTable, { tableData: tableData, timefilter: _timefilter.timefilter })\n        )\n      );\n    }\n  }]);\n\n  return Explorer;\n}(_react2.default.Component), _class.propTypes = {\n  appStateHandler: _propTypes2.default.func.isRequired,\n  dateFormatTz: _propTypes2.default.string.isRequired,\n  mlJobSelectService: _propTypes2.default.object.isRequired,\n  MlTimeBuckets: _propTypes2.default.func.isRequired\n}, _temp2));",null]}