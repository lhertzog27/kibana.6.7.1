{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/cross_cluster_replication/public/app/store/actions/follower_index.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/cross_cluster_replication/public/app/store/actions/follower_index.js","mtime":1567631711955},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unfollowLeaderIndex = exports.resumeFollowerIndex = exports.pauseFollowerIndex = exports.saveFollowerIndex = exports.getFollowerIndex = exports.loadFollowerIndices = exports.selectEditFollowerIndex = exports.selectDetailFollowerIndex = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _i18n = require('@kbn/i18n');\n\nvar _notify = require('ui/notify');\n\nvar _routing = require('../../services/routing');\n\nvar _routing2 = _interopRequireDefault(_routing);\n\nvar _constants = require('../../constants');\n\nvar _api = require('../../services/api');\n\nvar _action_types = require('../action_types');\n\nvar t = _interopRequireWildcard(_action_types);\n\nvar _api2 = require('./api');\n\nvar _selectors = require('../selectors');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */\n\n\nvar scope = _constants.SECTIONS.FOLLOWER_INDEX;\nvar selectDetailFollowerIndex = exports.selectDetailFollowerIndex = function selectDetailFollowerIndex(id) {\n  return {\n    type: t.FOLLOWER_INDEX_SELECT_DETAIL,\n    payload: id\n  };\n};\n\nvar selectEditFollowerIndex = exports.selectEditFollowerIndex = function selectEditFollowerIndex(id) {\n  return {\n    type: t.FOLLOWER_INDEX_SELECT_EDIT,\n    payload: id\n  };\n};\n\nvar loadFollowerIndices = exports.loadFollowerIndices = function loadFollowerIndices() {\n  var isUpdating = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return (0, _api2.sendApiRequest)({\n    label: t.FOLLOWER_INDEX_LOAD,\n    scope: scope,\n    status: isUpdating ? _constants.API_STATUS.UPDATING : _constants.API_STATUS.LOADING,\n    handler: function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return (0, _api.loadFollowerIndices)();\n\n              case 2:\n                return _context.abrupt('return', _context.sent);\n\n              case 3:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, undefined);\n      }));\n\n      function handler() {\n        return _ref.apply(this, arguments);\n      }\n\n      return handler;\n    }()\n  });\n};\n\nvar getFollowerIndex = exports.getFollowerIndex = function getFollowerIndex(id) {\n  return (0, _api2.sendApiRequest)({\n    label: t.FOLLOWER_INDEX_GET,\n    scope: scope + '-get',\n    handler: function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return (0, _api.getFollowerIndex)(id);\n\n              case 2:\n                return _context2.abrupt('return', _context2.sent);\n\n              case 3:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, undefined);\n      }));\n\n      function handler() {\n        return _ref2.apply(this, arguments);\n      }\n\n      return handler;\n    }()\n  });\n};\n\nvar saveFollowerIndex = exports.saveFollowerIndex = function saveFollowerIndex(name, followerIndex) {\n  var isUpdating = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return (0, _api2.sendApiRequest)({\n    label: t.FOLLOWER_INDEX_CREATE,\n    status: _constants.API_STATUS.SAVING,\n    scope: scope + '-save',\n    handler: function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!isUpdating) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                _context3.next = 3;\n                return (0, _api.updateFollowerIndex)(name, followerIndex);\n\n              case 3:\n                return _context3.abrupt('return', _context3.sent);\n\n              case 4:\n                _context3.next = 6;\n                return (0, _api.createFollowerIndex)(_extends({ name: name }, followerIndex));\n\n              case 6:\n                return _context3.abrupt('return', _context3.sent);\n\n              case 7:\n              case 'end':\n                return _context3.stop();\n            }\n          }\n        }, _callee3, undefined);\n      }));\n\n      function handler() {\n        return _ref3.apply(this, arguments);\n      }\n\n      return handler;\n    }(),\n    onSuccess: function onSuccess() {\n      var successMessage = isUpdating ? _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.updateAction.successNotificationTitle', {\n        defaultMessage: 'Follower index \\'{name}\\' updated successfully',\n        values: { name: name }\n      }) : _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.addAction.successNotificationTitle', {\n        defaultMessage: 'Added follower index \\'{name}\\'',\n        values: { name: name }\n      });\n\n      _notify.toastNotifications.addSuccess(successMessage);\n      _routing2.default.navigate('/follower_indices', undefined, {\n        name: encodeURIComponent(name)\n      });\n    }\n  });\n};\n\nvar pauseFollowerIndex = exports.pauseFollowerIndex = function pauseFollowerIndex(id) {\n  return (0, _api2.sendApiRequest)({\n    label: t.FOLLOWER_INDEX_PAUSE,\n    status: _constants.API_STATUS.SAVING,\n    scope: scope,\n    handler: function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt('return', (0, _api.pauseFollowerIndex)(id));\n\n              case 1:\n              case 'end':\n                return _context4.stop();\n            }\n          }\n        }, _callee4, undefined);\n      }));\n\n      function handler() {\n        return _ref4.apply(this, arguments);\n      }\n\n      return handler;\n    }(),\n    onSuccess: function onSuccess(response, dispatch) {\n      /**\n       * We can have 1 or more follower index pause operation\n       * that can fail or succeed. We will show 1 toast notification for each.\n       */\n      if (response.errors.length) {\n        var hasMultipleErrors = response.errors.length > 1;\n        var errorMessage = hasMultipleErrors ? _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.pauseAction.errorMultipleNotificationTitle', {\n          defaultMessage: 'Error pausing {count} follower indices',\n          values: { count: response.errors.length }\n        }) : _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.pauseAction.errorSingleNotificationTitle', {\n          defaultMessage: 'Error pausing follower index \\'{name}\\'',\n          values: { name: response.errors[0].id }\n        });\n\n        _notify.toastNotifications.addDanger(errorMessage);\n      }\n\n      if (response.itemsPaused.length) {\n        var hasMultiplePaused = response.itemsPaused.length > 1;\n\n        var successMessage = hasMultiplePaused ? _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.pauseAction.successMultipleNotificationTitle', {\n          defaultMessage: '{count} follower indices were paused',\n          values: { count: response.itemsPaused.length }\n        }) : _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.pauseAction.successSingleNotificationTitle', {\n          defaultMessage: 'Follower index \\'{name}\\' was paused',\n          values: { name: response.itemsPaused[0] }\n        });\n\n        _notify.toastNotifications.addSuccess(successMessage);\n\n        // Refresh list\n        dispatch(loadFollowerIndices(true));\n      }\n    }\n  });\n};\n\nvar resumeFollowerIndex = exports.resumeFollowerIndex = function resumeFollowerIndex(id) {\n  return (0, _api2.sendApiRequest)({\n    label: t.FOLLOWER_INDEX_RESUME,\n    status: _constants.API_STATUS.SAVING,\n    scope: scope,\n    handler: function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt('return', (0, _api.resumeFollowerIndex)(id));\n\n              case 1:\n              case 'end':\n                return _context5.stop();\n            }\n          }\n        }, _callee5, undefined);\n      }));\n\n      function handler() {\n        return _ref5.apply(this, arguments);\n      }\n\n      return handler;\n    }(),\n    onSuccess: function onSuccess(response, dispatch) {\n      /**\n       * We can have 1 or more follower index resume operation\n       * that can fail or succeed. We will show 1 toast notification for each.\n       */\n      if (response.errors.length) {\n        var hasMultipleErrors = response.errors.length > 1;\n        var errorMessage = hasMultipleErrors ? _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.resumeAction.errorMultipleNotificationTitle', {\n          defaultMessage: 'Error resuming {count} follower indices',\n          values: { count: response.errors.length }\n        }) : _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.resumeAction.errorSingleNotificationTitle', {\n          defaultMessage: 'Error resuming follower index \\'{name}\\'',\n          values: { name: response.errors[0].id }\n        });\n\n        _notify.toastNotifications.addDanger(errorMessage);\n      }\n\n      if (response.itemsResumed.length) {\n        var hasMultipleResumed = response.itemsResumed.length > 1;\n\n        var successMessage = hasMultipleResumed ? _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.resumeAction.successMultipleNotificationTitle', {\n          defaultMessage: '{count} follower indices were resumed',\n          values: { count: response.itemsResumed.length }\n        }) : _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.resumeAction.successSingleNotificationTitle', {\n          defaultMessage: 'Follower index \\'{name}\\' was resumed',\n          values: { name: response.itemsResumed[0] }\n        });\n\n        _notify.toastNotifications.addSuccess(successMessage);\n      }\n\n      // Refresh list\n      dispatch(loadFollowerIndices(true));\n    }\n  });\n};\n\nvar unfollowLeaderIndex = exports.unfollowLeaderIndex = function unfollowLeaderIndex(id) {\n  return (0, _api2.sendApiRequest)({\n    label: t.FOLLOWER_INDEX_UNFOLLOW,\n    status: _constants.API_STATUS.DELETING,\n    scope: scope + '-delete',\n    handler: function () {\n      var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt('return', (0, _api.unfollowLeaderIndex)(id));\n\n              case 1:\n              case 'end':\n                return _context6.stop();\n            }\n          }\n        }, _callee6, undefined);\n      }));\n\n      function handler() {\n        return _ref6.apply(this, arguments);\n      }\n\n      return handler;\n    }(),\n    onSuccess: function onSuccess(response, dispatch, getState) {\n      /**\n       * We can have 1 or more follower index unfollow operation\n       * that can fail or succeed. We will show 1 toast notification for each.\n       */\n      if (response.errors.length) {\n        var hasMultipleErrors = response.errors.length > 1;\n        var errorMessage = hasMultipleErrors ? _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.unfollowAction.errorMultipleNotificationTitle', {\n          defaultMessage: 'Error unfollowing leader index of {count} follower indices',\n          values: { count: response.errors.length }\n        }) : _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.unfollowAction.errorSingleNotificationTitle', {\n          defaultMessage: 'Error unfollowing leader index of follower index \\'{name}\\'',\n          values: { name: response.errors[0].id }\n        });\n\n        _notify.toastNotifications.addDanger(errorMessage);\n      }\n\n      if (response.itemsUnfollowed.length) {\n        var hasMultipleUnfollow = response.itemsUnfollowed.length > 1;\n\n        var successMessage = hasMultipleUnfollow ? _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.unfollowAction.successMultipleNotificationTitle', {\n          defaultMessage: 'Leader indices of {count} follower indices were unfollowed',\n          values: { count: response.itemsUnfollowed.length }\n        }) : _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.unfollowAction.successSingleNotificationTitle', {\n          defaultMessage: 'Leader index of follower index \\'{name}\\' was unfollowed',\n          values: { name: response.itemsUnfollowed[0] }\n        });\n\n        _notify.toastNotifications.addSuccess(successMessage);\n      }\n\n      if (response.itemsNotOpen.length) {\n        var hasMultipleNotOpen = response.itemsNotOpen.length > 1;\n\n        var warningMessage = hasMultipleNotOpen ? _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.unfollowAction.notOpenWarningMultipleNotificationTitle', {\n          defaultMessage: '{count} indices could not be re-opened',\n          values: { count: response.itemsNotOpen.length }\n        }) : _i18n.i18n.translate('xpack.crossClusterReplication.followerIndex.unfollowAction.notOpenWarningSingleNotificationTitle', {\n          defaultMessage: 'Index \\'{name}\\' could not be re-opened',\n          values: { name: response.itemsNotOpen[0] }\n        });\n\n        _notify.toastNotifications.addWarning(warningMessage);\n      }\n\n      // If we've just unfollowed a follower index we were looking at, we need to close the panel.\n      var followerIndexId = (0, _selectors.getSelectedFollowerIndexId)('detail')(getState());\n      if (response.itemsUnfollowed.includes(followerIndexId)) {\n        dispatch(selectDetailFollowerIndex(null));\n      }\n    }\n  });\n};",null]}