{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/courier/fetch/fetch_now.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/courier/fetch/fetch_now.js","mtime":1567631711712},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FetchNowProvider = FetchNowProvider;\n\nvar _notify = require('../../notify');\n\nvar _call_client = require('./call_client');\n\nvar _call_response_handlers = require('./call_response_handlers');\n\nvar _continue_incomplete = require('./continue_incomplete');\n\nvar _req_status = require('./req_status');\n\nvar _i18n = require('@kbn/i18n');\n\n/**\n * Fetch now provider should be used if you want the results searched and returned immediately.\n * This can be slightly inefficient if a large number of requests are queued up, we can batch these\n * by using fetchSoon. This introduces a slight delay which allows other requests to queue up before\n * sending out requests in a batch.\n *\n * @param Private\n * @param Promise\n * @return {fetchNow}\n * @constructor\n */\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nfunction FetchNowProvider(Private, Promise) {\n  // core tasks\n  var callClient = Private(_call_client.CallClientProvider);\n  var callResponseHandlers = Private(_call_response_handlers.CallResponseHandlersProvider);\n  var continueIncomplete = Private(_continue_incomplete.ContinueIncompleteProvider);\n\n  var ABORTED = _req_status.RequestStatus.ABORTED;\n  var DUPLICATE = _req_status.RequestStatus.DUPLICATE;\n  var INCOMPLETE = _req_status.RequestStatus.INCOMPLETE;\n\n  function fetchNow(searchRequests) {\n    return fetchSearchResults(searchRequests.map(function (searchRequest) {\n      if (!searchRequest.started) {\n        return searchRequest;\n      }\n\n      return searchRequest.retry();\n    })).catch(function (error) {\n      // If any errors occur after the search requests have resolved, then we kill Kibana.\n      (0, _notify.fatalError)(error, 'Courier fetch');\n    });\n  }\n\n  function fetchSearchResults(searchRequests) {\n    function replaceAbortedRequests() {\n      searchRequests = searchRequests.map(function (searchRequest) {\n        if (searchRequest.aborted) {\n          return ABORTED;\n        }\n\n        return searchRequest;\n      });\n    }\n\n    replaceAbortedRequests();\n    return startRequests(searchRequests).then(function () {\n      replaceAbortedRequests();\n      return callClient(searchRequests).catch(function () {\n        // Silently swallow errors that result from search requests so the consumer can surface\n        // them as notifications instead of courier forcing fatal errors.\n      });\n    }).then(function (responses) {\n      replaceAbortedRequests();\n      return callResponseHandlers(searchRequests, responses);\n    }).then(function (responses) {\n      replaceAbortedRequests();\n      return continueIncomplete(searchRequests, responses, fetchSearchResults);\n    }).then(function (responses) {\n      replaceAbortedRequests();\n      return responses.map(function (resp) {\n        switch (resp) {\n          case ABORTED:\n            return null;\n          case DUPLICATE:\n          case INCOMPLETE:\n            throw new Error(_i18n.i18n.translate('common.ui.courier.fetch.failedToClearRequestErrorMessage', {\n              defaultMessage: 'Failed to clear incomplete or duplicate request from responses.'\n            }));\n          default:\n            return resp;\n        }\n      });\n    });\n  }\n\n  function startRequests(searchRequests) {\n    return Promise.map(searchRequests, function (searchRequest) {\n      if (searchRequest === ABORTED) {\n        return searchRequest;\n      }\n\n      return new Promise(function (resolve) {\n        var action = searchRequest.started ? searchRequest.continue : searchRequest.start;\n        resolve(action.call(searchRequest));\n      }).catch(function (err) {\n        return searchRequest.handleFailure(err);\n      });\n    });\n  }\n\n  return fetchNow;\n}",null]}