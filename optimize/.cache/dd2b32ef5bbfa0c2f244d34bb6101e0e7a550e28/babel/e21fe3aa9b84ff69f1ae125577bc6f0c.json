{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/components/job_select_list/job_select_service.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/components/job_select_list/job_select_service.js","mtime":1567631712033},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.JobSelectServiceProvider = JobSelectServiceProvider;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _notify = require('ui/notify');\n\nvar _job_service = require('plugins/ml/services/job_service');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /*\n                                                                                                                                                                                                     * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                     * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                     * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                     */\n\n// Service with functions used for broadcasting job picker changes\n\nvar jobSelectService = undefined;\n\nfunction JobSelectServiceProvider($rootScope, globalState, i18n) {\n\n  function checkGlobalState() {\n    if (globalState.ml === undefined) {\n      globalState.ml = {};\n      globalState.save();\n    }\n  }\n  checkGlobalState();\n\n  function loadJobIdsFromGlobalState() {\n    var jobIds = [];\n    if (globalState.ml && globalState.ml.jobIds) {\n      var tempJobIds = [];\n      if (typeof globalState.ml.jobIds === 'string') {\n        tempJobIds.push(globalState.ml.jobIds);\n      } else {\n        tempJobIds = globalState.ml.jobIds;\n      }\n      tempJobIds = tempJobIds.map(function (id) {\n        return String(id);\n      });\n      var invalidIds = getInvalidJobIds(removeGroupIds(tempJobIds));\n      warnAboutInvalidJobIds(invalidIds);\n\n      var validIds = _lodash2.default.difference(tempJobIds, invalidIds);\n\n      // if there are no valid ids, warn and then select the first job\n      if (validIds.length === 0) {\n        _notify.toastNotifications.addWarning(i18n('xpack.ml.jobSelect.noJobsSelectedWarningMessage', {\n          defaultMessage: 'No jobs selected, auto selecting first job'\n        }));\n\n        if (_job_service.mlJobService.jobs.length) {\n          validIds = [_job_service.mlJobService.jobs[0].job_id];\n        }\n      }\n      jobIds.push.apply(jobIds, _toConsumableArray(validIds));\n\n      // replace the job ids in the url with the ones which are valid\n      storeJobIdsInGlobalState(jobIds);\n    } else {\n      checkGlobalState();\n\n      // no jobs selected, use the first in the list\n      if (_job_service.mlJobService.jobs.length) {\n        jobIds.push(_job_service.mlJobService.jobs[0].job_id);\n      }\n      storeJobIdsInGlobalState(jobIds);\n    }\n\n    return jobIds;\n  }\n\n  function storeJobIdsInGlobalState(jobIds) {\n    globalState.ml.jobIds = jobIds;\n    globalState.save();\n  }\n\n  // check that the ids read from the url exist by comparing them to the\n  // jobs loaded via mlJobsService.\n  function getInvalidJobIds(ids) {\n    return ids.filter(function (id) {\n      var job = _lodash2.default.find(_job_service.mlJobService.jobs, { 'job_id': id });\n      return job === undefined && id !== '*';\n    });\n  }\n\n  function removeGroupIds(jobIds) {\n    return jobIds.map(function (id) {\n      var splitId = id.split('.');\n      return splitId.length > 1 ? splitId[1] : splitId[0];\n    });\n  }\n\n  function warnAboutInvalidJobIds(invalidIds) {\n    if (invalidIds.length > 0) {\n      _notify.toastNotifications.addWarning(i18n('xpack.ml.jobSelect.requestedJobsDoesNotExistWarningMessage', {\n        defaultMessage: 'Requested\\n{invalidIdsLength, plural, one {job {invalidIds} does not exist} other {jobs {invalidIds} do not exist}}',\n        values: {\n          invalidIdsLength: invalidIds.length,\n          invalidIds: invalidIds\n        }\n      }));\n    }\n  }\n\n  function createDescription(jobs) {\n    var txt = '';\n    // add up the number of jobs including duplicates if they belong to multiple groups\n    var count = _job_service.mlJobService.jobs.reduce(function (sum, job) {\n      return sum + (job.groups === undefined ? 1 : job.groups.length);\n    }, 0);\n    if (jobs.length === count) {\n      txt = i18n('xpack.ml.jobSelect.allJobsDescription', {\n        defaultMessage: 'All jobs'\n      });\n    } else {\n      // not all jobs have been selected\n      // add up how many jobs belong to groups and how many don't\n      var groupCounts = {};\n      var groupLessJobs = 0;\n      jobs.forEach(function (job) {\n        var obj = splitJobId(job);\n        if (obj.group) {\n          groupCounts[obj.group] = (groupCounts[obj.group] || 0) + 1;\n        } else {\n          groupLessJobs++;\n        }\n      });\n      var wholeGroups = [];\n      var groups = _job_service.mlJobService.getJobGroups();\n      // work out how many groups have all of their jobs selected\n      groups.forEach(function (group) {\n        var groupCount = groupCounts[group.id];\n        if (groupCount !== undefined && groupCount === group.jobs.length) {\n          // this group has all of it's jobs selected\n          wholeGroups.push(group.id);\n        } else {\n          if (groupCount !== undefined) {\n            // this job doesn't so add it to the count of groupless jobs\n            groupLessJobs += groupCount;\n          }\n        }\n      });\n\n      // show the whole groups first\n      if (wholeGroups.length) {\n        txt = wholeGroups[0];\n        if (wholeGroups.length > 1 || groupLessJobs > 0) {\n          var total = wholeGroups.length - 1 + groupLessJobs;\n          txt = i18n('xpack.ml.jobSelect.wholeGroupDescription', {\n            defaultMessage: '{wholeGroup} and {total, plural, zero {# other} one {# other} other {# others}}',\n            values: {\n              wholeGroup: wholeGroups[0],\n              total: total\n            }\n          });\n        }\n      } else {\n        // otherwise just list the job ids\n        txt = splitJobId(jobs[0]).job;\n        if (jobs.length > 1) {\n          txt = i18n('xpack.ml.jobSelect.jobDescription', {\n            defaultMessage: '{jobId} and {jobsAmount, plural, zero {# other} one {# other} other {# others}}',\n            values: {\n              jobId: splitJobId(jobs[0]).job,\n              jobsAmount: jobs.length - 1\n            }\n          });\n        }\n      }\n    }\n    return txt;\n  }\n  // function to split the group from the job and return both or just the job\n  function splitJobId(jobId) {\n    var obj = {};\n    var splitId = jobId.split('.');\n    if (splitId.length === 2) {\n      obj = { group: splitId[0], job: splitId[1] };\n    } else {\n      obj = { job: jobId };\n    }\n    return obj;\n  }\n  this.splitJobId = splitJobId;\n\n  // expands `*` into groupId.jobId list\n  // expands `groupId.*` into `groupId.jobId` list\n  // returns list of expanded job ids\n  function expandGroups(jobIds) {\n    var newJobIds = [];\n    var groups = _job_service.mlJobService.getJobGroups();\n    jobIds.forEach(function (jobId) {\n      if (jobId === '*') {\n        _job_service.mlJobService.jobs.forEach(function (job) {\n          if (job.groups === undefined) {\n            newJobIds.push(job.job_id);\n          } else {\n            newJobIds.push.apply(newJobIds, _toConsumableArray(job.groups.map(function (g) {\n              return g + '.' + job.job_id;\n            })));\n          }\n        });\n      } else {\n        var splitId = splitJobId(jobId);\n        if (splitId.group !== undefined && splitId.job === '*') {\n          var groupId = splitId.group;\n          var group = groups.find(function (g) {\n            return g.id === groupId;\n          });\n          group.jobs.forEach(function (j) {\n            newJobIds.push(groupId + '.' + j.job_id);\n          });\n        } else {\n          newJobIds.push(jobId);\n        }\n      }\n    });\n    return newJobIds;\n  }\n\n  function getGroupIds(jobIds) {\n    var groupIds = [];\n    jobIds.forEach(function (jobId) {\n      var splitId = splitJobId(jobId);\n      if (splitId.group !== undefined && splitId.job === '*') {\n        groupIds.push(splitId.group);\n      }\n    });\n    return groupIds;\n  }\n\n  // takes an array of ids.\n  // this could be a mixture of job ids, group ids or a *.\n  // stores an expanded list of job ids (i.e. groupId.jobId) and a list of jobs ids only.\n  // creates the description text used on the job picker button.\n  function processIds(service, ids) {\n    var _service$jobIdsWithGr, _service$jobIds;\n\n    var expandedJobIds = expandGroups(ids);\n    service.jobIdsWithGroup.length = 0;\n    (_service$jobIdsWithGr = service.jobIdsWithGroup).push.apply(_service$jobIdsWithGr, _toConsumableArray(expandedJobIds));\n    service.groupIds = getGroupIds(ids);\n    service.jobIds.length = 0;\n    (_service$jobIds = service.jobIds).push.apply(_service$jobIds, _toConsumableArray(removeGroupIds(expandedJobIds)));\n    service.description.txt = createDescription(service.jobIdsWithGroup);\n    service.singleJobDescription.txt = ids[0];\n    setBrowserTitle(service.description.txt);\n  }\n\n  // display the job id in the tab title\n  function setBrowserTitle(title) {\n    document.title = title + ' - Kibana';\n  }\n\n  var JobSelectService = function () {\n    function JobSelectService() {\n      _classCallCheck(this, JobSelectService);\n\n      this.jobIds = [];\n      this.groupIds = [];\n      this.description = { txt: '' };\n      this.singleJobDescription = { txt: '' };\n      this.jobSelectListState = {\n        applyTimeRange: true\n      };\n      this.jobIdsWithGroup = [];\n      this.splitJobId = splitJobId;\n    }\n\n    // Broadcasts that a change has been made to the selected jobs.\n\n\n    _createClass(JobSelectService, [{\n      key: 'broadcastJobSelectionChange',\n      value: function broadcastJobSelectionChange() {\n        $rootScope.$broadcast('jobSelectionChange', this.getSelectedJobIds());\n      }\n\n      // Add a listener for changes to the selected jobs.\n\n    }, {\n      key: 'listenJobSelectionChange',\n      value: function listenJobSelectionChange(scope, callback) {\n        var handler = $rootScope.$on('jobSelectionChange', callback);\n        scope.$on('$destroy', handler);\n      }\n\n      // called externally to retrieve the selected jobs ids.\n      // passing in `true` will load the jobs ids from the URL first\n\n    }, {\n      key: 'getSelectedJobIds',\n      value: function getSelectedJobIds(loadFromURL) {\n        if (loadFromURL) {\n          processIds(this, loadJobIdsFromGlobalState());\n        }\n        return this.jobIds;\n      }\n\n      // called externally to set the job ids.\n      // job ids are added to the URL and an event is broadcast for anything listening.\n      // e.g. the anomaly explorer or time series explorer.\n      // currently only called by the jobs selection menu.\n\n    }, {\n      key: 'setJobIds',\n      value: function setJobIds(jobIds) {\n        processIds(this, jobIds);\n        storeJobIdsInGlobalState(jobIds);\n        this.broadcastJobSelectionChange();\n      }\n    }]);\n\n    return JobSelectService;\n  }();\n\n  if (jobSelectService === undefined) {\n    jobSelectService = new JobSelectService();\n  }\n  return jobSelectService;\n}",null]}