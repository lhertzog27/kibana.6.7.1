{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/middleware/history.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/middleware/history.js","mtime":1567631711935},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.historyMiddleware = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                   */\n\nvar _lodash = require('lodash');\n\nvar _apps = require('../../apps');\n\nvar _history_provider = require('../../lib/history_provider');\n\nvar _router_provider = require('../../lib/router_provider');\n\nvar _workpad_service = require('../../lib/workpad_service');\n\nvar _history = require('../actions/history');\n\nvar _workpad = require('../actions/workpad');\n\nvar _assets = require('../actions/assets');\n\nvar _app = require('../selectors/app');\n\nvar _workpad2 = require('../selectors/workpad');\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction getHistoryState(state) {\n  // this is what gets written to browser history\n  return state.persistent;\n}\n\nvar historyMiddleware = exports.historyMiddleware = function historyMiddleware(_ref) {\n  var dispatch = _ref.dispatch,\n      getState = _ref.getState;\n\n  // iterate over routes, injecting redux to action handlers\n  var reduxInject = function reduxInject(routes) {\n    return routes.map(function (route) {\n      if (route.children) {\n        return _extends({}, route, {\n          children: reduxInject(route.children)\n        });\n      }\n\n      if (!route.action) {\n        return route;\n      }\n\n      return _extends({}, route, {\n        action: route.action(dispatch, getState)\n      });\n    });\n  };\n\n  var handlerState = {\n    pendingCount: 0\n  };\n\n  // wrap up the application route actions in redux\n  var router = (0, _router_provider.routerProvider)(reduxInject(_apps.routes));\n  var history = (0, _history_provider.historyProvider)();\n\n  // wire up history change handler (this only happens once)\n  var handleHistoryChanges = function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(location, prevLocation) {\n      var pathname, historyState, historyAction, isBrowserNav, isUrlChange, currentWorkpadId, newWorkpad;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              pathname = location.pathname, historyState = location.state, historyAction = location.action;\n              // pop state will fire on any hash-based url change, but only back/forward will have state\n\n              isBrowserNav = historyAction === 'pop' && historyState != null;\n              isUrlChange = !isBrowserNav && historyAction === 'pop' || (historyAction === 'push' || historyAction === 'replace') && prevLocation.pathname !== pathname;\n\n              // only restore the history on popState events with state\n              // this only happens when using back/forward with popState objects\n\n              if (!isBrowserNav) {\n                _context.next = 11;\n                break;\n              }\n\n              // TODO: oof, this sucks. we can't just shove assets into history state because\n              // firefox is limited to 640k (wat!). so, when we see that the workpad id is changing,\n              // we instead just restore the assets, which ensures the overall state is correct.\n              // there must be a better way to handle history though...\n              currentWorkpadId = (0, _workpad2.getWorkpad)(getState()).id;\n\n              if (!(currentWorkpadId !== historyState.workpad.id)) {\n                _context.next = 10;\n                break;\n              }\n\n              _context.next = 8;\n              return (0, _workpad_service.get)(historyState.workpad.id);\n\n            case 8:\n              newWorkpad = _context.sent;\n\n              dispatch((0, _assets.setAssets)(newWorkpad.assets));\n\n            case 10:\n              return _context.abrupt('return', dispatch((0, _history.restoreHistory)(historyState)));\n\n            case 11:\n              if (!isUrlChange) {\n                _context.next = 15;\n                break;\n              }\n\n              _context.next = 14;\n              return router.parse(pathname);\n\n            case 14:\n              return _context.abrupt('return', _context.sent);\n\n            case 15:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, undefined);\n    }));\n\n    return function handleHistoryChanges(_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  history.onChange(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n    var _args2 = arguments;\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // use history replace until any async handlers are completed\n            handlerState.pendingCount += 1;\n\n            _context2.prev = 1;\n            _context2.next = 4;\n            return handleHistoryChanges.apply(undefined, _args2);\n\n          case 4:\n            _context2.next = 8;\n            break;\n\n          case 6:\n            _context2.prev = 6;\n            _context2.t0 = _context2['catch'](1);\n\n          case 8:\n            _context2.prev = 8;\n\n            // restore default history method\n            handlerState.pendingCount -= 1;\n            return _context2.finish(8);\n\n          case 11:\n          case 'end':\n            return _context2.stop();\n        }\n      }\n    }, _callee2, undefined, [[1, 6, 8, 11]]);\n  })));\n\n  return function (next) {\n    return function (action) {\n      var oldState = getState();\n\n      // deal with history actions\n      switch (action.type) {\n        case _history.undoHistory.toString():\n          return history.undo();\n        case _history.redoHistory.toString():\n          return history.redo();\n        case _history.restoreHistory.toString():\n          // skip state compare, simply execute the action\n          next(action);\n          // TODO: we shouldn't need to reset the entire workpad for undo/redo\n          dispatch((0, _workpad.initializeWorkpad)());\n          return;\n      }\n\n      // execute the action like normal\n      next(action);\n      var newState = getState();\n\n      // if the app is not ready, don't persist anything\n      if (!(0, _app.isAppReady)(newState)) {\n        return;\n      }\n\n      // if app switched from not ready to ready, replace current state\n      // this allows the back button to work correctly all the way to first page load\n      if (!(0, _app.isAppReady)(oldState) && (0, _app.isAppReady)(newState)) {\n        history.replace(getHistoryState(newState));\n        return;\n      }\n\n      // if the persistent state changed, push it into the history\n      var oldHistoryState = getHistoryState(oldState);\n      var historyState = getHistoryState(newState);\n      if (!(0, _lodash.isEqual)(historyState, oldHistoryState)) {\n        // if there are pending route changes, just replace current route (to avoid extra back/forth history entries)\n        var useReplaceState = handlerState.pendingCount !== 0;\n        useReplaceState ? history.replace(historyState) : history.push(historyState);\n      }\n    };\n  };\n};",null]}