{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/test_harness/test_sharding/setup_top_level_describe_filter.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/test_harness/test_sharding/setup_top_level_describe_filter.js","mtime":1567631711760},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupTopLevelDescribeFilter = setupTopLevelDescribeFilter;\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n *  Intercept all calls to mocha.describe() and determine\n *  which calls make it through using a filter function.\n *\n *  The filter function is also only called for top-level\n *  describe() calls; all describe calls nested within another\n *  are allowed based on the filter value for the parent\n *  describe\n *\n *  ## example\n *\n *  assume tests that look like this:\n *\n *  ```js\n *  describe('section 1', () => {\n *    describe('item 1', () => {\n *\n *    })\n *  })\n *  ```\n *\n *  If the filter function returned true for \"section 1\" then \"item 1\"\n *  would automatically be defined. If it returned false for \"section 1\"\n *  then \"section 1\" would be ignored and \"item 1\" would never be defined\n *\n *  @param {function} test - a function that takes the first argument\n *                             passed to describe, the sections name, and\n *                             returns true if the describe call should\n *                             be delegated to mocha, any other value causes\n *                             the describe call to be ignored\n *  @return {undefined}\n */\nfunction setupTopLevelDescribeFilter(test) {\n  var originalDescribe = window.describe;\n\n  if (!originalDescribe) {\n    throw new TypeError('window.describe must be defined by mocha before test sharding can be setup');\n  }\n\n  /**\n   *  When describe is called it is likely to make additional, nested,\n   *  calls to describe. We track how deeply nested we are at any time\n   *  with a depth counter, `describeCallDepth`.\n   *\n   *  Before delegating a describe call to mocha we increment\n   *  that counter, and once mocha is done we decrement it.\n   *\n   *  This way, we can check if `describeCallDepth > 0` at any time\n   *  to know if we are already within a describe call.\n   *\n   *  ```js\n   *  // +1\n   *  describe('section 1', () => {\n   *    // describeCallDepth = 1\n   *    // +1\n   *    describe('item 1', () => {\n   *      // describeCallDepth = 2\n   *    })\n   *    // -1\n   *  })\n   *  // -1\n   *  // describeCallDepth = 0\n   *  ```\n   *\n   *  @type {Number}\n   */\n  var describeCallDepth = 0;\n\n  var describeInterceptor = function describeInterceptor(describeName, describeBody) {\n    var context = this;\n\n    var isTopLevelCall = describeCallDepth === 0;\n    var shouldIgnore = isTopLevelCall && Boolean(test(describeName)) === false;\n    if (shouldIgnore) return;\n\n    /**\n     *  we wrap the delegation to mocha in a try/finally block\n     *  to ensure that our describeCallDepth counter stays up\n     *  to date even if the call throws an error.\n     *\n     *  note that try/finally won't actually catch the error, it\n     *  will continue to propagate up the call stack\n     */\n    var result = void 0;\n    try {\n      describeCallDepth += 1;\n      result = originalDescribe.call(context, describeName, describeBody);\n    } finally {\n      describeCallDepth -= 1;\n    }\n    return result;\n  };\n\n  // to allow describe.only calls. we dont need interceptor as it will call describe internally\n  describeInterceptor.only = originalDescribe.only;\n  describeInterceptor.skip = originalDescribe.skip;\n\n  // ensure that window.describe isn't messed with by other code\n  Object.defineProperty(window, 'describe', {\n    configurable: false,\n    enumerable: true,\n    value: describeInterceptor\n  });\n}",null]}