{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/packages/kbn-es-query/target/filters/range.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/packages/kbn-es-query/target/filters/range.js","mtime":1567666387486},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildRangeFilter = buildRangeFilter;\nexports.getRangeScript = getRangeScript;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nvar OPERANDS_IN_RANGE = 2; /*\n                            * Licensed to Elasticsearch B.V. under one or more contributor\n                            * license agreements. See the NOTICE file distributed with\n                            * this work for additional information regarding copyright\n                            * ownership. Elasticsearch B.V. licenses this file to you under\n                            * the Apache License, Version 2.0 (the \"License\"); you may\n                            * not use this file except in compliance with the License.\n                            * You may obtain a copy of the License at\n                            *\n                            *    http://www.apache.org/licenses/LICENSE-2.0\n                            *\n                            * Unless required by applicable law or agreed to in writing,\n                            * software distributed under the License is distributed on an\n                            * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                            * KIND, either express or implied.  See the License for the\n                            * specific language governing permissions and limitations\n                            * under the License.\n                            */\n\nvar operators = {\n  gt: '>',\n  gte: '>=',\n  lte: '<=',\n  lt: '<'\n};\nvar comparators = {\n  gt: 'boolean gt(Supplier s, def v) {return s.get() > v}',\n  gte: 'boolean gte(Supplier s, def v) {return s.get() >= v}',\n  lte: 'boolean lte(Supplier s, def v) {return s.get() <= v}',\n  lt: 'boolean lt(Supplier s, def v) {return s.get() < v}'\n};\n\nfunction formatValue(field, params) {\n  return _lodash2.default.map(params, function (val, key) {\n    return operators[key] + format(field, val);\n  }).join(' ');\n}\n\nfunction buildRangeFilter(field, params, indexPattern, formattedValue) {\n  var filter = { meta: { index: indexPattern.id } };\n  if (formattedValue) filter.meta.formattedValue = formattedValue;\n\n  params = _lodash2.default.mapValues(params, function (value) {\n    return field.type === 'number' ? parseFloat(value) : value;\n  });\n\n  if ('gte' in params && 'gt' in params) throw new Error('gte and gt are mutually exclusive');\n  if ('lte' in params && 'lt' in params) throw new Error('lte and lt are mutually exclusive');\n\n  var totalInfinite = ['gt', 'lt'].reduce(function (totalInfinite, op) {\n    var key = op in params ? op : op + 'e';\n    var isInfinite = Math.abs(params[key]) === Infinity;\n\n    if (isInfinite) {\n      totalInfinite++;\n      delete params[key];\n    }\n\n    return totalInfinite;\n  }, 0);\n\n  if (totalInfinite === OPERANDS_IN_RANGE) {\n    filter.match_all = {};\n    filter.meta.field = field.name;\n  } else if (field.scripted) {\n    filter.script = getRangeScript(field, params);\n    filter.script.script.params.value = formatValue(field, filter.script.script.params);\n\n    filter.meta.field = field.name;\n  } else {\n    filter.range = {};\n    filter.range[field.name] = params;\n  }\n\n  return filter;\n}\n\nfunction getRangeScript(field, params) {\n  var knownParams = _lodash2.default.pick(params, function (val, key) {\n    return key in operators;\n  });\n  var script = _lodash2.default.map(knownParams, function (val, key) {\n    return '(' + field.script + ')' + operators[key] + key;\n  }).join(' && ');\n\n  // We must wrap painless scripts in a lambda in case they're more than a simple expression\n  if (field.lang === 'painless') {\n    var currentComparators = _lodash2.default.reduce(knownParams, function (acc, val, key) {\n      return acc.concat(comparators[key]);\n    }, []).join(' ');\n\n    var comparisons = _lodash2.default.map(knownParams, function (val, key) {\n      return key + '(() -> { ' + field.script + ' }, params.' + key + ')';\n    }).join(' && ');\n\n    script = '' + currentComparators + comparisons;\n  }\n\n  return {\n    script: {\n      source: script,\n      params: knownParams,\n      lang: field.lang\n    }\n  };\n}\n\nfunction format(field, value) {\n  return field && field.format && field.format.convert ? field.format.convert(value) : value;\n}",null]}