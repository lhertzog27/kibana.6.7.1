{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/components/forecasting_modal/forecasting_modal.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/components/forecasting_modal/forecasting_modal.js","mtime":1567631712068},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForecastingModal = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _class, _temp; /*\n                    * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                    * or more contributor license agreements. Licensed under the Elastic License;\n                    * you may not use this file except in compliance with the Elastic License.\n                    */\n\n/*\n * React modal dialog which allows the user to run and view time series forecasts.\n */\n\n// don't use something like plugins/ml/../common\n// because it won't work with the jest tests\n\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _eui = require('@elastic/eui');\n\nvar _states = require('../../../../common/constants/states');\n\nvar _message_levels = require('../../../../common/constants/message_levels');\n\nvar _job_utils = require('../../../../common/util/job_utils');\n\nvar _parse_interval = require('../../../../common/util/parse_interval');\n\nvar _modal = require('./modal');\n\nvar _progress_states = require('./progress_states');\n\nvar _ml_api_service = require('plugins/ml/services/ml_api_service');\n\nvar _job_service = require('plugins/ml/services/job_service');\n\nvar _forecast_service = require('plugins/ml/services/forecast_service');\n\nvar _react3 = require('@kbn/i18n/react');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar FORECAST_JOB_MIN_VERSION = '6.1.0'; // Forecasting only allowed for jobs created >= 6.1.0.\nvar FORECASTS_VIEW_MAX = 5; // Display links to a maximum of 5 forecasts.\nvar FORECAST_DURATION_MAX_MS = 4838400000; // Max forecast duration of 8 weeks.\nvar WARN_NUM_PARTITIONS = 100; // Warn about running a forecast with this number of field values.\nvar FORECAST_STATS_POLL_FREQUENCY = 250; // Frequency in ms at which to poll for forecast request stats.\nvar WARN_NO_PROGRESS_MS = 120000; // If no progress in forecast request, abort check and warn.\n\n\nfunction getDefaultState() {\n  return {\n    isModalVisible: false,\n    previousForecasts: [],\n    isForecastRequested: false,\n    forecastProgress: _progress_states.PROGRESS_STATES.UNSET,\n    jobOpeningState: _progress_states.PROGRESS_STATES.UNSET,\n    jobClosingState: _progress_states.PROGRESS_STATES.UNSET,\n    newForecastDuration: '1d',\n    isNewForecastDurationValid: true,\n    newForecastDurationErrors: [],\n    messages: []\n  };\n}\n\nvar ForecastingModal = exports.ForecastingModal = (0, _react3.injectI18n)((_temp = _class = function (_Component) {\n  _inherits(ForecastingModal, _Component);\n\n  function ForecastingModal(props) {\n    _classCallCheck(this, ForecastingModal);\n\n    var _this = _possibleConstructorReturn(this, (ForecastingModal.__proto__ || Object.getPrototypeOf(ForecastingModal)).call(this, props));\n\n    _this.addMessage = function (message, status) {\n      var clearFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var msg = { message: message, status: status };\n\n      _this.setState(function (prevState) {\n        return {\n          messages: clearFirst ? [msg] : [].concat(_toConsumableArray(prevState.messages), [msg])\n        };\n      });\n    };\n\n    _this.viewForecast = function (forecastId) {\n      _this.props.loadForForecastId(forecastId);\n      _this.closeModal();\n    };\n\n    _this.onNewForecastDurationChange = function (event) {\n      var intl = _this.props.intl;\n\n      var newForecastDurationErrors = [];\n      var isNewForecastDurationValid = true;\n      var duration = (0, _parse_interval.parseInterval)(event.target.value);\n      if (duration === null) {\n        isNewForecastDurationValid = false;\n        newForecastDurationErrors.push(intl.formatMessage({\n          id: 'xpack.ml.timeSeriesExplorer.forecastingModal.invalidDurationFormatErrorMessage',\n          defaultMessage: 'Invalid duration format'\n        }));\n      } else if (duration.asMilliseconds() > FORECAST_DURATION_MAX_MS) {\n        isNewForecastDurationValid = false;\n        newForecastDurationErrors.push(intl.formatMessage({\n          id: 'xpack.ml.timeSeriesExplorer.forecastingModal.forecastDurationMustNotBeGreaterThanMaximumErrorMessage',\n          defaultMessage: 'Forecast duration must not be greater than {maximumForecastDurationValue} weeks'\n        }, { maximumForecastDurationValue: 8 }));\n      } else if (duration.asMilliseconds() === 0) {\n        isNewForecastDurationValid = false;\n        newForecastDurationErrors.push(intl.formatMessage({\n          id: 'xpack.ml.timeSeriesExplorer.forecastingModal.forecastDurationMustNotBeZeroErrorMessage',\n          defaultMessage: 'Forecast duration must not be zero'\n        }));\n      }\n\n      _this.setState({\n        newForecastDuration: event.target.value,\n        isNewForecastDurationValid: isNewForecastDurationValid,\n        newForecastDurationErrors: newForecastDurationErrors\n      });\n    };\n\n    _this.checkJobStateAndRunForecast = function () {\n      _this.setState({\n        isForecastRequested: true,\n        messages: []\n      });\n\n      // A forecast can only be run on an opened job,\n      // so open job if it is closed.\n      if (_this.props.job.state === _states.JOB_STATE.CLOSED) {\n        _this.openJobAndRunForecast();\n      } else {\n        _this.runForecast(false);\n      }\n    };\n\n    _this.openJobAndRunForecast = function () {\n      // Opens a job in a 'closed' state prior to running a forecast.\n      _this.setState({\n        jobOpeningState: _progress_states.PROGRESS_STATES.WAITING\n      });\n\n      _job_service.mlJobService.openJob(_this.props.job.job_id).then(function () {\n        // If open was successful run the forecast, then close the job again.\n        _this.setState({\n          jobOpeningState: _progress_states.PROGRESS_STATES.DONE\n        });\n        _this.runForecast(true);\n      }).catch(function (resp) {\n        console.log('Time series forecast modal - could not open job:', resp);\n        _this.addMessage(_this.props.intl.formatMessage({\n          id: 'xpack.ml.timeSeriesExplorer.forecastingModal.errorWithOpeningJobBeforeRunningForecastErrorMessage',\n          defaultMessage: 'Error opening job before running forecast'\n        }), _message_levels.MESSAGE_LEVEL.ERROR);\n        _this.setState({\n          jobOpeningState: _progress_states.PROGRESS_STATES.ERROR\n        });\n      });\n    };\n\n    _this.runForecastErrorHandler = function (resp) {\n      _this.setState({ forecastProgress: _progress_states.PROGRESS_STATES.ERROR });\n      console.log('Time series forecast modal - error running forecast:', resp);\n      if (resp && resp.message) {\n        _this.addMessage(resp.message, _message_levels.MESSAGE_LEVEL.ERROR, true);\n      } else {\n        _this.addMessage(_this.props.intl.formatMessage({\n          id: 'xpack.ml.timeSeriesExplorer.forecastingModal.unexpectedResponseFromRunningForecastErrorMessage',\n          defaultMessage: 'Unexpected response from running forecast. The request may have failed.'\n        }), _message_levels.MESSAGE_LEVEL.ERROR, true);\n      }\n    };\n\n    _this.runForecast = function (closeJobAfterRunning) {\n      _this.setState({\n        forecastProgress: 0\n      });\n\n      // Always supply the duration to the endpoint in seconds as some of the moment duration\n      // formats accepted by Kibana (w, M, y) are not valid formats in Elasticsearch.\n      var durationInSeconds = (0, _parse_interval.parseInterval)(_this.state.newForecastDuration).asSeconds();\n\n      _forecast_service.mlForecastService.runForecast(_this.props.job.job_id, durationInSeconds + 's').then(function (resp) {\n        // Endpoint will return { acknowledged:true, id: <now timestamp> } before forecast is complete.\n        // So wait for results and then refresh the dashboard to the end of the forecast.\n        if (resp.forecast_id !== undefined) {\n          _this.waitForForecastResults(resp.forecast_id, closeJobAfterRunning);\n        } else {\n          _this.runForecastErrorHandler(resp);\n        }\n      }).catch(_this.runForecastErrorHandler);\n    };\n\n    _this.waitForForecastResults = function (forecastId, closeJobAfterRunning) {\n      // Obtain the stats for the forecast request and check forecast is progressing.\n      // When the stats show the forecast is finished, load the\n      // forecast results into the view.\n      var intl = _this.props.intl;\n\n      var previousProgress = 0;\n      var noProgressMs = 0;\n      _this.forecastChecker = setInterval(function () {\n        _forecast_service.mlForecastService.getForecastRequestStats(_this.props.job, forecastId).then(function (resp) {\n          // Get the progress (stats value is between 0 and 1).\n          var progress = _lodash2.default.get(resp, ['stats', 'forecast_progress'], previousProgress);\n          var status = _lodash2.default.get(resp, ['stats', 'forecast_status']);\n\n          _this.setState({ forecastProgress: Math.round(100 * progress) });\n\n          // Display any messages returned in the request stats.\n          var messages = _lodash2.default.get(resp, ['stats', 'forecast_messages'], []);\n          messages = messages.map(function (message) {\n            return { message: message, status: _message_levels.MESSAGE_LEVEL.WARNING };\n          });\n          _this.setState({ messages: messages });\n\n          if (status === _states.FORECAST_REQUEST_STATE.FINISHED) {\n            clearInterval(_this.forecastChecker);\n\n            if (closeJobAfterRunning === true) {\n              _this.setState({ jobClosingState: _progress_states.PROGRESS_STATES.WAITING });\n              _job_service.mlJobService.closeJob(_this.props.job.job_id).then(function () {\n                _this.setState({\n                  jobClosingState: _progress_states.PROGRESS_STATES.DONE\n                });\n                _this.props.loadForForecastId(forecastId);\n                _this.closeAfterRunningForecast();\n              }).catch(function (response) {\n                // Load the forecast data in the main page,\n                // but leave this dialog open so the error can be viewed.\n                console.log('Time series forecast modal - could not close job:', response);\n                _this.addMessage(intl.formatMessage({\n                  id: 'xpack.ml.timeSeriesExplorer.forecastingModal.errorWithClosingJobAfterRunningForecastErrorMessage',\n                  defaultMessage: 'Error closing job after running forecast'\n                }), _message_levels.MESSAGE_LEVEL.ERROR);\n                _this.setState({\n                  jobClosingState: _progress_states.PROGRESS_STATES.ERROR\n                });\n                _this.props.loadForForecastId(forecastId);\n              });\n            } else {\n              _this.props.loadForForecastId(forecastId);\n              _this.closeAfterRunningForecast();\n            }\n          } else {\n            // Display a warning and abort check if the forecast hasn't\n            // progressed for WARN_NO_PROGRESS_MS.\n            if (progress === previousProgress) {\n              noProgressMs += FORECAST_STATS_POLL_FREQUENCY;\n              if (noProgressMs > WARN_NO_PROGRESS_MS) {\n                console.log('Forecast request has not progressed for ' + WARN_NO_PROGRESS_MS + 'ms. Cancelling check.');\n                _this.addMessage(intl.formatMessage({\n                  id: 'xpack.ml.timeSeriesExplorer.forecastingModal.noProgressReportedForNewForecastErrorMessage',\n                  defaultMessage: 'No progress reported for the new forecast for {WarnNoProgressMs}ms.' + 'An error may have occurred whilst running the forecast.'\n                }, { WarnNoProgressMs: WARN_NO_PROGRESS_MS }), _message_levels.MESSAGE_LEVEL.ERROR);\n\n                // Try and load any results which may have been created.\n                _this.props.loadForForecastId(forecastId);\n                _this.setState({ forecastProgress: _progress_states.PROGRESS_STATES.ERROR });\n                clearInterval(_this.forecastChecker);\n              }\n            } else {\n              previousProgress = progress;\n            }\n          }\n        }).catch(function (resp) {\n          console.log('Time series forecast modal - error loading stats of forecast from elasticsearch:', resp);\n          _this.addMessage(intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.forecastingModal.errorWithLoadingStatsOfRunningForecastErrorMessage',\n            defaultMessage: 'Error loading stats of running forecast.'\n          }), _message_levels.MESSAGE_LEVEL.ERROR);\n          _this.setState({\n            forecastProgress: _progress_states.PROGRESS_STATES.ERROR\n          });\n          clearInterval(_this.forecastChecker);\n        });\n      }, FORECAST_STATS_POLL_FREQUENCY);\n    };\n\n    _this.openModal = function () {\n      var intl = _this.props.intl;\n\n      var job = _this.props.job;\n\n      if ((typeof job === 'undefined' ? 'undefined' : _typeof(job)) === 'object') {\n        // Get the list of all the finished forecasts for this job with results at or later than the dashboard 'from' time.\n        var bounds = _this.props.timefilter.getActiveBounds();\n        var statusFinishedQuery = {\n          term: {\n            forecast_status: _states.FORECAST_REQUEST_STATE.FINISHED\n          }\n        };\n        _forecast_service.mlForecastService.getForecastsSummary(job, statusFinishedQuery, bounds.min.valueOf(), FORECASTS_VIEW_MAX).then(function (resp) {\n          _this.setState({\n            previousForecasts: resp.forecasts\n          });\n        }).catch(function (resp) {\n          console.log('Time series forecast modal - error obtaining forecasts summary:', resp);\n          _this.addMessage(intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.forecastingModal.errorWithObtainingListOfPreviousForecastsErrorMessage',\n            defaultMessage: 'Error obtaining list of previous forecasts'\n          }), _message_levels.MESSAGE_LEVEL.ERROR);\n        });\n\n        // Display a warning about running a forecast if there is high number\n        // of partitioning fields.\n        var entityFieldNames = _this.props.entities.map(function (entity) {\n          return entity.fieldName;\n        });\n        if (entityFieldNames.length > 0) {\n          _ml_api_service.ml.getCardinalityOfFields({\n            index: job.datafeed_config.indices,\n            types: job.datafeed_config.types,\n            fieldNames: entityFieldNames,\n            query: job.datafeed_config.query,\n            timeFieldName: job.data_description.time_field,\n            earliestMs: job.data_counts.earliest_record_timestamp,\n            latestMs: job.data_counts.latest_record_timestamp\n          }).then(function (results) {\n            var numPartitions = 1;\n            Object.values(results).forEach(function (cardinality) {\n              numPartitions = numPartitions * cardinality;\n            });\n            if (numPartitions > WARN_NUM_PARTITIONS) {\n              _this.addMessage(intl.formatMessage({\n                id: 'xpack.ml.timeSeriesExplorer.forecastingModal.dataContainsMorePartitionsMessage',\n                defaultMessage: 'Note that this data contains more than {warnNumPartitions} ' + 'partitions so running a forecast may take a long time and consume a high amount of resource'\n              }, { warnNumPartitions: WARN_NUM_PARTITIONS }), _message_levels.MESSAGE_LEVEL.WARNING);\n            }\n          }).catch(function (resp) {\n            console.log('Time series forecast modal - error obtaining cardinality of fields:', resp);\n          });\n        }\n\n        _this.setState({ isModalVisible: true });\n      }\n    };\n\n    _this.closeAfterRunningForecast = function () {\n      // Only close the dialog automatically after a forecast has run\n      // if the message bar is clear. Otherwise the user may not catch\n      // any messages returned in the forecast request stats.\n      if (_this.state.messages.length === 0) {\n        // Wrap the close in a timeout to give the user a chance to see progress update.\n        setTimeout(function () {\n          _this.closeModal();\n        }, 1000);\n      }\n    };\n\n    _this.closeModal = function () {\n      if (_this.forecastChecker !== null) {\n        clearInterval(_this.forecastChecker);\n      }\n      _this.setState(getDefaultState());\n    };\n\n    _this.state = getDefaultState();\n\n    // Used to poll for updates on a running forecast.\n    _this.forecastChecker = null;\n    return _this;\n  }\n\n  _createClass(ForecastingModal, [{\n    key: 'render',\n    value: function render() {\n      // Forecasting disabled if detector has an over field or job created < 6.1.0.\n      var isForecastingDisabled = false;\n      var forecastingDisabledMessage = null;\n      var _props = this.props,\n          intl = _props.intl,\n          job = _props.job;\n\n      if (job !== undefined) {\n        var detector = job.analysis_config.detectors[this.props.detectorIndex];\n        var overFieldName = detector.over_field_name;\n        if (overFieldName !== undefined) {\n          isForecastingDisabled = true;\n          forecastingDisabledMessage = intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.forecastingModal.forecastingNotAvailableForPopulationDetectorsMessage',\n            defaultMessage: 'Forecasting is not available for population detectors with an over field'\n          });\n        } else if ((0, _job_utils.isJobVersionGte)(job, FORECAST_JOB_MIN_VERSION) === false) {\n          isForecastingDisabled = true;\n          forecastingDisabledMessage = intl.formatMessage({\n            id: 'xpack.ml.timeSeriesExplorer.forecastingModal.forecastingOnlyAvailableForJobsCreatedInSpecifiedVersionMessage',\n            defaultMessage: 'Forecasting is only available for jobs created in version {minVersion} or later'\n          }, { minVersion: FORECAST_JOB_MIN_VERSION });\n        }\n      }\n\n      var forecastButton = _react2.default.createElement(\n        _eui.EuiButton,\n        {\n          onClick: this.openModal,\n          size: 's',\n          isDisabled: isForecastingDisabled,\n          fill: true\n        },\n        _react2.default.createElement(_react3.FormattedMessage, {\n          id: 'xpack.ml.timeSeriesExplorer.forecastingModal.forecastButtonLabel',\n          defaultMessage: 'Forecast'\n        })\n      );\n\n      return _react2.default.createElement(\n        'div',\n        null,\n        isForecastingDisabled ? _react2.default.createElement(\n          _eui.EuiToolTip,\n          {\n            position: 'left',\n            content: forecastingDisabledMessage\n          },\n          forecastButton\n        ) : forecastButton,\n        this.state.isModalVisible && _react2.default.createElement(_modal.Modal, {\n          job: this.props.job,\n          forecasts: this.state.previousForecasts,\n          close: this.closeModal,\n          viewForecast: this.viewForecast,\n          runForecast: this.checkJobStateAndRunForecast,\n          newForecastDuration: this.state.newForecastDuration,\n          onNewForecastDurationChange: this.onNewForecastDurationChange,\n          isNewForecastDurationValid: this.state.isNewForecastDurationValid,\n          newForecastDurationErrors: this.state.newForecastDurationErrors,\n          isForecastRequested: this.state.isForecastRequested,\n          forecastProgress: this.state.forecastProgress,\n          jobOpeningState: this.state.jobOpeningState,\n          jobClosingState: this.state.jobClosingState,\n          messages: this.state.messages\n        })\n      );\n    }\n  }]);\n\n  return ForecastingModal;\n}(_react.Component), _class.propTypes = {\n  isDisabled: _propTypes2.default.bool,\n  job: _propTypes2.default.object,\n  detectorIndex: _propTypes2.default.number,\n  entities: _propTypes2.default.array,\n  loadForForecastId: _propTypes2.default.func,\n  timefilter: _propTypes2.default.object\n}, _temp));",null]}