{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/cross_cluster_replication/public/app/store/actions/auto_follow_pattern.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/cross_cluster_replication/public/app/store/actions/auto_follow_pattern.js","mtime":1567631711955},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deleteAutoFollowPattern = exports.saveAutoFollowPattern = exports.getAutoFollowPattern = exports.loadAutoFollowPatterns = exports.selectEditAutoFollowPattern = exports.selectDetailAutoFollowPattern = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _i18n = require('@kbn/i18n');\n\nvar _notify = require('ui/notify');\n\nvar _constants = require('../../constants');\n\nvar _api = require('../../services/api');\n\nvar _routing = require('../../services/routing');\n\nvar _routing2 = _interopRequireDefault(_routing);\n\nvar _action_types = require('../action_types');\n\nvar t = _interopRequireWildcard(_action_types);\n\nvar _api2 = require('./api');\n\nvar _selectors = require('../selectors');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            */\n\n\nvar scope = _constants.SECTIONS.AUTO_FOLLOW_PATTERN;\nvar selectDetailAutoFollowPattern = exports.selectDetailAutoFollowPattern = function selectDetailAutoFollowPattern(id) {\n  return {\n    type: t.AUTO_FOLLOW_PATTERN_SELECT_DETAIL,\n    payload: id\n  };\n};\n\nvar selectEditAutoFollowPattern = exports.selectEditAutoFollowPattern = function selectEditAutoFollowPattern(id) {\n  return {\n    type: t.AUTO_FOLLOW_PATTERN_SELECT_EDIT,\n    payload: id\n  };\n};\n\nvar loadAutoFollowPatterns = exports.loadAutoFollowPatterns = function loadAutoFollowPatterns() {\n  var isUpdating = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return (0, _api2.sendApiRequest)({\n    label: t.AUTO_FOLLOW_PATTERN_LOAD,\n    scope: scope,\n    status: isUpdating ? _constants.API_STATUS.UPDATING : _constants.API_STATUS.LOADING,\n    handler: function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return (0, _api.loadAutoFollowPatterns)();\n\n              case 2:\n                return _context.abrupt('return', _context.sent);\n\n              case 3:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, undefined);\n      }));\n\n      function handler() {\n        return _ref.apply(this, arguments);\n      }\n\n      return handler;\n    }()\n  });\n};\n\nvar getAutoFollowPattern = exports.getAutoFollowPattern = function getAutoFollowPattern(id) {\n  return (0, _api2.sendApiRequest)({\n    label: t.AUTO_FOLLOW_PATTERN_GET,\n    scope: scope + '-get',\n    handler: function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return (0, _api.getAutoFollowPattern)(id);\n\n              case 2:\n                return _context2.abrupt('return', _context2.sent);\n\n              case 3:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, undefined);\n      }));\n\n      function handler() {\n        return _ref2.apply(this, arguments);\n      }\n\n      return handler;\n    }()\n  });\n};\n\nvar saveAutoFollowPattern = exports.saveAutoFollowPattern = function saveAutoFollowPattern(id, autoFollowPattern) {\n  var isUpdating = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return (0, _api2.sendApiRequest)({\n    label: isUpdating ? t.AUTO_FOLLOW_PATTERN_UPDATE : t.AUTO_FOLLOW_PATTERN_CREATE,\n    status: _constants.API_STATUS.SAVING,\n    scope: scope + '-save',\n    handler: function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!isUpdating) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                _context3.next = 3;\n                return (0, _api.updateAutoFollowPattern)(id, autoFollowPattern);\n\n              case 3:\n                return _context3.abrupt('return', _context3.sent);\n\n              case 4:\n                _context3.next = 6;\n                return (0, _api.createAutoFollowPattern)(_extends({ id: id }, autoFollowPattern));\n\n              case 6:\n                return _context3.abrupt('return', _context3.sent);\n\n              case 7:\n              case 'end':\n                return _context3.stop();\n            }\n          }\n        }, _callee3, undefined);\n      }));\n\n      function handler() {\n        return _ref3.apply(this, arguments);\n      }\n\n      return handler;\n    }(),\n    onSuccess: function onSuccess() {\n      var successMessage = isUpdating ? _i18n.i18n.translate('xpack.crossClusterReplication.autoFollowPattern.updateAction.successNotificationTitle', {\n        defaultMessage: 'Auto-follow pattern \\'{name}\\' updated successfully',\n        values: { name: id }\n      }) : _i18n.i18n.translate('xpack.crossClusterReplication.autoFollowPattern.addAction.successNotificationTitle', {\n        defaultMessage: 'Added auto-follow pattern \\'{name}\\'',\n        values: { name: id }\n      });\n\n      _notify.toastNotifications.addSuccess(successMessage);\n      _routing2.default.navigate('/auto_follow_patterns', undefined, {\n        pattern: encodeURIComponent(id)\n      });\n    }\n  });\n};\n\nvar deleteAutoFollowPattern = exports.deleteAutoFollowPattern = function deleteAutoFollowPattern(id) {\n  return (0, _api2.sendApiRequest)({\n    label: t.AUTO_FOLLOW_PATTERN_DELETE,\n    scope: scope + '-delete',\n    status: _constants.API_STATUS.DELETING,\n    handler: function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt('return', (0, _api.deleteAutoFollowPattern)(id));\n\n              case 1:\n              case 'end':\n                return _context4.stop();\n            }\n          }\n        }, _callee4, undefined);\n      }));\n\n      function handler() {\n        return _ref4.apply(this, arguments);\n      }\n\n      return handler;\n    }(),\n    onSuccess: function onSuccess(response, dispatch, getState) {\n      /**\n       * We can have 1 or more auto-follow pattern delete operation\n       * that can fail or succeed. We will show 1 toast notification for each.\n       */\n      if (response.errors.length) {\n        var hasMultipleErrors = response.errors.length > 1;\n        var errorMessage = hasMultipleErrors ? _i18n.i18n.translate('xpack.crossClusterReplication.autoFollowPattern.removeAction.errorMultipleNotificationTitle', {\n          defaultMessage: 'Error removing {count} auto-follow patterns',\n          values: { count: response.errors.length }\n        }) : _i18n.i18n.translate('xpack.crossClusterReplication.autoFollowPattern.removeAction.errorSingleNotificationTitle', {\n          defaultMessage: 'Error removing the \\'{name}\\' auto-follow pattern',\n          values: { name: response.errors[0].id }\n        });\n\n        _notify.toastNotifications.addDanger(errorMessage);\n      }\n\n      if (response.itemsDeleted.length) {\n        var hasMultipleDelete = response.itemsDeleted.length > 1;\n\n        var successMessage = hasMultipleDelete ? _i18n.i18n.translate('xpack.crossClusterReplication.autoFollowPattern.removeAction.successMultipleNotificationTitle', {\n          defaultMessage: '{count} auto-follow patterns were removed',\n          values: { count: response.itemsDeleted.length }\n        }) : _i18n.i18n.translate('xpack.crossClusterReplication.autoFollowPattern.removeAction.successSingleNotificationTitle', {\n          defaultMessage: 'Auto-follow pattern \\'{name}\\' was removed',\n          values: { name: response.itemsDeleted[0] }\n        });\n\n        _notify.toastNotifications.addSuccess(successMessage);\n\n        // If we've just deleted a pattern we were looking at, we need to close the panel.\n        var autoFollowPatternId = (0, _selectors.getSelectedAutoFollowPatternId)('detail')(getState());\n        if (response.itemsDeleted.includes(autoFollowPatternId)) {\n          dispatch(selectDetailAutoFollowPattern(null));\n        }\n      }\n    }\n  });\n};",null]}