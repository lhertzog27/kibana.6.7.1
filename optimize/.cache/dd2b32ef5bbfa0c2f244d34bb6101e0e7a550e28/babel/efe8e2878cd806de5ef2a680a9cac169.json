{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/ui/public/agg_types/buckets/_terms_other_bucket_helper.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/agg_types/buckets/_terms_other_bucket_helper.js","mtime":1567631711696},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateMissingBucket = exports.mergeOtherBucketAggResponse = exports.buildOtherBucketAgg = undefined;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _esQuery = require('@kbn/es-query');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /*\n                                                                                                                                                                                                     * Licensed to Elasticsearch B.V. under one or more contributor\n                                                                                                                                                                                                     * license agreements. See the NOTICE file distributed with\n                                                                                                                                                                                                     * this work for additional information regarding copyright\n                                                                                                                                                                                                     * ownership. Elasticsearch B.V. licenses this file to you under\n                                                                                                                                                                                                     * the Apache License, Version 2.0 (the \"License\"); you may\n                                                                                                                                                                                                     * not use this file except in compliance with the License.\n                                                                                                                                                                                                     * You may obtain a copy of the License at\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     *    http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                     *\n                                                                                                                                                                                                     * Unless required by applicable law or agreed to in writing,\n                                                                                                                                                                                                     * software distributed under the License is distributed on an\n                                                                                                                                                                                                     * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n                                                                                                                                                                                                     * KIND, either express or implied.  See the License for the\n                                                                                                                                                                                                     * specific language governing permissions and limitations\n                                                                                                                                                                                                     * under the License.\n                                                                                                                                                                                                     */\n\n/**\n * walks the aggregation DSL and returns DSL starting at aggregation with id of startFromAggId\n * @param aggNestedDsl: aggregation config DSL (top level)\n * @param startFromId: id of an aggregation from where we want to get the nested DSL\n */\nvar getNestedAggDSL = function getNestedAggDSL(aggNestedDsl, startFromAggId) {\n  if (aggNestedDsl[startFromAggId]) return aggNestedDsl[startFromAggId];\n  return getNestedAggDSL(_lodash2.default.values(aggNestedDsl)[0].aggs, startFromAggId);\n};\n\n/**\n * returns buckets from response for a specific other bucket\n * @param aggConfigs: configuration for the aggregations\n * @param response: response from elasticsearch\n * @param aggWithOtherBucket: AggConfig of the aggregation with other bucket enabled\n * @param key: key from the other bucket request for a specific other bucket\n */\nvar getAggResultBuckets = function getAggResultBuckets(aggConfigs, response, aggWithOtherBucket, key) {\n  var keyParts = key.split('-');\n  var responseAgg = response;\n\n  var _loop = function _loop(i) {\n    if (keyParts[i]) {\n      var agg = _lodash2.default.values(responseAgg)[0];\n      var aggKey = _lodash2.default.keys(responseAgg)[0];\n      var aggConfig = _lodash2.default.find(aggConfigs, function (agg) {\n        return agg.id === aggKey;\n      });\n      var bucket = _lodash2.default.find(agg.buckets, function (bucket, bucketObjKey) {\n        var bucketKey = aggConfig.getKey(bucket, Number.isInteger(bucketObjKey) ? null : bucketObjKey).toString();\n        return bucketKey === keyParts[i];\n      });\n      if (bucket) {\n        responseAgg = bucket;\n      }\n    }\n  };\n\n  for (var i in keyParts) {\n    _loop(i);\n  }\n  if (responseAgg[aggWithOtherBucket.id]) return responseAgg[aggWithOtherBucket.id].buckets;\n  return [];\n};\n\n/**\n * gets all the missing buckets in our response for a specific aggregation id\n * @param responseAggs: array of aggregations from response\n * @param aggId: id of the aggregation with missing bucket\n */\nvar getAggConfigResultMissingBuckets = function getAggConfigResultMissingBuckets(responseAggs, aggId) {\n  var missingKey = '__missing__';\n  var resultBuckets = [];\n  if (responseAggs[aggId]) {\n    var matchingBucket = responseAggs[aggId].buckets.find(function (bucket) {\n      return bucket.key === missingKey;\n    });\n    if (matchingBucket) resultBuckets.push(matchingBucket);\n    return resultBuckets;\n  }\n  _lodash2.default.each(responseAggs, function (agg) {\n    if (agg.buckets) {\n      _lodash2.default.each(agg.buckets, function (bucket) {\n        resultBuckets = [].concat(_toConsumableArray(resultBuckets), _toConsumableArray(getAggConfigResultMissingBuckets(bucket, aggId, missingKey)));\n      });\n    }\n  });\n\n  return resultBuckets;\n};\n\n/**\n * gets all the terms that are NOT in the other bucket\n * @param requestAgg: an aggregation we are looking at\n * @param key: the key for this specific other bucket\n * @param otherAgg: AggConfig of the aggregation with other bucket\n */\nvar getOtherAggTerms = function getOtherAggTerms(requestAgg, key, otherAgg) {\n  return requestAgg['other-filter'].filters.filters[key].bool.must_not.filter(function (filter) {\n    return filter.match_phrase && filter.match_phrase[otherAgg.params.field.name];\n  }).map(function (filter) {\n    return filter.match_phrase[otherAgg.params.field.name].query;\n  });\n};\n\nvar buildOtherBucketAgg = function buildOtherBucketAgg(aggConfigs, aggWithOtherBucket, response) {\n  var bucketAggs = aggConfigs.filter(function (agg) {\n    return agg.type.type === 'buckets';\n  });\n  var index = bucketAggs.findIndex(function (agg) {\n    return agg.id === aggWithOtherBucket.id;\n  });\n  var aggs = aggConfigs.toDsl();\n  var indexPattern = aggWithOtherBucket.params.field.indexPattern;\n\n  // create filters aggregation\n  var filterAgg = aggConfigs.createAggConfig({\n    type: 'filters',\n    id: 'other'\n  }, {\n    addToAggConfigs: false\n  });\n\n  // nest all the child aggregations of aggWithOtherBucket\n  var resultAgg = {\n    aggs: getNestedAggDSL(aggs, aggWithOtherBucket.id).aggs,\n    filters: filterAgg.toDsl()\n  };\n\n  // create filters for all parent aggregation buckets\n  var walkBucketTree = function walkBucketTree(aggIndex, aggs, aggId, filters, key) {\n    var agg = aggs[aggId];\n    var newAggIndex = aggIndex + 1;\n    var newAgg = bucketAggs[newAggIndex];\n    var currentAgg = bucketAggs[aggIndex];\n    if (aggIndex < index) {\n      _lodash2.default.each(agg.buckets, function (bucket, bucketObjKey) {\n        var bucketKey = currentAgg.getKey(bucket, Number.isInteger(bucketObjKey) ? null : bucketObjKey);\n        var filter = _lodash2.default.cloneDeep(bucket.filters) || currentAgg.createFilter(bucketKey);\n        var newFilters = _lodash2.default.flatten([].concat(_toConsumableArray(filters), [filter]));\n        walkBucketTree(newAggIndex, bucket, newAgg.id, newFilters, key + '-' + bucketKey.toString());\n      });\n      return;\n    }\n\n    if (!aggWithOtherBucket.params.missingBucket || agg.buckets.some(function (bucket) {\n      return bucket.key === '__missing__';\n    })) {\n      filters.push((0, _esQuery.buildExistsFilter)(aggWithOtherBucket.params.field, aggWithOtherBucket.params.field.indexPattern));\n    }\n\n    // create not filters for all the buckets\n    _lodash2.default.each(agg.buckets, function (bucket) {\n      if (bucket.key === '__missing__') return;\n      var filter = currentAgg.createFilter(bucket.key);\n      filter.meta.negate = true;\n      filters.push(filter);\n    });\n\n    resultAgg.filters.filters[key] = {\n      bool: (0, _esQuery.buildQueryFromFilters)(filters, indexPattern)\n    };\n  };\n  walkBucketTree(0, response.aggregations, bucketAggs[0].id, [], '');\n\n  return function () {\n    return {\n      'other-filter': resultAgg\n    };\n  };\n};\n\nvar mergeOtherBucketAggResponse = function mergeOtherBucketAggResponse(aggsConfig, response, otherResponse, otherAgg, requestAgg) {\n  var updatedResponse = _lodash2.default.cloneDeep(response);\n  _lodash2.default.each(otherResponse.aggregations['other-filter'].buckets, function (bucket, key) {\n    if (!bucket.doc_count) return;\n    var bucketKey = key.replace(/^-/, '');\n    var aggResultBuckets = getAggResultBuckets(aggsConfig, updatedResponse.aggregations, otherAgg, bucketKey);\n    var requestFilterTerms = getOtherAggTerms(requestAgg, key, otherAgg);\n\n    var phraseFilter = (0, _esQuery.buildPhrasesFilter)(otherAgg.params.field, requestFilterTerms, otherAgg.params.field.indexPattern);\n    phraseFilter.meta.negate = true;\n    bucket.filters = [phraseFilter];\n    bucket.key = '__other__';\n\n    if (aggResultBuckets.some(function (bucket) {\n      return bucket.key === '__missing__';\n    })) {\n      bucket.filters.push((0, _esQuery.buildExistsFilter)(otherAgg.params.field, otherAgg.params.field.indexPattern));\n    }\n    aggResultBuckets.push(bucket);\n  });\n  return updatedResponse;\n};\n\nvar updateMissingBucket = function updateMissingBucket(response, aggConfigs, agg) {\n  var updatedResponse = _lodash2.default.cloneDeep(response);\n  var aggResultBuckets = getAggConfigResultMissingBuckets(updatedResponse.aggregations, agg.id);\n  aggResultBuckets.forEach(function (bucket) {\n    bucket.key = '__missing__';\n  });\n  return updatedResponse;\n};\n\nexports.buildOtherBucketAgg = buildOtherBucketAgg;\nexports.mergeOtherBucketAggResponse = mergeOtherBucketAggResponse;\nexports.updateMissingBucket = updateMissingBucket;",null]}