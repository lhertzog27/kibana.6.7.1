{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/reducers/resolved_args.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/state/reducers/resolved_args.js","mtime":1567631711936},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolvedArgsReducer = undefined;\n\nvar _handleActions;\n\nvar _reduxActions = require('redux-actions');\n\nvar _objectPathImmutable = require('object-path-immutable');\n\nvar _lodash = require('lodash');\n\nvar _modify_path = require('../../lib/modify_path');\n\nvar _resolved_args = require('../actions/resolved_args');\n\nvar actions = _interopRequireWildcard(_resolved_args);\n\nvar _elements = require('../actions/elements');\n\nvar _workpad = require('../actions/workpad');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError(\"Cannot destructure undefined\"); } /*\n                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                   */\n\n/*\n  Resolved args are a way to handle async values. They track the status, value, and error\n  state thgouh the lifecycle of the request, and are an object that looks like this:\n\n  {\n    status: 'pending',\n    value: null,\n    error: null,\n  }\n\n  Here, the request is in flight, and the application is waiting for a value. Valid statuses\n  are `initializing`, `pending`, `ready`, and `error`.\n\n  When status is `ready`, the value will be whatever came back in the response.\n\n  When status is `error`, the value will not change, and the error property will be the error.\n*/\n\nfunction _getState(hasError, loading) {\n  if (hasError) {\n    return 'error';\n  }\n  if (Boolean(loading)) {\n    return 'pending';\n  }\n  return 'ready';\n}\n\nfunction _getValue(hasError, value, oldVal) {\n  if (hasError || value == null) {\n    return oldVal && oldVal.value;\n  }\n  return value;\n}\n\nfunction getContext(value) {\n  var loading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var oldVal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  // TODO: this is no longer correct.\n  var hasError = value instanceof Error;\n  return {\n    state: _getState(hasError, loading),\n    value: _getValue(hasError, value, oldVal),\n    error: hasError ? value : null\n  };\n}\n\nfunction getFullPath(path) {\n  var isArray = Array.isArray(path);\n  var isString = typeof path === 'string';\n  if (!isArray && !isString) {\n    throw new Error('Resolved argument path is invalid: ' + path);\n  }\n  return (0, _modify_path.prepend)(path, 'resolvedArgs');\n}\n\nvar resolvedArgsReducer = exports.resolvedArgsReducer = (0, _reduxActions.handleActions)((_handleActions = {}, _defineProperty(_handleActions, actions.setLoading, function (transientState, _ref) {\n  var payload = _ref.payload;\n  var path = payload.path,\n      _payload$loading = payload.loading,\n      loading = _payload$loading === undefined ? true : _payload$loading;\n\n  var fullPath = getFullPath(path);\n  var oldVal = (0, _lodash.get)(transientState, fullPath, null);\n  return (0, _objectPathImmutable.set)(transientState, fullPath, getContext((0, _lodash.get)(oldVal, 'value', null), loading));\n}), _defineProperty(_handleActions, actions.setValue, function (transientState, _ref2) {\n  var payload = _ref2.payload;\n  var path = payload.path,\n      value = payload.value;\n\n  var fullPath = getFullPath(path);\n  var oldVal = (0, _lodash.get)(transientState, fullPath, null);\n  return (0, _objectPathImmutable.set)(transientState, fullPath, getContext(value, false, oldVal));\n}), _defineProperty(_handleActions, actions.setValues, function (transientState, _ref3) {\n  var payload = _ref3.payload;\n\n  return payload.reduce(function (acc, setValueObj) {\n    var fullPath = getFullPath(setValueObj.path);\n    var oldVal = (0, _lodash.get)(acc, fullPath, null);\n    return (0, _objectPathImmutable.set)(acc, fullPath, getContext(setValueObj.value, false, oldVal));\n  }, transientState);\n}), _defineProperty(_handleActions, actions.clearValue, function (transientState, _ref4) {\n  var payload = _ref4.payload;\n  var path = payload.path;\n\n  return (0, _objectPathImmutable.del)(transientState, getFullPath(path));\n}), _defineProperty(_handleActions, actions.clearValues, function (transientState, _ref5) {\n  var payload = _ref5.payload;\n\n  return payload.reduce(function (transientState, path) {\n    return (0, _objectPathImmutable.del)(transientState, getFullPath(path));\n  }, transientState);\n}), _defineProperty(_handleActions, actions.inFlightActive, function (transientState) {\n  return (0, _objectPathImmutable.set)(transientState, 'inFlight', true);\n}), _defineProperty(_handleActions, actions.inFlightComplete, function (transientState) {\n  return (0, _objectPathImmutable.set)(transientState, 'inFlight', false);\n}), _defineProperty(_handleActions, _elements.flushContext, function (transientState, _ref6) {\n  var elementId = _ref6.payload;\n\n  return (0, _objectPathImmutable.del)(transientState, getFullPath([elementId, 'expressionContext']));\n}), _defineProperty(_handleActions, _elements.flushContextAfterIndex, function (transientState, _ref7) {\n  var payload = _ref7.payload;\n  var elementId = payload.elementId,\n      index = payload.index;\n\n  var expressionContext = (0, _lodash.get)(transientState, getFullPath([elementId, 'expressionContext']));\n\n  // if there is not existing context, there's nothing to do here\n  if (!expressionContext) {\n    return transientState;\n  }\n\n  return Object.keys(expressionContext).reduce(function (state, indexKey) {\n    var indexAsNum = parseInt(indexKey, 10);\n    if (indexAsNum >= index) {\n      return (0, _objectPathImmutable.del)(state, getFullPath([elementId, 'expressionContext', indexKey]));\n    }\n\n    return state;\n  }, transientState);\n}), _defineProperty(_handleActions, _workpad.setWorkpad, function (transientState, _ref8) {\n  _objectDestructuringEmpty(_ref8);\n\n  return (0, _objectPathImmutable.set)(transientState, 'resolvedArgs', {});\n}), _handleActions), {});",null]}