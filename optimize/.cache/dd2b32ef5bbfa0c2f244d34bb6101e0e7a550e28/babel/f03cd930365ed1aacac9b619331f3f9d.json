{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/monitoring/public/services/executor_provider.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/monitoring/public/services/executor_provider.js","mtime":1567631712099},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executorProvider = executorProvider;\n\nvar _timefilter = require('ui/timefilter');\n\nfunction executorProvider(Promise, $timeout) {\n\n  var queue = [];\n  var executionTimer = void 0;\n  var ignorePaused = false;\n\n  /**\n     * Resets the timer to start again\n     * @returns {void}\n     */\n  function reset() {\n    cancel();\n    _start();\n  }\n\n  function killTimer() {\n    if (executionTimer) {\n      $timeout.cancel(executionTimer);\n    }\n  }\n\n  /**\n     * Cancels the execution timer\n     * @returns {void}\n     */\n  function cancel() {\n    killTimer();\n  }\n\n  /**\n     * Registers a service with the executor\n     * @param {object} service The service to register\n     * @returns {void}\n     */\n  function register(service) {\n    queue.push(service);\n  }\n\n  /**\n     * Stops the executor and empties the service queue\n     * @returns {void}\n     */\n  function destroy() {\n    cancel();\n    ignorePaused = false;\n    queue.splice(0, queue.length);\n  }\n\n  /**\n     * Runs the queue (all at once)\n     * @returns {Promise} a promise of all the services\n     */\n  function run() {\n    var noop = function noop() {\n      return Promise.resolve();\n    };\n    return Promise.all(queue.map(function (service) {\n      return service.execute().then(service.handleResponse || noop).catch(service.handleError || noop);\n    })).finally(reset);\n  }\n\n  function reFetch(_changes) {\n    cancel();\n    run();\n  }\n\n  function killIfPaused() {\n    if (_timefilter.timefilter.getRefreshInterval().pause) {\n      killTimer();\n    }\n  }\n\n  /**\n     * Starts the executor service if the timefilter is not paused\n     * @returns {void}\n     */\n  function _start() {\n    if ((ignorePaused || _timefilter.timefilter.getRefreshInterval().pause === false) && _timefilter.timefilter.getRefreshInterval().value > 0) {\n      executionTimer = $timeout(run, _timefilter.timefilter.getRefreshInterval().value);\n    }\n  }\n\n  /**\n     * Expose the methods\n     */\n  return {\n    register: register,\n    start: function start($scope) {\n      $scope.$listenAndDigestAsync(_timefilter.timefilter, 'fetch', reFetch);\n      $scope.$listenAndDigestAsync(_timefilter.timefilter, 'refreshIntervalUpdate', killIfPaused);\n      _start();\n    },\n\n    run: run,\n    destroy: destroy,\n    reset: reset,\n    cancel: cancel\n  };\n} /*\n   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n   * or more contributor license agreements. Licensed under the Elastic License;\n   * you may not use this file except in compliance with the Elastic License.\n   */",null]}