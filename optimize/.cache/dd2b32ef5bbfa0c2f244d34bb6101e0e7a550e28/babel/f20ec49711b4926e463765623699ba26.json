{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/services/forecast_service.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/services/forecast_service.js","mtime":1567631712062},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mlForecastService = undefined;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _index_patterns = require('plugins/ml/../common/constants/index_patterns');\n\nvar _ml_api_service = require('plugins/ml/services/ml_api_service');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /*\n                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                   */\n\n// Service for carrying out requests to run ML forecasts and to obtain\n// data on forecasts that have been performed.\n\n\n// Gets a basic summary of the most recently run forecasts for the specified\n// job, with results at or later than the supplied timestamp.\n// Extra query object can be supplied, or pass null if no additional query.\n// Returned response contains a forecasts property, which is an array of objects\n// containing id, earliest and latest keys.\nfunction getForecastsSummary(job, query, earliestMs, maxResults) {\n  return new Promise(function (resolve, reject) {\n    var obj = {\n      success: true,\n      forecasts: []\n    };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Add criteria for the job ID, result type and earliest time, plus\n    // the additional query if supplied.\n    var filterCriteria = [{\n      term: { result_type: 'model_forecast_request_stats' }\n    }, {\n      term: { job_id: job.job_id }\n    }, {\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }];\n\n    if (query) {\n      filterCriteria.push(query);\n    }\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: maxResults,\n      rest_total_hits_as_int: true,\n      body: {\n        query: {\n          bool: {\n            filter: filterCriteria\n          }\n        },\n        sort: [{ forecast_create_timestamp: { 'order': 'desc' } }]\n      }\n    }).then(function (resp) {\n      if (resp.hits.total !== 0) {\n        obj.forecasts = resp.hits.hits.map(function (hit) {\n          return hit._source;\n        });\n      }\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Obtains the earliest and latest timestamps for the forecast data from\n// the forecast with the specified ID.\n// Returned response contains earliest and latest properties which are the\n// timestamps of the first and last model_forecast results.\nfunction getForecastDateRange(job, forecastId) {\n\n  return new Promise(function (resolve, reject) {\n    var obj = {\n      success: true,\n      earliest: null,\n      latest: null\n    };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Add criteria for the job ID, forecast ID, result type and time range.\n    var filterCriteria = [{\n      query_string: {\n        query: 'result_type:model_forecast',\n        analyze_wildcard: true\n      }\n    }, {\n      term: { job_id: job.job_id }\n    }, {\n      term: { forecast_id: forecastId }\n    }];\n\n    // TODO - add in criteria for detector index and entity fields (by, over, partition)\n    // once forecasting with these parameters is supported.\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: 0,\n      body: {\n        query: {\n          bool: {\n            filter: filterCriteria\n          }\n        },\n        aggs: {\n          earliest: {\n            min: {\n              field: 'timestamp'\n            }\n          },\n          latest: {\n            max: {\n              field: 'timestamp'\n            }\n          }\n        }\n      }\n    }).then(function (resp) {\n      obj.earliest = _lodash2.default.get(resp, 'aggregations.earliest.value', null);\n      obj.latest = _lodash2.default.get(resp, 'aggregations.latest.value', null);\n      if (obj.earliest === null || obj.latest === null) {\n        reject(resp);\n      } else {\n        resolve(obj);\n      }\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Obtains the requested forecast model data for the forecast with the specified ID.\nfunction getForecastData(job, detectorIndex, forecastId, entityFields, earliestMs, latestMs, interval, aggType) {\n  // Extract the partition, by, over fields on which to filter.\n  var criteriaFields = [];\n  var detector = job.analysis_config.detectors[detectorIndex];\n  if (_lodash2.default.has(detector, 'partition_field_name')) {\n    var partitionEntity = _lodash2.default.find(entityFields, { 'fieldName': detector.partition_field_name });\n    if (partitionEntity !== undefined) {\n      criteriaFields.push({ fieldName: 'partition_field_name', fieldValue: partitionEntity.fieldName }, { fieldName: 'partition_field_value', fieldValue: partitionEntity.fieldValue });\n    }\n  }\n\n  if (_lodash2.default.has(detector, 'over_field_name')) {\n    var overEntity = _lodash2.default.find(entityFields, { 'fieldName': detector.over_field_name });\n    if (overEntity !== undefined) {\n      criteriaFields.push({ fieldName: 'over_field_name', fieldValue: overEntity.fieldName }, { fieldName: 'over_field_value', fieldValue: overEntity.fieldValue });\n    }\n  }\n\n  if (_lodash2.default.has(detector, 'by_field_name')) {\n    var byEntity = _lodash2.default.find(entityFields, { 'fieldName': detector.by_field_name });\n    if (byEntity !== undefined) {\n      criteriaFields.push({ fieldName: 'by_field_name', fieldValue: byEntity.fieldName }, { fieldName: 'by_field_value', fieldValue: byEntity.fieldValue });\n    }\n  }\n\n  return new Promise(function (resolve, reject) {\n    var obj = {\n      success: true,\n      results: {}\n    };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Add criteria for the job ID, forecast ID, detector index, result type and time range.\n    var filterCriteria = [{\n      query_string: {\n        query: 'result_type:model_forecast',\n        analyze_wildcard: true\n      }\n    }, {\n      term: { job_id: job.job_id }\n    }, {\n      term: { forecast_id: forecastId }\n    }, {\n      term: { detector_index: detectorIndex }\n    }, {\n      range: {\n        timestamp: {\n          gte: earliestMs,\n          lte: latestMs,\n          format: 'epoch_millis'\n        }\n      }\n    }];\n\n    // Add in term queries for each of the specified criteria.\n    _lodash2.default.each(criteriaFields, function (criteria) {\n      filterCriteria.push({\n        term: _defineProperty({}, criteria.fieldName, criteria.fieldValue)\n      });\n    });\n\n    // If an aggType object has been passed in, use it.\n    // Otherwise default to avg, min and max aggs for the\n    // forecast prediction, upper and lower\n    var forecastAggs = aggType === undefined ? { avg: 'avg', max: 'max', min: 'min' } : {\n      avg: aggType.avg,\n      max: aggType.max,\n      min: aggType.min\n    };\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: 0,\n      body: {\n        query: {\n          bool: {\n            filter: filterCriteria\n          }\n        },\n        aggs: {\n          times: {\n            date_histogram: {\n              field: 'timestamp',\n              interval: interval,\n              min_doc_count: 1\n            },\n            aggs: {\n              prediction: _defineProperty({}, forecastAggs.avg, {\n                field: 'forecast_prediction'\n              }),\n              forecastUpper: _defineProperty({}, forecastAggs.max, {\n                field: 'forecast_upper'\n              }),\n              forecastLower: _defineProperty({}, forecastAggs.min, {\n                field: 'forecast_lower'\n              })\n            }\n          }\n        }\n      }\n    }).then(function (resp) {\n      var aggregationsByTime = _lodash2.default.get(resp, ['aggregations', 'times', 'buckets'], []);\n      _lodash2.default.each(aggregationsByTime, function (dataForTime) {\n        var time = dataForTime.key;\n        obj.results[time] = {\n          prediction: _lodash2.default.get(dataForTime, ['prediction', 'value']),\n          forecastUpper: _lodash2.default.get(dataForTime, ['forecastUpper', 'value']),\n          forecastLower: _lodash2.default.get(dataForTime, ['forecastLower', 'value'])\n        };\n      });\n\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\n// Runs a forecast\nfunction runForecast(jobId, duration) {\n  console.log('ML forecast service run forecast with duration:', duration);\n  return new Promise(function (resolve, reject) {\n\n    _ml_api_service.ml.forecast({\n      jobId: jobId,\n      duration: duration\n    }).then(function (resp) {\n      resolve(resp);\n    }).catch(function (err) {\n      reject(err);\n    });\n  });\n}\n\n// Gets stats for a forecast that has been run on the specified job.\n// Returned response contains a stats property, including\n// forecast_progress (a value from 0 to 1),\n// and forecast_status ('finished' when complete) properties.\nfunction getForecastRequestStats(job, forecastId) {\n  return new Promise(function (resolve, reject) {\n    var obj = {\n      success: true,\n      stats: {}\n    };\n\n    // Build the criteria to use in the bool filter part of the request.\n    // Add criteria for the job ID, result type and earliest time.\n    var filterCriteria = [{\n      query_string: {\n        query: 'result_type:model_forecast_request_stats',\n        analyze_wildcard: true\n      }\n    }, {\n      term: { job_id: job.job_id }\n    }, {\n      term: { forecast_id: forecastId }\n    }];\n\n    _ml_api_service.ml.esSearch({\n      index: _index_patterns.ML_RESULTS_INDEX_PATTERN,\n      size: 1,\n      rest_total_hits_as_int: true,\n      body: {\n        query: {\n          bool: {\n            filter: filterCriteria\n          }\n        }\n      }\n    }).then(function (resp) {\n      if (resp.hits.total !== 0) {\n        obj.stats = _lodash2.default.first(resp.hits.hits)._source;\n      }\n      resolve(obj);\n    }).catch(function (resp) {\n      reject(resp);\n    });\n  });\n}\n\nvar mlForecastService = exports.mlForecastService = {\n  getForecastsSummary: getForecastsSummary,\n  getForecastDateRange: getForecastDateRange,\n  getForecastData: getForecastData,\n  runForecast: runForecast,\n  getForecastRequestStats: getForecastRequestStats\n};",null]}