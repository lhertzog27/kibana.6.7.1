{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/components/field_data_card/metric_distribution_chart_directive.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/components/field_data_card/metric_distribution_chart_directive.js","mtime":1567631712030},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _d = require('d3');\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _chart_utils = require('../../util/chart_utils');\n\nvar _ordinal_suffix = require('ui/utils/ordinal_suffix');\n\nvar _chart_tooltip_service = require('../../components/chart_tooltip/chart_tooltip_service');\n\nvar _modules = require('ui/modules');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\n/*\n * AngularJS directive for rendering a chart showing the distribution of values for\n * a metric on the field data card.\n */\n\nvar _module = _modules.uiModules.get('apps/ml');\n\n_module.directive('mlMetricDistributionChart', function (i18n) {\n\n  function link(scope, element, attrs) {\n    var svgWidth = attrs.width ? +attrs.width : 400;\n    var svgHeight = scope.height = attrs.height ? +attrs.height : 400;\n\n    // TODO - do we want to label the y axis?\n    var margin = { top: 0, right: 15, bottom: 20, left: 15 };\n    var infoLabelHeight = 15;\n\n    var chartWidth = svgWidth - (margin.left + margin.right);\n    var chartHeight = svgHeight - (margin.top + margin.bottom + infoLabelHeight);\n\n    var xScale = _d2.default.scale.linear().range([0, chartWidth]);\n    var yScale = _d2.default.scale.linear().range([chartHeight, 0]);\n    var xAxisMin = 0;\n    var xAxisMax = 1;\n    var chartGroup = void 0;\n\n    var distributionArea = _d2.default.svg.area().x(function (d) {\n      return xScale(d.x);\n    }).y0(function () {\n      return yScale(0);\n    }).y1(function (d) {\n      return yScale(d.y);\n    });\n\n    var MIN_BAR_WIDTH = 3; // Minimum bar width, in pixels.\n\n    element.on('$destroy', function () {\n      scope.$destroy();\n    });\n\n    function processDistributionData() {\n      var distributionData = _lodash2.default.get(scope, ['card', 'stats', 'distribution', 'percentiles'], []);\n      var chartData = [];\n\n      // Process the raw distribution data so it is in a suitable format for plotting:\n      if (distributionData.length === 0) {\n        return chartData;\n      }\n\n      // Adjust x axis min and max if there is a single bar.\n      var minX = distributionData[0].minValue;\n      var maxX = distributionData[distributionData.length - 1].maxValue;\n      xAxisMin = minX;\n      xAxisMax = maxX;\n      if (maxX === minX) {\n        if (minX !== 0) {\n          xAxisMin = 0;\n          xAxisMax = 2 * minX;\n        } else {\n          xAxisMax = 1;\n        }\n      }\n\n      // Adjust the right hand x coordinates so that each bar is\n      // at least MIN_BAR_WIDTH.\n      // TODO - make sure last bar isn't cropped at RHS.\n      var minBarWidth = MIN_BAR_WIDTH / chartWidth * (xAxisMax - xAxisMin);\n      var processedData = [];\n      var lastBar = undefined;\n      _lodash2.default.each(distributionData, function (data, index) {\n\n        if (index === 0) {\n          var bar = {\n            x0: data.minValue,\n            x1: Math.max(data.minValue + minBarWidth, data.maxValue),\n            dataMin: data.minValue,\n            dataMax: data.maxValue,\n            percent: data.percent\n          };\n\n          // Scale the height of the bar according to the range of data values in the bar.\n          bar.y = data.percent / (bar.x1 - bar.x0) * Math.max(1, minBarWidth / Math.max(data.maxValue - data.minValue, 0.5 * minBarWidth));\n          bar.isMinWidth = data.maxValue <= data.minValue + minBarWidth;\n          processedData.push(bar);\n          lastBar = bar;\n        } else {\n          if (lastBar.isMinWidth === false || data.maxValue > lastBar.x1) {\n            var _bar = {\n              x0: lastBar.x1,\n              x1: Math.max(lastBar.x1 + minBarWidth, data.maxValue),\n              dataMin: data.minValue,\n              dataMax: data.maxValue,\n              percent: data.percent\n            };\n\n            // Scale the height of the bar according to the range of data values in the bar.\n            _bar.y = data.percent / (_bar.x1 - _bar.x0) * Math.max(1, minBarWidth / Math.max(data.maxValue - data.minValue, 0.5 * minBarWidth));\n            _bar.isMinWidth = data.maxValue <= lastBar.x1 + minBarWidth;\n            processedData.push(_bar);\n            lastBar = _bar;\n          } else {\n            // Combine bars which are less than minBarWidth apart.\n            lastBar.percent = lastBar.percent + data.percent;\n            lastBar.y = lastBar.percent / (lastBar.x1 - lastBar.x0);\n            lastBar.dataMax = data.maxValue;\n          }\n        }\n      });\n\n      if (maxX !== minX) {\n        xAxisMax = _lodash2.default.last(processedData).x1;\n      }\n\n      // Adjust the maximum bar height to be (10 * median bar height).\n      // TODO indicate if a bar height has been truncated?\n      var barHeights = _lodash2.default.pluck(processedData, 'y');\n      barHeights = barHeights.sort(function (a, b) {\n        return a - b;\n      });\n\n      var maxBarHeight = 0;\n      var processedDataLength = processedData.length;\n      if (Math.abs(processedDataLength % 2) === 1) {\n        maxBarHeight = 20 * barHeights[Math.floor(processedDataLength / 2)];\n      } else {\n        maxBarHeight = 20 * (barHeights[Math.floor(processedDataLength / 2) - 1] + barHeights[Math.floor(processedDataLength / 2)]) / 2;\n      }\n\n      _lodash2.default.each(processedData, function (data) {\n        data.y = Math.min(data.y, maxBarHeight);\n      });\n\n      scope.processedData = processedData;\n\n      chartData.push({ x: minX, y: 0 });\n      _lodash2.default.each(processedData, function (data) {\n        chartData.push({ x: data.x0, y: data.y });\n        chartData.push({ x: data.x1, y: data.y });\n      });\n      chartData.push({ x: processedData[processedData.length - 1].x1, y: 0 });\n\n      return chartData;\n    }\n\n    function init() {\n      scope.chartData = processDistributionData();\n\n      // Clear any existing elements from the visualization,\n      // then build the svg elements for the chart.\n      var chartElement = _d2.default.select(element.get(0)).select('.content-wrapper');\n      chartElement.select('svg').remove();\n\n      var svg = chartElement.append('svg').attr('width', svgWidth).attr('height', svgHeight);\n\n      // Add a label above the chart to display percentiles being plotted.\n      var minPercentile = _lodash2.default.get(scope, ['card', 'stats', 'distribution', 'minPercentile']);\n      var maxPercentile = _lodash2.default.get(scope, ['card', 'stats', 'distribution', 'maxPercentile']);\n      var minPercent = (0, _ordinal_suffix.ordinalSuffix)(minPercentile);\n      var maxPercent = (0, _ordinal_suffix.ordinalSuffix)(maxPercentile);\n      svg.append('text').attr('x', chartWidth / 2).attr('y', 10).attr('class', 'info-text').attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')').text(i18n('xpack.ml.fieldDataCard.metricDistributionChart.displayingPercentilesLabel', {\n        defaultMessage: 'Displaying {minPercent} - {maxPercent} percentiles',\n        values: {\n          minPercent: minPercent,\n          maxPercent: maxPercent\n        }\n      }));\n\n      var translateTop = margin.top + infoLabelHeight;\n      chartGroup = svg.append('g').attr('class', 'distribution-chart').attr('transform', 'translate(' + margin.left + ', ' + translateTop + ')');\n\n      var dataLength = scope.chartData.length;\n      if (dataLength > 0) {\n        xScale = xScale.domain([xAxisMin, xAxisMax]);\n\n        var yMax = _d2.default.max(scope.chartData, function (d) {\n          return d.y;\n        });\n        yScale = yScale.domain([0, yMax]);\n      }\n    }\n\n    function drawAxes() {\n      var axes = chartGroup.append('g').attr('class', 'axes');\n\n      // Use the numTicks util function to calculate the number of ticks\n      // for the x axis, according to the width of the chart.\n      // Note that d3 doesn't guarantee that the axis will end up with\n      // this exact number of ticks.\n      var xAxis = _d2.default.svg.axis().scale(xScale).orient('bottom').outerTickSize(0).ticks((0, _chart_utils.numTicks)(chartWidth)).tickFormat(function (d) {\n        // Format the tick label according to the format of the index pattern field.\n        return scope.card.fieldFormat.convert(d, 'text');\n      });\n\n      var yAxis = _d2.default.svg.axis().scale(yScale).orient('left').outerTickSize(0).ticks(0);\n\n      axes.append('g').attr('class', 'x axis').attr('transform', 'translate(0, ' + chartHeight + ')').call(xAxis);\n\n      axes.append('g').attr('class', 'y axis').call(yAxis);\n    }\n\n    function drawDistributionArea() {\n      var path = chartGroup.append('path');\n      path.datum(scope.chartData).attr('class', 'area').attr('d', distributionArea).on('mouseover', showChartTooltip).on('mouseout', function () {\n        return _chart_tooltip_service.mlChartTooltipService.hide();\n      }).on('mousemove', showChartTooltip);\n\n      function showChartTooltip() {\n        var xPos = _d2.default.mouse(this)[0];\n        var yPos = _d2.default.mouse(this)[1];\n        var xVal = xScale.invert(xPos);\n\n        var processedDataIdx = 0;\n        for (var i = 0; i < scope.processedData.length; i++) {\n          if (xVal < scope.processedData[i].x1) {\n            processedDataIdx = i;\n            break;\n          }\n        }\n\n        var contents = void 0;\n        var bar = scope.processedData[processedDataIdx];\n        var minValFormatted = scope.card.fieldFormat.convert(bar.dataMin, 'text');\n        if (bar.dataMax > bar.dataMin) {\n          var maxValFormatted = scope.card.fieldFormat.convert(bar.dataMax, 'text');\n          contents = i18n('xpack.ml.fieldDataCard.metricDistributionChart.documentsBarPercentBetweenValuesDescription', {\n            defaultMessage: '{barPercent}% of documents have{br}values between {minValFormatted} and {maxValFormatted}',\n            values: {\n              barPercent: bar.percent,\n              minValFormatted: minValFormatted,\n              maxValFormatted: maxValFormatted,\n              br: '<br />'\n            }\n          });\n        } else {\n          contents = i18n('xpack.ml.fieldDataCard.metricDistributionChart.documentsBarPercentValueDescription', {\n            defaultMessage: '{barPercent}% of documents have{br}a value of {minValFormatted}',\n            values: {\n              barPercent: bar.percent,\n              minValFormatted: minValFormatted,\n              br: '<br />'\n            }\n          });\n        }\n\n        contents = '<div class=\\'eui-textCenter\\'>' + contents + '</div>';\n\n        if (path.length && path[0].length) {\n          _chart_tooltip_service.mlChartTooltipService.show(contents, path[0][0], {\n            x: xPos + 5,\n            y: yPos + 10\n          });\n        }\n      }\n    }\n\n    init();\n    drawAxes();\n    drawDistributionArea();\n  }\n\n  return {\n    scope: false,\n    link: link\n  };\n});",null]}