{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/searchprofiler/public/directives/profile_tree/util.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/searchprofiler/public/directives/profile_tree/util.js","mtime":1567631712295},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * or more contributor license agreements. Licensed under the Elastic License;\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * you may not use this file except in compliance with the Elastic License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\nexports.timeInMilliseconds = timeInMilliseconds;\nexports.calcTimes = calcTimes;\nexports.normalizeBreakdown = normalizeBreakdown;\nexports.normalizeTimes = normalizeTimes;\nexports.normalizeIndices = normalizeIndices;\nexports.flattenResults = flattenResults;\nexports.closeNode = closeNode;\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nvar _tinycolor = require('tinycolor2');\n\nvar _tinycolor2 = _interopRequireDefault(_tinycolor);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar comparator = function comparator(v1, v2) {\n  if (v1 < v2) {\n    return 1;\n  }\n  return v1 > v2 ? -1 : 0;\n};\n\nfunction getToolTip(key) {\n  switch (key) {\n    case 'build_scorer':\n      return 'The time taken to create the Scoring object, which is later used to execute the actual scoring of each doc.';\n    case 'create_weight':\n      return 'The time taken to create the Weight object, which holds temporary information during scoring.';\n    case 'next_doc':\n      return 'The time taken to advance the iterator to the next matching document.';\n    case 'score':\n      return 'The time taken in actually scoring the document against the query.';\n    case 'match':\n      return 'The time taken to execute a secondary, more precise scoring phase (used by phrase queries).';\n    case 'advance':\n      return 'The time taken to advance the iterator to the next document.';\n    default:\n      return '';\n  }\n}\n\nfunction timeInMilliseconds(data) {\n  if (data.time_in_nanos) {\n    return data.time_in_nanos / 1000000;\n  }\n\n  if (typeof data.time === 'string') {\n    return data.time.replace('ms', '');\n  }\n\n  return data.time;\n}\n\nfunction calcTimes(data, parentId) {\n  if (data == null) {\n    return;\n  }\n\n  var totalTime = 0;\n  //First pass to collect total\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var child = _step.value;\n\n      totalTime += timeInMilliseconds(child);\n\n      child.id = _uuid2.default.v4();\n      child.parentId = parentId;\n      child.childrenIds = [];\n      child.breakdown = normalizeBreakdown(child.breakdown);\n\n      var childrenTime = 0;\n      if (child.children != null && child.children.length !== 0) {\n        childrenTime = calcTimes(child.children, child.id);\n        child.hasChildren = true;\n\n        // Save the IDs of our children, has to be called after calcTimes recursion above\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = child.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var c = _step2.value;\n\n            child.childrenIds.push(c.id);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n      child.selfTime = timeInMilliseconds(child) - childrenTime;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return totalTime;\n}\n\nfunction normalizeBreakdown(breakdown) {\n  var final = [];\n  var total = Object.keys(breakdown).reduce(function (partialTotal, currentKey) {\n    if (currentKey.indexOf('_count') === -1) {\n      partialTotal += breakdown[currentKey];\n    }\n    return partialTotal;\n  }, 0);\n  Object.keys(breakdown).sort().forEach(function (key) {\n    var relative = 0;\n    if (key.indexOf('_count') === -1) {\n      relative = (breakdown[key] / total * 100).toFixed(1);\n    }\n    final.push({\n      key: key,\n      time: breakdown[key],\n      relative: relative,\n      color: _tinycolor2.default.mix('#F5F5F5', '#FFAFAF', relative).toHexString(),\n      tip: getToolTip(key)\n    });\n  });\n\n  // Sort by time descending and then key ascending\n  return final.sort(function (a, b) {\n    if (comparator(a.time, b.time) !== 0) {\n      return comparator(a.time, b.time);\n    }\n\n    return -1 * comparator(a.key, b.key);\n  });\n}\n\nfunction normalizeTimes(data, totalTime, depth) {\n  //Second pass to normalize\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var child = _step3.value;\n\n      child.timePercentage = (timeInMilliseconds(child) / totalTime * 100).toFixed(2);\n      child.absoluteColor = _tinycolor2.default.mix('#F5F5F5', '#FFAFAF', child.timePercentage).toHexString();\n      child.depth = depth;\n\n      if (child.children != null && child.children.length !== 0) {\n        normalizeTimes(child.children, totalTime, depth + 1);\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  data.sort(function (a, b) {\n    return comparator(timeInMilliseconds(a), timeInMilliseconds(b));\n  });\n}\n\nfunction normalizeIndices(indices, visibility, target) {\n  // Sort the shards per-index\n  var sortQueryComponents = void 0;\n  if (target === 'searches') {\n    sortQueryComponents = function sortQueryComponents(a, b) {\n      var aTime = _lodash2.default.sum(a.searches, function (search) {\n        return search.flat[0].time;\n      });\n      var bTime = _lodash2.default.sum(b.searches, function (search) {\n        return search.flat[0].time;\n      });\n\n      return comparator(aTime, bTime);\n    };\n  } else if (target === 'aggregations') {\n    sortQueryComponents = function sortQueryComponents(a, b) {\n      var aTime = _lodash2.default.sum(a.aggregations, function (agg) {\n        return agg.flat[0].time;\n      });\n      var bTime = _lodash2.default.sum(b.aggregations, function (agg) {\n        return agg.flat[0].time;\n      });\n\n      return comparator(aTime, bTime);\n    };\n  }\n  var sortedIndices = [];\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = Object.entries(indices)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var _ref = _step4.value;\n\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      var key = _ref2[0];\n      var index = _ref2[1];\n\n      index.shards.sort(sortQueryComponents);\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = index.shards[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var shard = _step5.value;\n\n          shard.relative[target] = (shard.time[target] / index.time[target] * 100).toFixed(2);\n          shard.color[target] = _tinycolor2.default.mix('#F5F5F5', '#FFAFAF', shard.relative[target]).toHexString();\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      sortedIndices.push(index);\n      visibility[key] = false;\n    }\n\n    // And now sort the indices themselves\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  sortedIndices.sort(function (a, b) {\n    return comparator(a.time, b.time);\n  });\n  return sortedIndices;\n}\n\nfunction flattenResults(data, accumulator, depth, visibleMap) {\n  if (data == null) {\n    return;\n  }\n\n  var _iteratorNormalCompletion6 = true;\n  var _didIteratorError6 = false;\n  var _iteratorError6 = undefined;\n\n  try {\n    for (var _iterator6 = data[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n      var child = _step6.value;\n\n\n      // For bwc of older profile responses\n      if (!child.description) {\n        child.description = child.lucene;\n        child.lucene = null;\n\n        child.type = child.query_type;\n        child.query_type = null;\n      }\n      accumulator.push({\n        id: child.id,\n        parentId: child.parentId,\n        childrenIds: child.childrenIds,\n        lucene: child.description,\n        time: timeInMilliseconds(child),\n        selfTime: child.selfTime,\n        timePercentage: child.timePercentage,\n        query_type: child.type.split('.').pop(),\n        absoluteColor: child.absoluteColor,\n        depth: depth,\n        hasChildren: child.hasChildren,\n        breakdown: child.breakdown\n      });\n\n      visibleMap[child.id] = {\n        visible: child.timePercentage > 20,\n        children: child.children\n      };\n\n      if (child.children != null && child.children.length !== 0) {\n        flattenResults(child.children, accumulator, depth + 1, visibleMap);\n      }\n    }\n  } catch (err) {\n    _didIteratorError6 = true;\n    _iteratorError6 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion6 && _iterator6.return) {\n        _iterator6.return();\n      }\n    } finally {\n      if (_didIteratorError6) {\n        throw _iteratorError6;\n      }\n    }\n  }\n}\n\nfunction closeNode(visibleMap, id) {\n  visibleMap[id].visible = false;\n\n  if (visibleMap[id].children == null || visibleMap[id].children.length === 0) {\n    return;\n  }\n\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = visibleMap[id].children[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var child = _step7.value;\n\n      closeNode(visibleMap, child.id);\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n}",null]}