{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/lib/beats.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/lib/beats.ts","mtime":1567631711882},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport * as tslib_1 from \"tslib\";\nvar BeatsLib = /** @class */ (function () {\n    function BeatsLib(adapter, elasticsearch) {\n        var _this = this;\n        this.adapter = adapter;\n        this.elasticsearch = elasticsearch;\n        /** Get a single beat using the token it was enrolled in for lookup */\n        this.getBeatWithToken = function (enrollmentToken) { return tslib_1.__awaiter(_this, void 0, Promise, function () {\n            var beat;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.adapter.getBeatWithToken(enrollmentToken)];\n                    case 1:\n                        beat = _a.sent();\n                        return [2 /*return*/, beat];\n                }\n            });\n        }); };\n        /** Get an array of beats that have a given tag id assigned to it */\n        this.getBeatsWithTag = function (tagId) { return tslib_1.__awaiter(_this, void 0, Promise, function () {\n            var beats;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.adapter.getBeatsWithTag(tagId)];\n                    case 1:\n                        beats = _a.sent();\n                        return [2 /*return*/, beats];\n                }\n            });\n        }); };\n        // FIXME: This needs to be paginated https://github.com/elastic/kibana/issues/26022\n        /** Get an array of all enrolled beats. */\n        this.getAll = function (kuery) { return tslib_1.__awaiter(_this, void 0, Promise, function () {\n            var ESQuery, beats;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!kuery) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.elasticsearch.convertKueryToEsQuery(kuery)];\n                    case 1:\n                        ESQuery = _a.sent();\n                        _a.label = 2;\n                    case 2: return [4 /*yield*/, this.adapter.getAll(ESQuery)];\n                    case 3:\n                        beats = _a.sent();\n                        return [2 /*return*/, beats];\n                }\n            });\n        }); };\n        /** Update a given beat via it's ID */\n        this.update = function (id, beatData) { return tslib_1.__awaiter(_this, void 0, Promise, function () {\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.adapter.update(id, beatData)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        }); };\n        /** unassign tags from beats using an array of tags and beats */\n        this.removeTagsFromBeats = function (removals) { return tslib_1.__awaiter(_this, void 0, Promise, function () {\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.adapter.removeTagsFromBeats(removals)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        }); };\n        /** assign tags from beats using an array of tags and beats */\n        this.assignTagsToBeats = function (assignments) { return tslib_1.__awaiter(_this, void 0, Promise, function () {\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.adapter.assignTagsToBeats(assignments)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        }); };\n    }\n    /** Get a single beat using it's ID for lookup */\n    BeatsLib.prototype.get = function (id) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var beat;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.adapter.get(id)];\n                    case 1:\n                        beat = _a.sent();\n                        return [2 /*return*/, beat];\n                }\n            });\n        });\n    };\n    return BeatsLib;\n}());\nexport { BeatsLib };\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/lib/beats.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/lib/beats.ts"],"names":[],"mappings":"AAAA;;;;GAIG;;AAWH;IACE,kBACmB,OAAuB,EACvB,aAA+B;QAFlD,iBAGI;QAFe,YAAO,GAAP,OAAO,CAAgB;QACvB,kBAAa,GAAb,aAAa,CAAkB;QASlD,sEAAsE;QAC/D,qBAAgB,GAAG,UAAO,eAAuB,4CAAG,OAAO;;;;4BACnD,qBAAM,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,eAAe,CAAC,EAAA;;wBAA3D,IAAI,GAAG,SAAoD;wBACjE,sBAAO,IAAI,EAAC;;;aACb,CAAC;QAEF,oEAAoE;QAC7D,oBAAe,GAAG,UAAO,KAAa,4CAAG,OAAO;;;;4BACvC,qBAAM,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,KAAK,CAAC,EAAA;;wBAAjD,KAAK,GAAG,SAAyC;wBACvD,sBAAO,KAAK,EAAC;;;aACd,CAAC;QAEF,mFAAmF;QACnF,0CAA0C;QACnC,WAAM,GAAG,UAAO,KAAc,4CAAG,OAAO;;;;;6BAEzC,KAAK,EAAL,wBAAK;wBACG,qBAAM,IAAI,CAAC,aAAa,CAAC,qBAAqB,CAAC,KAAK,CAAC,EAAA;;wBAA/D,OAAO,GAAG,SAAqD,CAAC;;4BAEpD,qBAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,EAAA;;wBAA1C,KAAK,GAAG,SAAkC;wBAChD,sBAAO,KAAK,EAAC;;;aACd,CAAC;QAEF,sCAAsC;QAC/B,WAAM,GAAG,UAAO,EAAU,EAAE,QAAyB,4CAAG,OAAO;;;4BAC7D,qBAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,EAAE,QAAQ,CAAC,EAAA;4BAA9C,sBAAO,SAAuC,EAAC;;;aAChD,CAAC;QAEF,gEAAgE;QACzD,wBAAmB,GAAG,UAC3B,QAA8B,4CAC7B,OAAO;;;4BACD,qBAAM,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,QAAQ,CAAC,EAAA;4BAAvD,sBAAO,SAAgD,EAAC;;;aACzD,CAAC;QAEF,8DAA8D;QACvD,sBAAiB,GAAG,UACzB,WAAiC,4CAChC,OAAO;;;4BACD,qBAAM,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,WAAW,CAAC,EAAA;4BAAxD,sBAAO,SAAiD,EAAC;;;aAC1D,CAAC;IAhDC,CAAC;IAEJ,iDAAiD;IACpC,sBAAG,GAAhB,UAAiB,EAAU;+CAAG,OAAO;;;;4BACtB,qBAAM,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,EAAA;;wBAAjC,IAAI,GAAG,SAA0B;wBACvC,sBAAO,IAAI,EAAC;;;;KACb;IA2CH,eAAC;AAAD,CAAC,AArDD,IAqDC","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport { CMBeat } from './../../common/domain_types';\nimport {\n  BeatsRemovalReturn,\n  BeatsTagAssignment,\n  CMAssignmentReturn,\n  CMBeatsAdapter,\n} from './adapters/beats/adapter_types';\nimport { ElasticsearchLib } from './elasticsearch';\n\nexport class BeatsLib {\n  constructor(\n    private readonly adapter: CMBeatsAdapter,\n    private readonly elasticsearch: ElasticsearchLib\n  ) {}\n\n  /** Get a single beat using it's ID for lookup */\n  public async get(id: string): Promise<CMBeat | null> {\n    const beat = await this.adapter.get(id);\n    return beat;\n  }\n\n  /** Get a single beat using the token it was enrolled in for lookup */\n  public getBeatWithToken = async (enrollmentToken: string): Promise<CMBeat | null> => {\n    const beat = await this.adapter.getBeatWithToken(enrollmentToken);\n    return beat;\n  };\n\n  /** Get an array of beats that have a given tag id assigned to it */\n  public getBeatsWithTag = async (tagId: string): Promise<CMBeat[]> => {\n    const beats = await this.adapter.getBeatsWithTag(tagId);\n    return beats;\n  };\n\n  // FIXME: This needs to be paginated https://github.com/elastic/kibana/issues/26022\n  /** Get an array of all enrolled beats. */\n  public getAll = async (kuery?: string): Promise<CMBeat[]> => {\n    let ESQuery;\n    if (kuery) {\n      ESQuery = await this.elasticsearch.convertKueryToEsQuery(kuery);\n    }\n    const beats = await this.adapter.getAll(ESQuery);\n    return beats;\n  };\n\n  /** Update a given beat via it's ID */\n  public update = async (id: string, beatData: Partial<CMBeat>): Promise<boolean> => {\n    return await this.adapter.update(id, beatData);\n  };\n\n  /** unassign tags from beats using an array of tags and beats */\n  public removeTagsFromBeats = async (\n    removals: BeatsTagAssignment[]\n  ): Promise<BeatsRemovalReturn[]> => {\n    return await this.adapter.removeTagsFromBeats(removals);\n  };\n\n  /** assign tags from beats using an array of tags and beats */\n  public assignTagsToBeats = async (\n    assignments: BeatsTagAssignment[]\n  ): Promise<CMAssignmentReturn[]> => {\n    return await this.adapter.assignTagsToBeats(assignments);\n  };\n}\n"]}]}