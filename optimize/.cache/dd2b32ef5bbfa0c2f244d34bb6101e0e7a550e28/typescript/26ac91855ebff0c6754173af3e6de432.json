{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/containers/tags.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/containers/tags.ts","mtime":1567631711881},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { Container } from 'unstated';\nvar TagsContainer = /** @class */ (function (_super) {\n    tslib_1.__extends(TagsContainer, _super);\n    function TagsContainer(libs) {\n        var _this = _super.call(this) || this;\n        _this.libs = libs;\n        _this.reload = function (kuery) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            var tags;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (kuery) {\n                            this.query = kuery;\n                        }\n                        else {\n                            this.query = undefined;\n                        }\n                        return [4 /*yield*/, this.libs.tags.getAll(this.query)];\n                    case 1:\n                        tags = _a.sent();\n                        this.setState({\n                            list: tags,\n                        });\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        _this.delete = function (tags) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            var tagIds, success;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        tagIds = tags.map(function (tag) { return tag.id; });\n                        return [4 /*yield*/, this.libs.tags.delete(tagIds)];\n                    case 1:\n                        success = _a.sent();\n                        if (success) {\n                            this.setState({\n                                list: this.state.list.filter(function (tag) { return tagIds.includes(tag.id); }),\n                            });\n                        }\n                        return [2 /*return*/, success];\n                }\n            });\n        }); };\n        _this.upsertTag = function (tag) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            var beatTag;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.libs.tags.upsertTag(tag)];\n                    case 1:\n                        beatTag = _a.sent();\n                        return [4 /*yield*/, this.reload()];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/, beatTag !== null];\n                }\n            });\n        }); };\n        _this.state = {\n            list: [],\n        };\n        return _this;\n    }\n    return TagsContainer;\n}(Container));\nexport { TagsContainer };\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/containers/tags.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/containers/tags.ts"],"names":[],"mappings":"AAAA;;;;GAIG;;AAEH,OAAO,EAAE,SAAS,EAAE,MAAM,UAAU,CAAC;AAQrC;IAAmC,yCAAyB;IAE1D,uBAA6B,IAAkB;QAA/C,YACE,iBAAO,SAIR;QAL4B,UAAI,GAAJ,IAAI,CAAc;QAMxC,YAAM,GAAG,UAAO,KAAc;;;;;wBACnC,IAAI,KAAK,EAAE;4BACT,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;yBACpB;6BAAM;4BACL,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;yBACxB;wBAEY,qBAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAA;;wBAA9C,IAAI,GAAG,SAAuC;wBAEpD,IAAI,CAAC,QAAQ,CAAC;4BACZ,IAAI,EAAE,IAAI;yBACX,CAAC,CAAC;;;;aACJ,CAAC;QAEK,YAAM,GAAG,UAAO,IAAe;;;;;wBAC9B,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,UAAC,GAAY,IAAK,OAAA,GAAG,CAAC,EAAE,EAAN,CAAM,CAAC,CAAC;wBAClC,qBAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,EAAA;;wBAA7C,OAAO,GAAG,SAAmC;wBACnD,IAAI,OAAO,EAAE;4BACX,IAAI,CAAC,QAAQ,CAAC;gCACZ,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,UAAA,GAAG,IAAI,OAAA,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC,EAAvB,CAAuB,CAAC;6BAC7D,CAAC,CAAC;yBACJ;wBACD,sBAAO,OAAO,EAAC;;;aAChB,CAAC;QAEK,eAAS,GAAG,UAAO,GAAY;;;;4BACpB,qBAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAA;;wBAA7C,OAAO,GAAG,SAAmC;wBACnD,qBAAM,IAAI,CAAC,MAAM,EAAE,EAAA;;wBAAnB,SAAmB,CAAC;wBACpB,sBAAO,OAAO,KAAK,IAAI,EAAC;;;aACzB,CAAC;QAjCA,KAAI,CAAC,KAAK,GAAG;YACX,IAAI,EAAE,EAAE;SACT,CAAC;;IACJ,CAAC;IA+BH,oBAAC;AAAD,CAAC,AAtCD,CAAmC,SAAS,GAsC3C","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport { Container } from 'unstated';\nimport { BeatTag } from '../../common/domain_types';\nimport { FrontendLibs } from '../lib/types';\n\ninterface ContainerState {\n  list: BeatTag[];\n}\n\nexport class TagsContainer extends Container<ContainerState> {\n  private query?: string;\n  constructor(private readonly libs: FrontendLibs) {\n    super();\n    this.state = {\n      list: [],\n    };\n  }\n  public reload = async (kuery?: string) => {\n    if (kuery) {\n      this.query = kuery;\n    } else {\n      this.query = undefined;\n    }\n\n    const tags = await this.libs.tags.getAll(this.query);\n\n    this.setState({\n      list: tags,\n    });\n  };\n\n  public delete = async (tags: BeatTag[]) => {\n    const tagIds = tags.map((tag: BeatTag) => tag.id);\n    const success = await this.libs.tags.delete(tagIds);\n    if (success) {\n      this.setState({\n        list: this.state.list.filter(tag => tagIds.includes(tag.id)),\n      });\n    }\n    return success;\n  };\n\n  public upsertTag = async (tag: BeatTag) => {\n    const beatTag = await this.libs.tags.upsertTag(tag);\n    await this.reload();\n    return beatTag !== null;\n  };\n}\n"]}]}