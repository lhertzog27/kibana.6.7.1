{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/apply_wafflemap_layout.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/apply_wafflemap_layout.ts","mtime":1567631711982},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["import * as tslib_1 from \"tslib\";\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport { first, sortBy } from 'lodash';\nimport { isWaffleMapGroupWithGroups, isWaffleMapGroupWithNodes, } from '../../../containers/waffle/type_guards';\nimport { sizeOfSquares } from './size_of_squares';\nexport function getColumns(n, w, h) {\n    if (w === void 0) { w = 1; }\n    if (h === void 0) { h = 1; }\n    var pageRatio = w / h;\n    var ratio = pageRatio > 1.2 ? 1.2 : pageRatio;\n    var width = Math.ceil(Math.sqrt(n));\n    return Math.ceil(width * ratio);\n}\nexport function getTotalItems(groups) {\n    if (!groups) {\n        return 0;\n    }\n    return groups.reduce(function (acc, group) {\n        if (isWaffleMapGroupWithGroups(group)) {\n            return group.groups.reduce(function (total, subGroup) { return subGroup.nodes.length + total; }, acc);\n        }\n        if (isWaffleMapGroupWithNodes(group)) {\n            return group.nodes.length + acc;\n        }\n        return acc;\n    }, 0);\n}\nexport function getLargestCount(groups) {\n    if (!groups) {\n        return 0;\n    }\n    return groups.reduce(function (total, group) {\n        if (isWaffleMapGroupWithGroups(group)) {\n            return group.groups.reduce(function (subTotal, subGroup) {\n                if (isWaffleMapGroupWithNodes(subGroup)) {\n                    return subTotal > subGroup.nodes.length ? subTotal : subGroup.nodes.length;\n                }\n                return subTotal;\n            }, total);\n        }\n        if (isWaffleMapGroupWithNodes(group)) {\n            return total > group.nodes.length ? total : group.nodes.length;\n        }\n        return total;\n    }, 0);\n}\nvar getTotalItemsOfGroup = function (group) { return getTotalItems([group]); };\nexport function applyWaffleMapLayout(groups, width, height) {\n    if (groups.length === 0) {\n        return [];\n    }\n    var levels = isWaffleMapGroupWithGroups(first(groups)) ? 2 : 1;\n    var totalItems = getTotalItems(groups);\n    var squareSize = Math.round(sizeOfSquares(width, height, totalItems, levels));\n    var largestCount = getLargestCount(groups);\n    return sortBy(groups, getTotalItemsOfGroup)\n        .reverse()\n        .map(function (group) {\n        if (isWaffleMapGroupWithGroups(group)) {\n            var columns_1 = getColumns(largestCount, width, height);\n            var groupOfNodes = group.groups;\n            var subGroups = sortBy(groupOfNodes, getTotalItemsOfGroup)\n                .reverse()\n                .filter(isWaffleMapGroupWithNodes)\n                .map(function (subGroup) {\n                return tslib_1.__assign({}, subGroup, { count: subGroup.nodes.length, columns: columns_1, width: columns_1 * squareSize, squareSize: squareSize });\n            });\n            return tslib_1.__assign({}, group, { groups: subGroups, count: getTotalItems([group]), squareSize: squareSize });\n        }\n        if (isWaffleMapGroupWithNodes(group)) {\n            var columns = getColumns(Math.max(group.nodes.length, largestCount), width, height);\n            return tslib_1.__assign({}, group, { count: group.nodes.length, squareSize: squareSize, width: columns * squareSize });\n        }\n        return group;\n    });\n}\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/apply_wafflemap_layout.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/apply_wafflemap_layout.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport { first, sortBy } from 'lodash';\nimport {\n  isWaffleMapGroupWithGroups,\n  isWaffleMapGroupWithNodes,\n} from '../../../containers/waffle/type_guards';\nimport { InfraWaffleMapGroup } from '../../../lib/lib';\nimport { sizeOfSquares } from './size_of_squares';\n\nexport function getColumns(n: number, w = 1, h = 1) {\n  const pageRatio = w / h;\n  const ratio = pageRatio > 1.2 ? 1.2 : pageRatio;\n  const width = Math.ceil(Math.sqrt(n));\n  return Math.ceil(width * ratio);\n}\n\nexport function getTotalItems(groups: InfraWaffleMapGroup[]) {\n  if (!groups) {\n    return 0;\n  }\n  return groups.reduce((acc, group) => {\n    if (isWaffleMapGroupWithGroups(group)) {\n      return group.groups.reduce((total, subGroup) => subGroup.nodes.length + total, acc);\n    }\n    if (isWaffleMapGroupWithNodes(group)) {\n      return group.nodes.length + acc;\n    }\n    return acc;\n  }, 0);\n}\n\nexport function getLargestCount(groups: InfraWaffleMapGroup[]) {\n  if (!groups) {\n    return 0;\n  }\n  return groups.reduce((total, group) => {\n    if (isWaffleMapGroupWithGroups(group)) {\n      return group.groups.reduce((subTotal, subGroup) => {\n        if (isWaffleMapGroupWithNodes(subGroup)) {\n          return subTotal > subGroup.nodes.length ? subTotal : subGroup.nodes.length;\n        }\n        return subTotal;\n      }, total);\n    }\n    if (isWaffleMapGroupWithNodes(group)) {\n      return total > group.nodes.length ? total : group.nodes.length;\n    }\n    return total;\n  }, 0);\n}\n\nconst getTotalItemsOfGroup = (group: InfraWaffleMapGroup): number => getTotalItems([group]);\n\nexport function applyWaffleMapLayout(\n  groups: InfraWaffleMapGroup[],\n  width: number,\n  height: number\n): InfraWaffleMapGroup[] {\n  if (groups.length === 0) {\n    return [];\n  }\n  const levels = isWaffleMapGroupWithGroups(first(groups)) ? 2 : 1;\n  const totalItems = getTotalItems(groups);\n  const squareSize = Math.round(sizeOfSquares(width, height, totalItems, levels));\n  const largestCount = getLargestCount(groups);\n  return sortBy(groups, getTotalItemsOfGroup)\n    .reverse()\n    .map(group => {\n      if (isWaffleMapGroupWithGroups(group)) {\n        const columns = getColumns(largestCount, width, height);\n        const groupOfNodes = group.groups;\n        const subGroups = sortBy(groupOfNodes, getTotalItemsOfGroup)\n          .reverse()\n          .filter(isWaffleMapGroupWithNodes)\n          .map(subGroup => {\n            return {\n              ...subGroup,\n              count: subGroup.nodes.length,\n              columns,\n              width: columns * squareSize,\n              squareSize,\n            };\n          });\n        return {\n          ...group,\n          groups: subGroups,\n          count: getTotalItems([group]),\n          squareSize,\n        };\n      }\n      if (isWaffleMapGroupWithNodes(group)) {\n        const columns = getColumns(Math.max(group.nodes.length, largestCount), width, height);\n        return {\n          ...group,\n          count: group.nodes.length,\n          squareSize,\n          width: columns * squareSize,\n        };\n      }\n      return group;\n    });\n}\n"]}]}