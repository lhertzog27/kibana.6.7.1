{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/color_from_value.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/color_from_value.ts","mtime":1567631711982},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nvar _a;\nimport { eq, first, gt, gte, last, lt, lte, sortBy } from 'lodash';\nimport { mix, parseToRgb, toColorString } from 'polished';\nimport { InfraWaffleMapRuleOperator, } from '../../../lib/lib';\nimport { isInfraWaffleMapGradientLegend, isInfraWaffleMapStepLegend } from './type_guards';\nvar OPERATOR_TO_FN = (_a = {},\n    _a[InfraWaffleMapRuleOperator.eq] = eq,\n    _a[InfraWaffleMapRuleOperator.lt] = lt,\n    _a[InfraWaffleMapRuleOperator.lte] = lte,\n    _a[InfraWaffleMapRuleOperator.gte] = gte,\n    _a[InfraWaffleMapRuleOperator.gt] = gt,\n    _a);\nvar convertToRgbString = function (color) {\n    return toColorString(parseToRgb(color));\n};\nexport var colorFromValue = function (legend, value, bounds, defaultColor) {\n    if (defaultColor === void 0) { defaultColor = 'rgba(217, 217, 217, 1)'; }\n    try {\n        if (isInfraWaffleMapStepLegend(legend)) {\n            return convertToRgbString(calculateStepColor(legend, value, defaultColor));\n        }\n        if (isInfraWaffleMapGradientLegend(legend)) {\n            return convertToRgbString(calculateGradientColor(legend, value, bounds, defaultColor));\n        }\n        return defaultColor;\n    }\n    catch (error) {\n        return defaultColor;\n    }\n};\nvar normalizeValue = function (min, max, value) {\n    return (value - min) / (max - min);\n};\nexport var calculateStepColor = function (legend, value, defaultColor) {\n    if (defaultColor === void 0) { defaultColor = 'rgba(217, 217, 217, 1)'; }\n    return sortBy(legend.rules, 'sortBy').reduce(function (color, rule) {\n        var operatorFn = OPERATOR_TO_FN[rule.operator];\n        if (operatorFn(value, rule.value)) {\n            return rule.color;\n        }\n        return color;\n    }, defaultColor);\n};\nexport var calculateGradientColor = function (legend, value, bounds, defaultColor) {\n    if (defaultColor === void 0) { defaultColor = 'rgba(0, 179, 164, 1)'; }\n    if (legend.rules.length === 0) {\n        return defaultColor;\n    }\n    if (legend.rules.length === 1) {\n        return last(legend.rules).color;\n    }\n    var min = bounds.min, max = bounds.max;\n    var sortedRules = sortBy(legend.rules, 'value');\n    var normValue = normalizeValue(min, max, Number(value));\n    var startRule = sortedRules.reduce(function (acc, rule) {\n        if (rule.value <= normValue) {\n            return rule;\n        }\n        return acc;\n    }, first(sortedRules));\n    var endRule = sortedRules.filter(function (r) { return r !== startRule; }).find(function (r) { return r.value >= normValue; });\n    if (!endRule) {\n        return startRule.color;\n    }\n    var mixValue = normalizeValue(startRule.value, endRule.value, normValue);\n    return mix(mixValue, endRule.color, startRule.color);\n};\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/color_from_value.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/color_from_value.ts"],"names":[],"mappings":"AAAA;;;;GAIG;;AAEH,OAAO,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AACnE,OAAO,EAAE,GAAG,EAAE,UAAU,EAAE,aAAa,EAAE,MAAM,UAAU,CAAC;AAC1D,OAAO,EAIL,0BAA0B,GAE3B,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EAAE,8BAA8B,EAAE,0BAA0B,EAAE,MAAM,eAAe,CAAC;AAE3F,IAAM,cAAc;IAClB,GAAC,0BAA0B,CAAC,EAAE,IAAG,EAAE;IACnC,GAAC,0BAA0B,CAAC,EAAE,IAAG,EAAE;IACnC,GAAC,0BAA0B,CAAC,GAAG,IAAG,GAAG;IACrC,GAAC,0BAA0B,CAAC,GAAG,IAAG,GAAG;IACrC,GAAC,0BAA0B,CAAC,EAAE,IAAG,EAAE;OACpC,CAAC;AAEF,IAAM,kBAAkB,GAAG,UAAC,KAAa;IACvC,OAAO,aAAa,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;AAC1C,CAAC,CAAC;AAEF,MAAM,CAAC,IAAM,cAAc,GAAG,UAC5B,MAA4B,EAC5B,KAAsB,EACtB,MAA4B,EAC5B,YAAuC;IAAvC,6BAAA,EAAA,uCAAuC;IAEvC,IAAI;QACF,IAAI,0BAA0B,CAAC,MAAM,CAAC,EAAE;YACtC,OAAO,kBAAkB,CAAC,kBAAkB,CAAC,MAAM,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC,CAAC;SAC5E;QACD,IAAI,8BAA8B,CAAC,MAAM,CAAC,EAAE;YAC1C,OAAO,kBAAkB,CAAC,sBAAsB,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,YAAY,CAAC,CAAC,CAAC;SACxF;QACD,OAAO,YAAY,CAAC;KACrB;IAAC,OAAO,KAAK,EAAE;QACd,OAAO,YAAY,CAAC;KACrB;AACH,CAAC,CAAC;AAEF,IAAM,cAAc,GAAG,UAAC,GAAW,EAAE,GAAW,EAAE,KAAa;IAC7D,OAAO,CAAC,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;AACrC,CAAC,CAAC;AAEF,MAAM,CAAC,IAAM,kBAAkB,GAAG,UAChC,MAAgC,EAChC,KAAsB,EACtB,YAAuC;IAAvC,6BAAA,EAAA,uCAAuC;IAEvC,OAAO,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,MAAM,CAAC,UAAC,KAAa,EAAE,IAAI;QAC/D,IAAM,UAAU,GAAG,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACjD,IAAI,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE;YACjC,OAAO,IAAI,CAAC,KAAK,CAAC;SACnB;QACD,OAAO,KAAK,CAAC;IACf,CAAC,EAAE,YAAY,CAAC,CAAC;AACnB,CAAC,CAAC;AAEF,MAAM,CAAC,IAAM,sBAAsB,GAAG,UACpC,MAAoC,EACpC,KAAsB,EACtB,MAA4B,EAC5B,YAAqC;IAArC,6BAAA,EAAA,qCAAqC;IAErC,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO,YAAY,CAAC;KACrB;IACD,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC;KACjC;IACO,IAAA,gBAAG,EAAE,gBAAG,CAAY;IAC5B,IAAM,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IAClD,IAAM,SAAS,GAAG,cAAc,CAAC,GAAG,EAAE,GAAG,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;IAC1D,IAAM,SAAS,GAAG,WAAW,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,IAAI;QAC7C,IAAI,IAAI,CAAC,KAAK,IAAI,SAAS,EAAE;YAC3B,OAAO,IAAI,CAAC;SACb;QACD,OAAO,GAAG,CAAC;IACb,CAAC,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC;IACvB,IAAM,OAAO,GAAG,WAAW,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,KAAK,SAAS,EAAf,CAAe,CAAC,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,KAAK,IAAI,SAAS,EAApB,CAAoB,CAAC,CAAC;IACzF,IAAI,CAAC,OAAO,EAAE;QACZ,OAAO,SAAS,CAAC,KAAK,CAAC;KACxB;IAED,IAAM,QAAQ,GAAG,cAAc,CAAC,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;IAE3E,OAAO,GAAG,CAAC,QAAQ,EAAE,OAAO,CAAC,KAAK,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;AACvD,CAAC,CAAC","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport { eq, first, gt, gte, last, lt, lte, sortBy } from 'lodash';\nimport { mix, parseToRgb, toColorString } from 'polished';\nimport {\n  InfraWaffleMapBounds,\n  InfraWaffleMapGradientLegend,\n  InfraWaffleMapLegend,\n  InfraWaffleMapRuleOperator,\n  InfraWaffleMapStepLegend,\n} from '../../../lib/lib';\nimport { isInfraWaffleMapGradientLegend, isInfraWaffleMapStepLegend } from './type_guards';\n\nconst OPERATOR_TO_FN = {\n  [InfraWaffleMapRuleOperator.eq]: eq,\n  [InfraWaffleMapRuleOperator.lt]: lt,\n  [InfraWaffleMapRuleOperator.lte]: lte,\n  [InfraWaffleMapRuleOperator.gte]: gte,\n  [InfraWaffleMapRuleOperator.gt]: gt,\n};\n\nconst convertToRgbString = (color: string) => {\n  return toColorString(parseToRgb(color));\n};\n\nexport const colorFromValue = (\n  legend: InfraWaffleMapLegend,\n  value: number | string,\n  bounds: InfraWaffleMapBounds,\n  defaultColor = 'rgba(217, 217, 217, 1)'\n): string => {\n  try {\n    if (isInfraWaffleMapStepLegend(legend)) {\n      return convertToRgbString(calculateStepColor(legend, value, defaultColor));\n    }\n    if (isInfraWaffleMapGradientLegend(legend)) {\n      return convertToRgbString(calculateGradientColor(legend, value, bounds, defaultColor));\n    }\n    return defaultColor;\n  } catch (error) {\n    return defaultColor;\n  }\n};\n\nconst normalizeValue = (min: number, max: number, value: number): number => {\n  return (value - min) / (max - min);\n};\n\nexport const calculateStepColor = (\n  legend: InfraWaffleMapStepLegend,\n  value: number | string,\n  defaultColor = 'rgba(217, 217, 217, 1)'\n): string => {\n  return sortBy(legend.rules, 'sortBy').reduce((color: string, rule) => {\n    const operatorFn = OPERATOR_TO_FN[rule.operator];\n    if (operatorFn(value, rule.value)) {\n      return rule.color;\n    }\n    return color;\n  }, defaultColor);\n};\n\nexport const calculateGradientColor = (\n  legend: InfraWaffleMapGradientLegend,\n  value: number | string,\n  bounds: InfraWaffleMapBounds,\n  defaultColor = 'rgba(0, 179, 164, 1)'\n): string => {\n  if (legend.rules.length === 0) {\n    return defaultColor;\n  }\n  if (legend.rules.length === 1) {\n    return last(legend.rules).color;\n  }\n  const { min, max } = bounds;\n  const sortedRules = sortBy(legend.rules, 'value');\n  const normValue = normalizeValue(min, max, Number(value));\n  const startRule = sortedRules.reduce((acc, rule) => {\n    if (rule.value <= normValue) {\n      return rule;\n    }\n    return acc;\n  }, first(sortedRules));\n  const endRule = sortedRules.filter(r => r !== startRule).find(r => r.value >= normValue);\n  if (!endRule) {\n    return startRule.color;\n  }\n\n  const mixValue = normalizeValue(startRule.value, endRule.value, normValue);\n\n  return mix(mixValue, endRule.color, startRule.color);\n};\n"]}]}