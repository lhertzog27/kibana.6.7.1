{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/waffle/nodes_to_wafflemap.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/waffle/nodes_to_wafflemap.ts","mtime":1567631711984},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport { i18n } from '@kbn/i18n';\nimport { first, last } from 'lodash';\nimport { isWaffleMapGroupWithGroups, isWaffleMapGroupWithNodes } from './type_guards';\nexport function createId(path) {\n    return path.map(function (p) { return p.value; }).join('/');\n}\nfunction findOrCreateGroupWithNodes(groups, path) {\n    var id = path.length === 0 ? '__all__' : createId(path);\n    /**\n     * If the group is going to be a top level group then we can just\n     * look for the full id. Otherwise we need to find the parent group and\n     * then look for the group in it's sub groups.\n     */\n    if (path.length === 2) {\n        var parentId_1 = first(path).value;\n        var existingParentGroup = groups.find(function (g) { return g.id === parentId_1; });\n        if (isWaffleMapGroupWithGroups(existingParentGroup)) {\n            var existingSubGroup = existingParentGroup.groups.find(function (g) { return g.id === id; });\n            if (isWaffleMapGroupWithNodes(existingSubGroup)) {\n                return existingSubGroup;\n            }\n        }\n    }\n    var lastPath = last(path);\n    var existingGroup = groups.find(function (g) { return g.id === id; });\n    if (isWaffleMapGroupWithNodes(existingGroup)) {\n        return existingGroup;\n    }\n    return {\n        id: id,\n        name: id === '__all__'\n            ? i18n.translate('xpack.infra.nodesToWaffleMap.groupsWithNodes.allName', {\n                defaultMessage: 'All',\n            })\n            : (lastPath && lastPath.label) || 'Unknown Group',\n        count: 0,\n        width: 0,\n        squareSize: 0,\n        nodes: [],\n    };\n}\nfunction findOrCreateGroupWithGroups(groups, path) {\n    var id = path.length === 0 ? '__all__' : createId(path);\n    var lastPath = last(path);\n    var existingGroup = groups.find(function (g) { return g.id === id; });\n    if (isWaffleMapGroupWithGroups(existingGroup)) {\n        return existingGroup;\n    }\n    return {\n        id: id,\n        name: id === '__all__'\n            ? i18n.translate('xpack.infra.nodesToWaffleMap.groupsWithGroups.allName', {\n                defaultMessage: 'All',\n            })\n            : (lastPath && lastPath.label) || 'Unknown Group',\n        count: 0,\n        width: 0,\n        squareSize: 0,\n        groups: [],\n    };\n}\nexport function createWaffleMapNode(node) {\n    var nodePathItem = last(node.path);\n    if (!nodePathItem) {\n        throw new Error('There must be at least one node path item');\n    }\n    return {\n        pathId: node.path.map(function (p) { return p.value; }).join('/'),\n        path: node.path,\n        id: nodePathItem.value,\n        name: nodePathItem.label || nodePathItem.value,\n        metric: node.metric,\n    };\n}\nfunction withoutGroup(group) {\n    return function (subject) {\n        return subject.id !== group.id;\n    };\n}\nexport function nodesToWaffleMap(nodes) {\n    return nodes.reduce(function (groups, node) {\n        var waffleNode = createWaffleMapNode(node);\n        if (node.path.length === 2) {\n            var parentGroup = findOrCreateGroupWithNodes(groups, node.path.slice(0, node.path.length - 1));\n            parentGroup.nodes.push(waffleNode);\n            return groups.filter(withoutGroup(parentGroup)).concat([parentGroup]);\n        }\n        if (node.path.length === 3) {\n            var parentGroup = findOrCreateGroupWithNodes(groups, node.path.slice(0, node.path.length - 1));\n            parentGroup.nodes.push(waffleNode);\n            var topGroup = findOrCreateGroupWithGroups(groups, node.path.slice(0, node.path.length - 2));\n            topGroup.groups = topGroup.groups.filter(withoutGroup(parentGroup)).concat([parentGroup]);\n            return groups.filter(withoutGroup(topGroup)).concat([topGroup]);\n        }\n        var allGroup = findOrCreateGroupWithNodes(groups, []);\n        allGroup.nodes.push(waffleNode);\n        return groups.filter(withoutGroup(allGroup)).concat([allGroup]);\n    }, []);\n}\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/waffle/nodes_to_wafflemap.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/waffle/nodes_to_wafflemap.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport { i18n } from '@kbn/i18n';\nimport { first, last } from 'lodash';\n\nimport { InfraNode, InfraNodePath } from '../../graphql/types';\nimport {\n  InfraWaffleMapGroup,\n  InfraWaffleMapGroupOfGroups,\n  InfraWaffleMapGroupOfNodes,\n  InfraWaffleMapNode,\n} from '../../lib/lib';\nimport { isWaffleMapGroupWithGroups, isWaffleMapGroupWithNodes } from './type_guards';\n\nexport function createId(path: InfraNodePath[]) {\n  return path.map(p => p.value).join('/');\n}\n\nfunction findOrCreateGroupWithNodes(\n  groups: InfraWaffleMapGroup[],\n  path: InfraNodePath[]\n): InfraWaffleMapGroupOfNodes {\n  const id = path.length === 0 ? '__all__' : createId(path);\n  /**\n   * If the group is going to be a top level group then we can just\n   * look for the full id. Otherwise we need to find the parent group and\n   * then look for the group in it's sub groups.\n   */\n  if (path.length === 2) {\n    const parentId = first(path).value;\n    const existingParentGroup = groups.find(g => g.id === parentId);\n    if (isWaffleMapGroupWithGroups(existingParentGroup)) {\n      const existingSubGroup = existingParentGroup.groups.find(g => g.id === id);\n      if (isWaffleMapGroupWithNodes(existingSubGroup)) {\n        return existingSubGroup;\n      }\n    }\n  }\n  const lastPath = last(path);\n  const existingGroup = groups.find(g => g.id === id);\n  if (isWaffleMapGroupWithNodes(existingGroup)) {\n    return existingGroup;\n  }\n  return {\n    id,\n    name:\n      id === '__all__'\n        ? i18n.translate('xpack.infra.nodesToWaffleMap.groupsWithNodes.allName', {\n            defaultMessage: 'All',\n          })\n        : (lastPath && lastPath.label) || 'Unknown Group',\n    count: 0,\n    width: 0,\n    squareSize: 0,\n    nodes: [],\n  };\n}\n\nfunction findOrCreateGroupWithGroups(\n  groups: InfraWaffleMapGroup[],\n  path: InfraNodePath[]\n): InfraWaffleMapGroupOfGroups {\n  const id = path.length === 0 ? '__all__' : createId(path);\n  const lastPath = last(path);\n  const existingGroup = groups.find(g => g.id === id);\n  if (isWaffleMapGroupWithGroups(existingGroup)) {\n    return existingGroup;\n  }\n  return {\n    id,\n    name:\n      id === '__all__'\n        ? i18n.translate('xpack.infra.nodesToWaffleMap.groupsWithGroups.allName', {\n            defaultMessage: 'All',\n          })\n        : (lastPath && lastPath.label) || 'Unknown Group',\n    count: 0,\n    width: 0,\n    squareSize: 0,\n    groups: [],\n  };\n}\n\nexport function createWaffleMapNode(node: InfraNode): InfraWaffleMapNode {\n  const nodePathItem = last(node.path);\n  if (!nodePathItem) {\n    throw new Error('There must be at least one node path item');\n  }\n  return {\n    pathId: node.path.map(p => p.value).join('/'),\n    path: node.path,\n    id: nodePathItem.value,\n    name: nodePathItem.label || nodePathItem.value,\n    metric: node.metric,\n  };\n}\n\nfunction withoutGroup(group: InfraWaffleMapGroup) {\n  return (subject: InfraWaffleMapGroup) => {\n    return subject.id !== group.id;\n  };\n}\n\nexport function nodesToWaffleMap(nodes: InfraNode[]): InfraWaffleMapGroup[] {\n  return nodes.reduce((groups: InfraWaffleMapGroup[], node: InfraNode) => {\n    const waffleNode = createWaffleMapNode(node);\n    if (node.path.length === 2) {\n      const parentGroup = findOrCreateGroupWithNodes(\n        groups,\n        node.path.slice(0, node.path.length - 1)\n      );\n      parentGroup.nodes.push(waffleNode);\n      return groups.filter(withoutGroup(parentGroup)).concat([parentGroup]);\n    }\n    if (node.path.length === 3) {\n      const parentGroup = findOrCreateGroupWithNodes(\n        groups,\n        node.path.slice(0, node.path.length - 1)\n      );\n      parentGroup.nodes.push(waffleNode);\n      const topGroup = findOrCreateGroupWithGroups(\n        groups,\n        node.path.slice(0, node.path.length - 2)\n      );\n      topGroup.groups = topGroup.groups.filter(withoutGroup(parentGroup)).concat([parentGroup]);\n      return groups.filter(withoutGroup(topGroup)).concat([topGroup]);\n    }\n    const allGroup = findOrCreateGroupWithNodes(groups, []);\n    allGroup.nodes.push(waffleNode);\n    return groups.filter(withoutGroup(allGroup)).concat([allGroup]);\n  }, []);\n}\n"]}]}