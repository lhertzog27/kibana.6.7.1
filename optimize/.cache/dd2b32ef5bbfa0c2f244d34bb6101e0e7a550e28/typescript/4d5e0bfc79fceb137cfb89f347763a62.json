{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/src/ui/public/utils/decode_geo_hash.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/utils/decode_geo_hash.ts","mtime":1567631711765},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport * as tslib_1 from \"tslib\";\nexport function decodeGeoHash(geohash) {\n    var e_1, _a;\n    var BITS = [16, 8, 4, 2, 1];\n    var BASE32 = '0123456789bcdefghjkmnpqrstuvwxyz';\n    var isEven = true;\n    var lat = [];\n    var lon = [];\n    lat[0] = -90.0;\n    lat[1] = 90.0;\n    lon[0] = -180.0;\n    lon[1] = 180.0;\n    var latErr = 90.0;\n    var lonErr = 180.0;\n    try {\n        for (var geohash_1 = tslib_1.__values(geohash), geohash_1_1 = geohash_1.next(); !geohash_1_1.done; geohash_1_1 = geohash_1.next()) {\n            var geohashEl = geohash_1_1.value;\n            var c = geohashEl.toString();\n            var cd = BASE32.indexOf(c);\n            for (var j = 0; j < 5; j++) {\n                var mask = BITS[j];\n                if (isEven) {\n                    lonErr = lonErr /= 2;\n                    refine_interval(lon, cd, mask);\n                }\n                else {\n                    latErr = latErr /= 2;\n                    refine_interval(lat, cd, mask);\n                }\n                isEven = !isEven;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (geohash_1_1 && !geohash_1_1.done && (_a = geohash_1.return)) _a.call(geohash_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    lat[2] = (lat[0] + lat[1]) / 2;\n    lon[2] = (lon[0] + lon[1]) / 2;\n    return {\n        latitude: lat,\n        longitude: lon,\n    };\n}\nfunction refine_interval(interval, cd, mask) {\n    if (cd & mask) { /* tslint:disable-line */\n        interval[0] = (interval[0] + interval[1]) / 2;\n    }\n    else {\n        interval[1] = (interval[0] + interval[1]) / 2;\n    }\n}\n/**\n * Get the number of geohash cells for a given precision\n *\n * @param {number} precision the geohash precision (1<=precision<=12).\n * @param {number} axis constant for the axis 0=lengthwise (ie. columns, along longitude), 1=heightwise (ie. rows, along latitude).\n * @returns {number} Number of geohash cells (rows or columns) at that precision\n */\nfunction geohashCells(precision, axis) {\n    var cells = 1;\n    for (var i = 1; i <= precision; i += 1) {\n        /*On odd precisions, rows divide by 4 and columns by 8. Vice-versa on even precisions */\n        cells *= i % 2 === axis ? 4 : 8;\n    }\n    return cells;\n}\n/**\n * Get the number of geohash columns (world-wide) for a given precision\n * @param precision the geohash precision\n * @returns {number} the number of columns\n */\nexport function geohashColumns(precision) {\n    return geohashCells(precision, 0);\n}\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/src/ui/public/utils/decode_geo_hash.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/src/ui/public/utils/decode_geo_hash.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\ninterface Coordinates {\n  latitude: number[];\n  longitude: number[];\n}\n\nexport function decodeGeoHash(geohash: number[]): Coordinates {\n  const BITS: number[] = [16, 8, 4, 2, 1];\n  const BASE32: string = '0123456789bcdefghjkmnpqrstuvwxyz';\n  let isEven: boolean = true;\n  const lat: number[] = [];\n  const lon: number[] = [];\n  lat[0] = -90.0;\n  lat[1] = 90.0;\n  lon[0] = -180.0;\n  lon[1] = 180.0;\n  let latErr: number = 90.0;\n  let lonErr: number = 180.0;\n  for (const geohashEl of geohash) {\n    const c: string = geohashEl.toString();\n    const cd: number = BASE32.indexOf(c);\n    for (let j = 0; j < 5; j++) {\n      const mask: number = BITS[j];\n      if (isEven) {\n        lonErr = lonErr /= 2;\n        refine_interval(lon, cd, mask);\n      } else {\n        latErr = latErr /= 2;\n        refine_interval(lat, cd, mask);\n      }\n      isEven = !isEven;\n    }\n  }\n  lat[2] = (lat[0] + lat[1]) / 2;\n  lon[2] = (lon[0] + lon[1]) / 2;\n  return {\n    latitude: lat,\n    longitude: lon,\n  } as Coordinates;\n}\n\nfunction refine_interval(interval: number[], cd: number, mask: number) {\n  if (cd & mask) { /* tslint:disable-line */\n    interval[0] = (interval[0] + interval[1]) / 2;\n  } else {\n    interval[1] = (interval[0] + interval[1]) / 2;\n  }\n}\n\n/**\n * Get the number of geohash cells for a given precision\n *\n * @param {number} precision the geohash precision (1<=precision<=12).\n * @param {number} axis constant for the axis 0=lengthwise (ie. columns, along longitude), 1=heightwise (ie. rows, along latitude).\n * @returns {number} Number of geohash cells (rows or columns) at that precision\n */\nfunction geohashCells(precision: number, axis: number) {\n  let cells = 1;\n  for (let i = 1; i <= precision; i += 1) {\n    /*On odd precisions, rows divide by 4 and columns by 8. Vice-versa on even precisions */\n    cells *= i % 2 === axis ? 4 : 8;\n  }\n  return cells;\n}\n\n/**\n * Get the number of geohash columns (world-wide) for a given precision\n * @param precision the geohash precision\n * @returns {number} the number of columns\n */\nexport function geohashColumns(precision: number): number {\n  return geohashCells(precision, 0);\n}\n"]}]}