{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/utils/typed_constate.tsx","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/utils/typed_constate.tsx","mtime":1567631711990},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nexport var inferActionMap = function () { return function (actionMap) { return actionMap; }; };\nexport var inferEffectMap = function () { return function (effectMap) { return effectMap; }; };\nexport var inferSelectorMap = function () { return function (selectorMap) { return selectorMap; }; };\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/utils/typed_constate.tsx","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/utils/typed_constate.tsx"],"names":[],"mappings":"AAAA;;;;GAIG;AA8CH,MAAM,CAAC,IAAM,cAAc,GAAG,cAAyB,OAAA,UAKrD,SAAkB,IACkB,OAAA,SAAgB,EAAhB,CAAgB,EANC,CAMD,CAAC;AAmBvD,MAAM,CAAC,IAAM,cAAc,GAAG,cAAyB,OAAA,UAKrD,SAAkB,IACkB,OAAA,SAAgB,EAAhB,CAAgB,EANC,CAMD,CAAC;AAmBvD,MAAM,CAAC,IAAM,gBAAgB,GAAG,cAAyB,OAAA,UAKvD,WAAsB,IACkB,OAAA,WAAkB,EAAlB,CAAkB,EANH,CAMG,CAAC","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\n/**\n * The helper types and functions below are designed to be used with constate\n * v0.9. From version 1.0 the use of react hooks probably makes them\n * unnecessary.\n *\n * The `inferActionMap`, `inferEffectMap` and `inferSelectorMap` functions\n * remove the necessity to type out the child-facing interfaces as suggested in\n * the constate typescript documentation by inferring the `ActionMap`,\n * `EffectMap` and `SelectorMap` types from the object passed as an argument.\n * At runtime these functions just return their first argument without\n * modification.\n *\n * Until partial type argument inference is (hopefully) introduced with\n * TypeScript 3.3, the functions are split into two nested functions to allow\n * for specifying the `State` type argument while leaving the other type\n * arguments for inference by the compiler.\n *\n * Example Usage:\n *\n * ```typescript\n * const actions = inferActionMap<State>()({\n *   increment: (amount: number) => state => ({ ...state, count: state.count + amount }),\n * });\n * // actions has type ActionMap<State, { increment: (amount: number) => void; }>\n * ```\n */\n\nimport { ActionMap, EffectMap, EffectProps, SelectorMap } from 'constate';\n\n/**\n * actions\n */\n\ntype InferredAction<State, Action> = Action extends (...args: infer A) => (state: State) => State\n  ? (...args: A) => void\n  : never;\n\ntype InferredActions<State, Actions> = ActionMap<\n  State,\n  { [K in keyof Actions]: InferredAction<State, Actions[K]> }\n>;\n\nexport type ActionsFromMap<M> = M extends ActionMap<any, infer A> ? A : never;\n\nexport const inferActionMap = <State extends any>() => <\n  Actions extends {\n    [key: string]: (...args: any[]) => (state: State) => State;\n  }\n>(\n  actionMap: Actions\n): InferredActions<State, Actions> => actionMap as any;\n\n/**\n * effects\n */\n\ntype InferredEffect<State, Effect> = Effect extends (\n  ...args: infer A\n) => (props: EffectProps<State>) => infer R\n  ? (...args: A) => R\n  : never;\n\ntype InferredEffects<State, Effects> = EffectMap<\n  State,\n  { [K in keyof Effects]: InferredEffect<State, Effects[K]> }\n>;\n\nexport type EffectsFromMap<M> = M extends EffectMap<any, infer E> ? E : never;\n\nexport const inferEffectMap = <State extends any>() => <\n  Effects extends {\n    [key: string]: (...args: any[]) => (props: EffectProps<State>) => any;\n  }\n>(\n  effectMap: Effects\n): InferredEffects<State, Effects> => effectMap as any;\n\n/**\n * selectors\n */\n\ntype InferredSelector<State, Selector> = Selector extends (\n  ...args: infer A\n) => (state: State) => infer R\n  ? (...args: A) => R\n  : never;\n\ntype InferredSelectors<State, Selectors> = SelectorMap<\n  State,\n  { [K in keyof Selectors]: InferredSelector<State, Selectors[K]> }\n>;\n\nexport type SelectorsFromMap<M> = M extends SelectorMap<any, infer S> ? S : never;\n\nexport const inferSelectorMap = <State extends any>() => <\n  Selectors extends {\n    [key: string]: (...args: any[]) => (state: State) => any;\n  }\n>(\n  selectorMap: Selectors\n): InferredSelectors<State, Selectors> => selectorMap as any;\n"]}]}