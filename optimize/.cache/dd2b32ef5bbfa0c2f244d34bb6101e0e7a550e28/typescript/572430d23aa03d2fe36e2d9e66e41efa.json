{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/components/timeseries_chart/timeseries_chart_annotations.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/components/timeseries_chart/timeseries_chart_annotations.ts","mtime":1567631712069},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport d3 from 'd3';\nimport moment from 'moment';\nimport { ANNOTATION_TYPE } from '../../../../common/constants/annotations';\n// @ts-ignore\nimport { mlChartTooltipService } from '../../../components/chart_tooltip/chart_tooltip_service';\nimport { annotation$ } from '../../../services/annotations_service';\nexport var ANNOTATION_MASK_ID = 'mlAnnotationMask';\n// getAnnotationBrush() is expected to be called like getAnnotationBrush.call(this)\n// so it gets passed on the context of the component it gets called from.\nexport function getAnnotationBrush() {\n    var focusXScale = this.focusXScale;\n    var annotateBrush = d3.svg\n        .brush()\n        .x(focusXScale)\n        .on('brushend', brushend.bind(this));\n    // cast a reference to this so we get the latest state when brushend() gets called\n    function brushend() {\n        var selectedJob = this.props.selectedJob;\n        // TS TODO make this work with the actual types.\n        var extent = annotateBrush.extent();\n        var timestamp = extent[0].getTime();\n        var endTimestamp = extent[1].getTime();\n        if (timestamp === endTimestamp) {\n            annotation$.next(null);\n            return;\n        }\n        var annotation = {\n            timestamp: timestamp,\n            end_timestamp: endTimestamp,\n            annotation: '',\n            job_id: selectedJob.job_id,\n            type: ANNOTATION_TYPE.ANNOTATION,\n        };\n        annotation$.next(annotation);\n    }\n    return annotateBrush;\n}\n// Used to resolve overlapping annotations in the UI.\n// The returned levels can be used to create a vertical offset.\nexport function getAnnotationLevels(focusAnnotationData) {\n    var levels = {};\n    focusAnnotationData.forEach(function (d, i) {\n        if (d.key !== undefined) {\n            var longerAnnotations = focusAnnotationData.filter(function (d2, i2) { return i2 < i; });\n            levels[d.key] = longerAnnotations.reduce(function (level, d2) {\n                // For now we only support overlap removal for annotations which have both\n                // `timestamp` and `end_timestamp` set.\n                if (d.end_timestamp === undefined ||\n                    d2.end_timestamp === undefined ||\n                    d2.key === undefined) {\n                    return level;\n                }\n                if (\n                // d2 is completely before d\n                (d2.timestamp < d.timestamp && d2.end_timestamp < d.timestamp) ||\n                    // d2 is completely after d\n                    (d2.timestamp > d.end_timestamp && d2.end_timestamp > d.end_timestamp)) {\n                    return level;\n                }\n                return levels[d2.key] + 1;\n            }, 0);\n        }\n    });\n    return levels;\n}\nvar ANNOTATION_DEFAULT_LEVEL = 1;\nvar ANNOTATION_LEVEL_HEIGHT = 28;\nvar ANNOTATION_UPPER_RECT_MARGIN = 0;\nvar ANNOTATION_UPPER_TEXT_MARGIN = -7;\nvar ANNOTATION_MIN_WIDTH = 2;\nvar ANNOTATION_RECT_BORDER_RADIUS = 2;\nvar ANNOTATION_TEXT_VERTICAL_OFFSET = 26;\nvar ANNOTATION_TEXT_RECT_VERTICAL_OFFSET = 12;\nvar ANNOTATION_TEXT_RECT_WIDTH = 24;\nvar ANNOTATION_TEXT_RECT_HEIGHT = 20;\nexport function renderAnnotations(focusChart, focusAnnotationData, focusZoomPanelHeight, focusChartHeight, focusXScale, showAnnotations, showFocusChartTooltip) {\n    var upperRectMargin = ANNOTATION_UPPER_RECT_MARGIN;\n    var upperTextMargin = ANNOTATION_UPPER_TEXT_MARGIN;\n    var durations = {};\n    focusAnnotationData.forEach(function (d) {\n        if (d.key !== undefined) {\n            var duration = (d.end_timestamp || 0) - d.timestamp;\n            durations[d.key] = duration;\n        }\n    });\n    // sort by duration\n    focusAnnotationData.sort(function (a, b) {\n        if (a.key === undefined || b.key === undefined) {\n            return 0;\n        }\n        return durations[b.key] - durations[a.key];\n    });\n    var levelHeight = ANNOTATION_LEVEL_HEIGHT;\n    var levels = getAnnotationLevels(focusAnnotationData);\n    var annotations = focusChart\n        .select('.mlAnnotations')\n        .selectAll('g.mlAnnotation')\n        .data(focusAnnotationData || [], function (d) { return d._id || ''; });\n    annotations\n        .enter()\n        .append('g')\n        .classed('mlAnnotation', true);\n    var rects = annotations.selectAll('.mlAnnotationRect').data(function (d) { return [d]; });\n    rects\n        .enter()\n        .append('rect')\n        .attr('rx', ANNOTATION_RECT_BORDER_RADIUS)\n        .attr('ry', ANNOTATION_RECT_BORDER_RADIUS)\n        .classed('mlAnnotationRect', true)\n        .attr('mask', \"url(#\" + ANNOTATION_MASK_ID + \")\")\n        .on('mouseover', function (d) {\n        showFocusChartTooltip(d, this);\n    })\n        .on('mouseout', function () { return mlChartTooltipService.hide(); })\n        .on('click', function (d) {\n        // clear a possible existing annotation set up for editing before setting the new one.\n        // this needs to be done explicitly here because a new annotation created using the brush tool\n        // could still be present in the chart.\n        annotation$.next(null);\n        // set the actual annotation and trigger the flyout\n        annotation$.next(d);\n    });\n    rects\n        .attr('x', function (d) {\n        var date = moment(d.timestamp);\n        return focusXScale(date);\n    })\n        .attr('y', function (d) {\n        var level = d.key !== undefined ? levels[d.key] : ANNOTATION_DEFAULT_LEVEL;\n        return focusZoomPanelHeight + 1 + upperRectMargin + level * levelHeight;\n    })\n        .attr('height', function (d) {\n        var level = d.key !== undefined ? levels[d.key] : ANNOTATION_DEFAULT_LEVEL;\n        return focusChartHeight - 2 - upperRectMargin - level * levelHeight;\n    })\n        .attr('width', function (d) {\n        var s = focusXScale(moment(d.timestamp)) + 1;\n        var e = typeof d.end_timestamp !== 'undefined'\n            ? focusXScale(moment(d.end_timestamp)) - 1\n            : s + ANNOTATION_MIN_WIDTH;\n        var width = Math.max(ANNOTATION_MIN_WIDTH, e - s);\n        return width;\n    });\n    rects.exit().remove();\n    var textRects = annotations.selectAll('.mlAnnotationTextRect').data(function (d) { return [d]; });\n    var texts = annotations.selectAll('.mlAnnotationText').data(function (d) { return [d]; });\n    textRects\n        .enter()\n        .append('rect')\n        .classed('mlAnnotationTextRect', true)\n        .attr('width', ANNOTATION_TEXT_RECT_WIDTH)\n        .attr('height', ANNOTATION_TEXT_RECT_HEIGHT)\n        .attr('rx', ANNOTATION_RECT_BORDER_RADIUS)\n        .attr('ry', ANNOTATION_RECT_BORDER_RADIUS);\n    texts\n        .enter()\n        .append('text')\n        .classed('mlAnnotationText', true);\n    function labelXOffset(ts) {\n        var earliestMs = focusXScale.domain()[0];\n        var latestMs = focusXScale.domain()[1];\n        var date = moment(ts);\n        var minX = Math.max(focusXScale(earliestMs), focusXScale(date));\n        // To avoid overflow to the right, substract maxOffset which is\n        // the width of the text label (24px) plus left margin (8xp).\n        var maxOffset = 32;\n        return Math.min(focusXScale(latestMs) - maxOffset, minX);\n    }\n    texts\n        .attr('x', function (d) {\n        var leftInnerOffset = 17;\n        return labelXOffset(d.timestamp) + leftInnerOffset;\n    })\n        .attr('y', function (d) {\n        var level = d.key !== undefined ? levels[d.key] : ANNOTATION_DEFAULT_LEVEL;\n        return (focusZoomPanelHeight +\n            upperTextMargin +\n            ANNOTATION_TEXT_VERTICAL_OFFSET +\n            level * levelHeight);\n    })\n        .text(function (d) { return d.key; });\n    textRects\n        .attr('x', function (d) {\n        var leftInnerOffset = 5;\n        return labelXOffset(d.timestamp) + leftInnerOffset;\n    })\n        .attr('y', function (d) {\n        var level = d.key !== undefined ? levels[d.key] : ANNOTATION_DEFAULT_LEVEL;\n        return (focusZoomPanelHeight +\n            upperTextMargin +\n            ANNOTATION_TEXT_RECT_VERTICAL_OFFSET +\n            level * levelHeight);\n    });\n    textRects.exit().remove();\n    texts.exit().remove();\n    annotations.classed('mlAnnotationHidden', !showAnnotations);\n    annotations.exit().remove();\n}\nexport function highlightFocusChartAnnotation(annotation) {\n    var annotations = d3.selectAll('.mlAnnotation');\n    annotations.each(function (d) {\n        // @ts-ignore\n        var element = d3.select(this);\n        if (d._id === annotation._id) {\n            element.selectAll('.mlAnnotationRect').classed('mlAnnotationRect-isHighlight', true);\n        }\n        else {\n            element.selectAll('.mlAnnotationTextRect').classed('mlAnnotationTextRect-isBlur', true);\n            element.selectAll('.mlAnnotationText').classed('mlAnnotationText-isBlur', true);\n            element.selectAll('.mlAnnotationRect').classed('mlAnnotationRect-isBlur', true);\n        }\n    });\n}\nexport function unhighlightFocusChartAnnotation() {\n    var annotations = d3.selectAll('.mlAnnotation');\n    annotations.each(function () {\n        // @ts-ignore\n        var element = d3.select(this);\n        element.selectAll('.mlAnnotationTextRect').classed('mlAnnotationTextRect-isBlur', false);\n        element\n            .selectAll('.mlAnnotationRect')\n            .classed('mlAnnotationRect-isHighlight', false)\n            .classed('mlAnnotationRect-isBlur', false);\n        element.selectAll('.mlAnnotationText').classed('mlAnnotationText-isBlur', false);\n    });\n}\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/components/timeseries_chart/timeseries_chart_annotations.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/ml/public/timeseriesexplorer/components/timeseries_chart/timeseries_chart_annotations.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport d3 from 'd3';\nimport moment from 'moment';\n\nimport { ANNOTATION_TYPE } from '../../../../common/constants/annotations';\nimport { Annotation, Annotations } from '../../../../common/types/annotations';\nimport { Dictionary } from '../../../../common/types/common';\n\n// @ts-ignore\nimport { mlChartTooltipService } from '../../../components/chart_tooltip/chart_tooltip_service';\n\nimport { TimeseriesChart } from './timeseries_chart';\n\nimport { annotation$ } from '../../../services/annotations_service';\n\nexport const ANNOTATION_MASK_ID = 'mlAnnotationMask';\n\n// getAnnotationBrush() is expected to be called like getAnnotationBrush.call(this)\n// so it gets passed on the context of the component it gets called from.\nexport function getAnnotationBrush(this: TimeseriesChart) {\n  const focusXScale = this.focusXScale;\n\n  const annotateBrush = d3.svg\n    .brush()\n    .x(focusXScale)\n    .on('brushend', brushend.bind(this));\n\n  // cast a reference to this so we get the latest state when brushend() gets called\n  function brushend(this: TimeseriesChart) {\n    const { selectedJob } = this.props;\n\n    // TS TODO make this work with the actual types.\n    const extent = annotateBrush.extent() as any;\n\n    const timestamp = extent[0].getTime();\n    const endTimestamp = extent[1].getTime();\n\n    if (timestamp === endTimestamp) {\n      annotation$.next(null);\n      return;\n    }\n\n    const annotation: Annotation = {\n      timestamp,\n      end_timestamp: endTimestamp,\n      annotation: '',\n      job_id: selectedJob.job_id,\n      type: ANNOTATION_TYPE.ANNOTATION,\n    };\n\n    annotation$.next(annotation);\n  }\n\n  return annotateBrush;\n}\n\n// Used to resolve overlapping annotations in the UI.\n// The returned levels can be used to create a vertical offset.\nexport function getAnnotationLevels(focusAnnotationData: Annotations) {\n  const levels: Dictionary<number> = {};\n  focusAnnotationData.forEach((d, i) => {\n    if (d.key !== undefined) {\n      const longerAnnotations = focusAnnotationData.filter((d2, i2) => i2 < i);\n      levels[d.key] = longerAnnotations.reduce((level, d2) => {\n        // For now we only support overlap removal for annotations which have both\n        // `timestamp` and `end_timestamp` set.\n        if (\n          d.end_timestamp === undefined ||\n          d2.end_timestamp === undefined ||\n          d2.key === undefined\n        ) {\n          return level;\n        }\n\n        if (\n          // d2 is completely before d\n          (d2.timestamp < d.timestamp && d2.end_timestamp < d.timestamp) ||\n          // d2 is completely after d\n          (d2.timestamp > d.end_timestamp && d2.end_timestamp > d.end_timestamp)\n        ) {\n          return level;\n        }\n        return levels[d2.key] + 1;\n      }, 0);\n    }\n  });\n  return levels;\n}\n\nconst ANNOTATION_DEFAULT_LEVEL = 1;\nconst ANNOTATION_LEVEL_HEIGHT = 28;\nconst ANNOTATION_UPPER_RECT_MARGIN = 0;\nconst ANNOTATION_UPPER_TEXT_MARGIN = -7;\nconst ANNOTATION_MIN_WIDTH = 2;\nconst ANNOTATION_RECT_BORDER_RADIUS = 2;\nconst ANNOTATION_TEXT_VERTICAL_OFFSET = 26;\nconst ANNOTATION_TEXT_RECT_VERTICAL_OFFSET = 12;\nconst ANNOTATION_TEXT_RECT_WIDTH = 24;\nconst ANNOTATION_TEXT_RECT_HEIGHT = 20;\n\nexport function renderAnnotations(\n  focusChart: d3.Selection<[]>,\n  focusAnnotationData: Annotations,\n  focusZoomPanelHeight: number,\n  focusChartHeight: number,\n  focusXScale: TimeseriesChart['focusXScale'],\n  showAnnotations: boolean,\n  showFocusChartTooltip: (d: Annotation, t: object) => {}\n) {\n  const upperRectMargin = ANNOTATION_UPPER_RECT_MARGIN;\n  const upperTextMargin = ANNOTATION_UPPER_TEXT_MARGIN;\n\n  const durations: Dictionary<number> = {};\n  focusAnnotationData.forEach(d => {\n    if (d.key !== undefined) {\n      const duration = (d.end_timestamp || 0) - d.timestamp;\n      durations[d.key] = duration;\n    }\n  });\n\n  // sort by duration\n  focusAnnotationData.sort((a, b) => {\n    if (a.key === undefined || b.key === undefined) {\n      return 0;\n    }\n    return durations[b.key] - durations[a.key];\n  });\n\n  const levelHeight = ANNOTATION_LEVEL_HEIGHT;\n  const levels = getAnnotationLevels(focusAnnotationData);\n\n  const annotations = focusChart\n    .select('.mlAnnotations')\n    .selectAll('g.mlAnnotation')\n    .data(focusAnnotationData || [], (d: Annotation) => d._id || '');\n\n  annotations\n    .enter()\n    .append('g')\n    .classed('mlAnnotation', true);\n\n  const rects = annotations.selectAll('.mlAnnotationRect').data((d: Annotation) => [d]);\n\n  rects\n    .enter()\n    .append('rect')\n    .attr('rx', ANNOTATION_RECT_BORDER_RADIUS)\n    .attr('ry', ANNOTATION_RECT_BORDER_RADIUS)\n    .classed('mlAnnotationRect', true)\n    .attr('mask', `url(#${ANNOTATION_MASK_ID})`)\n    .on('mouseover', function(this: object, d: Annotation) {\n      showFocusChartTooltip(d, this);\n    })\n    .on('mouseout', () => mlChartTooltipService.hide())\n    .on('click', (d: Annotation) => {\n      // clear a possible existing annotation set up for editing before setting the new one.\n      // this needs to be done explicitly here because a new annotation created using the brush tool\n      // could still be present in the chart.\n      annotation$.next(null);\n      // set the actual annotation and trigger the flyout\n      annotation$.next(d);\n    });\n\n  rects\n    .attr('x', (d: Annotation) => {\n      const date = moment(d.timestamp);\n      return focusXScale(date);\n    })\n    .attr('y', (d: Annotation) => {\n      const level = d.key !== undefined ? levels[d.key] : ANNOTATION_DEFAULT_LEVEL;\n      return focusZoomPanelHeight + 1 + upperRectMargin + level * levelHeight;\n    })\n    .attr('height', (d: Annotation) => {\n      const level = d.key !== undefined ? levels[d.key] : ANNOTATION_DEFAULT_LEVEL;\n      return focusChartHeight - 2 - upperRectMargin - level * levelHeight;\n    })\n    .attr('width', (d: Annotation) => {\n      const s = focusXScale(moment(d.timestamp)) + 1;\n      const e =\n        typeof d.end_timestamp !== 'undefined'\n          ? focusXScale(moment(d.end_timestamp)) - 1\n          : s + ANNOTATION_MIN_WIDTH;\n      const width = Math.max(ANNOTATION_MIN_WIDTH, e - s);\n      return width;\n    });\n\n  rects.exit().remove();\n\n  const textRects = annotations.selectAll('.mlAnnotationTextRect').data(d => [d]);\n  const texts = annotations.selectAll('.mlAnnotationText').data(d => [d]);\n\n  textRects\n    .enter()\n    .append('rect')\n    .classed('mlAnnotationTextRect', true)\n    .attr('width', ANNOTATION_TEXT_RECT_WIDTH)\n    .attr('height', ANNOTATION_TEXT_RECT_HEIGHT)\n    .attr('rx', ANNOTATION_RECT_BORDER_RADIUS)\n    .attr('ry', ANNOTATION_RECT_BORDER_RADIUS);\n\n  texts\n    .enter()\n    .append('text')\n    .classed('mlAnnotationText', true);\n\n  function labelXOffset(ts: number) {\n    const earliestMs = focusXScale.domain()[0];\n    const latestMs = focusXScale.domain()[1];\n    const date = moment(ts);\n    const minX = Math.max(focusXScale(earliestMs), focusXScale(date));\n    // To avoid overflow to the right, substract maxOffset which is\n    // the width of the text label (24px) plus left margin (8xp).\n    const maxOffset = 32;\n    return Math.min(focusXScale(latestMs) - maxOffset, minX);\n  }\n\n  texts\n    .attr('x', (d: Annotation) => {\n      const leftInnerOffset = 17;\n      return labelXOffset(d.timestamp) + leftInnerOffset;\n    })\n    .attr('y', (d: Annotation) => {\n      const level = d.key !== undefined ? levels[d.key] : ANNOTATION_DEFAULT_LEVEL;\n      return (\n        focusZoomPanelHeight +\n        upperTextMargin +\n        ANNOTATION_TEXT_VERTICAL_OFFSET +\n        level * levelHeight\n      );\n    })\n    .text((d: Annotation) => d.key as any);\n\n  textRects\n    .attr('x', (d: Annotation) => {\n      const leftInnerOffset = 5;\n      return labelXOffset(d.timestamp) + leftInnerOffset;\n    })\n    .attr('y', (d: Annotation) => {\n      const level = d.key !== undefined ? levels[d.key] : ANNOTATION_DEFAULT_LEVEL;\n      return (\n        focusZoomPanelHeight +\n        upperTextMargin +\n        ANNOTATION_TEXT_RECT_VERTICAL_OFFSET +\n        level * levelHeight\n      );\n    });\n\n  textRects.exit().remove();\n  texts.exit().remove();\n\n  annotations.classed('mlAnnotationHidden', !showAnnotations);\n  annotations.exit().remove();\n}\n\nexport function highlightFocusChartAnnotation(annotation: Annotation) {\n  const annotations = d3.selectAll('.mlAnnotation');\n\n  annotations.each(function(d) {\n    // @ts-ignore\n    const element = d3.select(this);\n\n    if (d._id === annotation._id) {\n      element.selectAll('.mlAnnotationRect').classed('mlAnnotationRect-isHighlight', true);\n    } else {\n      element.selectAll('.mlAnnotationTextRect').classed('mlAnnotationTextRect-isBlur', true);\n      element.selectAll('.mlAnnotationText').classed('mlAnnotationText-isBlur', true);\n      element.selectAll('.mlAnnotationRect').classed('mlAnnotationRect-isBlur', true);\n    }\n  });\n}\n\nexport function unhighlightFocusChartAnnotation() {\n  const annotations = d3.selectAll('.mlAnnotation');\n\n  annotations.each(function() {\n    // @ts-ignore\n    const element = d3.select(this);\n\n    element.selectAll('.mlAnnotationTextRect').classed('mlAnnotationTextRect-isBlur', false);\n    element\n      .selectAll('.mlAnnotationRect')\n      .classed('mlAnnotationRect-isHighlight', false)\n      .classed('mlAnnotationRect-isBlur', false);\n    element.selectAll('.mlAnnotationText').classed('mlAnnotationText-isBlur', false);\n  });\n}\n"]}]}