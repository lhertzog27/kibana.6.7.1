{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/upgrade_assistant/public/components/tabs/checkup/deprecations/reindex/polling_service.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/upgrade_assistant/public/components/tabs/checkup/deprecations/reindex/polling_service.ts","mtime":1567631712323},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["import * as tslib_1 from \"tslib\";\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport axios from 'axios';\nimport chrome from 'ui/chrome';\nimport { BehaviorSubject } from 'rxjs';\nimport { ReindexStatus, } from '../../../../../../common/types';\nimport { LoadingState } from '../../../../types';\nvar POLL_INTERVAL = 1000;\nvar XSRF = chrome.getXsrfToken();\nexport var APIClient = axios.create({\n    headers: {\n        Accept: 'application/json',\n        credentials: 'same-origin',\n        'Content-Type': 'application/json',\n        'kbn-version': XSRF,\n        'kbn-xsrf': XSRF,\n    },\n});\n/**\n * Service used by the frontend to start reindexing and get updates on the state of a reindex\n * operation. Exposes an Observable that can be used to subscribe to state updates.\n */\nvar ReindexPollingService = /** @class */ (function () {\n    function ReindexPollingService(indexName) {\n        var _this = this;\n        this.indexName = indexName;\n        this.updateStatus = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            var data, e_1;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // Prevent two loops from being started.\n                        this.stopPolling();\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, APIClient.get(chrome.addBasePath(\"/api/upgrade_assistant/reindex/\" + this.indexName))];\n                    case 2:\n                        data = (_a.sent()).data;\n                        this.updateWithResponse(data);\n                        // Only keep polling if it exists and is in progress.\n                        if (data.reindexOp && data.reindexOp.status === ReindexStatus.inProgress) {\n                            this.pollTimeout = setTimeout(this.updateStatus, POLL_INTERVAL);\n                        }\n                        return [3 /*break*/, 4];\n                    case 3:\n                        e_1 = _a.sent();\n                        this.status$.next(tslib_1.__assign({}, this.status$.value, { status: ReindexStatus.failed }));\n                        return [3 /*break*/, 4];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        }); };\n        this.stopPolling = function () {\n            if (_this.pollTimeout) {\n                clearTimeout(_this.pollTimeout);\n            }\n        };\n        this.startReindex = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            var currentValue, data, e_2;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        currentValue = this.status$.value;\n                        this.status$.next(tslib_1.__assign({}, currentValue, { \n                            // Only reset last completed step if we aren't currently paused\n                            lastCompletedStep: currentValue.status === ReindexStatus.paused ? currentValue.lastCompletedStep : undefined, status: ReindexStatus.inProgress, reindexTaskPercComplete: null, errorMessage: null, cancelLoadingState: undefined }));\n                        return [4 /*yield*/, APIClient.post(chrome.addBasePath(\"/api/upgrade_assistant/reindex/\" + this.indexName))];\n                    case 1:\n                        data = (_a.sent()).data;\n                        this.updateWithResponse({ reindexOp: data });\n                        this.updateStatus();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        e_2 = _a.sent();\n                        this.status$.next(tslib_1.__assign({}, this.status$.value, { status: ReindexStatus.failed }));\n                        return [3 /*break*/, 3];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        }); };\n        this.cancelReindex = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            var e_3;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        this.status$.next(tslib_1.__assign({}, this.status$.value, { cancelLoadingState: LoadingState.Loading }));\n                        return [4 /*yield*/, APIClient.post(chrome.addBasePath(\"/api/upgrade_assistant/reindex/\" + this.indexName + \"/cancel\"))];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        e_3 = _a.sent();\n                        this.status$.next(tslib_1.__assign({}, this.status$.value, { cancelLoadingState: LoadingState.Error }));\n                        return [3 /*break*/, 3];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        }); };\n        this.updateWithResponse = function (_a) {\n            var reindexOp = _a.reindexOp, warnings = _a.warnings, hasRequiredPrivileges = _a.hasRequiredPrivileges, indexGroup = _a.indexGroup;\n            var currentValue = _this.status$.value;\n            // Next value should always include the entire state, not just what changes.\n            // We make a shallow copy as a starting new state.\n            var nextValue = tslib_1.__assign({}, currentValue, { \n                // If we're getting any updates, set to success.\n                loadingState: LoadingState.Success });\n            if (warnings) {\n                nextValue.reindexWarnings = warnings;\n            }\n            if (hasRequiredPrivileges !== undefined) {\n                nextValue.hasRequiredPrivileges = hasRequiredPrivileges;\n            }\n            if (indexGroup) {\n                nextValue.indexGroup = indexGroup;\n            }\n            if (reindexOp) {\n                // Prevent the UI flickering back to inProgres after cancelling.\n                nextValue.lastCompletedStep = reindexOp.lastCompletedStep;\n                nextValue.status = reindexOp.status;\n                nextValue.reindexTaskPercComplete = reindexOp.reindexTaskPercComplete;\n                nextValue.errorMessage = reindexOp.errorMessage;\n                if (reindexOp.status === ReindexStatus.cancelled) {\n                    nextValue.cancelLoadingState = LoadingState.Success;\n                }\n            }\n            _this.status$.next(nextValue);\n        };\n        this.status$ = new BehaviorSubject({\n            loadingState: LoadingState.Loading,\n            errorMessage: null,\n            reindexTaskPercComplete: null,\n        });\n    }\n    return ReindexPollingService;\n}());\nexport { ReindexPollingService };\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/upgrade_assistant/public/components/tabs/checkup/deprecations/reindex/polling_service.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/upgrade_assistant/public/components/tabs/checkup/deprecations/reindex/polling_service.ts"],"names":[],"mappings":";AAAA;;;;GAIG;AACH,OAAO,KAAK,MAAM,OAAO,CAAC;AAC1B,OAAO,MAAM,MAAM,WAAW,CAAC;AAE/B,OAAO,EAAE,eAAe,EAAE,MAAM,MAAM,CAAC;AACvC,OAAO,EAGL,aAAa,GAGd,MAAM,gCAAgC,CAAC;AACxC,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAEjD,IAAM,aAAa,GAAG,IAAI,CAAC;AAC3B,IAAM,IAAI,GAAG,MAAM,CAAC,YAAY,EAAE,CAAC;AAEnC,MAAM,CAAC,IAAM,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC;IACpC,OAAO,EAAE;QACP,MAAM,EAAE,kBAAkB;QAC1B,WAAW,EAAE,aAAa;QAC1B,cAAc,EAAE,kBAAkB;QAClC,aAAa,EAAE,IAAI;QACnB,UAAU,EAAE,IAAI;KACjB;CACF,CAAC,CAAC;AAqBH;;;GAGG;AACH;IAIE,+BAAoB,SAAiB;QAArC,iBAMC;QANmB,cAAS,GAAT,SAAS,CAAQ;QAQ9B,iBAAY,GAAG;;;;;wBACpB,wCAAwC;wBACxC,IAAI,CAAC,WAAW,EAAE,CAAC;;;;wBAGA,qBAAM,SAAS,CAAC,GAAG,CAClC,MAAM,CAAC,WAAW,CAAC,oCAAkC,IAAI,CAAC,SAAW,CAAC,CACvE,EAAA;;wBAFO,IAAI,GAAK,CAAA,SAEhB,CAAA,KAFW;wBAGZ,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;wBAE9B,qDAAqD;wBACrD,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,aAAa,CAAC,UAAU,EAAE;4BACxE,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC,IAAI,CAAC,YAAY,EAAE,aAAa,CAAC,CAAC;yBACjE;;;;wBAED,IAAI,CAAC,OAAO,CAAC,IAAI,sBACZ,IAAI,CAAC,OAAO,CAAC,KAAK,IACrB,MAAM,EAAE,aAAa,CAAC,MAAM,IAC5B,CAAC;;;;;aAEN,CAAC;QAEK,gBAAW,GAAG;YACnB,IAAI,KAAI,CAAC,WAAW,EAAE;gBACpB,YAAY,CAAC,KAAI,CAAC,WAAW,CAAC,CAAC;aAChC;QACH,CAAC,CAAC;QAEK,iBAAY,GAAG;;;;;;wBAGZ,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC;wBACxC,IAAI,CAAC,OAAO,CAAC,IAAI,sBACZ,YAAY;4BACf,+DAA+D;4BAC/D,iBAAiB,EACf,YAAY,CAAC,MAAM,KAAK,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,iBAAiB,CAAC,CAAC,CAAC,SAAS,EAC3F,MAAM,EAAE,aAAa,CAAC,UAAU,EAChC,uBAAuB,EAAE,IAAI,EAC7B,YAAY,EAAE,IAAI,EAClB,kBAAkB,EAAE,SAAS,IAC7B,CAAC;wBACc,qBAAM,SAAS,CAAC,IAAI,CACnC,MAAM,CAAC,WAAW,CAAC,oCAAkC,IAAI,CAAC,SAAW,CAAC,CACvE,EAAA;;wBAFO,IAAI,GAAK,CAAA,SAEhB,CAAA,KAFW;wBAIZ,IAAI,CAAC,kBAAkB,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;wBAC7C,IAAI,CAAC,YAAY,EAAE,CAAC;;;;wBAEpB,IAAI,CAAC,OAAO,CAAC,IAAI,sBAAM,IAAI,CAAC,OAAO,CAAC,KAAK,IAAE,MAAM,EAAE,aAAa,CAAC,MAAM,IAAG,CAAC;;;;;aAE9E,CAAC;QAEK,kBAAa,GAAG;;;;;;wBAEnB,IAAI,CAAC,OAAO,CAAC,IAAI,sBACZ,IAAI,CAAC,OAAO,CAAC,KAAK,IACrB,kBAAkB,EAAE,YAAY,CAAC,OAAO,IACxC,CAAC;wBAEH,qBAAM,SAAS,CAAC,IAAI,CAClB,MAAM,CAAC,WAAW,CAAC,oCAAkC,IAAI,CAAC,SAAS,YAAS,CAAC,CAC9E,EAAA;;wBAFD,SAEC,CAAC;;;;wBAEF,IAAI,CAAC,OAAO,CAAC,IAAI,sBACZ,IAAI,CAAC,OAAO,CAAC,KAAK,IACrB,kBAAkB,EAAE,YAAY,CAAC,KAAK,IACtC,CAAC;;;;;aAEN,CAAC;QAEM,uBAAkB,GAAG,UAAC,EAKb;gBAJf,wBAAS,EACT,sBAAQ,EACR,gDAAqB,EACrB,0BAAU;YAEV,IAAM,YAAY,GAAG,KAAI,CAAC,OAAO,CAAC,KAAK,CAAC;YACxC,4EAA4E;YAC5E,kDAAkD;YAClD,IAAM,SAAS,wBACV,YAAY;gBACf,gDAAgD;gBAChD,YAAY,EAAE,YAAY,CAAC,OAAO,GACnC,CAAC;YAEF,IAAI,QAAQ,EAAE;gBACZ,SAAS,CAAC,eAAe,GAAG,QAAQ,CAAC;aACtC;YAED,IAAI,qBAAqB,KAAK,SAAS,EAAE;gBACvC,SAAS,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;aACzD;YAED,IAAI,UAAU,EAAE;gBACd,SAAS,CAAC,UAAU,GAAG,UAAU,CAAC;aACnC;YAED,IAAI,SAAS,EAAE;gBACb,gEAAgE;gBAChE,SAAS,CAAC,iBAAiB,GAAG,SAAS,CAAC,iBAAiB,CAAC;gBAC1D,SAAS,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC;gBACpC,SAAS,CAAC,uBAAuB,GAAG,SAAS,CAAC,uBAAuB,CAAC;gBACtE,SAAS,CAAC,YAAY,GAAG,SAAS,CAAC,YAAY,CAAC;gBAEhD,IAAI,SAAS,CAAC,MAAM,KAAK,aAAa,CAAC,SAAS,EAAE;oBAChD,SAAS,CAAC,kBAAkB,GAAG,YAAY,CAAC,OAAO,CAAC;iBACrD;aACF;YAED,KAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC/B,CAAC,CAAC;QAtHA,IAAI,CAAC,OAAO,GAAG,IAAI,eAAe,CAAe;YAC/C,YAAY,EAAE,YAAY,CAAC,OAAO;YAClC,YAAY,EAAE,IAAI;YAClB,uBAAuB,EAAE,IAAI;SAC9B,CAAC,CAAC;IACL,CAAC;IAkHH,4BAAC;AAAD,CAAC,AA5HD,IA4HC","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport axios from 'axios';\nimport chrome from 'ui/chrome';\n\nimport { BehaviorSubject } from 'rxjs';\nimport {\n  IndexGroup,\n  ReindexOperation,\n  ReindexStatus,\n  ReindexStep,\n  ReindexWarning,\n} from '../../../../../../common/types';\nimport { LoadingState } from '../../../../types';\n\nconst POLL_INTERVAL = 1000;\nconst XSRF = chrome.getXsrfToken();\n\nexport const APIClient = axios.create({\n  headers: {\n    Accept: 'application/json',\n    credentials: 'same-origin',\n    'Content-Type': 'application/json',\n    'kbn-version': XSRF,\n    'kbn-xsrf': XSRF,\n  },\n});\n\nexport interface ReindexState {\n  loadingState: LoadingState;\n  cancelLoadingState?: LoadingState;\n  lastCompletedStep?: ReindexStep;\n  status?: ReindexStatus;\n  reindexTaskPercComplete: number | null;\n  errorMessage: string | null;\n  reindexWarnings?: ReindexWarning[];\n  hasRequiredPrivileges?: boolean;\n  indexGroup?: IndexGroup;\n}\n\ninterface StatusResponse {\n  warnings?: ReindexWarning[];\n  reindexOp?: ReindexOperation;\n  hasRequiredPrivileges?: boolean;\n  indexGroup?: IndexGroup;\n}\n\n/**\n * Service used by the frontend to start reindexing and get updates on the state of a reindex\n * operation. Exposes an Observable that can be used to subscribe to state updates.\n */\nexport class ReindexPollingService {\n  public status$: BehaviorSubject<ReindexState>;\n  private pollTimeout?: NodeJS.Timeout;\n\n  constructor(private indexName: string) {\n    this.status$ = new BehaviorSubject<ReindexState>({\n      loadingState: LoadingState.Loading,\n      errorMessage: null,\n      reindexTaskPercComplete: null,\n    });\n  }\n\n  public updateStatus = async () => {\n    // Prevent two loops from being started.\n    this.stopPolling();\n\n    try {\n      const { data } = await APIClient.get<StatusResponse>(\n        chrome.addBasePath(`/api/upgrade_assistant/reindex/${this.indexName}`)\n      );\n      this.updateWithResponse(data);\n\n      // Only keep polling if it exists and is in progress.\n      if (data.reindexOp && data.reindexOp.status === ReindexStatus.inProgress) {\n        this.pollTimeout = setTimeout(this.updateStatus, POLL_INTERVAL);\n      }\n    } catch (e) {\n      this.status$.next({\n        ...this.status$.value,\n        status: ReindexStatus.failed,\n      });\n    }\n  };\n\n  public stopPolling = () => {\n    if (this.pollTimeout) {\n      clearTimeout(this.pollTimeout);\n    }\n  };\n\n  public startReindex = async () => {\n    try {\n      // Optimistically assume it will start, reset other state.\n      const currentValue = this.status$.value;\n      this.status$.next({\n        ...currentValue,\n        // Only reset last completed step if we aren't currently paused\n        lastCompletedStep:\n          currentValue.status === ReindexStatus.paused ? currentValue.lastCompletedStep : undefined,\n        status: ReindexStatus.inProgress,\n        reindexTaskPercComplete: null,\n        errorMessage: null,\n        cancelLoadingState: undefined,\n      });\n      const { data } = await APIClient.post<ReindexOperation>(\n        chrome.addBasePath(`/api/upgrade_assistant/reindex/${this.indexName}`)\n      );\n\n      this.updateWithResponse({ reindexOp: data });\n      this.updateStatus();\n    } catch (e) {\n      this.status$.next({ ...this.status$.value, status: ReindexStatus.failed });\n    }\n  };\n\n  public cancelReindex = async () => {\n    try {\n      this.status$.next({\n        ...this.status$.value,\n        cancelLoadingState: LoadingState.Loading,\n      });\n\n      await APIClient.post(\n        chrome.addBasePath(`/api/upgrade_assistant/reindex/${this.indexName}/cancel`)\n      );\n    } catch (e) {\n      this.status$.next({\n        ...this.status$.value,\n        cancelLoadingState: LoadingState.Error,\n      });\n    }\n  };\n\n  private updateWithResponse = ({\n    reindexOp,\n    warnings,\n    hasRequiredPrivileges,\n    indexGroup,\n  }: StatusResponse) => {\n    const currentValue = this.status$.value;\n    // Next value should always include the entire state, not just what changes.\n    // We make a shallow copy as a starting new state.\n    const nextValue = {\n      ...currentValue,\n      // If we're getting any updates, set to success.\n      loadingState: LoadingState.Success,\n    };\n\n    if (warnings) {\n      nextValue.reindexWarnings = warnings;\n    }\n\n    if (hasRequiredPrivileges !== undefined) {\n      nextValue.hasRequiredPrivileges = hasRequiredPrivileges;\n    }\n\n    if (indexGroup) {\n      nextValue.indexGroup = indexGroup;\n    }\n\n    if (reindexOp) {\n      // Prevent the UI flickering back to inProgres after cancelling.\n      nextValue.lastCompletedStep = reindexOp.lastCompletedStep;\n      nextValue.status = reindexOp.status;\n      nextValue.reindexTaskPercComplete = reindexOp.reindexTaskPercComplete;\n      nextValue.errorMessage = reindexOp.errorMessage;\n\n      if (reindexOp.status === ReindexStatus.cancelled) {\n        nextValue.cancelLoadingState = LoadingState.Success;\n      }\n    }\n\n    this.status$.next(nextValue);\n  };\n}\n"]}]}