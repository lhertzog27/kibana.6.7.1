{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/metadata/with_metadata.tsx","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/metadata/with_metadata.tsx","mtime":1567631711983},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport * as tslib_1 from \"tslib\";\nimport _ from 'lodash';\nimport React from 'react';\nimport { Query } from 'react-apollo';\nimport { metadataQuery } from './metadata.gql_query';\nexport var WithMetadata = function (_a) {\n    var children = _a.children, layouts = _a.layouts, nodeType = _a.nodeType, nodeId = _a.nodeId, sourceId = _a.sourceId;\n    return (React.createElement(Query, { query: metadataQuery, fetchPolicy: \"no-cache\", variables: {\n            sourceId: sourceId,\n            nodeType: nodeType,\n            nodeId: nodeId,\n        } }, function (_a) {\n        var data = _a.data, error = _a.error, loading = _a.loading;\n        var metadata = data && data.source && data.source.metadataByNode;\n        var filteredLayouts = (metadata && getFilteredLayouts(layouts, metadata.features)) || [];\n        return children({\n            name: (metadata && metadata.name) || '',\n            filteredLayouts: filteredLayouts,\n            error: error && error.message,\n            loading: loading,\n        });\n    }));\n};\nvar getFilteredLayouts = function (layouts, metadata) {\n    if (!metadata) {\n        return layouts;\n    }\n    var metricMetadata = metadata\n        .filter(function (data) { return data && data.source === 'metrics'; })\n        .map(function (data) { return data && data.name; });\n    // After filtering out sections that can't be displayed, a layout may end up empty and can be removed.\n    var filteredLayouts = layouts\n        .map(function (layout) { return getFilteredLayout(layout, metricMetadata); })\n        .filter(function (layout) { return layout.sections.length > 0; });\n    return filteredLayouts;\n};\nvar getFilteredLayout = function (layout, metricMetadata) {\n    // A section is only displayed if at least one of its requirements is met\n    // All others are filtered out.\n    var filteredSections = layout.sections.filter(function (section) { return _.intersection(section.requires, metricMetadata).length > 0; });\n    return tslib_1.__assign({}, layout, { sections: filteredSections });\n};\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/metadata/with_metadata.tsx","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/metadata/with_metadata.tsx"],"names":[],"mappings":"AAAA;;;;GAIG;;AAEH,OAAO,CAAC,MAAM,QAAQ,CAAC;AACvB,OAAO,KAAK,MAAM,OAAO,CAAC;AAC1B,OAAO,EAAE,KAAK,EAAE,MAAM,cAAc,CAAC;AAIrC,OAAO,EAAE,aAAa,EAAE,MAAM,sBAAsB,CAAC;AAiBrD,MAAM,CAAC,IAAM,YAAY,GAAG,UAAC,EAMT;QALlB,sBAAQ,EACR,oBAAO,EACP,sBAAQ,EACR,kBAAM,EACN,sBAAQ;IAER,OAAO,CACL,oBAAC,KAAK,IACJ,KAAK,EAAE,aAAa,EACpB,WAAW,EAAC,UAAU,EACtB,SAAS,EAAE;YACT,QAAQ,UAAA;YACR,QAAQ,UAAA;YACR,MAAM,QAAA;SACP,IAEA,UAAC,EAAwB;YAAtB,cAAI,EAAE,gBAAK,EAAE,oBAAO;QACtB,IAAM,QAAQ,GAAG,IAAI,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC;QACnE,IAAM,eAAe,GAAG,CAAC,QAAQ,IAAI,kBAAkB,CAAC,OAAO,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC,IAAI,EAAE,CAAC;QAC3F,OAAO,QAAQ,CAAC;YACd,IAAI,EAAE,CAAC,QAAQ,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE;YACvC,eAAe,iBAAA;YACf,KAAK,EAAE,KAAK,IAAI,KAAK,CAAC,OAAO;YAC7B,OAAO,SAAA;SACR,CAAC,CAAC;IACL,CAAC,CACK,CACT,CAAC;AACJ,CAAC,CAAC;AAEF,IAAM,kBAAkB,GAAG,UACzB,OAA4B,EAC5B,QAA0D;IAE1D,IAAI,CAAC,QAAQ,EAAE;QACb,OAAO,OAAO,CAAC;KAChB;IAED,IAAM,cAAc,GAAyB,QAAQ;SAClD,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAjC,CAAiC,CAAC;SACjD,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,IAAI,IAAI,CAAC,IAAI,EAAjB,CAAiB,CAAC,CAAC;IAElC,sGAAsG;IACtG,IAAM,eAAe,GAAG,OAAO;SAC5B,GAAG,CAAC,UAAA,MAAM,IAAI,OAAA,iBAAiB,CAAC,MAAM,EAAE,cAAc,CAAC,EAAzC,CAAyC,CAAC;SACxD,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAA1B,CAA0B,CAAC,CAAC;IAChD,OAAO,eAAe,CAAC;AACzB,CAAC,CAAC;AAEF,IAAM,iBAAiB,GAAG,UACxB,MAAyB,EACzB,cAAoC;IAEpC,yEAAyE;IACzE,+BAA+B;IAC/B,IAAM,gBAAgB,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,CAC7C,UAAA,OAAO,IAAI,OAAA,CAAC,CAAC,YAAY,CAAC,OAAO,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC,MAAM,GAAG,CAAC,EAA3D,CAA2D,CACvE,CAAC;IACF,4BAAY,MAAM,IAAE,QAAQ,EAAE,gBAAgB,IAAG;AACnD,CAAC,CAAC","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport _ from 'lodash';\nimport React from 'react';\nimport { Query } from 'react-apollo';\n\nimport { InfraNodeType, MetadataQuery } from '../../graphql/types';\nimport { InfraMetricLayout } from '../../pages/metrics/layouts/types';\nimport { metadataQuery } from './metadata.gql_query';\n\ninterface WithMetadataProps {\n  children: (args: WithMetadataArgs) => React.ReactNode;\n  layouts: InfraMetricLayout[];\n  nodeType: InfraNodeType;\n  nodeId: string;\n  sourceId: string;\n}\n\ninterface WithMetadataArgs {\n  name: string;\n  filteredLayouts: InfraMetricLayout[];\n  error?: string | undefined;\n  loading: boolean;\n}\n\nexport const WithMetadata = ({\n  children,\n  layouts,\n  nodeType,\n  nodeId,\n  sourceId,\n}: WithMetadataProps) => {\n  return (\n    <Query<MetadataQuery.Query, MetadataQuery.Variables>\n      query={metadataQuery}\n      fetchPolicy=\"no-cache\"\n      variables={{\n        sourceId,\n        nodeType,\n        nodeId,\n      }}\n    >\n      {({ data, error, loading }) => {\n        const metadata = data && data.source && data.source.metadataByNode;\n        const filteredLayouts = (metadata && getFilteredLayouts(layouts, metadata.features)) || [];\n        return children({\n          name: (metadata && metadata.name) || '',\n          filteredLayouts,\n          error: error && error.message,\n          loading,\n        });\n      }}\n    </Query>\n  );\n};\n\nconst getFilteredLayouts = (\n  layouts: InfraMetricLayout[],\n  metadata: Array<MetadataQuery.Features | null> | undefined\n): InfraMetricLayout[] => {\n  if (!metadata) {\n    return layouts;\n  }\n\n  const metricMetadata: Array<string | null> = metadata\n    .filter(data => data && data.source === 'metrics')\n    .map(data => data && data.name);\n\n  // After filtering out sections that can't be displayed, a layout may end up empty and can be removed.\n  const filteredLayouts = layouts\n    .map(layout => getFilteredLayout(layout, metricMetadata))\n    .filter(layout => layout.sections.length > 0);\n  return filteredLayouts;\n};\n\nconst getFilteredLayout = (\n  layout: InfraMetricLayout,\n  metricMetadata: Array<string | null>\n): InfraMetricLayout => {\n  // A section is only displayed if at least one of its requirements is met\n  // All others are filtered out.\n  const filteredSections = layout.sections.filter(\n    section => _.intersection(section.requires, metricMetadata).length > 0\n  );\n  return { ...layout, sections: filteredSections };\n};\n"]}]}