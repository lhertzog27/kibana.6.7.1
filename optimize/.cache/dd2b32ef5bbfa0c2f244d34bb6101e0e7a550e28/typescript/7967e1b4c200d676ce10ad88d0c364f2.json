{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/components/workpad_page/workpad_shortcuts.tsx","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/components/workpad_page/workpad_shortcuts.tsx","mtime":1567631711930},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport * as tslib_1 from \"tslib\";\nimport React, { Component } from 'react';\nimport isEqual from 'react-fast-compare';\n// @ts-ignore\nimport { Shortcuts } from 'react-shortcuts';\n// @ts-ignore\nimport { getClipboardData, setClipboardData } from '../../lib/clipboard';\n// @ts-ignore\nimport { cloneSubgraphs } from '../../lib/clone_subgraphs';\n// @ts-ignore\nimport { notify } from '../../lib/notify';\nvar WorkpadShortcuts = /** @class */ (function (_super) {\n    tslib_1.__extends(WorkpadShortcuts, _super);\n    function WorkpadShortcuts() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WorkpadShortcuts.prototype.render = function () {\n        var _this = this;\n        var pageId = this.props.pageId;\n        return (React.createElement(Shortcuts, { name: \"ELEMENT\", handler: function (action, event) { return _this._keyHandler(action, event); }, targetNodeSelector: \"#\" + pageId, global: true }));\n    };\n    WorkpadShortcuts.prototype.shouldComponentUpdate = function (nextProps) {\n        return !isEqual(nextProps, this.props);\n    };\n    WorkpadShortcuts.prototype._keyHandler = function (action, event) {\n        event.preventDefault();\n        switch (action) {\n            case 'COPY':\n                this._copyElements();\n                break;\n            case 'CLONE':\n                this._duplicateElements();\n                break;\n            case 'CUT':\n                this._cutElements();\n                break;\n            case 'DELETE':\n                this._removeElements();\n                break;\n            case 'PASTE':\n                this._pasteElements();\n                break;\n            case 'BRING_FORWARD':\n                this._bringForward();\n                break;\n            case 'BRING_TO_FRONT':\n                this._bringToFront();\n                break;\n            case 'SEND_BACKWARD':\n                this._sendBackward();\n                break;\n            case 'SEND_TO_BACK':\n                this._sendToBack();\n                break;\n            case 'GROUP':\n                this.props.groupElements();\n                break;\n            case 'UNGROUP':\n                this.props.ungroupElements();\n                break;\n        }\n    };\n    WorkpadShortcuts.prototype._removeElements = function () {\n        var _a = this.props, pageId = _a.pageId, removeElements = _a.removeElements, selectedElementIds = _a.selectedElementIds;\n        // currently, handle the removal of one element, exploiting multiselect subsequently\n        if (selectedElementIds.length) {\n            removeElements(pageId)(selectedElementIds);\n        }\n    };\n    WorkpadShortcuts.prototype._copyElements = function () {\n        var _a = this.props, selectedElements = _a.selectedElements, selectedPrimaryShapes = _a.selectedPrimaryShapes;\n        if (selectedElements.length) {\n            setClipboardData({ selectedElements: selectedElements, rootShapes: selectedPrimaryShapes });\n            notify.success('Copied element to clipboard');\n        }\n    };\n    WorkpadShortcuts.prototype._cutElements = function () {\n        var _a = this.props, pageId = _a.pageId, removeElements = _a.removeElements, selectedElements = _a.selectedElements, selectedElementIds = _a.selectedElementIds, selectedPrimaryShapes = _a.selectedPrimaryShapes;\n        if (selectedElements.length) {\n            setClipboardData({ selectedElements: selectedElements, rootShapes: selectedPrimaryShapes });\n            removeElements(pageId)(selectedElementIds);\n            notify.success('Copied element to clipboard');\n        }\n    };\n    // TODO: This is slightly different from the duplicateElements function in sidebar/index.js. Should they be doing the same thing?\n    // This should also be abstracted.\n    WorkpadShortcuts.prototype._duplicateElements = function () {\n        var _a = this.props, insertNodes = _a.insertNodes, pageId = _a.pageId, selectElement = _a.selectElement, selectedElements = _a.selectedElements, selectedPrimaryShapes = _a.selectedPrimaryShapes;\n        var clonedElements = selectedElements && cloneSubgraphs(selectedElements);\n        if (clonedElements) {\n            insertNodes(pageId)(clonedElements);\n            if (selectedPrimaryShapes.length) {\n                if (selectedElements.length > 1) {\n                    // adHocGroup branch (currently, pasting will leave only the 1st element selected, rather than forming a\n                    // new adHocGroup - todo)\n                    selectElement(clonedElements[0].id);\n                }\n                else {\n                    // single element or single persistentGroup branch\n                    selectElement(clonedElements[selectedElements.findIndex(function (s) { return s.id === selectedPrimaryShapes[0]; })].id);\n                }\n            }\n        }\n    };\n    WorkpadShortcuts.prototype._pasteElements = function () {\n        var _a = this.props, insertNodes = _a.insertNodes, pageId = _a.pageId, selectElement = _a.selectElement;\n        var _b = JSON.parse(getClipboardData()) || {\n            selectedElements: [],\n            rootShapes: [],\n        }, selectedElements = _b.selectedElements, rootShapes = _b.rootShapes;\n        var clonedElements = selectedElements && cloneSubgraphs(selectedElements);\n        if (clonedElements) {\n            // first clone and persist the new node(s)\n            insertNodes(pageId)(clonedElements);\n            // then select the cloned node\n            if (rootShapes.length) {\n                if (selectedElements.length > 1) {\n                    // adHocGroup branch (currently, pasting will leave only the 1st element selected, rather than forming a\n                    // new adHocGroup - todo)\n                    selectElement(clonedElements[0].id);\n                }\n                else {\n                    // single element or single persistentGroup branch\n                    selectElement(clonedElements[selectedElements.findIndex(function (s) { return s.id === rootShapes[0]; })].id);\n                }\n            }\n        }\n    };\n    // TODO: Same as above. Abstract these out. This is the same code as in sidebar/index.js\n    // Note: these layer actions only work when a single element is selected\n    WorkpadShortcuts.prototype._bringForward = function () {\n        var _a = this.props, elementLayer = _a.elementLayer, pageId = _a.pageId, selectedElements = _a.selectedElements;\n        if (selectedElements.length === 1) {\n            elementLayer(pageId, selectedElements[0], 1);\n        }\n    };\n    WorkpadShortcuts.prototype._bringToFront = function () {\n        var _a = this.props, elementLayer = _a.elementLayer, pageId = _a.pageId, selectedElements = _a.selectedElements;\n        if (selectedElements.length === 1) {\n            elementLayer(pageId, selectedElements[0], Infinity);\n        }\n    };\n    WorkpadShortcuts.prototype._sendBackward = function () {\n        var _a = this.props, elementLayer = _a.elementLayer, pageId = _a.pageId, selectedElements = _a.selectedElements;\n        if (selectedElements.length === 1) {\n            elementLayer(pageId, selectedElements[0], -1);\n        }\n    };\n    WorkpadShortcuts.prototype._sendToBack = function () {\n        var _a = this.props, elementLayer = _a.elementLayer, pageId = _a.pageId, selectedElements = _a.selectedElements;\n        if (selectedElements.length === 1) {\n            elementLayer(pageId, selectedElements[0], -Infinity);\n        }\n    };\n    return WorkpadShortcuts;\n}(Component));\nexport { WorkpadShortcuts };\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/components/workpad_page/workpad_shortcuts.tsx","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/canvas/public/components/workpad_page/workpad_shortcuts.tsx"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport _ from 'lodash';\nimport React, { Component } from 'react';\n\nimport isEqual from 'react-fast-compare';\n// @ts-ignore\nimport { Shortcuts } from 'react-shortcuts';\n// @ts-ignore\nimport { getClipboardData, setClipboardData } from '../../lib/clipboard';\n// @ts-ignore\nimport { cloneSubgraphs } from '../../lib/clone_subgraphs';\n// @ts-ignore\nimport { notify } from '../../lib/notify';\n\nexport interface Props {\n  pageId: string;\n  selectedElementIds: string[];\n  selectedElements: any[];\n  selectedPrimaryShapes: any[];\n  selectElement: (elementId: string) => void;\n  insertNodes: (pageId: string) => (selectedElements: any[]) => void;\n  removeElements: (pageId: string) => (selectedElementIds: string[]) => void;\n  elementLayer: (pageId: string, selectedElement: any, movement: any) => void;\n  groupElements: () => void;\n  ungroupElements: () => void;\n}\n\nexport class WorkpadShortcuts extends Component<Props> {\n  public render() {\n    const { pageId } = this.props;\n    return (\n      <Shortcuts\n        name=\"ELEMENT\"\n        handler={(action: string, event: Event) => this._keyHandler(action, event)}\n        targetNodeSelector={`#${pageId}`}\n        global\n      />\n    );\n  }\n\n  public shouldComponentUpdate(nextProps: Props) {\n    return !isEqual(nextProps, this.props);\n  }\n\n  private _keyHandler(action: string, event: Event) {\n    event.preventDefault();\n    switch (action) {\n      case 'COPY':\n        this._copyElements();\n        break;\n      case 'CLONE':\n        this._duplicateElements();\n        break;\n      case 'CUT':\n        this._cutElements();\n        break;\n      case 'DELETE':\n        this._removeElements();\n        break;\n      case 'PASTE':\n        this._pasteElements();\n        break;\n      case 'BRING_FORWARD':\n        this._bringForward();\n        break;\n      case 'BRING_TO_FRONT':\n        this._bringToFront();\n        break;\n      case 'SEND_BACKWARD':\n        this._sendBackward();\n        break;\n      case 'SEND_TO_BACK':\n        this._sendToBack();\n        break;\n      case 'GROUP':\n        this.props.groupElements();\n        break;\n      case 'UNGROUP':\n        this.props.ungroupElements();\n        break;\n    }\n  }\n\n  private _removeElements() {\n    const { pageId, removeElements, selectedElementIds } = this.props;\n    // currently, handle the removal of one element, exploiting multiselect subsequently\n    if (selectedElementIds.length) {\n      removeElements(pageId)(selectedElementIds);\n    }\n  }\n\n  private _copyElements() {\n    const { selectedElements, selectedPrimaryShapes } = this.props;\n    if (selectedElements.length) {\n      setClipboardData({ selectedElements, rootShapes: selectedPrimaryShapes });\n      notify.success('Copied element to clipboard');\n    }\n  }\n\n  private _cutElements() {\n    const {\n      pageId,\n      removeElements,\n      selectedElements,\n      selectedElementIds,\n      selectedPrimaryShapes,\n    } = this.props;\n\n    if (selectedElements.length) {\n      setClipboardData({ selectedElements, rootShapes: selectedPrimaryShapes });\n      removeElements(pageId)(selectedElementIds);\n      notify.success('Copied element to clipboard');\n    }\n  }\n\n  // TODO: This is slightly different from the duplicateElements function in sidebar/index.js. Should they be doing the same thing?\n  // This should also be abstracted.\n  private _duplicateElements() {\n    const {\n      insertNodes,\n      pageId,\n      selectElement,\n      selectedElements,\n      selectedPrimaryShapes,\n    } = this.props;\n    const clonedElements = selectedElements && cloneSubgraphs(selectedElements);\n\n    if (clonedElements) {\n      insertNodes(pageId)(clonedElements);\n      if (selectedPrimaryShapes.length) {\n        if (selectedElements.length > 1) {\n          // adHocGroup branch (currently, pasting will leave only the 1st element selected, rather than forming a\n          // new adHocGroup - todo)\n          selectElement(clonedElements[0].id);\n        } else {\n          // single element or single persistentGroup branch\n          selectElement(\n            clonedElements[selectedElements.findIndex(s => s.id === selectedPrimaryShapes[0])].id\n          );\n        }\n      }\n    }\n  }\n\n  private _pasteElements() {\n    const { insertNodes, pageId, selectElement } = this.props;\n    const { selectedElements, rootShapes } = JSON.parse(getClipboardData()) || {\n      selectedElements: [],\n      rootShapes: [],\n    };\n\n    const clonedElements = selectedElements && cloneSubgraphs(selectedElements);\n\n    if (clonedElements) {\n      // first clone and persist the new node(s)\n      insertNodes(pageId)(clonedElements);\n      // then select the cloned node\n      if (rootShapes.length) {\n        if (selectedElements.length > 1) {\n          // adHocGroup branch (currently, pasting will leave only the 1st element selected, rather than forming a\n          // new adHocGroup - todo)\n          selectElement(clonedElements[0].id);\n        } else {\n          // single element or single persistentGroup branch\n          selectElement(\n            clonedElements[\n              selectedElements.findIndex((s: { id: string }) => s.id === rootShapes[0])\n            ].id\n          );\n        }\n      }\n    }\n  }\n\n  // TODO: Same as above. Abstract these out. This is the same code as in sidebar/index.js\n  // Note: these layer actions only work when a single element is selected\n  private _bringForward() {\n    const { elementLayer, pageId, selectedElements } = this.props;\n    if (selectedElements.length === 1) {\n      elementLayer(pageId, selectedElements[0], 1);\n    }\n  }\n\n  private _bringToFront() {\n    const { elementLayer, pageId, selectedElements } = this.props;\n    if (selectedElements.length === 1) {\n      elementLayer(pageId, selectedElements[0], Infinity);\n    }\n  }\n\n  private _sendBackward() {\n    const { elementLayer, pageId, selectedElements } = this.props;\n    if (selectedElements.length === 1) {\n      elementLayer(pageId, selectedElements[0], -1);\n    }\n  }\n\n  private _sendToBack() {\n    const { elementLayer, pageId, selectedElements } = this.props;\n    if (selectedElements.length === 1) {\n      elementLayer(pageId, selectedElements[0], -Infinity);\n    }\n  }\n}\n"]}]}