{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/with_kuery_autocompletion.tsx","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/with_kuery_autocompletion.tsx","mtime":1567631711984},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport * as tslib_1 from \"tslib\";\nimport React from 'react';\nimport { getAutocompleteProvider } from 'ui/autocomplete_providers';\nvar WithKueryAutocompletion = /** @class */ (function (_super) {\n    tslib_1.__extends(WithKueryAutocompletion, _super);\n    function WithKueryAutocompletion() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            currentRequest: null,\n            suggestions: [],\n        };\n        _this.loadSuggestions = function (expression, cursorPosition, maxSuggestions) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            var indexPattern, autocompletionProvider, config, getSuggestions, suggestions;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        indexPattern = this.props.indexPattern;\n                        autocompletionProvider = getAutocompleteProvider('kuery');\n                        config = {\n                            get: function () { return true; },\n                        };\n                        if (!autocompletionProvider) {\n                            return [2 /*return*/];\n                        }\n                        getSuggestions = autocompletionProvider({\n                            config: config,\n                            indexPatterns: [indexPattern],\n                            boolFilter: [],\n                        });\n                        this.setState({\n                            currentRequest: {\n                                expression: expression,\n                                cursorPosition: cursorPosition,\n                            },\n                            suggestions: [],\n                        });\n                        return [4 /*yield*/, getSuggestions({\n                                query: expression,\n                                selectionStart: cursorPosition,\n                                selectionEnd: cursorPosition,\n                            })];\n                    case 1:\n                        suggestions = _a.sent();\n                        this.setState(function (state) {\n                            return state.currentRequest &&\n                                state.currentRequest.expression !== expression &&\n                                state.currentRequest.cursorPosition !== cursorPosition\n                                ? state // ignore this result, since a newer request is in flight\n                                : tslib_1.__assign({}, state, { currentRequest: null, suggestions: maxSuggestions ? suggestions.slice(0, maxSuggestions) : suggestions });\n                        });\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        return _this;\n    }\n    WithKueryAutocompletion.prototype.render = function () {\n        var _a = this.state, currentRequest = _a.currentRequest, suggestions = _a.suggestions;\n        return this.props.children({\n            isLoadingSuggestions: currentRequest !== null,\n            loadSuggestions: this.loadSuggestions,\n            suggestions: suggestions,\n        });\n    };\n    return WithKueryAutocompletion;\n}(React.Component));\nexport { WithKueryAutocompletion };\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/with_kuery_autocompletion.tsx","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/with_kuery_autocompletion.tsx"],"names":[],"mappings":"AAAA;;;;GAIG;;AAEH,OAAO,KAAK,MAAM,OAAO,CAAC;AAE1B,OAAO,EAA0B,uBAAuB,EAAE,MAAM,2BAA2B,CAAC;AAwB5F;IAA6C,mDAG5C;IAHD;QAAA,qEAkEC;QA9DiB,WAAK,GAA0C;YAC7D,cAAc,EAAE,IAAI;YACpB,WAAW,EAAE,EAAE;SAChB,CAAC;QAYM,qBAAe,GAAG,UACxB,UAAkB,EAClB,cAAsB,EACtB,cAAuB;;;;;wBAEf,YAAY,GAAK,IAAI,CAAC,KAAK,aAAf,CAAgB;wBAC9B,sBAAsB,GAAG,uBAAuB,CAAC,OAAO,CAAC,CAAC;wBAC1D,MAAM,GAAG;4BACb,GAAG,EAAE,cAAM,OAAA,IAAI,EAAJ,CAAI;yBAChB,CAAC;wBAEF,IAAI,CAAC,sBAAsB,EAAE;4BAC3B,sBAAO;yBACR;wBAEK,cAAc,GAAG,sBAAsB,CAAC;4BAC5C,MAAM,QAAA;4BACN,aAAa,EAAE,CAAC,YAAY,CAAC;4BAC7B,UAAU,EAAE,EAAE;yBACf,CAAC,CAAC;wBAEH,IAAI,CAAC,QAAQ,CAAC;4BACZ,cAAc,EAAE;gCACd,UAAU,YAAA;gCACV,cAAc,gBAAA;6BACf;4BACD,WAAW,EAAE,EAAE;yBAChB,CAAC,CAAC;wBAEiB,qBAAM,cAAc,CAAC;gCACvC,KAAK,EAAE,UAAU;gCACjB,cAAc,EAAE,cAAc;gCAC9B,YAAY,EAAE,cAAc;6BAC7B,CAAC,EAAA;;wBAJI,WAAW,GAAG,SAIlB;wBAEF,IAAI,CAAC,QAAQ,CAAC,UAAA,KAAK;4BACjB,OAAA,KAAK,CAAC,cAAc;gCACpB,KAAK,CAAC,cAAc,CAAC,UAAU,KAAK,UAAU;gCAC9C,KAAK,CAAC,cAAc,CAAC,cAAc,KAAK,cAAc;gCACpD,CAAC,CAAC,KAAK,CAAC,yDAAyD;gCACjE,CAAC,sBACM,KAAK,IACR,cAAc,EAAE,IAAI,EACpB,WAAW,EAAE,cAAc,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,WAAW,GACjF;wBARL,CAQK,CACN,CAAC;;;;aACH,CAAC;;IACJ,CAAC;IAzDQ,wCAAM,GAAb;QACQ,IAAA,eAA4C,EAA1C,kCAAc,EAAE,4BAAW,CAAgB;QAEnD,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;YACzB,oBAAoB,EAAE,cAAc,KAAK,IAAI;YAC7C,eAAe,EAAE,IAAI,CAAC,eAAe;YACrC,WAAW,aAAA;SACZ,CAAC,CAAC;IACL,CAAC;IAiDH,8BAAC;AAAD,CAAC,AAlED,CAA6C,KAAK,CAAC,SAAS,GAkE3D","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport React from 'react';\n\nimport { AutocompleteSuggestion, getAutocompleteProvider } from 'ui/autocomplete_providers';\nimport { StaticIndexPattern } from 'ui/index_patterns';\n\nimport { RendererFunction } from '../utils/typed_react';\n\ninterface WithKueryAutocompletionLifecycleProps {\n  children: RendererFunction<{\n    isLoadingSuggestions: boolean;\n    loadSuggestions: (expression: string, cursorPosition: number, maxSuggestions?: number) => void;\n    suggestions: AutocompleteSuggestion[];\n  }>;\n  indexPattern: StaticIndexPattern;\n}\n\ninterface WithKueryAutocompletionLifecycleState {\n  // lacking cancellation support in the autocompletion api,\n  // this is used to keep older, slower requests from clobbering newer ones\n  currentRequest: {\n    expression: string;\n    cursorPosition: number;\n  } | null;\n  suggestions: AutocompleteSuggestion[];\n}\n\nexport class WithKueryAutocompletion extends React.Component<\n  WithKueryAutocompletionLifecycleProps,\n  WithKueryAutocompletionLifecycleState\n> {\n  public readonly state: WithKueryAutocompletionLifecycleState = {\n    currentRequest: null,\n    suggestions: [],\n  };\n\n  public render() {\n    const { currentRequest, suggestions } = this.state;\n\n    return this.props.children({\n      isLoadingSuggestions: currentRequest !== null,\n      loadSuggestions: this.loadSuggestions,\n      suggestions,\n    });\n  }\n\n  private loadSuggestions = async (\n    expression: string,\n    cursorPosition: number,\n    maxSuggestions?: number\n  ) => {\n    const { indexPattern } = this.props;\n    const autocompletionProvider = getAutocompleteProvider('kuery');\n    const config = {\n      get: () => true,\n    };\n\n    if (!autocompletionProvider) {\n      return;\n    }\n\n    const getSuggestions = autocompletionProvider({\n      config,\n      indexPatterns: [indexPattern],\n      boolFilter: [],\n    });\n\n    this.setState({\n      currentRequest: {\n        expression,\n        cursorPosition,\n      },\n      suggestions: [],\n    });\n\n    const suggestions = await getSuggestions({\n      query: expression,\n      selectionStart: cursorPosition,\n      selectionEnd: cursorPosition,\n    });\n\n    this.setState(state =>\n      state.currentRequest &&\n      state.currentRequest.expression !== expression &&\n      state.currentRequest.cursorPosition !== cursorPosition\n        ? state // ignore this result, since a newer request is in flight\n        : {\n            ...state,\n            currentRequest: null,\n            suggestions: maxSuggestions ? suggestions.slice(0, maxSuggestions) : suggestions,\n          }\n    );\n  };\n}\n"]}]}