{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/apm/public/components/app/TransactionDetails/Transaction/WaterfallContainer/Waterfall/waterfall_helpers/waterfall_helpers.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/apm/public/components/app/TransactionDetails/Transaction/WaterfallContainer/Waterfall/waterfall_helpers/waterfall_helpers.ts","mtime":1567631711863},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { first, flatten, groupBy, indexBy, isEmpty, sortBy, uniq, zipObject } from 'lodash';\nimport { colors } from 'x-pack/plugins/apm/public/style/variables';\nfunction getTransactionItem(transaction) {\n    if (transaction.version === 'v1') {\n        return {\n            id: transaction.transaction.id,\n            serviceName: transaction.context.service.name,\n            name: transaction.transaction.name,\n            duration: transaction.transaction.duration.us,\n            timestamp: new Date(transaction['@timestamp']).getTime() * 1000,\n            offset: 0,\n            skew: 0,\n            docType: 'transaction',\n            transaction: transaction\n        };\n    }\n    return {\n        id: transaction.transaction.id,\n        parentId: transaction.parent && transaction.parent.id,\n        serviceName: transaction.context.service.name,\n        name: transaction.transaction.name,\n        duration: transaction.transaction.duration.us,\n        timestamp: transaction.timestamp.us,\n        offset: 0,\n        skew: 0,\n        docType: 'transaction',\n        transaction: transaction\n    };\n}\nfunction getSpanItem(span) {\n    if (span.version === 'v1') {\n        return {\n            id: span.span.id,\n            parentId: span.span.parent || span.transaction.id,\n            serviceName: span.context.service.name,\n            name: span.span.name,\n            duration: span.span.duration.us,\n            timestamp: new Date(span['@timestamp']).getTime() * 1000 + span.span.start.us,\n            offset: 0,\n            skew: 0,\n            docType: 'span',\n            span: span\n        };\n    }\n    return {\n        id: span.span.hex_id,\n        parentId: span.parent && span.parent.id,\n        serviceName: span.context.service.name,\n        name: span.span.name,\n        duration: span.span.duration.us,\n        timestamp: span.timestamp.us,\n        offset: 0,\n        skew: 0,\n        docType: 'span',\n        span: span\n    };\n}\nexport function getClockSkew(item, parentItem) {\n    if (!parentItem) {\n        return 0;\n    }\n    switch (item.docType) {\n        // don't calculate skew for spans. Just use parent's skew\n        case 'span':\n            return parentItem.skew;\n        // transaction is the inital entry in a service. Calculate skew for this, and it will be propogated to all child spans\n        case 'transaction': {\n            var parentStart = parentItem.timestamp + parentItem.skew;\n            var parentEnd = parentStart + parentItem.duration;\n            // determine if child starts before the parent\n            var offsetStart = parentStart - item.timestamp;\n            // determine if child starts after the parent has ended\n            var offsetEnd = item.timestamp - parentEnd;\n            // child transaction starts before parent OR\n            // child transaction starts after parent has ended\n            if (offsetStart > 0 || offsetEnd > 0) {\n                var latency = Math.max(parentItem.duration - item.duration, 0) / 2;\n                return offsetStart + latency;\n                // child transaction starts withing parent duration and no adjustment is needed\n            }\n            else {\n                return 0;\n            }\n        }\n    }\n}\nexport function getWaterfallItems(childrenByParentId, entryTransactionItem) {\n    var visitedWaterfallItemSet = new Set();\n    function getSortedChildren(item, parentItem) {\n        if (visitedWaterfallItemSet.has(item)) {\n            return [];\n        }\n        visitedWaterfallItemSet.add(item);\n        var children = sortBy(childrenByParentId[item.id] || [], 'timestamp');\n        item.childIds = children.map(function (child) { return child.id; });\n        item.offset = item.timestamp - entryTransactionItem.timestamp;\n        item.skew = getClockSkew(item, parentItem);\n        var deepChildren = flatten(children.map(function (child) { return getSortedChildren(child, item); }));\n        return tslib_1.__spread([item], deepChildren);\n    }\n    return getSortedChildren(entryTransactionItem);\n}\nfunction getTraceRoot(childrenByParentId) {\n    var item = first(childrenByParentId.root);\n    if (item && item.docType === 'transaction') {\n        return item.transaction;\n    }\n}\nfunction getServices(items) {\n    var serviceNames = items.map(function (item) { return item.serviceName; });\n    return uniq(serviceNames);\n}\nfunction getServiceColors(services) {\n    var assignedColors = [\n        colors.apmBlue,\n        colors.apmGreen,\n        colors.apmPurple,\n        colors.apmRed2,\n        colors.apmTan,\n        colors.apmOrange,\n        colors.apmYellow\n    ];\n    return zipObject(services, assignedColors);\n}\nfunction getDuration(items) {\n    var timestampStart = items[0].timestamp;\n    var timestampEnd = Math.max.apply(Math, tslib_1.__spread(items.map(function (item) { return item.timestamp + item.duration + item.skew; })));\n    return timestampEnd - timestampStart;\n}\nfunction createGetTransactionById(itemsById) {\n    return function (id) {\n        if (!id) {\n            return;\n        }\n        var item = itemsById[id];\n        if (item.docType === 'transaction') {\n            return item.transaction;\n        }\n    };\n}\nexport function getWaterfall(hits, entryTransaction) {\n    if (isEmpty(hits)) {\n        return {\n            services: [],\n            duration: 0,\n            items: [],\n            itemsById: {},\n            getTransactionById: function () { return undefined; },\n            serviceColors: {}\n        };\n    }\n    var filteredHits = hits\n        .filter(function (hit) {\n        var docType = hit.processor.event;\n        return ['span', 'transaction'].includes(docType);\n    })\n        .map(function (hit) {\n        var docType = hit.processor.event;\n        switch (docType) {\n            case 'span':\n                return getSpanItem(hit);\n            case 'transaction':\n                return getTransactionItem(hit);\n            default:\n                throw new Error(\"Unknown type \" + docType);\n        }\n    });\n    var childrenByParentId = groupBy(filteredHits, function (hit) {\n        return hit.parentId ? hit.parentId : 'root';\n    });\n    var entryTransactionItem = getTransactionItem(entryTransaction);\n    var itemsById = indexBy(filteredHits, 'id');\n    var items = getWaterfallItems(childrenByParentId, entryTransactionItem);\n    var traceRoot = getTraceRoot(childrenByParentId);\n    var duration = getDuration(items);\n    var traceRootDuration = traceRoot && traceRoot.transaction.duration.us;\n    var services = getServices(items);\n    var getTransactionById = createGetTransactionById(itemsById);\n    var serviceColors = getServiceColors(services);\n    return {\n        traceRoot: traceRoot,\n        traceRootDuration: traceRootDuration,\n        duration: duration,\n        services: services,\n        items: items,\n        itemsById: itemsById,\n        getTransactionById: getTransactionById,\n        serviceColors: serviceColors\n    };\n}\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/apm/public/components/app/TransactionDetails/Transaction/WaterfallContainer/Waterfall/waterfall_helpers/waterfall_helpers.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/apm/public/components/app/TransactionDetails/Transaction/WaterfallContainer/Waterfall/waterfall_helpers/waterfall_helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport {\n  first,\n  flatten,\n  groupBy,\n  indexBy,\n  isEmpty,\n  sortBy,\n  uniq,\n  zipObject\n} from 'lodash';\nimport { colors } from 'x-pack/plugins/apm/public/style/variables';\nimport { Span } from '../../../../../../../../typings/es_schemas/Span';\nimport { Transaction } from '../../../../../../../../typings/es_schemas/Transaction';\n\nexport interface IWaterfallIndex {\n  [key: string]: IWaterfallItem;\n}\n\nexport interface IWaterfallGroup {\n  [key: string]: IWaterfallItem[];\n}\n\nexport interface IWaterfall {\n  traceRoot?: Transaction;\n  traceRootDuration?: number;\n\n  /**\n   * Duration in us\n   */\n  duration: number;\n  services: string[];\n  items: IWaterfallItem[];\n  itemsById: IWaterfallIndex;\n  getTransactionById: (id?: IWaterfallItem['id']) => Transaction | undefined;\n  serviceColors: IServiceColors;\n}\n\ninterface IWaterfallItemBase {\n  id: string | number;\n  parentId?: string;\n  serviceName: string;\n  name: string;\n\n  /**\n   * Duration in us\n   */\n  duration: number;\n\n  /**\n   * start timestamp in us\n   */\n  timestamp: number;\n\n  /**\n   * offset from first item in us\n   */\n  offset: number;\n\n  /**\n   * skew from timestamp in us\n   */\n  skew: number;\n  childIds?: Array<IWaterfallItemBase['id']>;\n}\n\ninterface IWaterfallItemTransaction extends IWaterfallItemBase {\n  transaction: Transaction;\n  docType: 'transaction';\n}\n\ninterface IWaterfallItemSpan extends IWaterfallItemBase {\n  span: Span;\n  docType: 'span';\n}\n\nexport type IWaterfallItem = IWaterfallItemSpan | IWaterfallItemTransaction;\n\nfunction getTransactionItem(\n  transaction: Transaction\n): IWaterfallItemTransaction {\n  if (transaction.version === 'v1') {\n    return {\n      id: transaction.transaction.id,\n      serviceName: transaction.context.service.name,\n      name: transaction.transaction.name,\n      duration: transaction.transaction.duration.us,\n      timestamp: new Date(transaction['@timestamp']).getTime() * 1000,\n      offset: 0,\n      skew: 0,\n      docType: 'transaction',\n      transaction\n    };\n  }\n\n  return {\n    id: transaction.transaction.id,\n    parentId: transaction.parent && transaction.parent.id,\n    serviceName: transaction.context.service.name,\n    name: transaction.transaction.name,\n    duration: transaction.transaction.duration.us,\n    timestamp: transaction.timestamp.us,\n    offset: 0,\n    skew: 0,\n    docType: 'transaction',\n    transaction\n  };\n}\n\nfunction getSpanItem(span: Span): IWaterfallItemSpan {\n  if (span.version === 'v1') {\n    return {\n      id: span.span.id,\n      parentId: span.span.parent || span.transaction.id,\n      serviceName: span.context.service.name,\n      name: span.span.name,\n      duration: span.span.duration.us,\n      timestamp:\n        new Date(span['@timestamp']).getTime() * 1000 + span.span.start.us,\n      offset: 0,\n      skew: 0,\n      docType: 'span',\n      span\n    };\n  }\n\n  return {\n    id: span.span.hex_id,\n    parentId: span.parent && span.parent.id,\n    serviceName: span.context.service.name,\n    name: span.span.name,\n    duration: span.span.duration.us,\n    timestamp: span.timestamp.us,\n    offset: 0,\n    skew: 0,\n    docType: 'span',\n    span\n  };\n}\n\nexport function getClockSkew(\n  item: IWaterfallItem,\n  parentItem?: IWaterfallItem\n) {\n  if (!parentItem) {\n    return 0;\n  }\n\n  switch (item.docType) {\n    // don't calculate skew for spans. Just use parent's skew\n    case 'span':\n      return parentItem.skew;\n\n    // transaction is the inital entry in a service. Calculate skew for this, and it will be propogated to all child spans\n    case 'transaction': {\n      const parentStart = parentItem.timestamp + parentItem.skew;\n      const parentEnd = parentStart + parentItem.duration;\n\n      // determine if child starts before the parent\n      const offsetStart = parentStart - item.timestamp;\n\n      // determine if child starts after the parent has ended\n      const offsetEnd = item.timestamp - parentEnd;\n\n      // child transaction starts before parent OR\n      // child transaction starts after parent has ended\n      if (offsetStart > 0 || offsetEnd > 0) {\n        const latency = Math.max(parentItem.duration - item.duration, 0) / 2;\n        return offsetStart + latency;\n\n        // child transaction starts withing parent duration and no adjustment is needed\n      } else {\n        return 0;\n      }\n    }\n  }\n}\n\nexport function getWaterfallItems(\n  childrenByParentId: IWaterfallGroup,\n  entryTransactionItem: IWaterfallItem\n) {\n  const visitedWaterfallItemSet = new Set();\n  function getSortedChildren(\n    item: IWaterfallItem,\n    parentItem?: IWaterfallItem\n  ): IWaterfallItem[] {\n    if (visitedWaterfallItemSet.has(item)) {\n      return [];\n    }\n    visitedWaterfallItemSet.add(item);\n    const children = sortBy(childrenByParentId[item.id] || [], 'timestamp');\n\n    item.childIds = children.map(child => child.id);\n    item.offset = item.timestamp - entryTransactionItem.timestamp;\n    item.skew = getClockSkew(item, parentItem);\n\n    const deepChildren = flatten(\n      children.map(child => getSortedChildren(child, item))\n    );\n    return [item, ...deepChildren];\n  }\n\n  return getSortedChildren(entryTransactionItem);\n}\n\nfunction getTraceRoot(childrenByParentId: IWaterfallGroup) {\n  const item = first(childrenByParentId.root);\n  if (item && item.docType === 'transaction') {\n    return item.transaction;\n  }\n}\n\nfunction getServices(items: IWaterfallItem[]) {\n  const serviceNames = items.map(item => item.serviceName);\n  return uniq(serviceNames);\n}\n\nexport interface IServiceColors {\n  [key: string]: string;\n}\n\nfunction getServiceColors(services: string[]) {\n  const assignedColors = [\n    colors.apmBlue,\n    colors.apmGreen,\n    colors.apmPurple,\n    colors.apmRed2,\n    colors.apmTan,\n    colors.apmOrange,\n    colors.apmYellow\n  ];\n\n  return zipObject(services, assignedColors) as IServiceColors;\n}\n\nfunction getDuration(items: IWaterfallItem[]) {\n  const timestampStart = items[0].timestamp;\n  const timestampEnd = Math.max(\n    ...items.map(item => item.timestamp + item.duration + item.skew)\n  );\n  return timestampEnd - timestampStart;\n}\n\nfunction createGetTransactionById(itemsById: IWaterfallIndex) {\n  return (id?: IWaterfallItem['id']) => {\n    if (!id) {\n      return;\n    }\n\n    const item = itemsById[id];\n    if (item.docType === 'transaction') {\n      return item.transaction;\n    }\n  };\n}\n\nexport function getWaterfall(\n  hits: Array<Span | Transaction>,\n  entryTransaction: Transaction\n): IWaterfall {\n  if (isEmpty(hits)) {\n    return {\n      services: [],\n      duration: 0,\n      items: [],\n      itemsById: {},\n      getTransactionById: () => undefined,\n      serviceColors: {}\n    };\n  }\n\n  const filteredHits = hits\n    .filter(hit => {\n      const docType = hit.processor.event;\n      return ['span', 'transaction'].includes(docType);\n    })\n    .map(hit => {\n      const docType = hit.processor.event;\n      switch (docType) {\n        case 'span':\n          return getSpanItem(hit as Span);\n        case 'transaction':\n          return getTransactionItem(hit as Transaction);\n        default:\n          throw new Error(`Unknown type ${docType}`);\n      }\n    });\n\n  const childrenByParentId = groupBy(filteredHits, hit =>\n    hit.parentId ? hit.parentId : 'root'\n  );\n  const entryTransactionItem = getTransactionItem(entryTransaction);\n  const itemsById: IWaterfallIndex = indexBy(filteredHits, 'id');\n  const items = getWaterfallItems(childrenByParentId, entryTransactionItem);\n  const traceRoot = getTraceRoot(childrenByParentId);\n  const duration = getDuration(items);\n  const traceRootDuration = traceRoot && traceRoot.transaction.duration.us;\n  const services = getServices(items);\n  const getTransactionById = createGetTransactionById(itemsById);\n  const serviceColors = getServiceColors(services);\n\n  return {\n    traceRoot,\n    traceRootDuration,\n    duration,\n    services,\n    items,\n    itemsById,\n    getTransactionById,\n    serviceColors\n  };\n}\n"]}]}