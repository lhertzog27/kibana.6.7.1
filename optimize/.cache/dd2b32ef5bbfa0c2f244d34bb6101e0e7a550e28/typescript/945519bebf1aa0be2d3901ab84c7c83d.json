{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/logging/log_text_stream/vertical_scroll_panel.tsx","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/logging/log_text_stream/vertical_scroll_panel.tsx","mtime":1567631711981},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { bisector } from 'd3-array';\nimport sortBy from 'lodash/fp/sortBy';\nimport throttle from 'lodash/fp/throttle';\nimport * as React from 'react';\nimport styled from 'styled-components';\nvar SCROLL_THROTTLE_INTERVAL = 250;\nvar ASSUMED_SCROLLBAR_WIDTH = 20;\nvar VerticalScrollPanel = /** @class */ (function (_super) {\n    tslib_1.__extends(VerticalScrollPanel, _super);\n    function VerticalScrollPanel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.scrollRef = React.createRef();\n        _this.childRefs = new Map();\n        _this.childDimensions = new Map();\n        _this.handleScroll = throttle(SCROLL_THROTTLE_INTERVAL, function () {\n            _this.reportVisibleChildren();\n        });\n        _this.registerChild = function (key, element) {\n            if (element === null) {\n                _this.childRefs.delete(key);\n            }\n            else {\n                _this.childRefs.set(key, element);\n            }\n        };\n        _this.updateChildDimensions = function () {\n            _this.childDimensions = new Map(sortDimensionsByTop(Array.from(_this.childRefs.entries()).reduce(function (accumulatedDimensions, _a) {\n                var _b = tslib_1.__read(_a, 2), key = _b[0], child = _b[1];\n                var currentOffsetRect = child.getOffsetRect();\n                if (currentOffsetRect !== null) {\n                    accumulatedDimensions.push([key, currentOffsetRect]);\n                }\n                return accumulatedDimensions;\n            }, [])));\n        };\n        _this.getVisibleChildren = function () {\n            if (_this.scrollRef.current === null || _this.childDimensions.size <= 0) {\n                return;\n            }\n            var _a = _this, childDimensions = _a.childDimensions, scrollViewHeight = _a.props.height, scrollTop = _a.scrollRef.current.scrollTop;\n            return getVisibleChildren(Array.from(childDimensions.entries()), scrollViewHeight, scrollTop);\n        };\n        _this.getScrollPosition = function () {\n            if (_this.scrollRef.current === null) {\n                return;\n            }\n            var _a = _this, scrollViewHeight = _a.props.height, _b = _a.scrollRef.current, scrollHeight = _b.scrollHeight, scrollTop = _b.scrollTop;\n            return {\n                pagesAbove: scrollTop / scrollViewHeight,\n                pagesBelow: (scrollHeight - scrollTop - scrollViewHeight) / scrollViewHeight,\n            };\n        };\n        _this.reportVisibleChildren = function () {\n            var onVisibleChildrenChange = _this.props.onVisibleChildrenChange;\n            var visibleChildren = _this.getVisibleChildren();\n            var scrollPosition = _this.getScrollPosition();\n            if (!visibleChildren || !scrollPosition || typeof onVisibleChildrenChange !== 'function') {\n                return;\n            }\n            onVisibleChildrenChange(tslib_1.__assign({ bottomChild: visibleChildren.bottomChild, middleChild: visibleChildren.middleChild, topChild: visibleChildren.topChild }, scrollPosition));\n        };\n        _this.centerTarget = function (target, offset) {\n            var _a = _this, scrollViewHeight = _a.props.height, childDimensions = _a.childDimensions, scrollRef = _a.scrollRef;\n            if (scrollRef.current === null || !target || childDimensions.size <= 0) {\n                return;\n            }\n            var targetDimensions = childDimensions.get(target);\n            if (targetDimensions) {\n                var targetOffset = typeof offset === 'undefined' ? targetDimensions.height / 2 : offset;\n                scrollRef.current.scrollTop = targetDimensions.top + targetOffset - scrollViewHeight / 2;\n            }\n        };\n        _this.handleUpdatedChildren = function (target, offset) {\n            _this.updateChildDimensions();\n            if (!!target) {\n                _this.centerTarget(target, offset);\n            }\n            _this.reportVisibleChildren();\n        };\n        return _this;\n    }\n    VerticalScrollPanel.prototype.componentDidMount = function () {\n        this.handleUpdatedChildren(this.props.target, undefined);\n    };\n    VerticalScrollPanel.prototype.getSnapshotBeforeUpdate = function (prevProps) {\n        if (prevProps.target !== this.props.target && this.props.target) {\n            return {\n                scrollOffset: undefined,\n                scrollTarget: this.props.target,\n            };\n        }\n        else {\n            var visibleChildren = this.getVisibleChildren();\n            if (visibleChildren) {\n                return {\n                    scrollOffset: visibleChildren.middleChildOffset,\n                    scrollTarget: visibleChildren.middleChild,\n                };\n            }\n        }\n        return {\n            scrollOffset: undefined,\n            scrollTarget: undefined,\n        };\n    };\n    VerticalScrollPanel.prototype.componentDidUpdate = function (prevProps, prevState, snapshot) {\n        this.handleUpdatedChildren(snapshot.scrollTarget, snapshot.scrollOffset);\n    };\n    VerticalScrollPanel.prototype.componentWillUnmount = function () {\n        this.childRefs.clear();\n    };\n    VerticalScrollPanel.prototype.render = function () {\n        var _a = this.props, children = _a.children, height = _a.height, width = _a.width, hideScrollbar = _a.hideScrollbar;\n        var scrollbarOffset = hideScrollbar ? ASSUMED_SCROLLBAR_WIDTH : 0;\n        return (React.createElement(ScrollPanelWrapper, { style: { height: height, width: width + scrollbarOffset }, scrollbarOffset: scrollbarOffset, onScroll: this.handleScroll, innerRef: \n            /* workaround for missing RefObject support in styled-components typings */\n            this.scrollRef }, typeof children === 'function' ? children(this.registerChild) : null));\n    };\n    VerticalScrollPanel.defaultProps = {\n        hideScrollbar: false,\n    };\n    return VerticalScrollPanel;\n}(React.PureComponent));\nexport { VerticalScrollPanel };\nvar ScrollPanelWrapper = styled.div.attrs({})(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n  overflow-x: hidden;\\n  overflow-y: scroll;\\n  position: relative;\\n  padding-right: \", \"px;\\n\\n  & * {\\n    overflow-anchor: none;\\n  }\\n\"], [\"\\n  overflow-x: hidden;\\n  overflow-y: scroll;\\n  position: relative;\\n  padding-right: \", \"px;\\n\\n  & * {\\n    overflow-anchor: none;\\n  }\\n\"])), function (props) { return props.scrollbarOffset || 0; });\nvar getVisibleChildren = function (childDimensions, scrollViewHeight, scrollTop) {\n    var middleChildIndex = Math.min(getChildIndexBefore(childDimensions, scrollTop + scrollViewHeight / 2), childDimensions.length - 1);\n    var topChildIndex = Math.min(getChildIndexBefore(childDimensions, scrollTop, 0, middleChildIndex), childDimensions.length - 1);\n    var bottomChildIndex = Math.min(getChildIndexBefore(childDimensions, scrollTop + scrollViewHeight, middleChildIndex), childDimensions.length - 1);\n    return {\n        bottomChild: childDimensions[bottomChildIndex][0],\n        bottomChildOffset: childDimensions[bottomChildIndex][1].top - scrollTop - scrollViewHeight,\n        middleChild: childDimensions[middleChildIndex][0],\n        middleChildOffset: scrollTop + scrollViewHeight / 2 - childDimensions[middleChildIndex][1].top,\n        topChild: childDimensions[topChildIndex][0],\n        topChildOffset: childDimensions[topChildIndex][1].top - scrollTop,\n    };\n};\nvar sortDimensionsByTop = sortBy('1.top');\nvar getChildIndexBefore = bisector(function (_a) {\n    var _b = tslib_1.__read(_a, 2), key = _b[0], rect = _b[1];\n    return rect.top + rect.height;\n})\n    .left;\nvar templateObject_1;\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/logging/log_text_stream/vertical_scroll_panel.tsx","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/logging/log_text_stream/vertical_scroll_panel.tsx"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport { bisector } from 'd3-array';\nimport sortBy from 'lodash/fp/sortBy';\nimport throttle from 'lodash/fp/throttle';\nimport * as React from 'react';\nimport styled from 'styled-components';\n\nimport { Rect } from './measurable_item_view';\n\ninterface VerticalScrollPanelProps<Child> {\n  children?: (\n    registerChild: (key: Child, element: MeasurableChild | null) => void\n  ) => React.ReactNode;\n  onVisibleChildrenChange?: (\n    visibleChildren: {\n      topChild: Child;\n      middleChild: Child;\n      bottomChild: Child;\n      pagesAbove: number;\n      pagesBelow: number;\n    }\n  ) => void;\n  target: Child | undefined;\n  height: number;\n  width: number;\n  hideScrollbar?: boolean;\n}\n\ninterface VerticalScrollPanelSnapshot<Child> {\n  scrollTarget: Child | undefined;\n  scrollOffset: number | undefined;\n}\n\ninterface MeasurableChild {\n  getOffsetRect(): Rect | null;\n}\n\nconst SCROLL_THROTTLE_INTERVAL = 250;\nconst ASSUMED_SCROLLBAR_WIDTH = 20;\n\nexport class VerticalScrollPanel<Child> extends React.PureComponent<\n  VerticalScrollPanelProps<Child>\n> {\n  public static defaultProps: Partial<VerticalScrollPanelProps<any>> = {\n    hideScrollbar: false,\n  };\n\n  public scrollRef = React.createRef<HTMLDivElement>();\n  public childRefs = new Map<Child, MeasurableChild>();\n  public childDimensions = new Map<Child, Rect>();\n\n  public handleScroll: React.UIEventHandler<HTMLDivElement> = throttle(\n    SCROLL_THROTTLE_INTERVAL,\n    () => {\n      this.reportVisibleChildren();\n    }\n  );\n\n  public registerChild = (key: any, element: MeasurableChild | null) => {\n    if (element === null) {\n      this.childRefs.delete(key);\n    } else {\n      this.childRefs.set(key, element);\n    }\n  };\n\n  public updateChildDimensions = () => {\n    this.childDimensions = new Map<Child, Rect>(\n      sortDimensionsByTop(\n        Array.from(this.childRefs.entries()).reduce(\n          (accumulatedDimensions, [key, child]) => {\n            const currentOffsetRect = child.getOffsetRect();\n\n            if (currentOffsetRect !== null) {\n              accumulatedDimensions.push([key, currentOffsetRect]);\n            }\n\n            return accumulatedDimensions;\n          },\n          [] as Array<[any, Rect]>\n        )\n      )\n    );\n  };\n\n  public getVisibleChildren = () => {\n    if (this.scrollRef.current === null || this.childDimensions.size <= 0) {\n      return;\n    }\n\n    const {\n      childDimensions,\n      props: { height: scrollViewHeight },\n      scrollRef: {\n        current: { scrollTop },\n      },\n    } = this;\n\n    return getVisibleChildren(Array.from(childDimensions.entries()), scrollViewHeight, scrollTop);\n  };\n\n  public getScrollPosition = () => {\n    if (this.scrollRef.current === null) {\n      return;\n    }\n\n    const {\n      props: { height: scrollViewHeight },\n      scrollRef: {\n        current: { scrollHeight, scrollTop },\n      },\n    } = this;\n\n    return {\n      pagesAbove: scrollTop / scrollViewHeight,\n      pagesBelow: (scrollHeight - scrollTop - scrollViewHeight) / scrollViewHeight,\n    };\n  };\n\n  public reportVisibleChildren = () => {\n    const { onVisibleChildrenChange } = this.props;\n    const visibleChildren = this.getVisibleChildren();\n    const scrollPosition = this.getScrollPosition();\n\n    if (!visibleChildren || !scrollPosition || typeof onVisibleChildrenChange !== 'function') {\n      return;\n    }\n\n    onVisibleChildrenChange({\n      bottomChild: visibleChildren.bottomChild,\n      middleChild: visibleChildren.middleChild,\n      topChild: visibleChildren.topChild,\n      ...scrollPosition,\n    });\n  };\n\n  public centerTarget = (target: Child, offset?: number) => {\n    const {\n      props: { height: scrollViewHeight },\n      childDimensions,\n      scrollRef,\n    } = this;\n\n    if (scrollRef.current === null || !target || childDimensions.size <= 0) {\n      return;\n    }\n\n    const targetDimensions = childDimensions.get(target);\n\n    if (targetDimensions) {\n      const targetOffset = typeof offset === 'undefined' ? targetDimensions.height / 2 : offset;\n      scrollRef.current.scrollTop = targetDimensions.top + targetOffset - scrollViewHeight / 2;\n    }\n  };\n\n  public handleUpdatedChildren = (target: Child | undefined, offset: number | undefined) => {\n    this.updateChildDimensions();\n    if (!!target) {\n      this.centerTarget(target, offset);\n    }\n    this.reportVisibleChildren();\n  };\n\n  public componentDidMount() {\n    this.handleUpdatedChildren(this.props.target, undefined);\n  }\n\n  public getSnapshotBeforeUpdate(\n    prevProps: VerticalScrollPanelProps<Child>\n  ): VerticalScrollPanelSnapshot<Child> {\n    if (prevProps.target !== this.props.target && this.props.target) {\n      return {\n        scrollOffset: undefined,\n        scrollTarget: this.props.target,\n      };\n    } else {\n      const visibleChildren = this.getVisibleChildren();\n\n      if (visibleChildren) {\n        return {\n          scrollOffset: visibleChildren.middleChildOffset,\n          scrollTarget: visibleChildren.middleChild,\n        };\n      }\n    }\n\n    return {\n      scrollOffset: undefined,\n      scrollTarget: undefined,\n    };\n  }\n\n  public componentDidUpdate(\n    prevProps: VerticalScrollPanelProps<Child>,\n    prevState: {},\n    snapshot: VerticalScrollPanelSnapshot<Child>\n  ) {\n    this.handleUpdatedChildren(snapshot.scrollTarget, snapshot.scrollOffset);\n  }\n\n  public componentWillUnmount() {\n    this.childRefs.clear();\n  }\n\n  public render() {\n    const { children, height, width, hideScrollbar } = this.props;\n    const scrollbarOffset = hideScrollbar ? ASSUMED_SCROLLBAR_WIDTH : 0;\n\n    return (\n      <ScrollPanelWrapper\n        style={{ height, width: width + scrollbarOffset }}\n        scrollbarOffset={scrollbarOffset}\n        onScroll={this.handleScroll}\n        innerRef={\n          /* workaround for missing RefObject support in styled-components typings */\n          this.scrollRef as any\n        }\n      >\n        {typeof children === 'function' ? children(this.registerChild) : null}\n      </ScrollPanelWrapper>\n    );\n  }\n}\n\nconst ScrollPanelWrapper = styled.div.attrs<{ scrollbarOffset?: number }>({})`\n  overflow-x: hidden;\n  overflow-y: scroll;\n  position: relative;\n  padding-right: ${props => props.scrollbarOffset || 0}px;\n\n  & * {\n    overflow-anchor: none;\n  }\n`;\n\nconst getVisibleChildren = <Child extends {}>(\n  childDimensions: Array<[Child, Rect]>,\n  scrollViewHeight: number,\n  scrollTop: number\n) => {\n  const middleChildIndex = Math.min(\n    getChildIndexBefore(childDimensions, scrollTop + scrollViewHeight / 2),\n    childDimensions.length - 1\n  );\n\n  const topChildIndex = Math.min(\n    getChildIndexBefore(childDimensions, scrollTop, 0, middleChildIndex),\n    childDimensions.length - 1\n  );\n\n  const bottomChildIndex = Math.min(\n    getChildIndexBefore(childDimensions, scrollTop + scrollViewHeight, middleChildIndex),\n    childDimensions.length - 1\n  );\n\n  return {\n    bottomChild: childDimensions[bottomChildIndex][0],\n    bottomChildOffset: childDimensions[bottomChildIndex][1].top - scrollTop - scrollViewHeight,\n    middleChild: childDimensions[middleChildIndex][0],\n    middleChildOffset: scrollTop + scrollViewHeight / 2 - childDimensions[middleChildIndex][1].top,\n    topChild: childDimensions[topChildIndex][0],\n    topChildOffset: childDimensions[topChildIndex][1].top - scrollTop,\n  };\n};\n\nconst sortDimensionsByTop = sortBy<[any, Rect]>('1.top');\n\nconst getChildIndexBefore = bisector<[any, Rect], number>(([key, rect]) => rect.top + rect.height)\n  .left;\n"]}]}