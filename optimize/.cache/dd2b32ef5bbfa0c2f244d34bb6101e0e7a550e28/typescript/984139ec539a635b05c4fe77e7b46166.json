{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/lib/configuration_blocks.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/lib/configuration_blocks.ts","mtime":1567631711883},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport * as tslib_1 from \"tslib\";\nimport yaml from 'js-yaml';\nimport { get, has, omit, set } from 'lodash';\nvar ConfigBlocksLib = /** @class */ (function () {\n    function ConfigBlocksLib(adapter, configSchemas) {\n        var _this = this;\n        this.adapter = adapter;\n        this.configSchemas = configSchemas;\n        this.delete = this.adapter.delete.bind(this.adapter);\n        this.upsert = function (blocks) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.adapter.upsert(this.userConfigsToJson(blocks))];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        }); };\n        this.getForTags = function (tagIds, page) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            var result;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.adapter.getForTags(tagIds, page)];\n                    case 1:\n                        result = _a.sent();\n                        result.blocks = this.jsonConfigToUserYaml(result.blocks);\n                        return [2 /*return*/, result];\n                }\n            });\n        }); };\n    }\n    ConfigBlocksLib.prototype.jsonConfigToUserYaml = function (blocks) {\n        var _this = this;\n        // configuration_blocks yaml, JS cant read YAML so we parse it into JS,\n        // because beats flattens all fields, and we need more structure.\n        // we take tagConfigs, grab the config that applies here, render what we can into\n        // an object, and the rest we assume to be the yaml string that goes\n        // into the yaml editor...\n        // NOTE: The perk of this, is that as we support more features via controls\n        // vs yaml editing, it should \"just work\", and things that were in YAML\n        // will now be in the UI forms...\n        return blocks.map(function (block) {\n            var type = block.type, config = block.config;\n            var thisConfigSchema = _this.configSchemas.find(function (conf) { return conf.id === type; });\n            var thisConfigBlockSchema = thisConfigSchema ? thisConfigSchema.configs : null;\n            if (!thisConfigBlockSchema) {\n                throw new Error('No config block schema ');\n            }\n            var knownConfigIds = thisConfigBlockSchema.map(function (schema) { return schema.id; });\n            var convertedConfig = knownConfigIds.reduce(function (blockObj, configKey, index) {\n                var unhydratedKey = knownConfigIds[index];\n                set(blockObj, configKey, get(config, unhydratedKey));\n                return blockObj;\n            }, thisConfigSchema && thisConfigSchema.allowOtherConfigs\n                ? { other: yaml.safeDump(omit(config, knownConfigIds)) }\n                : {});\n            // Workaround to empty object passed into dump resulting in this odd output\n            if (convertedConfig.other && convertedConfig.other === '{}\\n') {\n                convertedConfig.other = '';\n            }\n            return tslib_1.__assign({}, block, { config: convertedConfig });\n        });\n    };\n    ConfigBlocksLib.prototype.userConfigsToJson = function (blocks) {\n        var _this = this;\n        // configurations is the JS representation of the config yaml,\n        // so here we take that JS and convert it into a YAML string.\n        // we do so while also flattening \"other\" into the flat yaml beats expect\n        return blocks.map(function (block) {\n            var _a;\n            var type = block.type, config = block.config;\n            var thisConfigSchema = _this.configSchemas.find(function (conf) { return conf.id === type; });\n            var thisConfigBlockSchema = thisConfigSchema ? thisConfigSchema.configs : null;\n            if (!thisConfigBlockSchema) {\n                throw new Error('No config block schema ');\n            }\n            var knownConfigIds = thisConfigBlockSchema\n                .map(function (schema) { return schema.id; })\n                .filter(function (id) { return id !== 'other'; });\n            var picked = _this.pickDeep(config, knownConfigIds);\n            var other = yaml.safeLoad(config.other || '{}');\n            if (typeof other === 'string') {\n                other = (_a = {},\n                    _a[other] = '',\n                    _a);\n            }\n            var convertedConfig = tslib_1.__assign({}, other, picked);\n            return tslib_1.__assign({}, block, { config: convertedConfig });\n        });\n    };\n    ConfigBlocksLib.prototype.pickDeep = function (obj, keys) {\n        var copy = {};\n        keys.forEach(function (key) {\n            if (has(obj, key)) {\n                var val = get(obj, key);\n                set(copy, key, val);\n            }\n        });\n        return copy;\n    };\n    return ConfigBlocksLib;\n}());\nexport { ConfigBlocksLib };\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/lib/configuration_blocks.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/beats_management/public/lib/configuration_blocks.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport yaml from 'js-yaml';\nimport { get, has, omit, set } from 'lodash';\nimport { ConfigBlockSchema, ConfigurationBlock } from '../../common/domain_types';\nimport { FrontendConfigBlocksAdapter } from './adapters/configuration_blocks/adapter_types';\n\nexport class ConfigBlocksLib {\n  public delete = this.adapter.delete.bind(this.adapter);\n\n  constructor(\n    private readonly adapter: FrontendConfigBlocksAdapter,\n    private readonly configSchemas: ConfigBlockSchema[]\n  ) {}\n\n  public upsert = async (blocks: ConfigurationBlock[]) => {\n    return await this.adapter.upsert(this.userConfigsToJson(blocks));\n  };\n\n  public getForTags = async (tagIds: string[], page: number) => {\n    const result = await this.adapter.getForTags(tagIds, page);\n    result.blocks = this.jsonConfigToUserYaml(result.blocks);\n    return result;\n  };\n\n  public jsonConfigToUserYaml(blocks: ConfigurationBlock[]): ConfigurationBlock[] {\n    // configuration_blocks yaml, JS cant read YAML so we parse it into JS,\n    // because beats flattens all fields, and we need more structure.\n    // we take tagConfigs, grab the config that applies here, render what we can into\n    // an object, and the rest we assume to be the yaml string that goes\n    // into the yaml editor...\n    // NOTE: The perk of this, is that as we support more features via controls\n    // vs yaml editing, it should \"just work\", and things that were in YAML\n    // will now be in the UI forms...\n    return blocks.map(block => {\n      const { type, config } = block;\n\n      const thisConfigSchema = this.configSchemas.find(conf => conf.id === type);\n      const thisConfigBlockSchema = thisConfigSchema ? thisConfigSchema.configs : null;\n      if (!thisConfigBlockSchema) {\n        throw new Error('No config block schema ');\n      }\n\n      const knownConfigIds: string[] = thisConfigBlockSchema.map(schema => schema.id);\n\n      const convertedConfig: ConfigurationBlock['config'] = knownConfigIds.reduce(\n        (blockObj: any, configKey: string, index: number) => {\n          const unhydratedKey = knownConfigIds[index];\n\n          set(blockObj, configKey, get(config, unhydratedKey));\n\n          return blockObj;\n        },\n        thisConfigSchema && thisConfigSchema.allowOtherConfigs\n          ? { other: yaml.safeDump(omit(config, knownConfigIds)) }\n          : {}\n      );\n\n      // Workaround to empty object passed into dump resulting in this odd output\n      if (convertedConfig.other && convertedConfig.other === '{}\\n') {\n        convertedConfig.other = '';\n      }\n\n      return {\n        ...block,\n        config: convertedConfig,\n      };\n    });\n  }\n\n  public userConfigsToJson(blocks: ConfigurationBlock[]): ConfigurationBlock[] {\n    // configurations is the JS representation of the config yaml,\n    // so here we take that JS and convert it into a YAML string.\n    // we do so while also flattening \"other\" into the flat yaml beats expect\n    return blocks.map(block => {\n      const { type, config } = block;\n      const thisConfigSchema = this.configSchemas.find(conf => conf.id === type);\n      const thisConfigBlockSchema = thisConfigSchema ? thisConfigSchema.configs : null;\n      if (!thisConfigBlockSchema) {\n        throw new Error('No config block schema ');\n      }\n      const knownConfigIds = thisConfigBlockSchema\n        .map((schema: ConfigurationBlock['config']) => schema.id)\n        .filter((id: string) => id !== 'other');\n\n      const picked = this.pickDeep(config, knownConfigIds);\n      let other = yaml.safeLoad(config.other || '{}');\n      if (typeof other === 'string') {\n        other = {\n          [other]: '',\n        };\n      }\n\n      const convertedConfig = {\n        ...other,\n        ...picked,\n      };\n\n      return {\n        ...block,\n        config: convertedConfig,\n      };\n    });\n  }\n\n  private pickDeep(obj: { [key: string]: any }, keys: string[]) {\n    const copy = {};\n    keys.forEach(key => {\n      if (has(obj, key)) {\n        const val = get(obj, key);\n        set(copy, key, val);\n      }\n    });\n    return copy;\n  }\n}\n"]}]}