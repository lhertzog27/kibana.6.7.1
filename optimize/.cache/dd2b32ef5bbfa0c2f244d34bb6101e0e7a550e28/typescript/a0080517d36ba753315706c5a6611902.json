{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/src/ui/public/kfetch/kfetch.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/ui/public/kfetch/kfetch.ts","mtime":1567631711742},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { merge } from 'lodash';\n// @ts-ignore not really worth typing\nimport { metadata } from 'ui/metadata';\nimport url from 'url';\nimport chrome from '../chrome';\nimport { KFetchError } from './kfetch_error';\nvar interceptors = [];\nexport var resetInterceptors = function () { return (interceptors.length = 0); };\nexport var addInterceptor = function (interceptor) { return interceptors.push(interceptor); };\nexport function kfetch(options, _a) {\n    var _b = (_a === void 0 ? {} : _a).prependBasePath, prependBasePath = _b === void 0 ? true : _b;\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n        var combinedOptions, promise;\n        var _this = this;\n        return tslib_1.__generator(this, function (_c) {\n            combinedOptions = withDefaultOptions(options);\n            promise = requestInterceptors(combinedOptions).then(function (_a) {\n                var pathname = _a.pathname, query = _a.query, restOptions = tslib_1.__rest(_a, [\"pathname\", \"query\"]);\n                var fullUrl = url.format({\n                    pathname: prependBasePath ? chrome.addBasePath(pathname) : pathname,\n                    query: query,\n                });\n                return window.fetch(fullUrl, restOptions).then(function (res) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                    var body;\n                    return tslib_1.__generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0: return [4 /*yield*/, getBodyAsJson(res)];\n                            case 1:\n                                body = _a.sent();\n                                if (res.ok) {\n                                    return [2 /*return*/, body];\n                                }\n                                throw new KFetchError(res, body);\n                        }\n                    });\n                }); });\n            });\n            return [2 /*return*/, responseInterceptors(promise)];\n        });\n    });\n}\n// Request/response interceptors are called in opposite orders.\n// Request hooks start from the newest interceptor and end with the oldest.\nfunction requestInterceptors(config) {\n    return interceptors.reduceRight(function (acc, interceptor) {\n        return acc.then(interceptor.request, interceptor.requestError);\n    }, Promise.resolve(config));\n}\n// Response hooks start from the oldest interceptor and end with the newest.\nfunction responseInterceptors(responsePromise) {\n    return interceptors.reduce(function (acc, interceptor) {\n        return acc.then(interceptor.response, interceptor.responseError);\n    }, responsePromise);\n}\nfunction getBodyAsJson(res) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n        var e_1;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, res.json()];\n                case 1: return [2 /*return*/, _a.sent()];\n                case 2:\n                    e_1 = _a.sent();\n                    return [2 /*return*/, null];\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\nexport function withDefaultOptions(options) {\n    return merge({\n        method: 'GET',\n        credentials: 'same-origin',\n        headers: {\n            'Content-Type': 'application/json',\n            'kbn-version': metadata.version,\n        },\n    }, options);\n}\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/src/ui/public/kfetch/kfetch.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/src/ui/public/kfetch/kfetch.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;GAiBG;;AAEH,OAAO,EAAE,KAAK,EAAE,MAAM,QAAQ,CAAC;AAC/B,qCAAqC;AACrC,OAAO,EAAE,QAAQ,EAAE,MAAM,aAAa,CAAC;AACvC,OAAO,GAAG,MAAM,KAAK,CAAC;AACtB,OAAO,MAAM,MAAM,WAAW,CAAC;AAC/B,OAAO,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAsB7C,IAAM,YAAY,GAAkB,EAAE,CAAC;AACvC,MAAM,CAAC,IAAM,iBAAiB,GAAG,cAAM,OAAA,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,EAAzB,CAAyB,CAAC;AACjE,MAAM,CAAC,IAAM,cAAc,GAAG,UAAC,WAAwB,IAAK,OAAA,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,EAA9B,CAA8B,CAAC;AAE3F,MAAM,UAAgB,MAAM,CAC1B,OAAsB,EACtB,EAAoD;QAAlD,8CAAsB,EAAtB,2CAAsB;;;;;YAElB,eAAe,GAAG,kBAAkB,CAAC,OAAO,CAAC,CAAC;YAC9C,OAAO,GAAG,mBAAmB,CAAC,eAAe,CAAC,CAAC,IAAI,CACvD,UAAC,EAAmC;gBAAjC,IAAA,sBAAQ,EAAE,gBAAK,EAAE,uDAAc;gBAChC,IAAM,OAAO,GAAG,GAAG,CAAC,MAAM,CAAC;oBACzB,QAAQ,EAAE,eAAe,CAAC,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ;oBACnE,KAAK,OAAA;iBACN,CAAC,CAAC;gBAEH,OAAO,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC,IAAI,CAAC,UAAM,GAAG;;;;oCACzC,qBAAM,aAAa,CAAC,GAAG,CAAC,EAAA;;gCAA/B,IAAI,GAAG,SAAwB;gCACrC,IAAI,GAAG,CAAC,EAAE,EAAE;oCACV,sBAAO,IAAI,EAAC;iCACb;gCACD,MAAM,IAAI,WAAW,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;;;qBAClC,CAAC,CAAC;YACL,CAAC,CACF,CAAC;YAEF,sBAAO,oBAAoB,CAAC,OAAO,CAAC,EAAC;;;CACtC;AAED,+DAA+D;AAC/D,2EAA2E;AAC3E,SAAS,mBAAmB,CAAC,MAAqB;IAChD,OAAO,YAAY,CAAC,WAAW,CAAC,UAAC,GAAG,EAAE,WAAW;QAC/C,OAAO,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,WAAW,CAAC,YAAY,CAAC,CAAC;IACjE,CAAC,EAAE,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;AAC9B,CAAC;AAED,4EAA4E;AAC5E,SAAS,oBAAoB,CAAC,eAA6B;IACzD,OAAO,YAAY,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,WAAW;QAC1C,OAAO,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,WAAW,CAAC,aAAa,CAAC,CAAC;IACnE,CAAC,EAAE,eAAe,CAAC,CAAC;AACtB,CAAC;AAED,SAAe,aAAa,CAAC,GAAa;;;;;;;oBAE/B,qBAAM,GAAG,CAAC,IAAI,EAAE,EAAA;wBAAvB,sBAAO,SAAgB,EAAC;;;oBAExB,sBAAO,IAAI,EAAC;;;;;CAEf;AAED,MAAM,UAAU,kBAAkB,CAAC,OAAuB;IACxD,OAAO,KAAK,CACV;QACE,MAAM,EAAE,KAAK;QACb,WAAW,EAAE,aAAa;QAC1B,OAAO,EAAE;YACP,cAAc,EAAE,kBAAkB;YAClC,aAAa,EAAE,QAAQ,CAAC,OAAO;SAChC;KACF,EACD,OAAO,CACR,CAAC;AACJ,CAAC","sourcesContent":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { merge } from 'lodash';\n// @ts-ignore not really worth typing\nimport { metadata } from 'ui/metadata';\nimport url from 'url';\nimport chrome from '../chrome';\nimport { KFetchError } from './kfetch_error';\n\ninterface KFetchQuery {\n  [key: string]: string | number | boolean | undefined;\n}\n\nexport interface KFetchOptions extends RequestInit {\n  pathname?: string;\n  query?: KFetchQuery;\n}\n\nexport interface KFetchKibanaOptions {\n  prependBasePath?: boolean;\n}\n\nexport interface Interceptor {\n  request?: (config: KFetchOptions) => Promise<KFetchOptions> | KFetchOptions;\n  requestError?: (e: any) => Promise<KFetchOptions> | KFetchOptions;\n  response?: (res: any) => any;\n  responseError?: (e: any) => any;\n}\n\nconst interceptors: Interceptor[] = [];\nexport const resetInterceptors = () => (interceptors.length = 0);\nexport const addInterceptor = (interceptor: Interceptor) => interceptors.push(interceptor);\n\nexport async function kfetch(\n  options: KFetchOptions,\n  { prependBasePath = true }: KFetchKibanaOptions = {}\n) {\n  const combinedOptions = withDefaultOptions(options);\n  const promise = requestInterceptors(combinedOptions).then(\n    ({ pathname, query, ...restOptions }) => {\n      const fullUrl = url.format({\n        pathname: prependBasePath ? chrome.addBasePath(pathname) : pathname,\n        query,\n      });\n\n      return window.fetch(fullUrl, restOptions).then(async res => {\n        const body = await getBodyAsJson(res);\n        if (res.ok) {\n          return body;\n        }\n        throw new KFetchError(res, body);\n      });\n    }\n  );\n\n  return responseInterceptors(promise);\n}\n\n// Request/response interceptors are called in opposite orders.\n// Request hooks start from the newest interceptor and end with the oldest.\nfunction requestInterceptors(config: KFetchOptions): Promise<KFetchOptions> {\n  return interceptors.reduceRight((acc, interceptor) => {\n    return acc.then(interceptor.request, interceptor.requestError);\n  }, Promise.resolve(config));\n}\n\n// Response hooks start from the oldest interceptor and end with the newest.\nfunction responseInterceptors(responsePromise: Promise<any>) {\n  return interceptors.reduce((acc, interceptor) => {\n    return acc.then(interceptor.response, interceptor.responseError);\n  }, responsePromise);\n}\n\nasync function getBodyAsJson(res: Response) {\n  try {\n    return await res.json();\n  } catch (e) {\n    return null;\n  }\n}\n\nexport function withDefaultOptions(options?: KFetchOptions): KFetchOptions {\n  return merge(\n    {\n      method: 'GET',\n      credentials: 'same-origin',\n      headers: {\n        'Content-Type': 'application/json',\n        'kbn-version': metadata.version,\n      },\n    },\n    options\n  );\n}\n"]}]}