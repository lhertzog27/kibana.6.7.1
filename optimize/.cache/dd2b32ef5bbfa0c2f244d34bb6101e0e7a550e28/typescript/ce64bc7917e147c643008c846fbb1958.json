{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/metrics/sections/chart_section.tsx","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/metrics/sections/chart_section.tsx","mtime":1567631711981},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["import * as tslib_1 from \"tslib\";\nvar _a;\nvar _b;\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport { EuiIcon, EuiPageContentBody, EuiTitle } from '@elastic/eui';\nimport { EuiAreaSeries, EuiBarSeries, EuiCrosshairX, EuiLineSeries, EuiSeriesChart, EuiXAxis, EuiYAxis, } from '@elastic/eui/lib/experimental';\nimport { injectI18n } from '@kbn/i18n/react';\nimport Color from 'color';\nimport { get } from 'lodash';\nimport moment from 'moment';\nimport React from 'react';\nimport { InfraFormatterType } from '../../../lib/lib';\nimport { InfraMetricLayoutVisualizationType, } from '../../../pages/metrics/layouts/types';\nimport { createFormatter } from '../../../utils/formatters';\nvar MARGIN_LEFT = 60;\nvar chartComponentsByType = (_a = {},\n    _a[InfraMetricLayoutVisualizationType.line] = EuiLineSeries,\n    _a[InfraMetricLayoutVisualizationType.area] = EuiAreaSeries,\n    _a[InfraMetricLayoutVisualizationType.bar] = EuiBarSeries,\n    _a);\nvar isInfraMetricLayoutVisualizationType = function (subject) {\n    return InfraMetricLayoutVisualizationType[subject] != null;\n};\nvar getChartName = function (section, seriesId) {\n    return get(section, ['visConfig', 'seriesOverrides', seriesId, 'name'], seriesId);\n};\nvar getChartColor = function (section, seriesId) {\n    var color = new Color(get(section, ['visConfig', 'seriesOverrides', seriesId, 'color'], '#999'));\n    return color.hex().toString();\n};\nvar getChartType = function (section, seriesId) {\n    var value = get(section, ['visConfig', 'type']);\n    var overrideValue = get(section, ['visConfig', 'seriesOverrides', seriesId, 'type']);\n    if (isInfraMetricLayoutVisualizationType(overrideValue)) {\n        return overrideValue;\n    }\n    if (isInfraMetricLayoutVisualizationType(value)) {\n        return value;\n    }\n    return InfraMetricLayoutVisualizationType.line;\n};\nvar getFormatter = function (formatter, formatterTemplate) { return function (val) {\n    if (val == null) {\n        return '';\n    }\n    return createFormatter(formatter, formatterTemplate)(val);\n}; };\nvar titleFormatter = function (dataPoints) {\n    if (dataPoints.length > 0) {\n        var _a = tslib_1.__read(dataPoints, 1), firstDataPoint = _a[0];\n        var originalValues = firstDataPoint.originalValues;\n        return {\n            title: React.createElement(EuiIcon, { type: \"clock\" }),\n            value: moment(originalValues.x).format('lll'),\n        };\n    }\n};\nvar createItemsFormatter = function (formatter, labels, seriesColors) { return function (dataPoints) {\n    return dataPoints.map(function (d) {\n        return {\n            title: (React.createElement(\"span\", null,\n                React.createElement(EuiIcon, { type: \"dot\", style: { color: seriesColors[d.seriesIndex] } }),\n                labels[d.seriesIndex])),\n            value: formatter(d.y),\n        };\n    });\n}; };\nvar seriesHasLessThen2DataPoints = function (series) {\n    return series.data.length < 2;\n};\nexport var ChartSection = injectI18n((_b = /** @class */ (function (_super) {\n        tslib_1.__extends(class_1, _super);\n        function class_1() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.handleSelectionBrushEnd = function (area) {\n                var _a = _this.props, onChangeRangeTime = _a.onChangeRangeTime, isLiveStreaming = _a.isLiveStreaming, stopLiveStreaming = _a.stopLiveStreaming;\n                var _b = area.domainArea, startX = _b.startX, endX = _b.endX;\n                if (onChangeRangeTime) {\n                    if (isLiveStreaming && stopLiveStreaming) {\n                        stopLiveStreaming();\n                    }\n                    onChangeRangeTime({\n                        to: endX.valueOf(),\n                        from: startX.valueOf(),\n                    });\n                }\n            };\n            return _this;\n        }\n        class_1.prototype.render = function () {\n            var _a = this.props, crosshairValue = _a.crosshairValue, section = _a.section, metric = _a.metric, onCrosshairUpdate = _a.onCrosshairUpdate, intl = _a.intl;\n            var visConfig = section.visConfig;\n            var crossHairProps = {\n                crosshairValue: crosshairValue,\n                onCrosshairUpdate: onCrosshairUpdate,\n            };\n            var chartProps = {\n                xType: 'time',\n                showCrosshair: false,\n                showDefaultAxis: false,\n                enableSelectionBrush: true,\n                onSelectionBrushEnd: this.handleSelectionBrushEnd,\n            };\n            var stacked = visConfig && visConfig.stacked;\n            if (stacked) {\n                chartProps.stackBy = 'y';\n            }\n            var bounds = visConfig && visConfig.bounds;\n            if (bounds) {\n                chartProps.yDomain = [bounds.min, bounds.max];\n            }\n            if (!metric) {\n                chartProps.statusText = intl.formatMessage({\n                    id: 'xpack.infra.chartSection.missingMetricDataText',\n                    defaultMessage: 'Missing data',\n                });\n            }\n            if (metric.series.some(seriesHasLessThen2DataPoints)) {\n                chartProps.statusText = intl.formatMessage({\n                    id: 'xpack.infra.chartSection.notEnoughDataPointsToRenderText',\n                    defaultMessage: 'Not enough data points to render chart, try increasing the time range.',\n                });\n            }\n            var formatter = get(visConfig, 'formatter', InfraFormatterType.number);\n            var formatterTemplate = get(visConfig, 'formatterTemplate', '{{value}}');\n            var formatterFunction = getFormatter(formatter, formatterTemplate);\n            var seriesLabels = get(metric, 'series', []).map(function (s) {\n                return getChartName(section, s.id);\n            });\n            var seriesColors = get(metric, 'series', []).map(function (s) { return getChartColor(section, s.id) || ''; });\n            var itemsFormatter = createItemsFormatter(formatterFunction, seriesLabels, seriesColors);\n            return (React.createElement(EuiPageContentBody, null,\n                React.createElement(EuiTitle, { size: \"s\" },\n                    React.createElement(\"h3\", { id: section.id }, section.label)),\n                React.createElement(\"div\", { style: { height: 200 } },\n                    React.createElement(EuiSeriesChart, tslib_1.__assign({}, chartProps),\n                        React.createElement(EuiXAxis, { marginLeft: MARGIN_LEFT }),\n                        React.createElement(EuiYAxis, { tickFormat: formatterFunction, marginLeft: MARGIN_LEFT }),\n                        React.createElement(EuiCrosshairX, tslib_1.__assign({ marginLeft: MARGIN_LEFT, seriesNames: seriesLabels, itemsFormat: itemsFormatter, titleFormat: titleFormatter }, crossHairProps)),\n                        metric &&\n                            metric.series.map(function (series) {\n                                if (!series || series.data.length < 2) {\n                                    return null;\n                                }\n                                var data = series.data.map(function (d) {\n                                    return { x: d.timestamp, y: d.value || 0, y0: 0 };\n                                });\n                                var chartType = getChartType(section, series.id);\n                                var name = getChartName(section, series.id);\n                                var seriesProps = {\n                                    data: data,\n                                    name: name,\n                                    lineSize: 2,\n                                };\n                                var color = getChartColor(section, series.id);\n                                if (color) {\n                                    seriesProps.color = color;\n                                }\n                                var EuiChartComponent = chartComponentsByType[chartType];\n                                return (React.createElement(EuiChartComponent, tslib_1.__assign({ key: section.id + \"-\" + series.id }, seriesProps, { marginLeft: MARGIN_LEFT })));\n                            })))));\n        };\n        return class_1;\n    }(React.PureComponent)),\n    _b.displayName = 'ChartSection',\n    _b));\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/metrics/sections/chart_section.tsx","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/metrics/sections/chart_section.tsx"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport { EuiIcon, EuiPageContentBody, EuiTitle } from '@elastic/eui';\nimport {\n  EuiAreaSeries,\n  EuiBarSeries,\n  EuiCrosshairX,\n  EuiDataPoint,\n  EuiLineSeries,\n  EuiSeriesChart,\n  EuiSeriesChartProps,\n  EuiSeriesProps,\n  EuiXAxis,\n  EuiYAxis,\n} from '@elastic/eui/lib/experimental';\nimport { InjectedIntl, injectI18n } from '@kbn/i18n/react';\nimport Color from 'color';\nimport { get } from 'lodash';\nimport moment from 'moment';\nimport React, { ReactText } from 'react';\nimport { InfraDataSeries, InfraMetricData } from '../../../graphql/types';\nimport { InfraFormatter, InfraFormatterType } from '../../../lib/lib';\nimport {\n  InfraMetricLayoutSection,\n  InfraMetricLayoutVisualizationType,\n} from '../../../pages/metrics/layouts/types';\nimport { metricTimeActions } from '../../../store';\nimport { createFormatter } from '../../../utils/formatters';\n\nconst MARGIN_LEFT = 60;\nconst chartComponentsByType = {\n  [InfraMetricLayoutVisualizationType.line]: EuiLineSeries,\n  [InfraMetricLayoutVisualizationType.area]: EuiAreaSeries,\n  [InfraMetricLayoutVisualizationType.bar]: EuiBarSeries,\n};\n\ninterface Props {\n  section: InfraMetricLayoutSection;\n  metric: InfraMetricData;\n  onChangeRangeTime?: (time: metricTimeActions.MetricRangeTimeState) => void;\n  crosshairValue?: number;\n  onCrosshairUpdate?: (crosshairValue: number) => void;\n  isLiveStreaming?: boolean;\n  stopLiveStreaming?: () => void;\n  intl: InjectedIntl;\n}\n\nconst isInfraMetricLayoutVisualizationType = (\n  subject: any\n): subject is InfraMetricLayoutVisualizationType => {\n  return InfraMetricLayoutVisualizationType[subject] != null;\n};\n\nconst getChartName = (section: InfraMetricLayoutSection, seriesId: string) => {\n  return get(section, ['visConfig', 'seriesOverrides', seriesId, 'name'], seriesId);\n};\n\nconst getChartColor = (section: InfraMetricLayoutSection, seriesId: string): string | undefined => {\n  const color = new Color(\n    get(section, ['visConfig', 'seriesOverrides', seriesId, 'color'], '#999')\n  );\n  return color.hex().toString();\n};\n\nconst getChartType = (section: InfraMetricLayoutSection, seriesId: string) => {\n  const value = get(section, ['visConfig', 'type']);\n  const overrideValue = get(section, ['visConfig', 'seriesOverrides', seriesId, 'type']);\n  if (isInfraMetricLayoutVisualizationType(overrideValue)) {\n    return overrideValue;\n  }\n  if (isInfraMetricLayoutVisualizationType(value)) {\n    return value;\n  }\n  return InfraMetricLayoutVisualizationType.line;\n};\n\nconst getFormatter = (formatter: InfraFormatterType, formatterTemplate: string) => (\n  val: ReactText\n) => {\n  if (val == null) {\n    return '';\n  }\n  return createFormatter(formatter, formatterTemplate)(val);\n};\n\nconst titleFormatter = (dataPoints: EuiDataPoint[]) => {\n  if (dataPoints.length > 0) {\n    const [firstDataPoint] = dataPoints;\n    const { originalValues } = firstDataPoint;\n    return {\n      title: <EuiIcon type=\"clock\" />,\n      value: moment(originalValues.x).format('lll'),\n    };\n  }\n};\n\nconst createItemsFormatter = (\n  formatter: InfraFormatter,\n  labels: string[],\n  seriesColors: string[]\n) => (dataPoints: EuiDataPoint[]) => {\n  return dataPoints.map(d => {\n    return {\n      title: (\n        <span>\n          <EuiIcon type=\"dot\" style={{ color: seriesColors[d.seriesIndex] }} />\n          {labels[d.seriesIndex]}\n        </span>\n      ),\n      value: formatter(d.y),\n    };\n  });\n};\n\nconst seriesHasLessThen2DataPoints = (series: InfraDataSeries): boolean => {\n  return series.data.length < 2;\n};\n\nexport const ChartSection = injectI18n(\n  class extends React.PureComponent<Props> {\n    public static displayName = 'ChartSection';\n    public render() {\n      const { crosshairValue, section, metric, onCrosshairUpdate, intl } = this.props;\n      const { visConfig } = section;\n      const crossHairProps = {\n        crosshairValue,\n        onCrosshairUpdate,\n      };\n      const chartProps: EuiSeriesChartProps = {\n        xType: 'time',\n        showCrosshair: false,\n        showDefaultAxis: false,\n        enableSelectionBrush: true,\n        onSelectionBrushEnd: this.handleSelectionBrushEnd,\n      };\n      const stacked = visConfig && visConfig.stacked;\n      if (stacked) {\n        chartProps.stackBy = 'y';\n      }\n      const bounds = visConfig && visConfig.bounds;\n      if (bounds) {\n        chartProps.yDomain = [bounds.min, bounds.max];\n      }\n      if (!metric) {\n        chartProps.statusText = intl.formatMessage({\n          id: 'xpack.infra.chartSection.missingMetricDataText',\n          defaultMessage: 'Missing data',\n        });\n      }\n      if (metric.series.some(seriesHasLessThen2DataPoints)) {\n        chartProps.statusText = intl.formatMessage({\n          id: 'xpack.infra.chartSection.notEnoughDataPointsToRenderText',\n          defaultMessage: 'Not enough data points to render chart, try increasing the time range.',\n        });\n      }\n      const formatter = get(visConfig, 'formatter', InfraFormatterType.number);\n      const formatterTemplate = get(visConfig, 'formatterTemplate', '{{value}}');\n      const formatterFunction = getFormatter(formatter, formatterTemplate);\n      const seriesLabels = get(metric, 'series', [] as InfraDataSeries[]).map(s =>\n        getChartName(section, s.id)\n      );\n      const seriesColors = get(metric, 'series', [] as InfraDataSeries[]).map(\n        s => getChartColor(section, s.id) || ''\n      );\n      const itemsFormatter = createItemsFormatter(formatterFunction, seriesLabels, seriesColors);\n      return (\n        <EuiPageContentBody>\n          <EuiTitle size=\"s\">\n            <h3 id={section.id}>{section.label}</h3>\n          </EuiTitle>\n          <div style={{ height: 200 }}>\n            <EuiSeriesChart {...chartProps}>\n              <EuiXAxis marginLeft={MARGIN_LEFT} />\n              <EuiYAxis tickFormat={formatterFunction} marginLeft={MARGIN_LEFT} />\n              <EuiCrosshairX\n                marginLeft={MARGIN_LEFT}\n                seriesNames={seriesLabels}\n                itemsFormat={itemsFormatter}\n                titleFormat={titleFormatter}\n                {...crossHairProps}\n              />\n              {metric &&\n                metric.series.map(series => {\n                  if (!series || series.data.length < 2) {\n                    return null;\n                  }\n                  const data = series.data.map(d => {\n                    return { x: d.timestamp, y: d.value || 0, y0: 0 };\n                  });\n                  const chartType = getChartType(section, series.id);\n                  const name = getChartName(section, series.id);\n                  const seriesProps: EuiSeriesProps = {\n                    data,\n                    name,\n                    lineSize: 2,\n                  };\n                  const color = getChartColor(section, series.id);\n                  if (color) {\n                    seriesProps.color = color;\n                  }\n                  const EuiChartComponent = chartComponentsByType[chartType];\n                  return (\n                    <EuiChartComponent\n                      key={`${section.id}-${series.id}`}\n                      {...seriesProps}\n                      marginLeft={MARGIN_LEFT}\n                    />\n                  );\n                })}\n            </EuiSeriesChart>\n          </div>\n        </EuiPageContentBody>\n      );\n    }\n\n    private handleSelectionBrushEnd = (area: Area) => {\n      const { onChangeRangeTime, isLiveStreaming, stopLiveStreaming } = this.props;\n      const { startX, endX } = area.domainArea;\n      if (onChangeRangeTime) {\n        if (isLiveStreaming && stopLiveStreaming) {\n          stopLiveStreaming();\n        }\n        onChangeRangeTime({\n          to: endX.valueOf(),\n          from: startX.valueOf(),\n        } as metricTimeActions.MetricRangeTimeState);\n      }\n    };\n  }\n);\n\ninterface DomainArea {\n  startX: moment.Moment;\n  endX: moment.Moment;\n  startY: number;\n  endY: number;\n}\n\ninterface DrawArea {\n  x0: number;\n  x1: number;\n  y0: number;\n  y1: number;\n}\n\ninterface Area {\n  domainArea: DomainArea;\n  drawArea: DrawArea;\n}\n"]}]}