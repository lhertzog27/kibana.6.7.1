{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/metrics/with_metrics_time.tsx","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/metrics/with_metrics_time.tsx","mtime":1567631711983},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport { metricTimeActions, metricTimeSelectors } from '../../store';\nimport { asChildFunctionRenderer } from '../../utils/typed_react';\nimport { bindPlainActionCreators } from '../../utils/typed_redux';\nimport { replaceStateKeyInQueryString, UrlStateContainer } from '../../utils/url_state';\nexport var withMetricsTime = connect(function (state) { return ({\n    currentTimeRange: metricTimeSelectors.selectRangeTime(state),\n    isAutoReloading: metricTimeSelectors.selectIsAutoReloading(state),\n    urlState: selectTimeUrlState(state),\n}); }, bindPlainActionCreators({\n    setRangeTime: metricTimeActions.setRangeTime,\n    startMetricsAutoReload: metricTimeActions.startMetricsAutoReload,\n    stopMetricsAutoReload: metricTimeActions.stopMetricsAutoReload,\n}));\nexport var WithMetricsTime = asChildFunctionRenderer(withMetricsTime, {\n    onCleanup: function (_a) {\n        var stopMetricsAutoReload = _a.stopMetricsAutoReload;\n        return stopMetricsAutoReload();\n    },\n});\nexport var WithMetricsTimeUrlState = function () { return (React.createElement(WithMetricsTime, null, function (_a) {\n    var setRangeTime = _a.setRangeTime, startMetricsAutoReload = _a.startMetricsAutoReload, stopMetricsAutoReload = _a.stopMetricsAutoReload, urlState = _a.urlState;\n    return (React.createElement(UrlStateContainer, { urlState: urlState, urlStateKey: \"metricTime\", mapToUrlState: mapToUrlState, onChange: function (newUrlState) {\n            if (newUrlState && newUrlState.time) {\n                setRangeTime(newUrlState.time);\n            }\n            if (newUrlState && newUrlState.autoReload) {\n                startMetricsAutoReload();\n            }\n            else if (newUrlState &&\n                typeof newUrlState.autoReload !== 'undefined' &&\n                !newUrlState.autoReload) {\n                stopMetricsAutoReload();\n            }\n        }, onInitialize: function (initialUrlState) {\n            if (initialUrlState && initialUrlState.time) {\n                setRangeTime(initialUrlState.time);\n            }\n            if (initialUrlState && initialUrlState.autoReload) {\n                startMetricsAutoReload();\n            }\n        } }));\n})); };\nvar selectTimeUrlState = createSelector(metricTimeSelectors.selectRangeTime, metricTimeSelectors.selectIsAutoReloading, function (time, autoReload) { return ({\n    time: time,\n    autoReload: autoReload,\n}); });\nvar mapToUrlState = function (value) {\n    return value\n        ? {\n            time: mapToTimeUrlState(value.time),\n            autoReload: mapToAutoReloadUrlState(value.autoReload),\n        }\n        : undefined;\n};\nvar mapToTimeUrlState = function (value) {\n    return value && (typeof value.to === 'number' && typeof value.from === 'number') ? value : undefined;\n};\nvar mapToAutoReloadUrlState = function (value) { return (typeof value === 'boolean' ? value : undefined); };\nexport var replaceMetricTimeInQueryString = function (from, to) {\n    return Number.isNaN(from) || Number.isNaN(to)\n        ? function (value) { return value; }\n        : replaceStateKeyInQueryString('metricTime', {\n            autoReload: false,\n            time: {\n                interval: '>=1m',\n                from: from,\n                to: to,\n            },\n        });\n};\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/metrics/with_metrics_time.tsx","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/containers/metrics/with_metrics_time.tsx"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { createSelector } from 'reselect';\n\nimport { metricTimeActions, metricTimeSelectors, State } from '../../store';\nimport { asChildFunctionRenderer } from '../../utils/typed_react';\nimport { bindPlainActionCreators } from '../../utils/typed_redux';\nimport { replaceStateKeyInQueryString, UrlStateContainer } from '../../utils/url_state';\n\nexport const withMetricsTime = connect(\n  (state: State) => ({\n    currentTimeRange: metricTimeSelectors.selectRangeTime(state),\n    isAutoReloading: metricTimeSelectors.selectIsAutoReloading(state),\n    urlState: selectTimeUrlState(state),\n  }),\n  bindPlainActionCreators({\n    setRangeTime: metricTimeActions.setRangeTime,\n    startMetricsAutoReload: metricTimeActions.startMetricsAutoReload,\n    stopMetricsAutoReload: metricTimeActions.stopMetricsAutoReload,\n  })\n);\n\nexport const WithMetricsTime = asChildFunctionRenderer(withMetricsTime, {\n  onCleanup: ({ stopMetricsAutoReload }) => stopMetricsAutoReload(),\n});\n\n/**\n * Url State\n */\n\ninterface MetricTimeUrlState {\n  time?: ReturnType<typeof metricTimeSelectors.selectRangeTime>;\n  autoReload?: ReturnType<typeof metricTimeSelectors.selectIsAutoReloading>;\n}\n\nexport const WithMetricsTimeUrlState = () => (\n  <WithMetricsTime>\n    {({ setRangeTime, startMetricsAutoReload, stopMetricsAutoReload, urlState }) => (\n      <UrlStateContainer\n        urlState={urlState}\n        urlStateKey=\"metricTime\"\n        mapToUrlState={mapToUrlState}\n        onChange={newUrlState => {\n          if (newUrlState && newUrlState.time) {\n            setRangeTime(newUrlState.time);\n          }\n          if (newUrlState && newUrlState.autoReload) {\n            startMetricsAutoReload();\n          } else if (\n            newUrlState &&\n            typeof newUrlState.autoReload !== 'undefined' &&\n            !newUrlState.autoReload\n          ) {\n            stopMetricsAutoReload();\n          }\n        }}\n        onInitialize={initialUrlState => {\n          if (initialUrlState && initialUrlState.time) {\n            setRangeTime(initialUrlState.time);\n          }\n          if (initialUrlState && initialUrlState.autoReload) {\n            startMetricsAutoReload();\n          }\n        }}\n      />\n    )}\n  </WithMetricsTime>\n);\n\nconst selectTimeUrlState = createSelector(\n  metricTimeSelectors.selectRangeTime,\n  metricTimeSelectors.selectIsAutoReloading,\n  (time, autoReload) => ({\n    time,\n    autoReload,\n  })\n);\n\nconst mapToUrlState = (value: any): MetricTimeUrlState | undefined =>\n  value\n    ? {\n        time: mapToTimeUrlState(value.time),\n        autoReload: mapToAutoReloadUrlState(value.autoReload),\n      }\n    : undefined;\n\nconst mapToTimeUrlState = (value: any) =>\n  value && (typeof value.to === 'number' && typeof value.from === 'number') ? value : undefined;\n\nconst mapToAutoReloadUrlState = (value: any) => (typeof value === 'boolean' ? value : undefined);\n\nexport const replaceMetricTimeInQueryString = (from: number, to: number) =>\n  Number.isNaN(from) || Number.isNaN(to)\n    ? (value: string) => value\n    : replaceStateKeyInQueryString<MetricTimeUrlState>('metricTime', {\n        autoReload: false,\n        time: {\n          interval: '>=1m',\n          from,\n          to,\n        },\n      });\n"]}]}