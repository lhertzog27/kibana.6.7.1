{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/store/local/metric_time/reducer.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/store/local/metric_time/reducer.ts","mtime":1567631711988},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["import * as tslib_1 from \"tslib\";\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport moment from 'moment';\nimport { combineReducers } from 'redux';\nimport { reducerWithInitialState } from 'typescript-fsa-reducers/dist';\nimport { setRangeTime, startMetricsAutoReload, stopMetricsAutoReload, } from './actions';\nexport var initialMetricTimeState = {\n    timeRange: {\n        from: moment()\n            .subtract(1, 'hour')\n            .valueOf(),\n        to: moment().valueOf(),\n        interval: '>=1m',\n    },\n    updatePolicy: {\n        policy: 'manual',\n    },\n};\nvar timeRangeReducer = reducerWithInitialState(initialMetricTimeState.timeRange).case(setRangeTime, function (state, _a) {\n    var to = _a.to, from = _a.from;\n    return (tslib_1.__assign({}, state, { to: to, from: from }));\n});\nvar updatePolicyReducer = reducerWithInitialState(initialMetricTimeState.updatePolicy)\n    .case(startMetricsAutoReload, function () { return ({\n    policy: 'interval',\n    interval: 5000,\n}); })\n    .case(stopMetricsAutoReload, function () { return ({\n    policy: 'manual',\n}); });\nexport var metricTimeReducer = combineReducers({\n    timeRange: timeRangeReducer,\n    updatePolicy: updatePolicyReducer,\n});\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/store/local/metric_time/reducer.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/store/local/metric_time/reducer.ts"],"names":[],"mappings":";AAAA;;;;GAIG;AACH,OAAO,MAAM,MAAM,QAAQ,CAAC;AAC5B,OAAO,EAAE,eAAe,EAAE,MAAM,OAAO,CAAC;AACxC,OAAO,EAAE,uBAAuB,EAAE,MAAM,8BAA8B,CAAC;AAEvE,OAAO,EAEL,YAAY,EACZ,sBAAsB,EACtB,qBAAqB,GACtB,MAAM,WAAW,CAAC;AAkBnB,MAAM,CAAC,IAAM,sBAAsB,GAAoB;IACrD,SAAS,EAAE;QACT,IAAI,EAAE,MAAM,EAAE;aACX,QAAQ,CAAC,CAAC,EAAE,MAAM,CAAC;aACnB,OAAO,EAAE;QACZ,EAAE,EAAE,MAAM,EAAE,CAAC,OAAO,EAAE;QACtB,QAAQ,EAAE,MAAM;KACjB;IACD,YAAY,EAAE;QACZ,MAAM,EAAE,QAAQ;KACjB;CACF,CAAC;AAEF,IAAM,gBAAgB,GAAG,uBAAuB,CAAC,sBAAsB,CAAC,SAAS,CAAC,CAAC,IAAI,CACrF,YAAY,EACZ,UAAC,KAAK,EAAE,EAAY;QAAV,UAAE,EAAE,cAAI;IAAO,OAAA,sBAAM,KAAK,IAAE,EAAE,IAAA,EAAE,IAAI,MAAA,IAAG;AAAxB,CAAwB,CAClD,CAAC;AAEF,IAAM,mBAAmB,GAAG,uBAAuB,CAAC,sBAAsB,CAAC,YAAY,CAAC;KACrF,IAAI,CAAC,sBAAsB,EAAE,cAAM,OAAA,CAAC;IACnC,MAAM,EAAE,UAAU;IAClB,QAAQ,EAAE,IAAI;CACf,CAAC,EAHkC,CAGlC,CAAC;KACF,IAAI,CAAC,qBAAqB,EAAE,cAAM,OAAA,CAAC;IAClC,MAAM,EAAE,QAAQ;CACjB,CAAC,EAFiC,CAEjC,CAAC,CAAC;AAEN,MAAM,CAAC,IAAM,iBAAiB,GAAG,eAAe,CAAkB;IAChE,SAAS,EAAE,gBAAgB;IAC3B,YAAY,EAAE,mBAAmB;CAClC,CAAC,CAAC","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport moment from 'moment';\nimport { combineReducers } from 'redux';\nimport { reducerWithInitialState } from 'typescript-fsa-reducers/dist';\n\nimport {\n  MetricRangeTimeState,\n  setRangeTime,\n  startMetricsAutoReload,\n  stopMetricsAutoReload,\n} from './actions';\n\ninterface ManualTimeUpdatePolicy {\n  policy: 'manual';\n}\n\ninterface IntervalTimeUpdatePolicy {\n  policy: 'interval';\n  interval: number;\n}\n\ntype TimeUpdatePolicy = ManualTimeUpdatePolicy | IntervalTimeUpdatePolicy;\n\nexport interface MetricTimeState {\n  timeRange: MetricRangeTimeState;\n  updatePolicy: TimeUpdatePolicy;\n}\n\nexport const initialMetricTimeState: MetricTimeState = {\n  timeRange: {\n    from: moment()\n      .subtract(1, 'hour')\n      .valueOf(),\n    to: moment().valueOf(),\n    interval: '>=1m',\n  },\n  updatePolicy: {\n    policy: 'manual',\n  },\n};\n\nconst timeRangeReducer = reducerWithInitialState(initialMetricTimeState.timeRange).case(\n  setRangeTime,\n  (state, { to, from }) => ({ ...state, to, from })\n);\n\nconst updatePolicyReducer = reducerWithInitialState(initialMetricTimeState.updatePolicy)\n  .case(startMetricsAutoReload, () => ({\n    policy: 'interval',\n    interval: 5000,\n  }))\n  .case(stopMetricsAutoReload, () => ({\n    policy: 'manual',\n  }));\n\nexport const metricTimeReducer = combineReducers<MetricTimeState>({\n  timeRange: timeRangeReducer,\n  updatePolicy: updatePolicyReducer,\n});\n"]}]}