{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/waffle_metric_controls.tsx","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/waffle_metric_controls.tsx","mtime":1567631711983},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport * as tslib_1 from \"tslib\";\nvar _a;\nimport { EuiContextMenu, EuiFilterButton, EuiFilterGroup, EuiPopover, } from '@elastic/eui';\nimport { FormattedMessage, injectI18n } from '@kbn/i18n/react';\nimport React from 'react';\nimport { InfraMetricType, InfraNodeType } from '../../graphql/types';\nvar OPTIONS;\nvar getOptions = function (nodeType, intl) {\n    var _a;\n    if (!OPTIONS) {\n        var CPUUsage = intl.formatMessage({\n            id: 'xpack.infra.waffle.metricOptions.cpuUsageText',\n            defaultMessage: 'CPU Usage',\n        });\n        var MemoryUsage = intl.formatMessage({\n            id: 'xpack.infra.waffle.metricOptions.memoryUsageText',\n            defaultMessage: 'Memory Usage',\n        });\n        var InboundTraffic = intl.formatMessage({\n            id: 'xpack.infra.waffle.metricOptions.inboundTrafficText',\n            defaultMessage: 'Inbound Traffic',\n        });\n        var OutboundTraffic = intl.formatMessage({\n            id: 'xpack.infra.waffle.metricOptions.outboundTrafficText',\n            defaultMessage: 'Outbound Traffic',\n        });\n        OPTIONS = (_a = {},\n            _a[InfraNodeType.pod] = [\n                {\n                    text: CPUUsage,\n                    value: InfraMetricType.cpu,\n                },\n                {\n                    text: MemoryUsage,\n                    value: InfraMetricType.memory,\n                },\n                {\n                    text: InboundTraffic,\n                    value: InfraMetricType.rx,\n                },\n                {\n                    text: OutboundTraffic,\n                    value: InfraMetricType.tx,\n                },\n            ],\n            _a[InfraNodeType.container] = [\n                {\n                    text: CPUUsage,\n                    value: InfraMetricType.cpu,\n                },\n                {\n                    text: MemoryUsage,\n                    value: InfraMetricType.memory,\n                },\n                {\n                    text: InboundTraffic,\n                    value: InfraMetricType.rx,\n                },\n                {\n                    text: OutboundTraffic,\n                    value: InfraMetricType.tx,\n                },\n            ],\n            _a[InfraNodeType.host] = [\n                {\n                    text: CPUUsage,\n                    value: InfraMetricType.cpu,\n                },\n                {\n                    text: MemoryUsage,\n                    value: InfraMetricType.memory,\n                },\n                {\n                    text: intl.formatMessage({\n                        id: 'xpack.infra.waffle.metricOptions.loadText',\n                        defaultMessage: 'Load',\n                    }),\n                    value: InfraMetricType.load,\n                },\n                {\n                    text: InboundTraffic,\n                    value: InfraMetricType.rx,\n                },\n                {\n                    text: OutboundTraffic,\n                    value: InfraMetricType.tx,\n                },\n                {\n                    text: intl.formatMessage({\n                        id: 'xpack.infra.waffle.metricOptions.hostLogRateText',\n                        defaultMessage: 'Log Rate',\n                    }),\n                    value: InfraMetricType.logRate,\n                },\n            ],\n            _a);\n    }\n    return OPTIONS[nodeType];\n};\nvar initialState = {\n    isPopoverOpen: false,\n};\nexport var WaffleMetricControls = injectI18n((_a = /** @class */ (function (_super) {\n        tslib_1.__extends(class_1, _super);\n        function class_1() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.state = initialState;\n            _this.handleClose = function () {\n                _this.setState({ isPopoverOpen: false });\n            };\n            _this.handleToggle = function () {\n                _this.setState(function (state) { return ({ isPopoverOpen: !state.isPopoverOpen }); });\n            };\n            _this.handleClick = function (value) { return function () {\n                _this.props.onChange({ type: value });\n                _this.handleClose();\n            }; };\n            return _this;\n        }\n        class_1.prototype.render = function () {\n            var _this = this;\n            var _a = this.props, metric = _a.metric, nodeType = _a.nodeType, intl = _a.intl;\n            var options = getOptions(nodeType, intl);\n            var value = metric.type;\n            if (!options.length || !value) {\n                throw Error(intl.formatMessage({\n                    id: 'xpack.infra.waffle.unableToSelectMetricErrorTitle',\n                    defaultMessage: 'Unable to select options or value for metric.',\n                }));\n            }\n            var currentLabel = options.find(function (o) { return o.value === metric.type; });\n            if (!currentLabel) {\n                return 'null';\n            }\n            var panels = [\n                {\n                    id: 0,\n                    title: '',\n                    items: options.map(function (o) {\n                        var icon = o.value === metric.type ? 'check' : 'empty';\n                        var panel = { name: o.text, onClick: _this.handleClick(o.value), icon: icon };\n                        return panel;\n                    }),\n                },\n            ];\n            var button = (React.createElement(EuiFilterButton, { iconType: \"arrowDown\", onClick: this.handleToggle },\n                React.createElement(FormattedMessage, { id: \"xpack.infra.waffle.metricButtonLabel\", defaultMessage: \"Metric: {selectedMetric}\", values: { selectedMetric: currentLabel.text } })));\n            return (React.createElement(EuiFilterGroup, null,\n                React.createElement(EuiPopover, { isOpen: this.state.isPopoverOpen, id: \"metricsPanel\", button: button, panelPaddingSize: \"none\", closePopover: this.handleClose },\n                    React.createElement(EuiContextMenu, { initialPanelId: 0, panels: panels }))));\n        };\n        return class_1;\n    }(React.PureComponent)),\n    _a.displayName = 'WaffleMetricControls',\n    _a));\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/waffle_metric_controls.tsx","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/waffle_metric_controls.tsx"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport {\n  EuiContextMenu,\n  EuiContextMenuPanelDescriptor,\n  EuiFilterButton,\n  EuiFilterGroup,\n  EuiPopover,\n} from '@elastic/eui';\nimport { FormattedMessage, InjectedIntl, injectI18n } from '@kbn/i18n/react';\nimport React from 'react';\n\nimport { InfraMetricInput, InfraMetricType, InfraNodeType } from '../../graphql/types';\n\ninterface Props {\n  nodeType: InfraNodeType;\n  metric: InfraMetricInput;\n  onChange: (metric: InfraMetricInput) => void;\n  intl: InjectedIntl;\n}\n\nlet OPTIONS: { [P in InfraNodeType]: Array<{ text: string; value: InfraMetricType }> };\nconst getOptions = (\n  nodeType: InfraNodeType,\n  intl: InjectedIntl\n): Array<{ text: string; value: InfraMetricType }> => {\n  if (!OPTIONS) {\n    const CPUUsage = intl.formatMessage({\n      id: 'xpack.infra.waffle.metricOptions.cpuUsageText',\n      defaultMessage: 'CPU Usage',\n    });\n\n    const MemoryUsage = intl.formatMessage({\n      id: 'xpack.infra.waffle.metricOptions.memoryUsageText',\n      defaultMessage: 'Memory Usage',\n    });\n\n    const InboundTraffic = intl.formatMessage({\n      id: 'xpack.infra.waffle.metricOptions.inboundTrafficText',\n      defaultMessage: 'Inbound Traffic',\n    });\n\n    const OutboundTraffic = intl.formatMessage({\n      id: 'xpack.infra.waffle.metricOptions.outboundTrafficText',\n      defaultMessage: 'Outbound Traffic',\n    });\n\n    OPTIONS = {\n      [InfraNodeType.pod]: [\n        {\n          text: CPUUsage,\n          value: InfraMetricType.cpu,\n        },\n        {\n          text: MemoryUsage,\n          value: InfraMetricType.memory,\n        },\n        {\n          text: InboundTraffic,\n          value: InfraMetricType.rx,\n        },\n        {\n          text: OutboundTraffic,\n          value: InfraMetricType.tx,\n        },\n      ],\n      [InfraNodeType.container]: [\n        {\n          text: CPUUsage,\n          value: InfraMetricType.cpu,\n        },\n        {\n          text: MemoryUsage,\n          value: InfraMetricType.memory,\n        },\n        {\n          text: InboundTraffic,\n          value: InfraMetricType.rx,\n        },\n        {\n          text: OutboundTraffic,\n          value: InfraMetricType.tx,\n        },\n      ],\n      [InfraNodeType.host]: [\n        {\n          text: CPUUsage,\n          value: InfraMetricType.cpu,\n        },\n        {\n          text: MemoryUsage,\n          value: InfraMetricType.memory,\n        },\n        {\n          text: intl.formatMessage({\n            id: 'xpack.infra.waffle.metricOptions.loadText',\n            defaultMessage: 'Load',\n          }),\n          value: InfraMetricType.load,\n        },\n        {\n          text: InboundTraffic,\n          value: InfraMetricType.rx,\n        },\n        {\n          text: OutboundTraffic,\n          value: InfraMetricType.tx,\n        },\n        {\n          text: intl.formatMessage({\n            id: 'xpack.infra.waffle.metricOptions.hostLogRateText',\n            defaultMessage: 'Log Rate',\n          }),\n          value: InfraMetricType.logRate,\n        },\n      ],\n    };\n  }\n\n  return OPTIONS[nodeType];\n};\n\nconst initialState = {\n  isPopoverOpen: false,\n};\ntype State = Readonly<typeof initialState>;\n\nexport const WaffleMetricControls = injectI18n(\n  class extends React.PureComponent<Props, State> {\n    public static displayName = 'WaffleMetricControls';\n    public readonly state: State = initialState;\n    public render() {\n      const { metric, nodeType, intl } = this.props;\n      const options = getOptions(nodeType, intl);\n      const value = metric.type;\n\n      if (!options.length || !value) {\n        throw Error(\n          intl.formatMessage({\n            id: 'xpack.infra.waffle.unableToSelectMetricErrorTitle',\n            defaultMessage: 'Unable to select options or value for metric.',\n          })\n        );\n      }\n      const currentLabel = options.find(o => o.value === metric.type);\n      if (!currentLabel) {\n        return 'null';\n      }\n      const panels: EuiContextMenuPanelDescriptor[] = [\n        {\n          id: 0,\n          title: '',\n          items: options.map(o => {\n            const icon = o.value === metric.type ? 'check' : 'empty';\n            const panel = { name: o.text, onClick: this.handleClick(o.value), icon };\n            return panel;\n          }),\n        },\n      ];\n      const button = (\n        <EuiFilterButton iconType=\"arrowDown\" onClick={this.handleToggle}>\n          <FormattedMessage\n            id=\"xpack.infra.waffle.metricButtonLabel\"\n            defaultMessage=\"Metric: {selectedMetric}\"\n            values={{ selectedMetric: currentLabel.text }}\n          />\n        </EuiFilterButton>\n      );\n\n      return (\n        <EuiFilterGroup>\n          <EuiPopover\n            isOpen={this.state.isPopoverOpen}\n            id=\"metricsPanel\"\n            button={button}\n            panelPaddingSize=\"none\"\n            closePopover={this.handleClose}\n          >\n            <EuiContextMenu initialPanelId={0} panels={panels} />\n          </EuiPopover>\n        </EuiFilterGroup>\n      );\n    }\n    private handleClose = () => {\n      this.setState({ isPopoverOpen: false });\n    };\n\n    private handleToggle = () => {\n      this.setState(state => ({ isPopoverOpen: !state.isPopoverOpen }));\n    };\n\n    private handleClick = (value: InfraMetricType) => () => {\n      this.props.onChange({ type: value });\n      this.handleClose();\n    };\n  }\n);\n"]}]}