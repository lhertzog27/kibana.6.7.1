{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/security/public/lib/parse_next.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/security/public/lib/parse_next.ts","mtime":1567631712297},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport { parse } from 'url';\nexport function parseNext(href, basePath) {\n    if (basePath === void 0) { basePath = ''; }\n    var _a = parse(href, true), query = _a.query, hash = _a.hash;\n    if (!query.next) {\n        return basePath + \"/\";\n    }\n    var next;\n    if (Array.isArray(query.next) && query.next.length > 0) {\n        next = query.next[0];\n    }\n    else {\n        next = query.next;\n    }\n    // validate that `next` is not attempting a redirect to somewhere\n    // outside of this Kibana install\n    var _b = parse(next, false /* parseQueryString */, true /* slashesDenoteHost */), protocol = _b.protocol, hostname = _b.hostname, port = _b.port, pathname = _b.pathname;\n    // We should explicitly compare `protocol`, `port` and `hostname` to null to make sure these are not\n    // detected in the URL at all. For example `hostname` can be empty string for Node URL parser, but\n    // browser (because of various bwc reasons) processes URL differently (e.g. `///abc.com` - for browser\n    // hostname is `abc.com`, but for Node hostname is an empty string i.e. everything between schema (`//`)\n    // and the first slash that belongs to path.\n    if (protocol !== null || hostname !== null || port !== null) {\n        return basePath + \"/\";\n    }\n    if (!String(pathname).startsWith(basePath)) {\n        return basePath + \"/\";\n    }\n    return query.next + (hash || '');\n}\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/security/public/lib/parse_next.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/security/public/lib/parse_next.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAE,KAAK,EAAE,MAAM,KAAK,CAAC;AAE5B,MAAM,UAAU,SAAS,CAAC,IAAY,EAAE,QAAa;IAAb,yBAAA,EAAA,aAAa;IAC7C,IAAA,sBAAmC,EAAjC,gBAAK,EAAE,cAAI,CAAuB;IAC1C,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;QACf,OAAU,QAAQ,MAAG,CAAC;KACvB;IAED,IAAI,IAAY,CAAC;IACjB,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;QACtD,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACtB;SAAM;QACL,IAAI,GAAG,KAAK,CAAC,IAAc,CAAC;KAC7B;IAED,iEAAiE;IACjE,iCAAiC;IAC3B,IAAA,4EAIL,EAJO,sBAAQ,EAAE,sBAAQ,EAAE,cAAI,EAAE,sBAAQ,CAIxC;IAEF,oGAAoG;IACpG,kGAAkG;IAClG,sGAAsG;IACtG,wGAAwG;IACxG,4CAA4C;IAC5C,IAAI,QAAQ,KAAK,IAAI,IAAI,QAAQ,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,EAAE;QAC3D,OAAU,QAAQ,MAAG,CAAC;KACvB;IAED,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;QAC1C,OAAU,QAAQ,MAAG,CAAC;KACvB;IAED,OAAO,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC;AACnC,CAAC","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport { parse } from 'url';\n\nexport function parseNext(href: string, basePath = '') {\n  const { query, hash } = parse(href, true);\n  if (!query.next) {\n    return `${basePath}/`;\n  }\n\n  let next: string;\n  if (Array.isArray(query.next) && query.next.length > 0) {\n    next = query.next[0];\n  } else {\n    next = query.next as string;\n  }\n\n  // validate that `next` is not attempting a redirect to somewhere\n  // outside of this Kibana install\n  const { protocol, hostname, port, pathname } = parse(\n    next,\n    false /* parseQueryString */,\n    true /* slashesDenoteHost */\n  );\n\n  // We should explicitly compare `protocol`, `port` and `hostname` to null to make sure these are not\n  // detected in the URL at all. For example `hostname` can be empty string for Node URL parser, but\n  // browser (because of various bwc reasons) processes URL differently (e.g. `///abc.com` - for browser\n  // hostname is `abc.com`, but for Node hostname is an empty string i.e. everything between schema (`//`)\n  // and the first slash that belongs to path.\n  if (protocol !== null || hostname !== null || port !== null) {\n    return `${basePath}/`;\n  }\n\n  if (!String(pathname).startsWith(basePath)) {\n    return `${basePath}/`;\n  }\n\n  return query.next + (hash || '');\n}\n"]}]}