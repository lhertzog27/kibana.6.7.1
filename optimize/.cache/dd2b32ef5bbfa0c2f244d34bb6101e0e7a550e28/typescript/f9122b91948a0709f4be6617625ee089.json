{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/size_of_squares.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/size_of_squares.ts","mtime":1567631711982},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nexport var SCALE_FACTOR = 0.55;\nexport var MAX_SIZE = Infinity;\nexport var MIN_SIZE = 24;\nexport function sizeOfSquares(width, height, totalItems, levels) {\n    if (levels === void 0) { levels = 1; }\n    var levelFactor = levels > 1 ? levels * 0.7 : 1;\n    var scale = SCALE_FACTOR / levelFactor;\n    var x = width * scale;\n    var y = height * scale;\n    var possibleX = Math.ceil(Math.sqrt((totalItems * x) / y));\n    var newX;\n    var newY;\n    if (Math.floor((possibleX * y) / x) * possibleX < totalItems) {\n        newX = y / Math.ceil((possibleX * y) / x);\n    }\n    else {\n        newX = x / possibleX;\n    }\n    var possibleY = Math.ceil(Math.sqrt((totalItems * y) / x));\n    if (Math.floor((possibleY * x) / y) * possibleY < totalItems) {\n        // does not fit\n        newY = x / Math.ceil((x * possibleY) / y);\n    }\n    else {\n        newY = y / possibleY;\n    }\n    var size = Math.max(newX, newY);\n    return Math.min(Math.max(size, MIN_SIZE), MAX_SIZE);\n}\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/size_of_squares.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/components/waffle/lib/size_of_squares.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,MAAM,CAAC,IAAM,YAAY,GAAG,IAAI,CAAC;AACjC,MAAM,CAAC,IAAM,QAAQ,GAAG,QAAQ,CAAC;AACjC,MAAM,CAAC,IAAM,QAAQ,GAAG,EAAE,CAAC;AAE3B,MAAM,UAAU,aAAa,CAC3B,KAAa,EACb,MAAc,EACd,UAAkB,EAClB,MAAU;IAAV,uBAAA,EAAA,UAAU;IAEV,IAAM,WAAW,GAAG,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAClD,IAAM,KAAK,GAAG,YAAY,GAAG,WAAW,CAAC;IACzC,IAAM,CAAC,GAAG,KAAK,GAAG,KAAK,CAAC;IACxB,IAAM,CAAC,GAAG,MAAM,GAAG,KAAK,CAAC;IACzB,IAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAC7D,IAAI,IAAI,CAAC;IACT,IAAI,IAAI,CAAC;IACT,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS,GAAG,UAAU,EAAE;QAC5D,IAAI,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;KAC3C;SAAM;QACL,IAAI,GAAG,CAAC,GAAG,SAAS,CAAC;KACtB;IACD,IAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAC7D,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS,GAAG,UAAU,EAAE;QAC5D,eAAe;QACf,IAAI,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;KAC3C;SAAM;QACL,IAAI,GAAG,CAAC,GAAG,SAAS,CAAC;KACtB;IACD,IAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IAClC,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;AACtD,CAAC","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nexport const SCALE_FACTOR = 0.55;\nexport const MAX_SIZE = Infinity;\nexport const MIN_SIZE = 24;\n\nexport function sizeOfSquares(\n  width: number,\n  height: number,\n  totalItems: number,\n  levels = 1\n): number {\n  const levelFactor = levels > 1 ? levels * 0.7 : 1;\n  const scale = SCALE_FACTOR / levelFactor;\n  const x = width * scale;\n  const y = height * scale;\n  const possibleX = Math.ceil(Math.sqrt((totalItems * x) / y));\n  let newX;\n  let newY;\n  if (Math.floor((possibleX * y) / x) * possibleX < totalItems) {\n    newX = y / Math.ceil((possibleX * y) / x);\n  } else {\n    newX = x / possibleX;\n  }\n  const possibleY = Math.ceil(Math.sqrt((totalItems * y) / x));\n  if (Math.floor((possibleY * x) / y) * possibleY < totalItems) {\n    // does not fit\n    newY = x / Math.ceil((x * possibleY) / y);\n  } else {\n    newY = y / possibleY;\n  }\n  const size = Math.max(newX, newY);\n  return Math.min(Math.max(size, MIN_SIZE), MAX_SIZE);\n}\n"]}]}