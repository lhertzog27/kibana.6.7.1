{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/store/remote/log_entries/epic.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/store/remote/log_entries/epic.ts","mtime":1567631711989},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { combineEpics } from 'redux-observable';\nimport { merge } from 'rxjs';\nimport { exhaustMap, filter, map, withLatestFrom } from 'rxjs/operators';\nimport { logFilterActions, logPositionActions } from '../..';\nimport { pickTimeKey, timeKeyIsBetween } from '../../../../common/time';\nimport { loadEntries, loadMoreEntries, loadNewerEntries } from './actions';\nimport { loadEntriesEpic } from './operations/load';\nimport { loadMoreEntriesEpic } from './operations/load_more';\nvar LOAD_CHUNK_SIZE = 200;\nvar DESIRED_BUFFER_PAGES = 2;\nexport var createLogEntriesEpic = function () {\n    return combineEpics(createEntriesEffectsEpic(), loadEntriesEpic, loadMoreEntriesEpic);\n};\nexport var createEntriesEffectsEpic = function () { return function (action$, state$, _a) {\n    var selectLogEntriesStart = _a.selectLogEntriesStart, selectLogEntriesEnd = _a.selectLogEntriesEnd, selectHasMoreLogEntriesBeforeStart = _a.selectHasMoreLogEntriesBeforeStart, selectHasMoreLogEntriesAfterEnd = _a.selectHasMoreLogEntriesAfterEnd, selectIsAutoReloadingLogEntries = _a.selectIsAutoReloadingLogEntries, selectIsLoadingLogEntries = _a.selectIsLoadingLogEntries, selectLogFilterQueryAsJson = _a.selectLogFilterQueryAsJson, selectVisibleLogMidpointOrTarget = _a.selectVisibleLogMidpointOrTarget;\n    var filterQuery$ = state$.pipe(map(selectLogFilterQueryAsJson));\n    var visibleMidpointOrTarget$ = state$.pipe(map(selectVisibleLogMidpointOrTarget), filter(isNotNull), map(pickTimeKey));\n    var shouldLoadAroundNewPosition$ = action$.pipe(filter(logPositionActions.jumpToTargetPosition.match), withLatestFrom(state$), filter(function (_a) {\n        var _b = tslib_1.__read(_a, 2), payload = _b[0].payload, state = _b[1];\n        var entriesStart = selectLogEntriesStart(state);\n        var entriesEnd = selectLogEntriesEnd(state);\n        return entriesStart && entriesEnd\n            ? !timeKeyIsBetween(entriesStart, entriesEnd, payload)\n            : true;\n    }), map(function (_a) {\n        var _b = tslib_1.__read(_a, 1), payload = _b[0].payload;\n        return pickTimeKey(payload);\n    }));\n    var shouldLoadWithNewFilter$ = action$.pipe(filter(logFilterActions.applyLogFilterQuery.match), withLatestFrom(filterQuery$, function (filterQuery, filterQueryString) { return filterQueryString; }));\n    var shouldLoadMoreBefore$ = action$.pipe(filter(logPositionActions.reportVisiblePositions.match), filter(function (_a) {\n        var pagesBeforeStart = _a.payload.pagesBeforeStart;\n        return pagesBeforeStart < DESIRED_BUFFER_PAGES;\n    }), withLatestFrom(state$), filter(function (_a) {\n        var _b = tslib_1.__read(_a, 2), action = _b[0], state = _b[1];\n        return !selectIsAutoReloadingLogEntries(state) &&\n            !selectIsLoadingLogEntries(state) &&\n            selectHasMoreLogEntriesBeforeStart(state);\n    }), map(function (_a) {\n        var _b = tslib_1.__read(_a, 2), action = _b[0], state = _b[1];\n        return selectLogEntriesStart(state);\n    }), filter(isNotNull), map(pickTimeKey));\n    var shouldLoadMoreAfter$ = merge(action$.pipe(filter(logPositionActions.reportVisiblePositions.match), filter(function (_a) {\n        var pagesAfterEnd = _a.payload.pagesAfterEnd;\n        return pagesAfterEnd < DESIRED_BUFFER_PAGES;\n    }), withLatestFrom(state$, function (action, state) { return state; }), filter(function (state) {\n        return !selectIsAutoReloadingLogEntries(state) &&\n            !selectIsLoadingLogEntries(state) &&\n            selectHasMoreLogEntriesAfterEnd(state);\n    })), action$.pipe(filter(loadNewerEntries.match), withLatestFrom(state$, function (action, state) { return state; }))).pipe(map(function (state) { return selectLogEntriesEnd(state); }), filter(isNotNull), map(pickTimeKey));\n    return merge(shouldLoadAroundNewPosition$.pipe(withLatestFrom(filterQuery$), exhaustMap(function (_a) {\n        var _b = tslib_1.__read(_a, 2), timeKey = _b[0], filterQuery = _b[1];\n        return [\n            loadEntries({\n                sourceId: 'default',\n                timeKey: timeKey,\n                countBefore: LOAD_CHUNK_SIZE,\n                countAfter: LOAD_CHUNK_SIZE,\n                filterQuery: filterQuery,\n            }),\n        ];\n    })), shouldLoadWithNewFilter$.pipe(withLatestFrom(visibleMidpointOrTarget$), exhaustMap(function (_a) {\n        var _b = tslib_1.__read(_a, 2), filterQuery = _b[0], timeKey = _b[1];\n        return [\n            loadEntries({\n                sourceId: 'default',\n                timeKey: timeKey,\n                countBefore: LOAD_CHUNK_SIZE,\n                countAfter: LOAD_CHUNK_SIZE,\n                filterQuery: filterQuery,\n            }),\n        ];\n    })), shouldLoadMoreAfter$.pipe(withLatestFrom(filterQuery$), exhaustMap(function (_a) {\n        var _b = tslib_1.__read(_a, 2), timeKey = _b[0], filterQuery = _b[1];\n        return [\n            loadMoreEntries({\n                sourceId: 'default',\n                timeKey: timeKey,\n                countBefore: 0,\n                countAfter: LOAD_CHUNK_SIZE,\n                filterQuery: filterQuery,\n            }),\n        ];\n    })), shouldLoadMoreBefore$.pipe(withLatestFrom(filterQuery$), exhaustMap(function (_a) {\n        var _b = tslib_1.__read(_a, 2), timeKey = _b[0], filterQuery = _b[1];\n        return [\n            loadMoreEntries({\n                sourceId: 'default',\n                timeKey: timeKey,\n                countBefore: LOAD_CHUNK_SIZE,\n                countAfter: 0,\n                filterQuery: filterQuery,\n            }),\n        ];\n    })));\n}; };\nvar isNotNull = function (value) { return value !== null; };\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/store/remote/log_entries/epic.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/infra/public/store/remote/log_entries/epic.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nimport { Action } from 'redux';\nimport { combineEpics, Epic, EpicWithState } from 'redux-observable';\nimport { merge } from 'rxjs';\nimport { exhaustMap, filter, map, withLatestFrom } from 'rxjs/operators';\n\nimport { logFilterActions, logPositionActions } from '../..';\nimport { pickTimeKey, TimeKey, timeKeyIsBetween } from '../../../../common/time';\nimport { loadEntries, loadMoreEntries, loadNewerEntries } from './actions';\nimport { loadEntriesEpic } from './operations/load';\nimport { loadMoreEntriesEpic } from './operations/load_more';\n\nconst LOAD_CHUNK_SIZE = 200;\nconst DESIRED_BUFFER_PAGES = 2;\n\ninterface ManageEntriesDependencies<State> {\n  selectLogEntriesStart: (state: State) => TimeKey | null;\n  selectLogEntriesEnd: (state: State) => TimeKey | null;\n  selectHasMoreLogEntriesBeforeStart: (state: State) => boolean;\n  selectHasMoreLogEntriesAfterEnd: (state: State) => boolean;\n  selectIsAutoReloadingLogEntries: (state: State) => boolean;\n  selectIsLoadingLogEntries: (state: State) => boolean;\n  selectLogFilterQueryAsJson: (state: State) => string | null;\n  selectVisibleLogMidpointOrTarget: (state: State) => TimeKey | null;\n}\n\nexport const createLogEntriesEpic = <State>() =>\n  combineEpics(\n    createEntriesEffectsEpic<State>(),\n    loadEntriesEpic as EpicWithState<typeof loadEntriesEpic, State>,\n    loadMoreEntriesEpic as EpicWithState<typeof loadEntriesEpic, State>\n  );\n\nexport const createEntriesEffectsEpic = <State>(): Epic<\n  Action,\n  Action,\n  State,\n  ManageEntriesDependencies<State>\n> => (\n  action$,\n  state$,\n  {\n    selectLogEntriesStart,\n    selectLogEntriesEnd,\n    selectHasMoreLogEntriesBeforeStart,\n    selectHasMoreLogEntriesAfterEnd,\n    selectIsAutoReloadingLogEntries,\n    selectIsLoadingLogEntries,\n    selectLogFilterQueryAsJson,\n    selectVisibleLogMidpointOrTarget,\n  }\n) => {\n  const filterQuery$ = state$.pipe(map(selectLogFilterQueryAsJson));\n  const visibleMidpointOrTarget$ = state$.pipe(\n    map(selectVisibleLogMidpointOrTarget),\n    filter(isNotNull),\n    map(pickTimeKey)\n  );\n\n  const shouldLoadAroundNewPosition$ = action$.pipe(\n    filter(logPositionActions.jumpToTargetPosition.match),\n    withLatestFrom(state$),\n    filter(([{ payload }, state]) => {\n      const entriesStart = selectLogEntriesStart(state);\n      const entriesEnd = selectLogEntriesEnd(state);\n\n      return entriesStart && entriesEnd\n        ? !timeKeyIsBetween(entriesStart, entriesEnd, payload)\n        : true;\n    }),\n    map(([{ payload }]) => pickTimeKey(payload))\n  );\n\n  const shouldLoadWithNewFilter$ = action$.pipe(\n    filter(logFilterActions.applyLogFilterQuery.match),\n    withLatestFrom(filterQuery$, (filterQuery, filterQueryString) => filterQueryString)\n  );\n\n  const shouldLoadMoreBefore$ = action$.pipe(\n    filter(logPositionActions.reportVisiblePositions.match),\n    filter(({ payload: { pagesBeforeStart } }) => pagesBeforeStart < DESIRED_BUFFER_PAGES),\n    withLatestFrom(state$),\n    filter(\n      ([action, state]) =>\n        !selectIsAutoReloadingLogEntries(state) &&\n        !selectIsLoadingLogEntries(state) &&\n        selectHasMoreLogEntriesBeforeStart(state)\n    ),\n    map(([action, state]) => selectLogEntriesStart(state)),\n    filter(isNotNull),\n    map(pickTimeKey)\n  );\n\n  const shouldLoadMoreAfter$ = merge(\n    action$.pipe(\n      filter(logPositionActions.reportVisiblePositions.match),\n      filter(({ payload: { pagesAfterEnd } }) => pagesAfterEnd < DESIRED_BUFFER_PAGES),\n      withLatestFrom(state$, (action, state) => state),\n      filter(\n        state =>\n          !selectIsAutoReloadingLogEntries(state) &&\n          !selectIsLoadingLogEntries(state) &&\n          selectHasMoreLogEntriesAfterEnd(state)\n      )\n    ),\n    action$.pipe(\n      filter(loadNewerEntries.match),\n      withLatestFrom(state$, (action, state) => state)\n    )\n  ).pipe(\n    map(state => selectLogEntriesEnd(state)),\n    filter(isNotNull),\n    map(pickTimeKey)\n  );\n\n  return merge(\n    shouldLoadAroundNewPosition$.pipe(\n      withLatestFrom(filterQuery$),\n      exhaustMap(([timeKey, filterQuery]) => [\n        loadEntries({\n          sourceId: 'default',\n          timeKey,\n          countBefore: LOAD_CHUNK_SIZE,\n          countAfter: LOAD_CHUNK_SIZE,\n          filterQuery,\n        }),\n      ])\n    ),\n    shouldLoadWithNewFilter$.pipe(\n      withLatestFrom(visibleMidpointOrTarget$),\n      exhaustMap(([filterQuery, timeKey]) => [\n        loadEntries({\n          sourceId: 'default',\n          timeKey,\n          countBefore: LOAD_CHUNK_SIZE,\n          countAfter: LOAD_CHUNK_SIZE,\n          filterQuery,\n        }),\n      ])\n    ),\n    shouldLoadMoreAfter$.pipe(\n      withLatestFrom(filterQuery$),\n      exhaustMap(([timeKey, filterQuery]) => [\n        loadMoreEntries({\n          sourceId: 'default',\n          timeKey,\n          countBefore: 0,\n          countAfter: LOAD_CHUNK_SIZE,\n          filterQuery,\n        }),\n      ])\n    ),\n    shouldLoadMoreBefore$.pipe(\n      withLatestFrom(filterQuery$),\n      exhaustMap(([timeKey, filterQuery]) => [\n        loadMoreEntries({\n          sourceId: 'default',\n          timeKey,\n          countBefore: LOAD_CHUNK_SIZE,\n          countAfter: 0,\n          filterQuery,\n        }),\n      ])\n    )\n  );\n};\n\nconst isNotNull = <T>(value: T | null): value is T => value !== null;\n"]}]}