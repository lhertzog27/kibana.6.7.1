{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--10-1!/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js??ref--10-2!/home/anthony/git_workspaces/kibana/x-pack/plugins/uptime/public/components/functional/format_sparkline_counts.ts","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/x-pack/plugins/uptime/public/components/functional/format_sparkline_counts.ts","mtime":1567631712328},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/ts-loader/index.js","mtime":1567666229769}],"contextDependencies":[],"result":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\nexport var formatSparklineCounts = function (counts) {\n    var defaultSize = 0;\n    var length = counts.length;\n    // assume points are uniform, use this\n    // for the last element's span\n    if (length > 1) {\n        defaultSize = Math.max(counts[1].x - counts[0].x, 0);\n    }\n    else if (length === 1) {\n        // wait for another point\n        return [];\n    }\n    return counts.map(function (_a, index, array) {\n        var x0 = _a.x, y = _a.y;\n        var x;\n        var nextIndex = index + 1;\n        if (nextIndex === array.length) {\n            x = x0 + defaultSize;\n        }\n        else {\n            var nextX = array[nextIndex].x;\n            x = nextX;\n        }\n        return { x: x, x0: x0, y: y };\n    });\n};\n",{"version":3,"file":"/home/anthony/git_workspaces/kibana/x-pack/plugins/uptime/public/components/functional/format_sparkline_counts.ts","sourceRoot":"","sources":["/home/anthony/git_workspaces/kibana/x-pack/plugins/uptime/public/components/functional/format_sparkline_counts.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAOH,MAAM,CAAC,IAAM,qBAAqB,GAAG,UAAC,MAAmB;IACvD,IAAI,WAAW,GAAG,CAAC,CAAC;IACZ,IAAA,sBAAM,CAAY;IAC1B,sCAAsC;IACtC,8BAA8B;IAC9B,IAAI,MAAM,GAAG,CAAC,EAAE;QACd,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;KACtD;SAAM,IAAI,MAAM,KAAK,CAAC,EAAE;QACvB,yBAAyB;QACzB,OAAO,EAAE,CAAC;KACX;IACD,OAAO,MAAM,CAAC,GAAG,CAAC,UAAC,EAAY,EAAE,KAAK,EAAE,KAAK;YAAxB,SAAK,EAAE,QAAC;QAC3B,IAAI,CAAC,CAAC;QACN,IAAM,SAAS,GAAG,KAAK,GAAG,CAAC,CAAC;QAC5B,IAAI,SAAS,KAAK,KAAK,CAAC,MAAM,EAAE;YAC9B,CAAC,GAAG,EAAE,GAAG,WAAW,CAAC;SACtB;aAAM;YACG,IAAA,0BAAQ,CAAsB;YACtC,CAAC,GAAG,KAAK,CAAC;SACX;QACD,OAAO,EAAE,CAAC,GAAA,EAAE,EAAE,IAAA,EAAE,CAAC,GAAA,EAAE,CAAC;IACtB,CAAC,CAAC,CAAC;AACL,CAAC,CAAC","sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License;\n * you may not use this file except in compliance with the Elastic License.\n */\n\nexport interface PingCount {\n  x: number;\n  y: number;\n}\n\nexport const formatSparklineCounts = (counts: PingCount[]) => {\n  let defaultSize = 0;\n  const { length } = counts;\n  // assume points are uniform, use this\n  // for the last element's span\n  if (length > 1) {\n    defaultSize = Math.max(counts[1].x - counts[0].x, 0);\n  } else if (length === 1) {\n    // wait for another point\n    return [];\n  }\n  return counts.map(({ x: x0, y }, index, array) => {\n    let x;\n    const nextIndex = index + 1;\n    if (nextIndex === array.length) {\n      x = x0 + defaultSize;\n    } else {\n      const { x: nextX } = array[nextIndex];\n      x = nextX;\n    }\n    return { x, x0, y };\n  });\n};\n"]}]}