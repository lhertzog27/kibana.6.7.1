"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const boom_1 = tslib_1.__importDefault(require("boom"));
const lodash_1 = require("lodash");
/**
 * Adds the index.query.default_field setting, generated from the index's mapping.
 *
 * @param callWithRequest
 * @param request
 * @param indexName
 * @param fieldTypes - Elasticsearch field types that should be used to generate the default_field from the index mapping
 * @param otherFields - Other fields that should be included in the generated default_field that do not match `fieldTypes`
 */
exports.addDefaultField = async (callWithRequest, request, indexName, fieldTypes, otherFields = new Set()) => {
    // Verify index.query.default_field is not already set.
    const settings = await callWithRequest(request, 'indices.getSettings', {
        index: indexName,
    });
    if (lodash_1.get(settings, `${indexName}.settings.index.query.default_field`)) {
        throw boom_1.default.badRequest(`Index ${indexName} already has index.query.default_field set`);
    }
    // Get the mapping and generate the default_field based on `fieldTypes`
    const mappingResp = await callWithRequest(request, 'indices.getMapping', {
        index: indexName,
        include_type_name: true,
    });
    const typeName = Object.getOwnPropertyNames(mappingResp[indexName].mappings)[0];
    const mapping = mappingResp[indexName].mappings[typeName].properties;
    const generatedDefaultFields = new Set(exports.generateDefaultFields(mapping, fieldTypes));
    // Update the setting with the generated default_field
    return await callWithRequest(request, 'indices.putSettings', {
        index: indexName,
        body: {
            index: { query: { default_field: [...generatedDefaultFields, ...otherFields] } },
        },
    });
};
/**
 * Recursively walks an index mapping and returns a flat array of dot-delimited
 * strings represent all fields that are of a type included in `DEFAULT_FIELD_TYPES`
 * @param mapping
 */
exports.generateDefaultFields = (mapping, fieldTypes) => Object.getOwnPropertyNames(mapping).reduce((defaultFields, fieldName) => {
    const { type, properties } = mapping[fieldName];
    if (type && fieldTypes.has(type)) {
        defaultFields.push(fieldName);
    }
    else if (properties) {
        exports.generateDefaultFields(properties, fieldTypes).forEach(subField => defaultFields.push(`${fieldName}.${subField}`));
    }
    return defaultFields;
}, []);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL2hvbWUvYW50aG9ueS9naXRfd29ya3NwYWNlcy9raWJhbmEveC1wYWNrL3BsdWdpbnMvdXBncmFkZV9hc3Npc3RhbnQvc2VydmVyL2xpYi9xdWVyeV9kZWZhdWx0X2ZpZWxkLnRzIiwic291cmNlcyI6WyIvaG9tZS9hbnRob255L2dpdF93b3Jrc3BhY2VzL2tpYmFuYS94LXBhY2svcGx1Z2lucy91cGdyYWRlX2Fzc2lzdGFudC9zZXJ2ZXIvbGliL3F1ZXJ5X2RlZmF1bHRfZmllbGQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7O0dBSUc7OztBQUVILHdEQUF3QjtBQUV4QixtQ0FBNkI7QUFLN0I7Ozs7Ozs7O0dBUUc7QUFDVSxRQUFBLGVBQWUsR0FBRyxLQUFLLEVBQ2xDLGVBQXVDLEVBQ3ZDLE9BQWdCLEVBQ2hCLFNBQWlCLEVBQ2pCLFVBQStCLEVBQy9CLGNBQW1DLElBQUksR0FBRyxFQUFFLEVBQzVDLEVBQUU7SUFDRix1REFBdUQ7SUFDdkQsTUFBTSxRQUFRLEdBQUcsTUFBTSxlQUFlLENBQUMsT0FBTyxFQUFFLHFCQUFxQixFQUFFO1FBQ3JFLEtBQUssRUFBRSxTQUFTO0tBQ2pCLENBQUMsQ0FBQztJQUNILElBQUksWUFBRyxDQUFDLFFBQVEsRUFBRSxHQUFHLFNBQVMscUNBQXFDLENBQUMsRUFBRTtRQUNwRSxNQUFNLGNBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxTQUFTLDRDQUE0QyxDQUFDLENBQUM7S0FDdkY7SUFFRCx1RUFBdUU7SUFDdkUsTUFBTSxXQUFXLEdBQUcsTUFBTSxlQUFlLENBQUMsT0FBTyxFQUFFLG9CQUFvQixFQUFFO1FBQ3ZFLEtBQUssRUFBRSxTQUFTO1FBQ2hCLGlCQUFpQixFQUFFLElBQUk7S0FDeEIsQ0FBQyxDQUFDO0lBQ0gsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLG1CQUFtQixDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRixNQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFVBQStCLENBQUM7SUFDMUYsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLEdBQUcsQ0FBQyw2QkFBcUIsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUVuRixzREFBc0Q7SUFDdEQsT0FBTyxNQUFNLGVBQWUsQ0FBQyxPQUFPLEVBQUUscUJBQXFCLEVBQUU7UUFDM0QsS0FBSyxFQUFFLFNBQVM7UUFDaEIsSUFBSSxFQUFFO1lBQ0osS0FBSyxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsYUFBYSxFQUFFLENBQUMsR0FBRyxzQkFBc0IsRUFBRSxHQUFHLFdBQVcsQ0FBQyxFQUFFLEVBQUU7U0FDakY7S0FDRixDQUFDLENBQUM7QUFDTCxDQUFDLENBQUM7QUFFRjs7OztHQUlHO0FBQ1UsUUFBQSxxQkFBcUIsR0FBRyxDQUNuQyxPQUEwQixFQUMxQixVQUErQixFQUNyQixFQUFFLENBQ1osTUFBTSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FDeEMsQ0FBQyxhQUFhLEVBQUUsU0FBUyxFQUFFLEVBQUU7SUFDM0IsTUFBTSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7SUFFaEQsSUFBSSxJQUFJLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUNoQyxhQUFhLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQy9CO1NBQU0sSUFBSSxVQUFVLEVBQUU7UUFDckIsNkJBQXFCLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUMvRCxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsU0FBUyxJQUFJLFFBQVEsRUFBRSxDQUFDLENBQy9DLENBQUM7S0FDSDtJQUVELE9BQU8sYUFBYSxDQUFDO0FBQ3ZCLENBQUMsRUFDRCxFQUFjLENBQ2YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgRWxhc3RpY3NlYXJjaCBCLlYuIGFuZC9vciBsaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gTGljZW5zZWQgdW5kZXIgdGhlIEVsYXN0aWMgTGljZW5zZTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgRWxhc3RpYyBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBCb29tIGZyb20gJ2Jvb20nO1xuaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gJ2hhcGknO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHsgQ2FsbENsdXN0ZXJXaXRoUmVxdWVzdCB9IGZyb20gJ3NyYy9sZWdhY3kvY29yZV9wbHVnaW5zL2VsYXN0aWNzZWFyY2gnO1xuaW1wb3J0IHsgTWFwcGluZ1Byb3BlcnRpZXMgfSBmcm9tICcuL3JlaW5kZXhpbmcvdHlwZXMnO1xuXG4vKipcbiAqIEFkZHMgdGhlIGluZGV4LnF1ZXJ5LmRlZmF1bHRfZmllbGQgc2V0dGluZywgZ2VuZXJhdGVkIGZyb20gdGhlIGluZGV4J3MgbWFwcGluZy5cbiAqXG4gKiBAcGFyYW0gY2FsbFdpdGhSZXF1ZXN0XG4gKiBAcGFyYW0gcmVxdWVzdFxuICogQHBhcmFtIGluZGV4TmFtZVxuICogQHBhcmFtIGZpZWxkVHlwZXMgLSBFbGFzdGljc2VhcmNoIGZpZWxkIHR5cGVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGRlZmF1bHRfZmllbGQgZnJvbSB0aGUgaW5kZXggbWFwcGluZ1xuICogQHBhcmFtIG90aGVyRmllbGRzIC0gT3RoZXIgZmllbGRzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWQgZGVmYXVsdF9maWVsZCB0aGF0IGRvIG5vdCBtYXRjaCBgZmllbGRUeXBlc2BcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZERlZmF1bHRGaWVsZCA9IGFzeW5jIChcbiAgY2FsbFdpdGhSZXF1ZXN0OiBDYWxsQ2x1c3RlcldpdGhSZXF1ZXN0LFxuICByZXF1ZXN0OiBSZXF1ZXN0LFxuICBpbmRleE5hbWU6IHN0cmluZyxcbiAgZmllbGRUeXBlczogUmVhZG9ubHlTZXQ8c3RyaW5nPixcbiAgb3RoZXJGaWVsZHM6IFJlYWRvbmx5U2V0PHN0cmluZz4gPSBuZXcgU2V0KClcbikgPT4ge1xuICAvLyBWZXJpZnkgaW5kZXgucXVlcnkuZGVmYXVsdF9maWVsZCBpcyBub3QgYWxyZWFkeSBzZXQuXG4gIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgY2FsbFdpdGhSZXF1ZXN0KHJlcXVlc3QsICdpbmRpY2VzLmdldFNldHRpbmdzJywge1xuICAgIGluZGV4OiBpbmRleE5hbWUsXG4gIH0pO1xuICBpZiAoZ2V0KHNldHRpbmdzLCBgJHtpbmRleE5hbWV9LnNldHRpbmdzLmluZGV4LnF1ZXJ5LmRlZmF1bHRfZmllbGRgKSkge1xuICAgIHRocm93IEJvb20uYmFkUmVxdWVzdChgSW5kZXggJHtpbmRleE5hbWV9IGFscmVhZHkgaGFzIGluZGV4LnF1ZXJ5LmRlZmF1bHRfZmllbGQgc2V0YCk7XG4gIH1cblxuICAvLyBHZXQgdGhlIG1hcHBpbmcgYW5kIGdlbmVyYXRlIHRoZSBkZWZhdWx0X2ZpZWxkIGJhc2VkIG9uIGBmaWVsZFR5cGVzYFxuICBjb25zdCBtYXBwaW5nUmVzcCA9IGF3YWl0IGNhbGxXaXRoUmVxdWVzdChyZXF1ZXN0LCAnaW5kaWNlcy5nZXRNYXBwaW5nJywge1xuICAgIGluZGV4OiBpbmRleE5hbWUsXG4gICAgaW5jbHVkZV90eXBlX25hbWU6IHRydWUsXG4gIH0pO1xuICBjb25zdCB0eXBlTmFtZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG1hcHBpbmdSZXNwW2luZGV4TmFtZV0ubWFwcGluZ3MpWzBdO1xuICBjb25zdCBtYXBwaW5nID0gbWFwcGluZ1Jlc3BbaW5kZXhOYW1lXS5tYXBwaW5nc1t0eXBlTmFtZV0ucHJvcGVydGllcyBhcyBNYXBwaW5nUHJvcGVydGllcztcbiAgY29uc3QgZ2VuZXJhdGVkRGVmYXVsdEZpZWxkcyA9IG5ldyBTZXQoZ2VuZXJhdGVEZWZhdWx0RmllbGRzKG1hcHBpbmcsIGZpZWxkVHlwZXMpKTtcblxuICAvLyBVcGRhdGUgdGhlIHNldHRpbmcgd2l0aCB0aGUgZ2VuZXJhdGVkIGRlZmF1bHRfZmllbGRcbiAgcmV0dXJuIGF3YWl0IGNhbGxXaXRoUmVxdWVzdChyZXF1ZXN0LCAnaW5kaWNlcy5wdXRTZXR0aW5ncycsIHtcbiAgICBpbmRleDogaW5kZXhOYW1lLFxuICAgIGJvZHk6IHtcbiAgICAgIGluZGV4OiB7IHF1ZXJ5OiB7IGRlZmF1bHRfZmllbGQ6IFsuLi5nZW5lcmF0ZWREZWZhdWx0RmllbGRzLCAuLi5vdGhlckZpZWxkc10gfSB9LFxuICAgIH0sXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB3YWxrcyBhbiBpbmRleCBtYXBwaW5nIGFuZCByZXR1cm5zIGEgZmxhdCBhcnJheSBvZiBkb3QtZGVsaW1pdGVkXG4gKiBzdHJpbmdzIHJlcHJlc2VudCBhbGwgZmllbGRzIHRoYXQgYXJlIG9mIGEgdHlwZSBpbmNsdWRlZCBpbiBgREVGQVVMVF9GSUVMRF9UWVBFU2BcbiAqIEBwYXJhbSBtYXBwaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZURlZmF1bHRGaWVsZHMgPSAoXG4gIG1hcHBpbmc6IE1hcHBpbmdQcm9wZXJ0aWVzLFxuICBmaWVsZFR5cGVzOiBSZWFkb25seVNldDxzdHJpbmc+XG4pOiBzdHJpbmdbXSA9PlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtYXBwaW5nKS5yZWR1Y2UoXG4gICAgKGRlZmF1bHRGaWVsZHMsIGZpZWxkTmFtZSkgPT4ge1xuICAgICAgY29uc3QgeyB0eXBlLCBwcm9wZXJ0aWVzIH0gPSBtYXBwaW5nW2ZpZWxkTmFtZV07XG5cbiAgICAgIGlmICh0eXBlICYmIGZpZWxkVHlwZXMuaGFzKHR5cGUpKSB7XG4gICAgICAgIGRlZmF1bHRGaWVsZHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGdlbmVyYXRlRGVmYXVsdEZpZWxkcyhwcm9wZXJ0aWVzLCBmaWVsZFR5cGVzKS5mb3JFYWNoKHN1YkZpZWxkID0+XG4gICAgICAgICAgZGVmYXVsdEZpZWxkcy5wdXNoKGAke2ZpZWxkTmFtZX0uJHtzdWJGaWVsZH1gKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmYXVsdEZpZWxkcztcbiAgICB9LFxuICAgIFtdIGFzIHN0cmluZ1tdXG4gICk7XG4iXX0=