import "core-js/modules/es6.regexp.match";
import { printIso8601 } from './date_format';
import { isDateValue } from './date_value';
import { AST, Operator } from './ast';
import { isArray, isDateLike, isString, isBoolean, isNumber } from '../../../services/predicate';

var emitMatch = function emitMatch(match) {
  if (!match) {
    return '';
  }

  return AST.Match.isMust(match) ? '+' : '-';
};

var emitFieldDateLikeClause = function emitFieldDateLikeClause(field, value, operator, match) {
  var matchOp = emitMatch(match);

  switch (operator) {
    case Operator.EQ:
      return "".concat(matchOp).concat(field, ":").concat(printIso8601(value));

    case Operator.GT:
      return "".concat(matchOp).concat(field, ":>").concat(printIso8601(value));

    case Operator.GTE:
      return "".concat(matchOp).concat(field, ":>=").concat(printIso8601(value));

    case Operator.LT:
      return "".concat(matchOp).concat(field, ":<").concat(printIso8601(value));

    case Operator.LTE:
      return "".concat(matchOp).concat(field, ":<=").concat(printIso8601(value));

    default:
      throw new Error("unknown operator [".concat(operator, "]"));
  }
};

var emitFieldDateValueClause = function emitFieldDateValueClause(field, value, operator, match) {
  var matchOp = emitMatch(match);
  var granularity = value.granularity,
      resolve = value.resolve;
  var date = resolve();

  if (granularity) {
    switch (operator) {
      case Operator.EQ:
        var gte = granularity.iso8601(granularity.start(date));
        var lt = granularity.iso8601(granularity.startOfNext(date));
        return "".concat(matchOp).concat(field, ":(>=").concat(gte, " AND <").concat(lt, ")");

      case Operator.GT:
        return "".concat(matchOp).concat(field, ":>=").concat(granularity.iso8601(granularity.startOfNext(date)));

      case Operator.GTE:
        return "".concat(matchOp).concat(field, ":>=").concat(granularity.iso8601(granularity.start(date)));

      case Operator.LT:
        return "".concat(matchOp).concat(field, ":<").concat(granularity.iso8601(granularity.start(date)));

      case Operator.LTE:
        return "".concat(matchOp).concat(field, ":<").concat(granularity.iso8601(granularity.startOfNext(date)));

      default:
        throw new Error("unknown operator [".concat(operator, "]"));
    }
  }

  return emitFieldDateLikeClause(field, date, operator, match);
};

var emitFieldNumericClause = function emitFieldNumericClause(field, value, operator, match) {
  var matchOp = emitMatch(match);

  switch (operator) {
    case Operator.EQ:
      return "".concat(matchOp).concat(field, ":").concat(value);

    case Operator.GT:
      return "".concat(matchOp).concat(field, ":>").concat(value);

    case Operator.GTE:
      return "".concat(matchOp).concat(field, ":>=").concat(value);

    case Operator.LT:
      return "".concat(matchOp).concat(field, ":<").concat(value);

    case Operator.LTE:
      return "".concat(matchOp).concat(field, ":<=").concat(value);

    default:
      throw new Error("unknown operator [".concat(operator, "]"));
  }
};

var emitFieldStringClause = function emitFieldStringClause(field, value, match) {
  var matchOp = emitMatch(match);

  if (value.match(/\s/)) {
    return "".concat(matchOp).concat(field, ":\"").concat(value, "\"");
  }

  return "".concat(matchOp).concat(field, ":").concat(value);
};

var emitFieldBooleanClause = function emitFieldBooleanClause(field, value, match) {
  var matchOp = emitMatch(match);
  return "".concat(matchOp).concat(field, ":").concat(value);
};

var emitFieldSingleValueClause = function emitFieldSingleValueClause(field, value, operator, match) {
  if (isDateValue(value)) {
    return emitFieldDateValueClause(field, value, operator, match);
  }

  if (isDateLike(value)) {
    return emitFieldDateLikeClause(field, value, operator, match);
  }

  if (isString(value)) {
    return emitFieldStringClause(field, value, match);
  }

  if (isNumber(value)) {
    return emitFieldNumericClause(field, value, operator, match);
  }

  if (isBoolean(value)) {
    return emitFieldBooleanClause(field, value, match);
  }

  throw new Error("unknown type of field value [".concat(value, "]"));
};

var emitFieldClause = function emitFieldClause(clause) {
  var field = clause.field,
      value = clause.value,
      operator = clause.operator,
      match = clause.match;

  if (!isArray(value)) {
    return emitFieldSingleValueClause(field, value, operator, match);
  }

  var matchOp = emitMatch(match);
  var clauses = value.map(function (v) {
    return emitFieldSingleValueClause(field, v, operator);
  }).join(' OR ');
  return "".concat(matchOp, "(").concat(clauses, ")");
};

var emitTermClause = function emitTermClause(clause) {
  var value = clause.value,
      match = clause.match;
  var matchOp = emitMatch(match);
  return "".concat(matchOp).concat(value);
};

var emitIsClause = function emitIsClause(clause) {
  var flag = clause.flag,
      match = clause.match;
  return AST.Match.isMust(match) ? "+".concat(flag, ":true") : "+".concat(flag, ":false");
};

export var astToEsQueryString = function astToEsQueryString(ast) {
  if (ast.clauses.length === 0) {
    return '';
  }

  return ast.clauses.map(function (clause) {
    if (AST.Field.isInstance(clause)) {
      return emitFieldClause(clause);
    }

    if (AST.Term.isInstance(clause)) {
      return emitTermClause(clause);
    }

    if (AST.Is.isInstance(clause)) {
      return emitIsClause(clause);
    }

    throw new Error("unknown clause type [".concat(JSON.stringify(clause), "]"));
  }).join(' ');
};